


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: SunGraphics2D</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.java2d</a> ]
</div>

<h1>Coverage Summary for Class: SunGraphics2D (sun.java2d)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SunGraphics2D</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 123)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1346)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.java2d;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.awt.Graphics;
<i>29</i>&nbsp;import java.awt.Graphics2D;
<i>30</i>&nbsp;import java.awt.RenderingHints;
<i>31</i>&nbsp;import java.awt.RenderingHints.Key;
<i>32</i>&nbsp;import java.awt.geom.Area;
<i>33</i>&nbsp;import java.awt.geom.AffineTransform;
<i>34</i>&nbsp;import java.awt.geom.NoninvertibleTransformException;
<i>35</i>&nbsp;import java.awt.AlphaComposite;
<i>36</i>&nbsp;import java.awt.BasicStroke;
<i>37</i>&nbsp;import java.awt.image.BufferedImage;
<i>38</i>&nbsp;import java.awt.image.BufferedImageOp;
<i>39</i>&nbsp;import java.awt.image.RenderedImage;
<i>40</i>&nbsp;import java.awt.image.renderable.RenderableImage;
<i>41</i>&nbsp;import java.awt.image.renderable.RenderContext;
<i>42</i>&nbsp;import java.awt.image.AffineTransformOp;
<i>43</i>&nbsp;import java.awt.image.Raster;
<i>44</i>&nbsp;import java.awt.image.WritableRaster;
<i>45</i>&nbsp;import java.awt.Image;
<i>46</i>&nbsp;import java.awt.Composite;
<i>47</i>&nbsp;import java.awt.Color;
<i>48</i>&nbsp;import java.awt.image.ColorModel;
<i>49</i>&nbsp;import java.awt.GraphicsConfiguration;
<i>50</i>&nbsp;import java.awt.Paint;
<i>51</i>&nbsp;import java.awt.GradientPaint;
<i>52</i>&nbsp;import java.awt.LinearGradientPaint;
<i>53</i>&nbsp;import java.awt.RadialGradientPaint;
<i>54</i>&nbsp;import java.awt.TexturePaint;
<i>55</i>&nbsp;import java.awt.geom.Rectangle2D;
<i>56</i>&nbsp;import java.awt.geom.PathIterator;
<i>57</i>&nbsp;import java.awt.geom.GeneralPath;
<i>58</i>&nbsp;import java.awt.Shape;
<i>59</i>&nbsp;import java.awt.Stroke;
<i>60</i>&nbsp;import java.awt.FontMetrics;
<i>61</i>&nbsp;import java.awt.Rectangle;
<i>62</i>&nbsp;import java.text.AttributedCharacterIterator;
<i>63</i>&nbsp;import java.awt.Font;
<i>64</i>&nbsp;import java.awt.image.ImageObserver;
<i>65</i>&nbsp;import java.awt.Transparency;
<i>66</i>&nbsp;import java.awt.font.GlyphVector;
<i>67</i>&nbsp;import java.awt.font.TextLayout;
<i>68</i>&nbsp;
<i>69</i>&nbsp;import sun.awt.image.SurfaceManager;
<i>70</i>&nbsp;import sun.font.FontDesignMetrics;
<i>71</i>&nbsp;import sun.font.FontUtilities;
<i>72</i>&nbsp;import sun.java2d.pipe.PixelDrawPipe;
<i>73</i>&nbsp;import sun.java2d.pipe.PixelFillPipe;
<i>74</i>&nbsp;import sun.java2d.pipe.ShapeDrawPipe;
<i>75</i>&nbsp;import sun.java2d.pipe.ValidatePipe;
<i>76</i>&nbsp;import sun.java2d.pipe.ShapeSpanIterator;
<i>77</i>&nbsp;import sun.java2d.pipe.Region;
<i>78</i>&nbsp;import sun.java2d.pipe.TextPipe;
<i>79</i>&nbsp;import sun.java2d.pipe.DrawImagePipe;
<i>80</i>&nbsp;import sun.java2d.pipe.LoopPipe;
<i>81</i>&nbsp;import sun.java2d.loops.FontInfo;
<i>82</i>&nbsp;import sun.java2d.loops.RenderLoops;
<i>83</i>&nbsp;import sun.java2d.loops.CompositeType;
<i>84</i>&nbsp;import sun.java2d.loops.SurfaceType;
<i>85</i>&nbsp;import sun.java2d.loops.Blit;
<i>86</i>&nbsp;import sun.java2d.loops.MaskFill;
<i>87</i>&nbsp;import java.awt.font.FontRenderContext;
<i>88</i>&nbsp;import sun.java2d.loops.XORComposite;
<i>89</i>&nbsp;import sun.awt.ConstrainableGraphics;
<i>90</i>&nbsp;import sun.awt.SunHints;
<i>91</i>&nbsp;import sun.awt.util.PerformanceLogger;
<i>92</i>&nbsp;import java.util.Map;
<i>93</i>&nbsp;import java.util.Iterator;
<i>94</i>&nbsp;
<i>95</i>&nbsp;import java.lang.annotation.Native;
<i>96</i>&nbsp;import java.awt.image.MultiResolutionImage;
<i>97</i>&nbsp;
<i>98</i>&nbsp;import static java.awt.geom.AffineTransform.TYPE_FLIP;
<i>99</i>&nbsp;import static java.awt.geom.AffineTransform.TYPE_MASK_SCALE;
<i>100</i>&nbsp;import static java.awt.geom.AffineTransform.TYPE_TRANSLATION;
<i>101</i>&nbsp;import java.awt.image.VolatileImage;
<i>102</i>&nbsp;import sun.awt.image.MultiResolutionToolkitImage;
<i>103</i>&nbsp;import sun.awt.image.ToolkitImage;
<i>104</i>&nbsp;
<i>105</i>&nbsp;/**
<i>106</i>&nbsp; * This is a the master Graphics2D superclass for all of the Sun
<i>107</i>&nbsp; * Graphics implementations.  This class relies on subclasses to
<i>108</i>&nbsp; * manage the various device information, but provides an overall
<i>109</i>&nbsp; * general framework for performing all of the requests in the
<i>110</i>&nbsp; * Graphics and Graphics2D APIs.
<i>111</i>&nbsp; *
<i>112</i>&nbsp; * @author Jim Graham
<i>113</i>&nbsp; */
<b class="nc"><i>114</i>&nbsp;public final class SunGraphics2D</b>
<i>115</i>&nbsp;    extends Graphics2D
<i>116</i>&nbsp;    implements ConstrainableGraphics, Cloneable, DestSurfaceProvider
<i>117</i>&nbsp;{
<i>118</i>&nbsp;    /*
<i>119</i>&nbsp;     * Attribute States
<i>120</i>&nbsp;     */
<i>121</i>&nbsp;    /* Paint */
<i>122</i>&nbsp;    @Native
<i>123</i>&nbsp;    public static final int PAINT_CUSTOM       = 6; /* Any other Paint object */
<i>124</i>&nbsp;    @Native
<i>125</i>&nbsp;    public static final int PAINT_TEXTURE      = 5; /* Tiled Image */
<i>126</i>&nbsp;    @Native
<i>127</i>&nbsp;    public static final int PAINT_RAD_GRADIENT = 4; /* Color RadialGradient */
<i>128</i>&nbsp;    @Native
<i>129</i>&nbsp;    public static final int PAINT_LIN_GRADIENT = 3; /* Color LinearGradient */
<i>130</i>&nbsp;    @Native
<i>131</i>&nbsp;    public static final int PAINT_GRADIENT     = 2; /* Color Gradient */
<i>132</i>&nbsp;    @Native
<i>133</i>&nbsp;    public static final int PAINT_ALPHACOLOR   = 1; /* Non-opaque Color */
<i>134</i>&nbsp;    @Native
<i>135</i>&nbsp;    public static final int PAINT_OPAQUECOLOR  = 0; /* Opaque Color */
<i>136</i>&nbsp;
<i>137</i>&nbsp;    /* Composite*/
<i>138</i>&nbsp;    @Native
<i>139</i>&nbsp;    public static final int COMP_CUSTOM = 3;/* Custom Composite */
<i>140</i>&nbsp;    @Native
<i>141</i>&nbsp;    public static final int COMP_XOR    = 2;/* XOR Mode Composite */
<i>142</i>&nbsp;    @Native
<i>143</i>&nbsp;    public static final int COMP_ALPHA  = 1;/* AlphaComposite */
<i>144</i>&nbsp;    @Native
<i>145</i>&nbsp;    public static final int COMP_ISCOPY = 0;/* simple stores into destination,
<i>146</i>&nbsp;                                             * i.e. Src, SrcOverNoEa, and other
<i>147</i>&nbsp;                                             * alpha modes which replace
<i>148</i>&nbsp;                                             * the destination.
<i>149</i>&nbsp;                                             */
<i>150</i>&nbsp;
<i>151</i>&nbsp;    /* Stroke */
<i>152</i>&nbsp;    @Native
<i>153</i>&nbsp;    public static final int STROKE_CUSTOM = 3; /* custom Stroke */
<i>154</i>&nbsp;    @Native
<i>155</i>&nbsp;    public static final int STROKE_WIDE   = 2; /* BasicStroke */
<i>156</i>&nbsp;    @Native
<i>157</i>&nbsp;    public static final int STROKE_THINDASHED   = 1; /* BasicStroke */
<i>158</i>&nbsp;    @Native
<i>159</i>&nbsp;    public static final int STROKE_THIN   = 0; /* BasicStroke */
<i>160</i>&nbsp;
<i>161</i>&nbsp;    /* Transform */
<i>162</i>&nbsp;    @Native
<i>163</i>&nbsp;    public static final int TRANSFORM_GENERIC = 4; /* any 3x2 */
<i>164</i>&nbsp;    @Native
<i>165</i>&nbsp;    public static final int TRANSFORM_TRANSLATESCALE = 3; /* scale XY */
<i>166</i>&nbsp;    @Native
<i>167</i>&nbsp;    public static final int TRANSFORM_ANY_TRANSLATE = 2; /* non-int translate */
<i>168</i>&nbsp;    @Native
<i>169</i>&nbsp;    public static final int TRANSFORM_INT_TRANSLATE = 1; /* int translate */
<i>170</i>&nbsp;    @Native
<i>171</i>&nbsp;    public static final int TRANSFORM_ISIDENT = 0; /* Identity */
<i>172</i>&nbsp;
<i>173</i>&nbsp;    /* Clipping */
<i>174</i>&nbsp;    @Native
<i>175</i>&nbsp;    public static final int CLIP_SHAPE       = 2; /* arbitrary clip */
<i>176</i>&nbsp;    @Native
<i>177</i>&nbsp;    public static final int CLIP_RECTANGULAR = 1; /* rectangular clip */
<i>178</i>&nbsp;    @Native
<i>179</i>&nbsp;    public static final int CLIP_DEVICE      = 0; /* no clipping set */
<i>180</i>&nbsp;
<i>181</i>&nbsp;    /* The following fields are used when the current Paint is a Color. */
<i>182</i>&nbsp;    public int eargb;  // ARGB value with ExtraAlpha baked in
<i>183</i>&nbsp;    public int pixel;  // pixel value for eargb
<i>184</i>&nbsp;
<i>185</i>&nbsp;    public SurfaceData surfaceData;
<i>186</i>&nbsp;
<i>187</i>&nbsp;    public PixelDrawPipe drawpipe;
<i>188</i>&nbsp;    public PixelFillPipe fillpipe;
<i>189</i>&nbsp;    public DrawImagePipe imagepipe;
<i>190</i>&nbsp;    public ShapeDrawPipe shapepipe;
<i>191</i>&nbsp;    public TextPipe textpipe;
<i>192</i>&nbsp;    public MaskFill alphafill;
<i>193</i>&nbsp;
<i>194</i>&nbsp;    public RenderLoops loops;
<i>195</i>&nbsp;
<i>196</i>&nbsp;    public CompositeType imageComp;     /* Image Transparency checked on fly */
<i>197</i>&nbsp;
<i>198</i>&nbsp;    public int paintState;
<i>199</i>&nbsp;    public int compositeState;
<i>200</i>&nbsp;    public int strokeState;
<i>201</i>&nbsp;    public int transformState;
<i>202</i>&nbsp;    public int clipState;
<i>203</i>&nbsp;
<i>204</i>&nbsp;    public Color foregroundColor;
<i>205</i>&nbsp;    public Color backgroundColor;
<i>206</i>&nbsp;
<i>207</i>&nbsp;    public AffineTransform transform;
<i>208</i>&nbsp;    public int transX;
<i>209</i>&nbsp;    public int transY;
<i>210</i>&nbsp;
<b class="nc"><i>211</i>&nbsp;    protected static final Stroke defaultStroke = new BasicStroke();</b>
<b class="nc"><i>212</i>&nbsp;    protected static final Composite defaultComposite = AlphaComposite.SrcOver;</b>
<b class="nc"><i>213</i>&nbsp;    private static final Font defaultFont =</b>
<i>214</i>&nbsp;        new Font(Font.DIALOG, Font.PLAIN, 12);
<i>215</i>&nbsp;
<i>216</i>&nbsp;    public Paint paint;
<i>217</i>&nbsp;    public Stroke stroke;
<i>218</i>&nbsp;    public Composite composite;
<i>219</i>&nbsp;    protected Font font;
<i>220</i>&nbsp;    protected FontMetrics fontMetrics;
<i>221</i>&nbsp;
<i>222</i>&nbsp;    public int renderHint;
<i>223</i>&nbsp;    public int antialiasHint;
<i>224</i>&nbsp;    public int textAntialiasHint;
<i>225</i>&nbsp;    protected int fractionalMetricsHint;
<i>226</i>&nbsp;
<i>227</i>&nbsp;    /* A gamma adjustment to the colour used in lcd text blitting */
<i>228</i>&nbsp;    public int lcdTextContrast;
<b class="nc"><i>229</i>&nbsp;    private static int lcdTextContrastDefaultValue = 140;</b>
<i>230</i>&nbsp;
<i>231</i>&nbsp;    private int interpolationHint;      // raw value of rendering Hint
<i>232</i>&nbsp;    public int strokeHint;
<i>233</i>&nbsp;
<i>234</i>&nbsp;    public int interpolationType;       // algorithm choice based on
<i>235</i>&nbsp;                                        // interpolation and render Hints
<i>236</i>&nbsp;
<i>237</i>&nbsp;    public RenderingHints hints;
<i>238</i>&nbsp;
<i>239</i>&nbsp;    public Region constrainClip;        // lightweight bounds in pixels
<i>240</i>&nbsp;    public int constrainX;
<i>241</i>&nbsp;    public int constrainY;
<i>242</i>&nbsp;
<i>243</i>&nbsp;    public Region clipRegion;
<i>244</i>&nbsp;    public Shape usrClip;
<i>245</i>&nbsp;    protected Region devClip;           // Actual physical drawable in pixels
<i>246</i>&nbsp;
<i>247</i>&nbsp;    private int resolutionVariantHint;
<i>248</i>&nbsp;
<i>249</i>&nbsp;    // cached state for text rendering
<i>250</i>&nbsp;    private boolean validFontInfo;
<i>251</i>&nbsp;    private FontInfo fontInfo;
<i>252</i>&nbsp;    private FontInfo glyphVectorFontInfo;
<i>253</i>&nbsp;    private FontRenderContext glyphVectorFRC;
<i>254</i>&nbsp;
<i>255</i>&nbsp;    private static final int slowTextTransformMask =
<i>256</i>&nbsp;                            AffineTransform.TYPE_GENERAL_TRANSFORM
<i>257</i>&nbsp;                        |   AffineTransform.TYPE_MASK_ROTATION
<i>258</i>&nbsp;                        |   AffineTransform.TYPE_FLIP;
<i>259</i>&nbsp;
<i>260</i>&nbsp;    static {
<b class="nc"><i>261</i>&nbsp;        if (PerformanceLogger.loggingEnabled()) {</b>
<b class="nc"><i>262</i>&nbsp;            PerformanceLogger.setTime(&quot;SunGraphics2D static initialization&quot;);</b>
<i>263</i>&nbsp;        }
<i>264</i>&nbsp;    }
<i>265</i>&nbsp;
<b class="nc"><i>266</i>&nbsp;    public SunGraphics2D(SurfaceData sd, Color fg, Color bg, Font f) {</b>
<b class="nc"><i>267</i>&nbsp;        surfaceData = sd;</b>
<b class="nc"><i>268</i>&nbsp;        foregroundColor = fg;</b>
<b class="nc"><i>269</i>&nbsp;        backgroundColor = bg;</b>
<b class="nc"><i>270</i>&nbsp;        stroke = defaultStroke;</b>
<b class="nc"><i>271</i>&nbsp;        composite = defaultComposite;</b>
<b class="nc"><i>272</i>&nbsp;        paint = foregroundColor;</b>
<i>273</i>&nbsp;
<b class="nc"><i>274</i>&nbsp;        imageComp = CompositeType.SrcOverNoEa;</b>
<i>275</i>&nbsp;
<b class="nc"><i>276</i>&nbsp;        renderHint = SunHints.INTVAL_RENDER_DEFAULT;</b>
<b class="nc"><i>277</i>&nbsp;        antialiasHint = SunHints.INTVAL_ANTIALIAS_OFF;</b>
<b class="nc"><i>278</i>&nbsp;        textAntialiasHint = SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT;</b>
<b class="nc"><i>279</i>&nbsp;        fractionalMetricsHint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;</b>
<b class="nc"><i>280</i>&nbsp;        lcdTextContrast = lcdTextContrastDefaultValue;</b>
<b class="nc"><i>281</i>&nbsp;        interpolationHint = -1;</b>
<b class="nc"><i>282</i>&nbsp;        strokeHint = SunHints.INTVAL_STROKE_DEFAULT;</b>
<b class="nc"><i>283</i>&nbsp;        resolutionVariantHint = SunHints.INTVAL_RESOLUTION_VARIANT_DEFAULT;</b>
<i>284</i>&nbsp;
<b class="nc"><i>285</i>&nbsp;        interpolationType = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;</b>
<i>286</i>&nbsp;
<b class="nc"><i>287</i>&nbsp;        transform = getDefaultTransform();</b>
<b class="nc"><i>288</i>&nbsp;        if (!transform.isIdentity()) {</b>
<b class="nc"><i>289</i>&nbsp;            invalidateTransform();</b>
<i>290</i>&nbsp;        }
<i>291</i>&nbsp;
<b class="nc"><i>292</i>&nbsp;        validateColor();</b>
<i>293</i>&nbsp;
<b class="nc"><i>294</i>&nbsp;        font = f;</b>
<b class="nc"><i>295</i>&nbsp;        if (font == null) {</b>
<b class="nc"><i>296</i>&nbsp;            font = defaultFont;</b>
<i>297</i>&nbsp;        }
<i>298</i>&nbsp;
<b class="nc"><i>299</i>&nbsp;        setDevClip(sd.getBounds());</b>
<b class="nc"><i>300</i>&nbsp;        invalidatePipe();</b>
<i>301</i>&nbsp;    }
<i>302</i>&nbsp;
<i>303</i>&nbsp;    private AffineTransform getDefaultTransform() {
<b class="nc"><i>304</i>&nbsp;        GraphicsConfiguration gc = getDeviceConfiguration();</b>
<b class="nc"><i>305</i>&nbsp;        return (gc == null) ? new AffineTransform() : gc.getDefaultTransform();</b>
<i>306</i>&nbsp;    }
<i>307</i>&nbsp;
<i>308</i>&nbsp;    protected Object clone() {
<i>309</i>&nbsp;        try {
<b class="nc"><i>310</i>&nbsp;            SunGraphics2D g = (SunGraphics2D) super.clone();</b>
<b class="nc"><i>311</i>&nbsp;            g.transform = new AffineTransform(this.transform);</b>
<b class="nc"><i>312</i>&nbsp;            if (hints != null) {</b>
<b class="nc"><i>313</i>&nbsp;                g.hints = (RenderingHints) this.hints.clone();</b>
<i>314</i>&nbsp;            }
<i>315</i>&nbsp;            /* FontInfos are re-used, so must be cloned too, if they
<i>316</i>&nbsp;             * are valid, and be nulled out if invalid.
<i>317</i>&nbsp;             * The implied trade-off is that there is more to be gained
<i>318</i>&nbsp;             * from re-using these objects than is lost by having to
<i>319</i>&nbsp;             * clone them when the SG2D is cloned.
<i>320</i>&nbsp;             */
<b class="nc"><i>321</i>&nbsp;            if (this.fontInfo != null) {</b>
<b class="nc"><i>322</i>&nbsp;                if (this.validFontInfo) {</b>
<b class="nc"><i>323</i>&nbsp;                    g.fontInfo = (FontInfo)this.fontInfo.clone();</b>
<i>324</i>&nbsp;                } else {
<b class="nc"><i>325</i>&nbsp;                    g.fontInfo = null;</b>
<i>326</i>&nbsp;                }
<i>327</i>&nbsp;            }
<b class="nc"><i>328</i>&nbsp;            if (this.glyphVectorFontInfo != null) {</b>
<b class="nc"><i>329</i>&nbsp;                g.glyphVectorFontInfo =</b>
<b class="nc"><i>330</i>&nbsp;                    (FontInfo)this.glyphVectorFontInfo.clone();</b>
<b class="nc"><i>331</i>&nbsp;                g.glyphVectorFRC = this.glyphVectorFRC;</b>
<i>332</i>&nbsp;            }
<i>333</i>&nbsp;            //g.invalidatePipe();
<b class="nc"><i>334</i>&nbsp;            return g;</b>
<b class="nc"><i>335</i>&nbsp;        } catch (CloneNotSupportedException e) {</b>
<i>336</i>&nbsp;        }
<b class="nc"><i>337</i>&nbsp;        return null;</b>
<i>338</i>&nbsp;    }
<i>339</i>&nbsp;
<i>340</i>&nbsp;    /**
<i>341</i>&nbsp;     * Create a new SunGraphics2D based on this one.
<i>342</i>&nbsp;     */
<i>343</i>&nbsp;    public Graphics create() {
<b class="nc"><i>344</i>&nbsp;        return (Graphics) clone();</b>
<i>345</i>&nbsp;    }
<i>346</i>&nbsp;
<i>347</i>&nbsp;    public void setDevClip(int x, int y, int w, int h) {
<b class="nc"><i>348</i>&nbsp;        Region c = constrainClip;</b>
<b class="nc"><i>349</i>&nbsp;        if (c == null) {</b>
<b class="nc"><i>350</i>&nbsp;            devClip = Region.getInstanceXYWH(x, y, w, h);</b>
<i>351</i>&nbsp;        } else {
<b class="nc"><i>352</i>&nbsp;            devClip = c.getIntersectionXYWH(x, y, w, h);</b>
<i>353</i>&nbsp;        }
<b class="nc"><i>354</i>&nbsp;        validateCompClip();</b>
<i>355</i>&nbsp;    }
<i>356</i>&nbsp;
<i>357</i>&nbsp;    public void setDevClip(Rectangle r) {
<b class="nc"><i>358</i>&nbsp;        setDevClip(r.x, r.y, r.width, r.height);</b>
<i>359</i>&nbsp;    }
<i>360</i>&nbsp;
<i>361</i>&nbsp;    /**
<i>362</i>&nbsp;     * Constrain rendering for lightweight objects.
<i>363</i>&nbsp;     */
<i>364</i>&nbsp;    public void constrain(int x, int y, int w, int h, Region region) {
<b class="nc"><i>365</i>&nbsp;        if ((x | y) != 0) {</b>
<b class="nc"><i>366</i>&nbsp;            translate(x, y);</b>
<i>367</i>&nbsp;        }
<b class="nc"><i>368</i>&nbsp;        if (transformState &gt; TRANSFORM_TRANSLATESCALE) {</b>
<b class="nc"><i>369</i>&nbsp;            clipRect(0, 0, w, h);</b>
<i>370</i>&nbsp;            return;
<i>371</i>&nbsp;        }
<i>372</i>&nbsp;        // changes parameters according to the current scale and translate.
<b class="nc"><i>373</i>&nbsp;        final double scaleX = transform.getScaleX();</b>
<b class="nc"><i>374</i>&nbsp;        final double scaleY = transform.getScaleY();</b>
<i>375</i>&nbsp;        x = constrainX = (int) transform.getTranslateX();
<b class="nc"><i>376</i>&nbsp;        y = constrainY = (int) transform.getTranslateY();</b>
<b class="nc"><i>377</i>&nbsp;        w = Region.dimAdd(x, Region.clipScale(w, scaleX));</b>
<b class="nc"><i>378</i>&nbsp;        h = Region.dimAdd(y, Region.clipScale(h, scaleY));</b>
<b class="nc"><i>379</i>&nbsp;</b>
<i>380</i>&nbsp;        Region c = constrainClip;
<b class="nc"><i>381</i>&nbsp;        if (c == null) {</b>
<b class="nc"><i>382</i>&nbsp;            c = Region.getInstanceXYXY(x, y, w, h);</b>
<b class="nc"><i>383</i>&nbsp;        } else {</b>
<i>384</i>&nbsp;            c = c.getIntersectionXYXY(x, y, w, h);
<b class="nc"><i>385</i>&nbsp;        }</b>
<i>386</i>&nbsp;        if (region != null) {
<b class="nc"><i>387</i>&nbsp;            region = region.getScaledRegion(scaleX, scaleY);</b>
<b class="nc"><i>388</i>&nbsp;            region = region.getTranslatedRegion(x, y);</b>
<b class="nc"><i>389</i>&nbsp;            c = c.getIntersection(region);</b>
<b class="nc"><i>390</i>&nbsp;        }</b>
<i>391</i>&nbsp;
<i>392</i>&nbsp;        if (c == constrainClip) {
<b class="nc"><i>393</i>&nbsp;            // Common case to ignore</b>
<i>394</i>&nbsp;            return;
<i>395</i>&nbsp;        }
<i>396</i>&nbsp;
<i>397</i>&nbsp;        constrainClip = c;
<b class="nc"><i>398</i>&nbsp;        if (!devClip.isInsideQuickCheck(c)) {</b>
<b class="nc"><i>399</i>&nbsp;            devClip = devClip.getIntersection(c);</b>
<b class="nc"><i>400</i>&nbsp;            validateCompClip();</b>
<b class="nc"><i>401</i>&nbsp;        }</b>
<i>402</i>&nbsp;    }
<i>403</i>&nbsp;
<i>404</i>&nbsp;    /**
<i>405</i>&nbsp;     * Constrain rendering for lightweight objects.
<i>406</i>&nbsp;     *
<i>407</i>&nbsp;     * REMIND: This method will back off to the &quot;workaround&quot;
<i>408</i>&nbsp;     * of using translate and clipRect if the Graphics
<i>409</i>&nbsp;     * to be constrained has a complex transform.  The
<i>410</i>&nbsp;     * drawback of the workaround is that the resulting
<i>411</i>&nbsp;     * clip and device origin cannot be &quot;enforced&quot;.
<i>412</i>&nbsp;     *
<i>413</i>&nbsp;     * @exception IllegalStateException If the Graphics
<i>414</i>&nbsp;     * to be constrained has a complex transform.
<i>415</i>&nbsp;     */
<i>416</i>&nbsp;    @Override
<i>417</i>&nbsp;    public void constrain(int x, int y, int w, int h) {
<i>418</i>&nbsp;        constrain(x, y, w, h, null);
<b class="nc"><i>419</i>&nbsp;    }</b>
<i>420</i>&nbsp;
<i>421</i>&nbsp;    protected static ValidatePipe invalidpipe = new ValidatePipe();
<b class="nc"><i>422</i>&nbsp;</b>
<i>423</i>&nbsp;    /*
<i>424</i>&nbsp;     * Invalidate the pipeline
<i>425</i>&nbsp;     */
<i>426</i>&nbsp;    protected void invalidatePipe() {
<i>427</i>&nbsp;        drawpipe = invalidpipe;
<b class="nc"><i>428</i>&nbsp;        fillpipe = invalidpipe;</b>
<b class="nc"><i>429</i>&nbsp;        shapepipe = invalidpipe;</b>
<b class="nc"><i>430</i>&nbsp;        textpipe = invalidpipe;</b>
<b class="nc"><i>431</i>&nbsp;        imagepipe = invalidpipe;</b>
<b class="nc"><i>432</i>&nbsp;        loops = null;</b>
<b class="nc"><i>433</i>&nbsp;    }</b>
<i>434</i>&nbsp;
<i>435</i>&nbsp;    public void validatePipe() {
<i>436</i>&nbsp;        /* This workaround is for the situation when we update the Pipelines
<i>437</i>&nbsp;         * for invalid SurfaceData and run further code when the current
<i>438</i>&nbsp;         * pipeline doesn&#39;t support the type of new SurfaceData created during
<i>439</i>&nbsp;         * the current pipeline&#39;s work (in place of the invalid SurfaceData).
<i>440</i>&nbsp;         * Usually SurfaceData and Pipelines are repaired (through revalidateAll)
<i>441</i>&nbsp;         * and called again in the exception handlers */
<i>442</i>&nbsp;
<i>443</i>&nbsp;        if (!surfaceData.isValid()) {
<b class="nc"><i>444</i>&nbsp;            throw new InvalidPipeException(&quot;attempt to validate Pipe with invalid SurfaceData&quot;);</b>
<b class="nc"><i>445</i>&nbsp;        }</b>
<i>446</i>&nbsp;
<i>447</i>&nbsp;        surfaceData.validatePipe(this);
<b class="nc"><i>448</i>&nbsp;    }</b>
<i>449</i>&nbsp;
<i>450</i>&nbsp;    /*
<i>451</i>&nbsp;     * Intersect two Shapes by the simplest method, attempting to produce
<i>452</i>&nbsp;     * a simplified result.
<i>453</i>&nbsp;     * The boolean arguments keep1 and keep2 specify whether or not
<i>454</i>&nbsp;     * the first or second shapes can be modified during the operation
<i>455</i>&nbsp;     * or whether that shape must be &quot;kept&quot; unmodified.
<i>456</i>&nbsp;     */
<i>457</i>&nbsp;    Shape intersectShapes(Shape s1, Shape s2, boolean keep1, boolean keep2) {
<i>458</i>&nbsp;        if (s1 instanceof Rectangle &amp;&amp; s2 instanceof Rectangle) {
<b class="nc"><i>459</i>&nbsp;            return ((Rectangle) s1).intersection((Rectangle) s2);</b>
<b class="nc"><i>460</i>&nbsp;        }</b>
<i>461</i>&nbsp;        if (s1 instanceof Rectangle2D) {
<b class="nc"><i>462</i>&nbsp;            return intersectRectShape((Rectangle2D) s1, s2, keep1, keep2);</b>
<b class="nc"><i>463</i>&nbsp;        } else if (s2 instanceof Rectangle2D) {</b>
<b class="nc"><i>464</i>&nbsp;            return intersectRectShape((Rectangle2D) s2, s1, keep2, keep1);</b>
<b class="nc"><i>465</i>&nbsp;        }</b>
<i>466</i>&nbsp;        return intersectByArea(s1, s2, keep1, keep2);
<b class="nc"><i>467</i>&nbsp;    }</b>
<i>468</i>&nbsp;
<i>469</i>&nbsp;    /*
<i>470</i>&nbsp;     * Intersect a Rectangle with a Shape by the simplest method,
<i>471</i>&nbsp;     * attempting to produce a simplified result.
<i>472</i>&nbsp;     * The boolean arguments keep1 and keep2 specify whether or not
<i>473</i>&nbsp;     * the first or second shapes can be modified during the operation
<i>474</i>&nbsp;     * or whether that shape must be &quot;kept&quot; unmodified.
<i>475</i>&nbsp;     */
<i>476</i>&nbsp;    Shape intersectRectShape(Rectangle2D r, Shape s,
<i>477</i>&nbsp;                             boolean keep1, boolean keep2) {
<i>478</i>&nbsp;        if (s instanceof Rectangle2D) {
<b class="nc"><i>479</i>&nbsp;            Rectangle2D r2 = (Rectangle2D) s;</b>
<b class="nc"><i>480</i>&nbsp;            Rectangle2D outrect;</b>
<i>481</i>&nbsp;            if (!keep1) {
<b class="nc"><i>482</i>&nbsp;                outrect = r;</b>
<b class="nc"><i>483</i>&nbsp;            } else if (!keep2) {</b>
<b class="nc"><i>484</i>&nbsp;                outrect = r2;</b>
<b class="nc"><i>485</i>&nbsp;            } else {</b>
<i>486</i>&nbsp;                outrect = new Rectangle2D.Float();
<b class="nc"><i>487</i>&nbsp;            }</b>
<i>488</i>&nbsp;            double x1 = Math.max(r.getX(), r2.getX());
<b class="nc"><i>489</i>&nbsp;            double x2 = Math.min(r.getX()  + r.getWidth(),</b>
<b class="nc"><i>490</i>&nbsp;                                 r2.getX() + r2.getWidth());</b>
<b class="nc"><i>491</i>&nbsp;            double y1 = Math.max(r.getY(), r2.getY());</b>
<b class="nc"><i>492</i>&nbsp;            double y2 = Math.min(r.getY()  + r.getHeight(),</b>
<b class="nc"><i>493</i>&nbsp;                                 r2.getY() + r2.getHeight());</b>
<b class="nc"><i>494</i>&nbsp;</b>
<i>495</i>&nbsp;            if (((x2 - x1) &lt; 0) || ((y2 - y1) &lt; 0))
<b class="nc"><i>496</i>&nbsp;                // Width or height is negative. No intersection.</b>
<i>497</i>&nbsp;                outrect.setFrameFromDiagonal(0, 0, 0, 0);
<b class="nc"><i>498</i>&nbsp;            else</b>
<i>499</i>&nbsp;                outrect.setFrameFromDiagonal(x1, y1, x2, y2);
<b class="nc"><i>500</i>&nbsp;            return outrect;</b>
<b class="nc"><i>501</i>&nbsp;        }</b>
<i>502</i>&nbsp;        if (r.contains(s.getBounds2D())) {
<b class="nc"><i>503</i>&nbsp;            if (keep2) {</b>
<b class="nc"><i>504</i>&nbsp;                s = cloneShape(s);</b>
<b class="nc"><i>505</i>&nbsp;            }</b>
<i>506</i>&nbsp;            return s;
<b class="nc"><i>507</i>&nbsp;        }</b>
<i>508</i>&nbsp;        return intersectByArea(r, s, keep1, keep2);
<b class="nc"><i>509</i>&nbsp;    }</b>
<i>510</i>&nbsp;
<i>511</i>&nbsp;    protected static Shape cloneShape(Shape s) {
<i>512</i>&nbsp;        return new GeneralPath(s);
<b class="nc"><i>513</i>&nbsp;    }</b>
<i>514</i>&nbsp;
<i>515</i>&nbsp;    /*
<i>516</i>&nbsp;     * Intersect two Shapes using the Area class.  Presumably other
<i>517</i>&nbsp;     * attempts at simpler intersection methods proved fruitless.
<i>518</i>&nbsp;     * The boolean arguments keep1 and keep2 specify whether or not
<i>519</i>&nbsp;     * the first or second shapes can be modified during the operation
<i>520</i>&nbsp;     * or whether that shape must be &quot;kept&quot; unmodified.
<i>521</i>&nbsp;     * @see #intersectShapes
<i>522</i>&nbsp;     * @see #intersectRectShape
<i>523</i>&nbsp;     */
<i>524</i>&nbsp;    Shape intersectByArea(Shape s1, Shape s2, boolean keep1, boolean keep2) {
<i>525</i>&nbsp;        Area a1, a2;
<i>526</i>&nbsp;
<i>527</i>&nbsp;        // First see if we can find an overwriteable source shape
<i>528</i>&nbsp;        // to use as our destination area to avoid duplication.
<i>529</i>&nbsp;        if (!keep1 &amp;&amp; (s1 instanceof Area)) {
<b class="nc"><i>530</i>&nbsp;            a1 = (Area) s1;</b>
<b class="nc"><i>531</i>&nbsp;        } else if (!keep2 &amp;&amp; (s2 instanceof Area)) {</b>
<b class="nc"><i>532</i>&nbsp;            a1 = (Area) s2;</b>
<b class="nc"><i>533</i>&nbsp;            s2 = s1;</b>
<b class="nc"><i>534</i>&nbsp;        } else {</b>
<i>535</i>&nbsp;            a1 = new Area(s1);
<b class="nc"><i>536</i>&nbsp;        }</b>
<i>537</i>&nbsp;
<i>538</i>&nbsp;        if (s2 instanceof Area) {
<b class="nc"><i>539</i>&nbsp;            a2 = (Area) s2;</b>
<b class="nc"><i>540</i>&nbsp;        } else {</b>
<i>541</i>&nbsp;            a2 = new Area(s2);
<b class="nc"><i>542</i>&nbsp;        }</b>
<i>543</i>&nbsp;
<i>544</i>&nbsp;        a1.intersect(a2);
<b class="nc"><i>545</i>&nbsp;        if (a1.isRectangular()) {</b>
<b class="nc"><i>546</i>&nbsp;            return a1.getBounds();</b>
<b class="nc"><i>547</i>&nbsp;        }</b>
<i>548</i>&nbsp;
<i>549</i>&nbsp;        return a1;
<b class="nc"><i>550</i>&nbsp;    }</b>
<i>551</i>&nbsp;
<i>552</i>&nbsp;    /*
<i>553</i>&nbsp;     * Intersect usrClip bounds and device bounds to determine the composite
<i>554</i>&nbsp;     * rendering boundaries.
<i>555</i>&nbsp;     */
<i>556</i>&nbsp;    public Region getCompClip() {
<i>557</i>&nbsp;        if (!surfaceData.isValid()) {
<b class="nc"><i>558</i>&nbsp;            // revalidateAll() implicitly recalculcates the composite clip</b>
<i>559</i>&nbsp;            revalidateAll();
<b class="nc"><i>560</i>&nbsp;        }</b>
<i>561</i>&nbsp;
<i>562</i>&nbsp;        return clipRegion;
<b class="nc"><i>563</i>&nbsp;    }</b>
<i>564</i>&nbsp;
<i>565</i>&nbsp;    public Font getFont() {
<i>566</i>&nbsp;        if (font == null) {
<b class="nc"><i>567</i>&nbsp;            font = defaultFont;</b>
<b class="nc"><i>568</i>&nbsp;        }</b>
<i>569</i>&nbsp;        return font;
<b class="nc"><i>570</i>&nbsp;    }</b>
<i>571</i>&nbsp;
<i>572</i>&nbsp;    private static final double[] IDENT_MATRIX = {1, 0, 0, 1};
<b class="nc"><i>573</i>&nbsp;    private static final AffineTransform IDENT_ATX =</b>
<b class="nc"><i>574</i>&nbsp;        new AffineTransform();</b>
<i>575</i>&nbsp;
<i>576</i>&nbsp;    private static final int MINALLOCATED = 8;
<i>577</i>&nbsp;    private static final int TEXTARRSIZE = 17;
<i>578</i>&nbsp;    private static double[][] textTxArr = new double[TEXTARRSIZE][];
<b class="nc"><i>579</i>&nbsp;    private static AffineTransform[] textAtArr =</b>
<b class="nc"><i>580</i>&nbsp;        new AffineTransform[TEXTARRSIZE];</b>
<i>581</i>&nbsp;
<i>582</i>&nbsp;    static {
<i>583</i>&nbsp;        for (int i=MINALLOCATED;i&lt;TEXTARRSIZE;i++) {
<b class="nc"><i>584</i>&nbsp;          textTxArr[i] = new double [] {i, 0, 0, i};</b>
<b class="nc"><i>585</i>&nbsp;          textAtArr[i] = new AffineTransform( textTxArr[i]);</b>
<b class="nc"><i>586</i>&nbsp;        }</b>
<i>587</i>&nbsp;    }
<i>588</i>&nbsp;
<i>589</i>&nbsp;    // cached state for various draw[String,Char,Byte] optimizations
<i>590</i>&nbsp;    public FontInfo checkFontInfo(FontInfo info, Font font,
<i>591</i>&nbsp;                                  FontRenderContext frc) {
<i>592</i>&nbsp;        /* Do not create a FontInfo object as part of construction of an
<i>593</i>&nbsp;         * SG2D as its possible it may never be needed - ie if no text
<i>594</i>&nbsp;         * is drawn using this SG2D.
<i>595</i>&nbsp;         */
<i>596</i>&nbsp;        if (info == null) {
<b class="nc"><i>597</i>&nbsp;            info = new FontInfo();</b>
<b class="nc"><i>598</i>&nbsp;        }</b>
<i>599</i>&nbsp;
<i>600</i>&nbsp;        float ptSize = font.getSize2D();
<b class="nc"><i>601</i>&nbsp;        int txFontType;</b>
<i>602</i>&nbsp;        AffineTransform devAt, textAt=null;
<b class="nc"><i>603</i>&nbsp;        if (font.isTransformed()) {</b>
<b class="nc"><i>604</i>&nbsp;            textAt = font.getTransform();</b>
<b class="nc"><i>605</i>&nbsp;            textAt.scale(ptSize, ptSize);</b>
<b class="nc"><i>606</i>&nbsp;            txFontType = textAt.getType();</b>
<b class="nc"><i>607</i>&nbsp;            info.originX = (float)textAt.getTranslateX();</b>
<b class="nc"><i>608</i>&nbsp;            info.originY = (float)textAt.getTranslateY();</b>
<b class="nc"><i>609</i>&nbsp;            textAt.translate(-info.originX, -info.originY);</b>
<b class="nc"><i>610</i>&nbsp;            if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {</b>
<b class="nc"><i>611</i>&nbsp;                transform.getMatrix(info.devTx = new double[4]);</b>
<b class="nc"><i>612</i>&nbsp;                devAt = new AffineTransform(info.devTx);</b>
<b class="nc"><i>613</i>&nbsp;                textAt.preConcatenate(devAt);</b>
<b class="nc"><i>614</i>&nbsp;            } else {</b>
<i>615</i>&nbsp;                info.devTx = IDENT_MATRIX;
<b class="nc"><i>616</i>&nbsp;                devAt = IDENT_ATX;</b>
<b class="nc"><i>617</i>&nbsp;            }</b>
<i>618</i>&nbsp;            textAt.getMatrix(info.glyphTx = new double[4]);
<b class="nc"><i>619</i>&nbsp;            double shearx = textAt.getShearX();</b>
<b class="nc"><i>620</i>&nbsp;            double scaley = textAt.getScaleY();</b>
<b class="nc"><i>621</i>&nbsp;            if (shearx != 0) {</b>
<b class="nc"><i>622</i>&nbsp;                scaley = Math.sqrt(shearx * shearx + scaley * scaley);</b>
<b class="nc"><i>623</i>&nbsp;            }</b>
<i>624</i>&nbsp;            info.pixelHeight = (int)(Math.abs(scaley)+0.5);
<b class="nc"><i>625</i>&nbsp;        } else {</b>
<b class="nc"><i>626</i>&nbsp;            txFontType = AffineTransform.TYPE_IDENTITY;</b>
<b class="nc"><i>627</i>&nbsp;            info.originX = info.originY = 0;</b>
<b class="nc"><i>628</i>&nbsp;            if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {</b>
<b class="nc"><i>629</i>&nbsp;                transform.getMatrix(info.devTx = new double[4]);</b>
<b class="nc"><i>630</i>&nbsp;                devAt = new AffineTransform(info.devTx);</b>
<b class="nc"><i>631</i>&nbsp;                info.glyphTx = new double[4];</b>
<b class="nc"><i>632</i>&nbsp;                for (int i = 0; i &lt; 4; i++) {</b>
<b class="nc"><i>633</i>&nbsp;                    info.glyphTx[i] = info.devTx[i] * ptSize;</b>
<b class="nc"><i>634</i>&nbsp;                }</b>
<i>635</i>&nbsp;                textAt = new AffineTransform(info.glyphTx);
<b class="nc"><i>636</i>&nbsp;                double shearx = transform.getShearX();</b>
<b class="nc"><i>637</i>&nbsp;                double scaley = transform.getScaleY();</b>
<b class="nc"><i>638</i>&nbsp;                if (shearx != 0) {</b>
<b class="nc"><i>639</i>&nbsp;                    scaley = Math.sqrt(shearx * shearx + scaley * scaley);</b>
<b class="nc"><i>640</i>&nbsp;                }</b>
<i>641</i>&nbsp;                info.pixelHeight = (int)(Math.abs(scaley * ptSize)+0.5);
<b class="nc"><i>642</i>&nbsp;            } else {</b>
<b class="nc"><i>643</i>&nbsp;                /* If the double represents a common integral, we</b>
<i>644</i>&nbsp;                 * may have pre-allocated objects.
<i>645</i>&nbsp;                 * A &quot;sparse&quot; array be seems to be as fast as a switch
<i>646</i>&nbsp;                 * even for 3 or 4 pt sizes, and is more flexible.
<i>647</i>&nbsp;                 * This should perform comparably in single-threaded
<i>648</i>&nbsp;                 * rendering to the old code which synchronized on the
<i>649</i>&nbsp;                 * class and scale better on MP systems.
<i>650</i>&nbsp;                 */
<i>651</i>&nbsp;                int pszInt = (int)ptSize;
<b class="nc"><i>652</i>&nbsp;                if (ptSize == pszInt &amp;&amp;</b>
<b class="nc"><i>653</i>&nbsp;                    pszInt &gt;= MINALLOCATED &amp;&amp; pszInt &lt; TEXTARRSIZE) {</b>
<i>654</i>&nbsp;                    info.glyphTx = textTxArr[pszInt];
<b class="nc"><i>655</i>&nbsp;                    textAt = textAtArr[pszInt];</b>
<b class="nc"><i>656</i>&nbsp;                    info.pixelHeight = pszInt;</b>
<b class="nc"><i>657</i>&nbsp;                } else {</b>
<i>658</i>&nbsp;                    info.pixelHeight = (int)(ptSize+0.5);
<b class="nc"><i>659</i>&nbsp;                }</b>
<i>660</i>&nbsp;                if (textAt == null) {
<b class="nc"><i>661</i>&nbsp;                    info.glyphTx = new double[] {ptSize, 0, 0, ptSize};</b>
<b class="nc"><i>662</i>&nbsp;                    textAt = new AffineTransform(info.glyphTx);</b>
<b class="nc"><i>663</i>&nbsp;                }</b>
<i>664</i>&nbsp;
<i>665</i>&nbsp;                info.devTx = IDENT_MATRIX;
<b class="nc"><i>666</i>&nbsp;                devAt = IDENT_ATX;</b>
<b class="nc"><i>667</i>&nbsp;            }</b>
<i>668</i>&nbsp;        }
<i>669</i>&nbsp;
<i>670</i>&nbsp;        info.font2D = FontUtilities.getFont2D(font);
<b class="nc"><i>671</i>&nbsp;</b>
<i>672</i>&nbsp;        int fmhint = fractionalMetricsHint;
<b class="nc"><i>673</i>&nbsp;        if (fmhint == SunHints.INTVAL_FRACTIONALMETRICS_DEFAULT) {</b>
<b class="nc"><i>674</i>&nbsp;            fmhint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;</b>
<b class="nc"><i>675</i>&nbsp;        }</b>
<i>676</i>&nbsp;        info.lcdSubPixPos = false; // conditionally set true in LCD mode.
<b class="nc"><i>677</i>&nbsp;</b>
<i>678</i>&nbsp;        /* The text anti-aliasing hints that are set by the client need
<i>679</i>&nbsp;         * to be interpreted for the current state and stored in the
<i>680</i>&nbsp;         * FontInfo.aahint which is what will actually be used and
<i>681</i>&nbsp;         * will be one of OFF, ON, LCD_HRGB or LCD_VRGB.
<i>682</i>&nbsp;         * This is what pipe selection code should typically refer to, not
<i>683</i>&nbsp;         * textAntialiasHint. This means we are now evaluating the meaning
<i>684</i>&nbsp;         * of &quot;default&quot; here. Any pipe that really cares about that will
<i>685</i>&nbsp;         * also need to consult that variable.
<i>686</i>&nbsp;         * Otherwise these are being used only as args to getStrike,
<i>687</i>&nbsp;         * and are encapsulated in that object which is part of the
<i>688</i>&nbsp;         * FontInfo, so we do not need to store them directly as fields
<i>689</i>&nbsp;         * in the FontInfo object.
<i>690</i>&nbsp;         * That could change if FontInfo&#39;s were more selectively
<i>691</i>&nbsp;         * revalidated when graphics state changed. Presently this
<i>692</i>&nbsp;         * method re-evaluates all fields in the fontInfo.
<i>693</i>&nbsp;         * The strike doesn&#39;t need to know the RGB subpixel order. Just
<i>694</i>&nbsp;         * if its H or V orientation, so if an LCD option is specified we
<i>695</i>&nbsp;         * always pass in the RGB hint to the strike.
<i>696</i>&nbsp;         * frc is non-null only if this is a GlyphVector. For reasons
<i>697</i>&nbsp;         * which are probably a historical mistake the AA hint in a GV
<i>698</i>&nbsp;         * is honoured when we render, overriding the Graphics setting.
<i>699</i>&nbsp;         */
<i>700</i>&nbsp;        int aahint;
<i>701</i>&nbsp;        if (frc == null) {
<b class="nc"><i>702</i>&nbsp;            aahint = textAntialiasHint;</b>
<b class="nc"><i>703</i>&nbsp;        } else {</b>
<i>704</i>&nbsp;            aahint = ((SunHints.Value)frc.getAntiAliasingHint()).getIndex();
<b class="nc"><i>705</i>&nbsp;        }</b>
<i>706</i>&nbsp;        if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT) {
<b class="nc"><i>707</i>&nbsp;            if (antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {</b>
<b class="nc"><i>708</i>&nbsp;                aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;</b>
<b class="nc"><i>709</i>&nbsp;            } else {</b>
<i>710</i>&nbsp;                aahint = SunHints.INTVAL_TEXT_ANTIALIAS_OFF;
<b class="nc"><i>711</i>&nbsp;            }</b>
<i>712</i>&nbsp;        } else {
<i>713</i>&nbsp;            /* If we are in checkFontInfo because a rendering hint has been
<i>714</i>&nbsp;             * set then all pipes are revalidated. But we can also
<i>715</i>&nbsp;             * be here because setFont() has been called when the &#39;gasp&#39;
<i>716</i>&nbsp;             * hint is set, as then the font size determines the text pipe.
<i>717</i>&nbsp;             * See comments in SunGraphics2d.setFont(Font).
<i>718</i>&nbsp;             */
<i>719</i>&nbsp;            if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_GASP) {
<b class="nc"><i>720</i>&nbsp;                if (info.font2D.useAAForPtSize(info.pixelHeight)) {</b>
<b class="nc"><i>721</i>&nbsp;                    aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;</b>
<b class="nc"><i>722</i>&nbsp;                } else {</b>
<i>723</i>&nbsp;                    aahint = SunHints.INTVAL_TEXT_ANTIALIAS_OFF;
<b class="nc"><i>724</i>&nbsp;                }</b>
<i>725</i>&nbsp;            } else if (aahint &gt;= SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB) {
<b class="nc"><i>726</i>&nbsp;                /* loops for default rendering modes are installed in the SG2D</b>
<i>727</i>&nbsp;                 * constructor. If there are none this will be null.
<i>728</i>&nbsp;                 * Not all compositing modes update the render loops, so
<i>729</i>&nbsp;                 * we also test that this is a mode we know should support
<i>730</i>&nbsp;                 * this. One minor issue is that the loops aren&#39;t necessarily
<i>731</i>&nbsp;                 * installed for a new rendering mode until after this
<i>732</i>&nbsp;                 * method is called during pipeline validation. So it is
<i>733</i>&nbsp;                 * theoretically possible that it was set to null for a
<i>734</i>&nbsp;                 * compositing mode, the composite is then set back to Src,
<i>735</i>&nbsp;                 * but the loop is still null when this is called and AA=ON
<i>736</i>&nbsp;                 * is installed instead of an LCD mode.
<i>737</i>&nbsp;                 * However this is done in the right order in SurfaceData.java
<i>738</i>&nbsp;                 * so this is not likely to be a problem - but not
<i>739</i>&nbsp;                 * guaranteed.
<i>740</i>&nbsp;                 */
<i>741</i>&nbsp;                if (
<b class="nc"><i>742</i>&nbsp;                    !surfaceData.canRenderLCDText(this)</b>
<b class="nc"><i>743</i>&nbsp;//                    loops.drawGlyphListLCDLoop == null ||</b>
<i>744</i>&nbsp;//                    compositeState &gt; COMP_ISCOPY ||
<i>745</i>&nbsp;//                    paintState &gt; PAINT_ALPHACOLOR
<i>746</i>&nbsp;                      ) {
<i>747</i>&nbsp;                    aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;
<b class="nc"><i>748</i>&nbsp;                } else {</b>
<i>749</i>&nbsp;                    info.lcdRGBOrder = true;
<b class="nc"><i>750</i>&nbsp;                    /* Collapse these into just HRGB or VRGB.</b>
<i>751</i>&nbsp;                     * Pipe selection code needs only to test for these two.
<i>752</i>&nbsp;                     * Since these both select the same pipe anyway its
<i>753</i>&nbsp;                     * tempting to collapse into one value. But they are
<i>754</i>&nbsp;                     * different strikes (glyph caches) so the distinction
<i>755</i>&nbsp;                     * needs to be made for that purpose.
<i>756</i>&nbsp;                     */
<i>757</i>&nbsp;                    if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HBGR) {
<b class="nc"><i>758</i>&nbsp;                        aahint = SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB;</b>
<b class="nc"><i>759</i>&nbsp;                        info.lcdRGBOrder = false;</b>
<b class="nc"><i>760</i>&nbsp;                    } else if</b>
<b class="nc"><i>761</i>&nbsp;                        (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VBGR) {</b>
<i>762</i>&nbsp;                        aahint = SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB;
<b class="nc"><i>763</i>&nbsp;                        info.lcdRGBOrder = false;</b>
<b class="nc"><i>764</i>&nbsp;                    }</b>
<i>765</i>&nbsp;                    /* Support subpixel positioning only for the case in
<i>766</i>&nbsp;                     * which the horizontal resolution is increased
<i>767</i>&nbsp;                     */
<i>768</i>&nbsp;                    info.lcdSubPixPos =
<b class="nc"><i>769</i>&nbsp;                        fmhint == SunHints.INTVAL_FRACTIONALMETRICS_ON &amp;&amp;</b>
<i>770</i>&nbsp;                        aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB;
<i>771</i>&nbsp;                }
<i>772</i>&nbsp;            }
<i>773</i>&nbsp;        }
<i>774</i>&nbsp;        info.aaHint = aahint;
<b class="nc"><i>775</i>&nbsp;        info.fontStrike = info.font2D.getStrike(font, devAt, textAt,</b>
<b class="nc"><i>776</i>&nbsp;                                                aahint, fmhint);</b>
<i>777</i>&nbsp;        return info;
<b class="nc"><i>778</i>&nbsp;    }</b>
<i>779</i>&nbsp;
<i>780</i>&nbsp;    public static boolean isRotated(double [] mtx) {
<i>781</i>&nbsp;        if ((mtx[0] == mtx[3]) &amp;&amp;
<b class="nc"><i>782</i>&nbsp;            (mtx[1] == 0.0) &amp;&amp;</b>
<i>783</i>&nbsp;            (mtx[2] == 0.0) &amp;&amp;
<i>784</i>&nbsp;            (mtx[0] &gt; 0.0))
<i>785</i>&nbsp;        {
<i>786</i>&nbsp;            return false;
<b class="nc"><i>787</i>&nbsp;        }</b>
<i>788</i>&nbsp;
<i>789</i>&nbsp;        return true;
<b class="nc"><i>790</i>&nbsp;    }</b>
<i>791</i>&nbsp;
<i>792</i>&nbsp;    public void setFont(Font font) {
<i>793</i>&nbsp;        /* replacing the reference equality test font != this.font with
<i>794</i>&nbsp;         * !font.equals(this.font) did not yield any measurable difference
<i>795</i>&nbsp;         * in testing, but there may be yet to be identified cases where it
<i>796</i>&nbsp;         * is beneficial.
<i>797</i>&nbsp;         */
<i>798</i>&nbsp;        if (font != null &amp;&amp; font!=this.font/*!font.equals(this.font)*/) {
<b class="nc"><i>799</i>&nbsp;            /* In the GASP AA case the textpipe depends on the glyph size</b>
<i>800</i>&nbsp;             * as determined by graphics and font transforms as well as the
<i>801</i>&nbsp;             * font size, and information in the font. But we may invalidate
<i>802</i>&nbsp;             * the pipe only to find that it made no difference.
<i>803</i>&nbsp;             * Deferring pipe invalidation to checkFontInfo won&#39;t work because
<i>804</i>&nbsp;             * when called we may already be rendering to the wrong pipe.
<i>805</i>&nbsp;             * So, if the font is transformed, or the graphics has more than
<i>806</i>&nbsp;             * a simple scale, we&#39;ll take that as enough of a hint to
<i>807</i>&nbsp;             * revalidate everything. But if they aren&#39;t we will
<i>808</i>&nbsp;             * use the font&#39;s point size to query the gasp table and see if
<i>809</i>&nbsp;             * what it says matches what&#39;s currently being used, in which
<i>810</i>&nbsp;             * case there&#39;s no need to invalidate the textpipe.
<i>811</i>&nbsp;             * This should be sufficient for all typical uses cases.
<i>812</i>&nbsp;             */
<i>813</i>&nbsp;            if (textAntialiasHint == SunHints.INTVAL_TEXT_ANTIALIAS_GASP &amp;&amp;
<b class="nc"><i>814</i>&nbsp;                textpipe != invalidpipe &amp;&amp;</b>
<i>815</i>&nbsp;                (transformState &gt; TRANSFORM_ANY_TRANSLATE ||
<i>816</i>&nbsp;                 font.isTransformed() ||
<b class="nc"><i>817</i>&nbsp;                 fontInfo == null || // Precaution, if true shouldn&#39;t get here</b>
<i>818</i>&nbsp;                 (fontInfo.aaHint == SunHints.INTVAL_TEXT_ANTIALIAS_ON) !=
<i>819</i>&nbsp;                     FontUtilities.getFont2D(font).
<b class="nc"><i>820</i>&nbsp;                         useAAForPtSize(font.getSize()))) {</b>
<b class="nc"><i>821</i>&nbsp;                textpipe = invalidpipe;</b>
<b class="nc"><i>822</i>&nbsp;            }</b>
<i>823</i>&nbsp;            this.font = font;
<b class="nc"><i>824</i>&nbsp;            this.fontMetrics = null;</b>
<b class="nc"><i>825</i>&nbsp;            this.validFontInfo = false;</b>
<b class="nc"><i>826</i>&nbsp;        }</b>
<i>827</i>&nbsp;    }
<i>828</i>&nbsp;
<i>829</i>&nbsp;    public FontInfo getFontInfo() {
<i>830</i>&nbsp;        if (!validFontInfo) {
<b class="nc"><i>831</i>&nbsp;            this.fontInfo = checkFontInfo(this.fontInfo, font, null);</b>
<b class="nc"><i>832</i>&nbsp;            validFontInfo = true;</b>
<b class="nc"><i>833</i>&nbsp;        }</b>
<i>834</i>&nbsp;        return this.fontInfo;
<b class="nc"><i>835</i>&nbsp;    }</b>
<i>836</i>&nbsp;
<i>837</i>&nbsp;    /* Used by drawGlyphVector which specifies its own font. */
<i>838</i>&nbsp;    public FontInfo getGVFontInfo(Font font, FontRenderContext frc) {
<i>839</i>&nbsp;        if (glyphVectorFontInfo != null &amp;&amp;
<b class="nc"><i>840</i>&nbsp;            glyphVectorFontInfo.font == font &amp;&amp;</b>
<i>841</i>&nbsp;            glyphVectorFRC == frc) {
<i>842</i>&nbsp;            return glyphVectorFontInfo;
<b class="nc"><i>843</i>&nbsp;        } else {</b>
<i>844</i>&nbsp;            glyphVectorFRC = frc;
<b class="nc"><i>845</i>&nbsp;            return glyphVectorFontInfo =</b>
<b class="nc"><i>846</i>&nbsp;                checkFontInfo(glyphVectorFontInfo, font, frc);</b>
<b class="nc"><i>847</i>&nbsp;        }</b>
<i>848</i>&nbsp;    }
<i>849</i>&nbsp;
<i>850</i>&nbsp;    public FontMetrics getFontMetrics() {
<i>851</i>&nbsp;        if (this.fontMetrics != null) {
<b class="nc"><i>852</i>&nbsp;            return this.fontMetrics;</b>
<b class="nc"><i>853</i>&nbsp;        }</b>
<i>854</i>&nbsp;        /* NB the constructor and the setter disallow &quot;font&quot; being null */
<i>855</i>&nbsp;        return this.fontMetrics =
<b class="nc"><i>856</i>&nbsp;           FontDesignMetrics.getMetrics(font, getFontRenderContext());</b>
<b class="nc"><i>857</i>&nbsp;    }</b>
<i>858</i>&nbsp;
<i>859</i>&nbsp;    public FontMetrics getFontMetrics(Font font) {
<i>860</i>&nbsp;        if ((this.fontMetrics != null) &amp;&amp; (font == this.font)) {
<b class="nc"><i>861</i>&nbsp;            return this.fontMetrics;</b>
<b class="nc"><i>862</i>&nbsp;        }</b>
<i>863</i>&nbsp;        FontMetrics fm =
<b class="nc"><i>864</i>&nbsp;          FontDesignMetrics.getMetrics(font, getFontRenderContext());</b>
<b class="nc"><i>865</i>&nbsp;</b>
<i>866</i>&nbsp;        if (this.font == font) {
<b class="nc"><i>867</i>&nbsp;            this.fontMetrics = fm;</b>
<b class="nc"><i>868</i>&nbsp;        }</b>
<i>869</i>&nbsp;        return fm;
<b class="nc"><i>870</i>&nbsp;    }</b>
<i>871</i>&nbsp;
<i>872</i>&nbsp;    /**
<i>873</i>&nbsp;     * Checks to see if a Path intersects the specified Rectangle in device
<i>874</i>&nbsp;     * space.  The rendering attributes taken into account include the
<i>875</i>&nbsp;     * clip, transform, and stroke attributes.
<i>876</i>&nbsp;     * @param rect The area in device space to check for a hit.
<i>877</i>&nbsp;     * @param s The path to check for a hit.
<i>878</i>&nbsp;     * @param onStroke Flag to choose between testing the stroked or
<i>879</i>&nbsp;     * the filled path.
<i>880</i>&nbsp;     * @return True if there is a hit, false otherwise.
<i>881</i>&nbsp;     * @see #setStroke
<i>882</i>&nbsp;     * @see #fill(Shape)
<i>883</i>&nbsp;     * @see #draw(Shape)
<i>884</i>&nbsp;     * @see #transform
<i>885</i>&nbsp;     * @see #setTransform
<i>886</i>&nbsp;     * @see #clip
<i>887</i>&nbsp;     * @see #setClip
<i>888</i>&nbsp;     */
<i>889</i>&nbsp;    public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
<i>890</i>&nbsp;        if (onStroke) {
<b class="nc"><i>891</i>&nbsp;            s = stroke.createStrokedShape(s);</b>
<b class="nc"><i>892</i>&nbsp;        }</b>
<i>893</i>&nbsp;
<i>894</i>&nbsp;        s = transformShape(s);
<b class="nc"><i>895</i>&nbsp;        if ((constrainX|constrainY) != 0) {</b>
<b class="nc"><i>896</i>&nbsp;            rect = new Rectangle(rect);</b>
<b class="nc"><i>897</i>&nbsp;            rect.translate(constrainX, constrainY);</b>
<b class="nc"><i>898</i>&nbsp;        }</b>
<i>899</i>&nbsp;
<i>900</i>&nbsp;        return s.intersects(rect);
<b class="nc"><i>901</i>&nbsp;    }</b>
<i>902</i>&nbsp;
<i>903</i>&nbsp;    /**
<i>904</i>&nbsp;     * Return the ColorModel associated with this Graphics2D.
<i>905</i>&nbsp;     */
<i>906</i>&nbsp;    public ColorModel getDeviceColorModel() {
<i>907</i>&nbsp;        return surfaceData.getColorModel();
<b class="nc"><i>908</i>&nbsp;    }</b>
<i>909</i>&nbsp;
<i>910</i>&nbsp;    /**
<i>911</i>&nbsp;     * Return the device configuration associated with this Graphics2D.
<i>912</i>&nbsp;     */
<i>913</i>&nbsp;    public GraphicsConfiguration getDeviceConfiguration() {
<i>914</i>&nbsp;        return surfaceData.getDeviceConfiguration();
<b class="nc"><i>915</i>&nbsp;    }</b>
<i>916</i>&nbsp;
<i>917</i>&nbsp;    /**
<i>918</i>&nbsp;     * Return the SurfaceData object assigned to manage the destination
<i>919</i>&nbsp;     * drawable surface of this Graphics2D.
<i>920</i>&nbsp;     */
<i>921</i>&nbsp;    public SurfaceData getSurfaceData() {
<i>922</i>&nbsp;        return surfaceData;
<b class="nc"><i>923</i>&nbsp;    }</b>
<i>924</i>&nbsp;
<i>925</i>&nbsp;    /**
<i>926</i>&nbsp;     * Sets the Composite in the current graphics state. Composite is used
<i>927</i>&nbsp;     * in all drawing methods such as drawImage, drawString, drawPath,
<i>928</i>&nbsp;     * and fillPath.  It specifies how new pixels are to be combined with
<i>929</i>&nbsp;     * the existing pixels on the graphics device in the rendering process.
<i>930</i>&nbsp;     * @param comp The Composite object to be used for drawing.
<i>931</i>&nbsp;     * @see java.awt.Graphics#setXORMode
<i>932</i>&nbsp;     * @see java.awt.Graphics#setPaintMode
<i>933</i>&nbsp;     * @see AlphaComposite
<i>934</i>&nbsp;     */
<i>935</i>&nbsp;    public void setComposite(Composite comp) {
<i>936</i>&nbsp;        if (composite == comp) {
<b class="nc"><i>937</i>&nbsp;            return;</b>
<i>938</i>&nbsp;        }
<i>939</i>&nbsp;        int newCompState;
<i>940</i>&nbsp;        CompositeType newCompType;
<i>941</i>&nbsp;        if (comp instanceof AlphaComposite) {
<b class="nc"><i>942</i>&nbsp;            AlphaComposite alphacomp = (AlphaComposite) comp;</b>
<b class="nc"><i>943</i>&nbsp;            newCompType = CompositeType.forAlphaComposite(alphacomp);</b>
<b class="nc"><i>944</i>&nbsp;            if (newCompType == CompositeType.SrcOverNoEa) {</b>
<b class="nc"><i>945</i>&nbsp;                if (paintState == PAINT_OPAQUECOLOR ||</b>
<b class="nc"><i>946</i>&nbsp;                    (paintState &gt; PAINT_ALPHACOLOR &amp;&amp;</b>
<i>947</i>&nbsp;                     paint.getTransparency() == Transparency.OPAQUE))
<b class="nc"><i>948</i>&nbsp;                {</b>
<i>949</i>&nbsp;                    newCompState = COMP_ISCOPY;
<b class="nc"><i>950</i>&nbsp;                } else {</b>
<i>951</i>&nbsp;                    newCompState = COMP_ALPHA;
<b class="nc"><i>952</i>&nbsp;                }</b>
<i>953</i>&nbsp;            } else if (newCompType == CompositeType.SrcNoEa ||
<b class="nc"><i>954</i>&nbsp;                       newCompType == CompositeType.Src ||</b>
<i>955</i>&nbsp;                       newCompType == CompositeType.Clear)
<i>956</i>&nbsp;            {
<i>957</i>&nbsp;                newCompState = COMP_ISCOPY;
<b class="nc"><i>958</i>&nbsp;            } else if (surfaceData.getTransparency() == Transparency.OPAQUE &amp;&amp;</b>
<b class="nc"><i>959</i>&nbsp;                       newCompType == CompositeType.SrcIn)</b>
<i>960</i>&nbsp;            {
<i>961</i>&nbsp;                newCompState = COMP_ISCOPY;
<b class="nc"><i>962</i>&nbsp;            } else {</b>
<i>963</i>&nbsp;                newCompState = COMP_ALPHA;
<b class="nc"><i>964</i>&nbsp;            }</b>
<i>965</i>&nbsp;        } else if (comp instanceof XORComposite) {
<b class="nc"><i>966</i>&nbsp;            newCompState = COMP_XOR;</b>
<b class="nc"><i>967</i>&nbsp;            newCompType = CompositeType.Xor;</b>
<b class="nc"><i>968</i>&nbsp;        } else if (comp == null) {</b>
<b class="nc"><i>969</i>&nbsp;            throw new IllegalArgumentException(&quot;null Composite&quot;);</b>
<b class="nc"><i>970</i>&nbsp;        } else {</b>
<i>971</i>&nbsp;            surfaceData.checkCustomComposite();
<b class="nc"><i>972</i>&nbsp;            newCompState = COMP_CUSTOM;</b>
<b class="nc"><i>973</i>&nbsp;            newCompType = CompositeType.General;</b>
<b class="nc"><i>974</i>&nbsp;        }</b>
<i>975</i>&nbsp;        if (compositeState != newCompState ||
<b class="nc"><i>976</i>&nbsp;            imageComp != newCompType)</b>
<i>977</i>&nbsp;        {
<i>978</i>&nbsp;            compositeState = newCompState;
<b class="nc"><i>979</i>&nbsp;            imageComp = newCompType;</b>
<b class="nc"><i>980</i>&nbsp;            invalidatePipe();</b>
<b class="nc"><i>981</i>&nbsp;            validFontInfo = false;</b>
<b class="nc"><i>982</i>&nbsp;        }</b>
<i>983</i>&nbsp;        composite = comp;
<b class="nc"><i>984</i>&nbsp;        if (paintState &lt;= PAINT_ALPHACOLOR) {</b>
<b class="nc"><i>985</i>&nbsp;            validateColor();</b>
<b class="nc"><i>986</i>&nbsp;        }</b>
<i>987</i>&nbsp;    }
<i>988</i>&nbsp;
<i>989</i>&nbsp;    /**
<i>990</i>&nbsp;     * Sets the Paint in the current graphics state.
<i>991</i>&nbsp;     * @param paint The Paint object to be used to generate color in
<i>992</i>&nbsp;     * the rendering process.
<i>993</i>&nbsp;     * @see java.awt.Graphics#setColor
<i>994</i>&nbsp;     * @see GradientPaint
<i>995</i>&nbsp;     * @see TexturePaint
<i>996</i>&nbsp;     */
<i>997</i>&nbsp;    public void setPaint(Paint paint) {
<i>998</i>&nbsp;        if (paint instanceof Color) {
<b class="nc"><i>999</i>&nbsp;            setColor((Color) paint);</b>
<b class="nc"><i>1000</i>&nbsp;            return;</b>
<i>1001</i>&nbsp;        }
<i>1002</i>&nbsp;        if (paint == null || this.paint == paint) {
<b class="nc"><i>1003</i>&nbsp;            return;</b>
<i>1004</i>&nbsp;        }
<i>1005</i>&nbsp;        this.paint = paint;
<b class="nc"><i>1006</i>&nbsp;        if (imageComp == CompositeType.SrcOverNoEa) {</b>
<b class="nc"><i>1007</i>&nbsp;            // special case where compState depends on opacity of paint</b>
<i>1008</i>&nbsp;            if (paint.getTransparency() == Transparency.OPAQUE) {
<b class="nc"><i>1009</i>&nbsp;                if (compositeState != COMP_ISCOPY) {</b>
<b class="nc"><i>1010</i>&nbsp;                    compositeState = COMP_ISCOPY;</b>
<b class="nc"><i>1011</i>&nbsp;                }</b>
<i>1012</i>&nbsp;            } else {
<i>1013</i>&nbsp;                if (compositeState == COMP_ISCOPY) {
<b class="nc"><i>1014</i>&nbsp;                    compositeState = COMP_ALPHA;</b>
<b class="nc"><i>1015</i>&nbsp;                }</b>
<i>1016</i>&nbsp;            }
<i>1017</i>&nbsp;        }
<i>1018</i>&nbsp;        Class&lt;? extends Paint&gt; paintClass = paint.getClass();
<b class="nc"><i>1019</i>&nbsp;        if (paintClass == GradientPaint.class) {</b>
<b class="nc"><i>1020</i>&nbsp;            paintState = PAINT_GRADIENT;</b>
<b class="nc"><i>1021</i>&nbsp;        } else if (paintClass == LinearGradientPaint.class) {</b>
<b class="nc"><i>1022</i>&nbsp;            paintState = PAINT_LIN_GRADIENT;</b>
<b class="nc"><i>1023</i>&nbsp;        } else if (paintClass == RadialGradientPaint.class) {</b>
<b class="nc"><i>1024</i>&nbsp;            paintState = PAINT_RAD_GRADIENT;</b>
<b class="nc"><i>1025</i>&nbsp;        } else if (paintClass == TexturePaint.class) {</b>
<b class="nc"><i>1026</i>&nbsp;            paintState = PAINT_TEXTURE;</b>
<b class="nc"><i>1027</i>&nbsp;        } else {</b>
<i>1028</i>&nbsp;            paintState = PAINT_CUSTOM;
<b class="nc"><i>1029</i>&nbsp;        }</b>
<i>1030</i>&nbsp;        validFontInfo = false;
<b class="nc"><i>1031</i>&nbsp;        invalidatePipe();</b>
<b class="nc"><i>1032</i>&nbsp;    }</b>
<i>1033</i>&nbsp;
<i>1034</i>&nbsp;    static final int NON_UNIFORM_SCALE_MASK =
<i>1035</i>&nbsp;        (AffineTransform.TYPE_GENERAL_TRANSFORM |
<i>1036</i>&nbsp;         AffineTransform.TYPE_GENERAL_SCALE);
<i>1037</i>&nbsp;    public static final double MinPenSizeAA =
<i>1038</i>&nbsp;        sun.java2d.pipe.RenderingEngine.getInstance().getMinimumAAPenSize();
<b class="nc"><i>1039</i>&nbsp;    public static final double MinPenSizeAASquared =</b>
<b class="nc"><i>1040</i>&nbsp;        (MinPenSizeAA * MinPenSizeAA);</b>
<i>1041</i>&nbsp;    // Since inaccuracies in the trig package can cause us to
<i>1042</i>&nbsp;    // calculated a rotated pen width of just slightly greater
<i>1043</i>&nbsp;    // than 1.0, we add a fudge factor to our comparison value
<i>1044</i>&nbsp;    // here so that we do not misclassify single width lines as
<i>1045</i>&nbsp;    // wide lines under certain rotations.
<i>1046</i>&nbsp;    public static final double MinPenSizeSquared = 1.000000001;
<i>1047</i>&nbsp;
<i>1048</i>&nbsp;    private void validateBasicStroke(BasicStroke bs) {
<i>1049</i>&nbsp;        boolean aa = (antialiasHint == SunHints.INTVAL_ANTIALIAS_ON);
<b class="nc"><i>1050</i>&nbsp;        if (transformState &lt; TRANSFORM_TRANSLATESCALE) {</b>
<b class="nc"><i>1051</i>&nbsp;            if (aa) {</b>
<b class="nc"><i>1052</i>&nbsp;                if (bs.getLineWidth() &lt;= MinPenSizeAA) {</b>
<b class="nc"><i>1053</i>&nbsp;                    if (bs.getDashArray() == null) {</b>
<b class="nc"><i>1054</i>&nbsp;                        strokeState = STROKE_THIN;</b>
<b class="nc"><i>1055</i>&nbsp;                    } else {</b>
<i>1056</i>&nbsp;                        strokeState = STROKE_THINDASHED;
<b class="nc"><i>1057</i>&nbsp;                    }</b>
<i>1058</i>&nbsp;                } else {
<i>1059</i>&nbsp;                    strokeState = STROKE_WIDE;
<b class="nc"><i>1060</i>&nbsp;                }</b>
<i>1061</i>&nbsp;            } else {
<i>1062</i>&nbsp;                if (bs == defaultStroke) {
<b class="nc"><i>1063</i>&nbsp;                    strokeState = STROKE_THIN;</b>
<b class="nc"><i>1064</i>&nbsp;                } else if (bs.getLineWidth() &lt;= 1.0f) {</b>
<b class="nc"><i>1065</i>&nbsp;                    if (bs.getDashArray() == null) {</b>
<b class="nc"><i>1066</i>&nbsp;                        strokeState = STROKE_THIN;</b>
<b class="nc"><i>1067</i>&nbsp;                    } else {</b>
<i>1068</i>&nbsp;                        strokeState = STROKE_THINDASHED;
<b class="nc"><i>1069</i>&nbsp;                    }</b>
<i>1070</i>&nbsp;                } else {
<i>1071</i>&nbsp;                    strokeState = STROKE_WIDE;
<b class="nc"><i>1072</i>&nbsp;                }</b>
<i>1073</i>&nbsp;            }
<i>1074</i>&nbsp;        } else {
<i>1075</i>&nbsp;            double widthsquared;
<i>1076</i>&nbsp;            if ((transform.getType() &amp; NON_UNIFORM_SCALE_MASK) == 0) {
<b class="nc"><i>1077</i>&nbsp;                /* sqrt omitted, compare to squared limits below. */</b>
<i>1078</i>&nbsp;                widthsquared = Math.abs(transform.getDeterminant());
<b class="nc"><i>1079</i>&nbsp;            } else {</b>
<i>1080</i>&nbsp;                /* First calculate the &quot;maximum scale&quot; of this transform. */
<i>1081</i>&nbsp;                double A = transform.getScaleX();       // m00
<b class="nc"><i>1082</i>&nbsp;                double C = transform.getShearX();       // m01</b>
<b class="nc"><i>1083</i>&nbsp;                double B = transform.getShearY();       // m10</b>
<b class="nc"><i>1084</i>&nbsp;                double D = transform.getScaleY();       // m11</b>
<b class="nc"><i>1085</i>&nbsp;</b>
<i>1086</i>&nbsp;                /*
<i>1087</i>&nbsp;                 * Given a 2 x 2 affine matrix [ A B ] such that
<i>1088</i>&nbsp;                 *                             [ C D ]
<i>1089</i>&nbsp;                 * v&#39; = [x&#39; y&#39;] = [Ax + Cy, Bx + Dy], we want to
<i>1090</i>&nbsp;                 * find the maximum magnitude (norm) of the vector v&#39;
<i>1091</i>&nbsp;                 * with the constraint (x^2 + y^2 = 1).
<i>1092</i>&nbsp;                 * The equation to maximize is
<i>1093</i>&nbsp;                 *     |v&#39;| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
<i>1094</i>&nbsp;                 * or  |v&#39;| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
<i>1095</i>&nbsp;                 * Since sqrt is monotonic we can maximize |v&#39;|^2
<i>1096</i>&nbsp;                 * instead and plug in the substitution y = sqrt(1 - x^2).
<i>1097</i>&nbsp;                 * Trigonometric equalities can then be used to get
<i>1098</i>&nbsp;                 * rid of most of the sqrt terms.
<i>1099</i>&nbsp;                 */
<i>1100</i>&nbsp;                double EA = A*A + B*B;          // x^2 coefficient
<b class="nc"><i>1101</i>&nbsp;                double EB = 2*(A*C + B*D);      // xy coefficient</b>
<b class="nc"><i>1102</i>&nbsp;                double EC = C*C + D*D;          // y^2 coefficient</b>
<b class="nc"><i>1103</i>&nbsp;</b>
<i>1104</i>&nbsp;                /*
<i>1105</i>&nbsp;                 * There is a lot of calculus omitted here.
<i>1106</i>&nbsp;                 *
<i>1107</i>&nbsp;                 * Conceptually, in the interests of understanding the
<i>1108</i>&nbsp;                 * terms that the calculus produced we can consider
<i>1109</i>&nbsp;                 * that EA and EC end up providing the lengths along
<i>1110</i>&nbsp;                 * the major axes and the hypot term ends up being an
<i>1111</i>&nbsp;                 * adjustment for the additional length along the off-axis
<i>1112</i>&nbsp;                 * angle of rotated or sheared ellipses as well as an
<i>1113</i>&nbsp;                 * adjustment for the fact that the equation below
<i>1114</i>&nbsp;                 * averages the two major axis lengths.  (Notice that
<i>1115</i>&nbsp;                 * the hypot term contains a part which resolves to the
<i>1116</i>&nbsp;                 * difference of these two axis lengths in the absence
<i>1117</i>&nbsp;                 * of rotation.)
<i>1118</i>&nbsp;                 *
<i>1119</i>&nbsp;                 * In the calculus, the ratio of the EB and (EA-EC) terms
<i>1120</i>&nbsp;                 * ends up being the tangent of 2*theta where theta is
<i>1121</i>&nbsp;                 * the angle that the long axis of the ellipse makes
<i>1122</i>&nbsp;                 * with the horizontal axis.  Thus, this equation is
<i>1123</i>&nbsp;                 * calculating the length of the hypotenuse of a triangle
<i>1124</i>&nbsp;                 * along that axis.
<i>1125</i>&nbsp;                 */
<i>1126</i>&nbsp;                double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));
<b class="nc"><i>1127</i>&nbsp;</b>
<i>1128</i>&nbsp;                /* sqrt omitted, compare to squared limits below. */
<i>1129</i>&nbsp;                widthsquared = ((EA + EC + hypot)/2.0);
<b class="nc"><i>1130</i>&nbsp;            }</b>
<i>1131</i>&nbsp;            if (bs != defaultStroke) {
<b class="nc"><i>1132</i>&nbsp;                widthsquared *= bs.getLineWidth() * bs.getLineWidth();</b>
<b class="nc"><i>1133</i>&nbsp;            }</b>
<i>1134</i>&nbsp;            if (widthsquared &lt;=
<b class="nc"><i>1135</i>&nbsp;                (aa ? MinPenSizeAASquared : MinPenSizeSquared))</b>
<i>1136</i>&nbsp;            {
<i>1137</i>&nbsp;                if (bs.getDashArray() == null) {
<b class="nc"><i>1138</i>&nbsp;                    strokeState = STROKE_THIN;</b>
<b class="nc"><i>1139</i>&nbsp;                } else {</b>
<i>1140</i>&nbsp;                    strokeState = STROKE_THINDASHED;
<b class="nc"><i>1141</i>&nbsp;                }</b>
<i>1142</i>&nbsp;            } else {
<i>1143</i>&nbsp;                strokeState = STROKE_WIDE;
<b class="nc"><i>1144</i>&nbsp;            }</b>
<i>1145</i>&nbsp;        }
<i>1146</i>&nbsp;    }
<i>1147</i>&nbsp;
<i>1148</i>&nbsp;    /*
<i>1149</i>&nbsp;     * Sets the Stroke in the current graphics state.
<i>1150</i>&nbsp;     * @param s The Stroke object to be used to stroke a Path in
<i>1151</i>&nbsp;     * the rendering process.
<i>1152</i>&nbsp;     * @see BasicStroke
<i>1153</i>&nbsp;     */
<i>1154</i>&nbsp;    public void setStroke(Stroke s) {
<i>1155</i>&nbsp;        if (s == null) {
<b class="nc"><i>1156</i>&nbsp;            throw new IllegalArgumentException(&quot;null Stroke&quot;);</b>
<b class="nc"><i>1157</i>&nbsp;        }</b>
<i>1158</i>&nbsp;        int saveStrokeState = strokeState;
<b class="nc"><i>1159</i>&nbsp;        stroke = s;</b>
<b class="nc"><i>1160</i>&nbsp;        if (s instanceof BasicStroke) {</b>
<b class="nc"><i>1161</i>&nbsp;            validateBasicStroke((BasicStroke) s);</b>
<b class="nc"><i>1162</i>&nbsp;        } else {</b>
<i>1163</i>&nbsp;            strokeState = STROKE_CUSTOM;
<b class="nc"><i>1164</i>&nbsp;        }</b>
<i>1165</i>&nbsp;        if (strokeState != saveStrokeState) {
<b class="nc"><i>1166</i>&nbsp;            invalidatePipe();</b>
<b class="nc"><i>1167</i>&nbsp;        }</b>
<i>1168</i>&nbsp;    }
<i>1169</i>&nbsp;
<i>1170</i>&nbsp;    /**
<i>1171</i>&nbsp;     * Sets the preferences for the rendering algorithms.
<i>1172</i>&nbsp;     * Hint categories include controls for rendering quality and
<i>1173</i>&nbsp;     * overall time/quality trade-off in the rendering process.
<i>1174</i>&nbsp;     * @param hintKey The key of hint to be set. The strings are
<i>1175</i>&nbsp;     * defined in the RenderingHints class.
<i>1176</i>&nbsp;     * @param hintValue The value indicating preferences for the specified
<i>1177</i>&nbsp;     * hint category. These strings are defined in the RenderingHints
<i>1178</i>&nbsp;     * class.
<i>1179</i>&nbsp;     * @see RenderingHints
<i>1180</i>&nbsp;     */
<i>1181</i>&nbsp;    public void setRenderingHint(Key hintKey, Object hintValue) {
<i>1182</i>&nbsp;        // If we recognize the key, we must recognize the value
<i>1183</i>&nbsp;        //     otherwise throw an IllegalArgumentException
<i>1184</i>&nbsp;        //     and do not change the Hints object
<i>1185</i>&nbsp;        // If we do not recognize the key, just pass it through
<i>1186</i>&nbsp;        //     to the Hints object untouched
<i>1187</i>&nbsp;        if (!hintKey.isCompatibleValue(hintValue)) {
<b class="nc"><i>1188</i>&nbsp;            throw new IllegalArgumentException</b>
<b class="nc"><i>1189</i>&nbsp;                (hintValue+&quot; is not compatible with &quot;+hintKey);</b>
<i>1190</i>&nbsp;        }
<i>1191</i>&nbsp;        if (hintKey instanceof SunHints.Key) {
<b class="nc"><i>1192</i>&nbsp;            boolean stateChanged;</b>
<i>1193</i>&nbsp;            boolean textStateChanged = false;
<b class="nc"><i>1194</i>&nbsp;            boolean recognized = true;</b>
<b class="nc"><i>1195</i>&nbsp;            SunHints.Key sunKey = (SunHints.Key) hintKey;</b>
<b class="nc"><i>1196</i>&nbsp;            int newHint;</b>
<i>1197</i>&nbsp;            if (sunKey == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST) {
<b class="nc"><i>1198</i>&nbsp;                newHint = ((Integer)hintValue).intValue();</b>
<b class="nc"><i>1199</i>&nbsp;            } else {</b>
<i>1200</i>&nbsp;                newHint = ((SunHints.Value) hintValue).getIndex();
<b class="nc"><i>1201</i>&nbsp;            }</b>
<i>1202</i>&nbsp;            switch (sunKey.getIndex()) {
<b class="nc"><i>1203</i>&nbsp;            case SunHints.INTKEY_RENDERING:</b>
<i>1204</i>&nbsp;                stateChanged = (renderHint != newHint);
<b class="nc"><i>1205</i>&nbsp;                if (stateChanged) {</b>
<b class="nc"><i>1206</i>&nbsp;                    renderHint = newHint;</b>
<b class="nc"><i>1207</i>&nbsp;                    if (interpolationHint == -1) {</b>
<b class="nc"><i>1208</i>&nbsp;                        interpolationType =</b>
<b class="nc"><i>1209</i>&nbsp;                            (newHint == SunHints.INTVAL_RENDER_QUALITY</b>
<i>1210</i>&nbsp;                             ? AffineTransformOp.TYPE_BILINEAR
<i>1211</i>&nbsp;                             : AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
<i>1212</i>&nbsp;                    }
<i>1213</i>&nbsp;                }
<i>1214</i>&nbsp;                break;
<i>1215</i>&nbsp;            case SunHints.INTKEY_ANTIALIASING:
<i>1216</i>&nbsp;                stateChanged = (antialiasHint != newHint);
<b class="nc"><i>1217</i>&nbsp;                antialiasHint = newHint;</b>
<b class="nc"><i>1218</i>&nbsp;                if (stateChanged) {</b>
<b class="nc"><i>1219</i>&nbsp;                    textStateChanged =</b>
<b class="nc"><i>1220</i>&nbsp;                        (textAntialiasHint ==</b>
<i>1221</i>&nbsp;                         SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT);
<i>1222</i>&nbsp;                    if (strokeState != STROKE_CUSTOM) {
<b class="nc"><i>1223</i>&nbsp;                        validateBasicStroke((BasicStroke) stroke);</b>
<b class="nc"><i>1224</i>&nbsp;                    }</b>
<i>1225</i>&nbsp;                }
<i>1226</i>&nbsp;                break;
<i>1227</i>&nbsp;            case SunHints.INTKEY_TEXT_ANTIALIASING:
<i>1228</i>&nbsp;                stateChanged = (textAntialiasHint != newHint);
<b class="nc"><i>1229</i>&nbsp;                textStateChanged = stateChanged;</b>
<b class="nc"><i>1230</i>&nbsp;                textAntialiasHint = newHint;</b>
<b class="nc"><i>1231</i>&nbsp;                break;</b>
<b class="nc"><i>1232</i>&nbsp;            case SunHints.INTKEY_FRACTIONALMETRICS:</b>
<i>1233</i>&nbsp;                stateChanged = (fractionalMetricsHint != newHint);
<b class="nc"><i>1234</i>&nbsp;                textStateChanged = stateChanged;</b>
<b class="nc"><i>1235</i>&nbsp;                fractionalMetricsHint = newHint;</b>
<b class="nc"><i>1236</i>&nbsp;                break;</b>
<b class="nc"><i>1237</i>&nbsp;            case SunHints.INTKEY_AATEXT_LCD_CONTRAST:</b>
<i>1238</i>&nbsp;                stateChanged = false;
<b class="nc"><i>1239</i>&nbsp;                /* Already have validated it is an int 100 &lt;= newHint &lt;= 250 */</b>
<i>1240</i>&nbsp;                lcdTextContrast = newHint;
<b class="nc"><i>1241</i>&nbsp;                break;</b>
<b class="nc"><i>1242</i>&nbsp;            case SunHints.INTKEY_INTERPOLATION:</b>
<i>1243</i>&nbsp;                interpolationHint = newHint;
<b class="nc"><i>1244</i>&nbsp;                switch (newHint) {</b>
<b class="nc"><i>1245</i>&nbsp;                case SunHints.INTVAL_INTERPOLATION_BICUBIC:</b>
<i>1246</i>&nbsp;                    newHint = AffineTransformOp.TYPE_BICUBIC;
<b class="nc"><i>1247</i>&nbsp;                    break;</b>
<b class="nc"><i>1248</i>&nbsp;                case SunHints.INTVAL_INTERPOLATION_BILINEAR:</b>
<i>1249</i>&nbsp;                    newHint = AffineTransformOp.TYPE_BILINEAR;
<b class="nc"><i>1250</i>&nbsp;                    break;</b>
<b class="nc"><i>1251</i>&nbsp;                default:</b>
<i>1252</i>&nbsp;                case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:
<i>1253</i>&nbsp;                    newHint = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;
<b class="nc"><i>1254</i>&nbsp;                    break;</b>
<i>1255</i>&nbsp;                }
<i>1256</i>&nbsp;                stateChanged = (interpolationType != newHint);
<b class="nc"><i>1257</i>&nbsp;                interpolationType = newHint;</b>
<b class="nc"><i>1258</i>&nbsp;                break;</b>
<b class="nc"><i>1259</i>&nbsp;            case SunHints.INTKEY_STROKE_CONTROL:</b>
<i>1260</i>&nbsp;                stateChanged = (strokeHint != newHint);
<b class="nc"><i>1261</i>&nbsp;                strokeHint = newHint;</b>
<b class="nc"><i>1262</i>&nbsp;                break;</b>
<b class="nc"><i>1263</i>&nbsp;            case SunHints.INTKEY_RESOLUTION_VARIANT:</b>
<i>1264</i>&nbsp;                stateChanged = (resolutionVariantHint != newHint);
<b class="nc"><i>1265</i>&nbsp;                resolutionVariantHint = newHint;</b>
<b class="nc"><i>1266</i>&nbsp;                break;</b>
<b class="nc"><i>1267</i>&nbsp;            default:</b>
<i>1268</i>&nbsp;                recognized = false;
<b class="nc"><i>1269</i>&nbsp;                stateChanged = false;</b>
<b class="nc"><i>1270</i>&nbsp;                break;</b>
<i>1271</i>&nbsp;            }
<i>1272</i>&nbsp;            if (recognized) {
<b class="nc"><i>1273</i>&nbsp;                if (stateChanged) {</b>
<b class="nc"><i>1274</i>&nbsp;                    invalidatePipe();</b>
<b class="nc"><i>1275</i>&nbsp;                    if (textStateChanged) {</b>
<b class="nc"><i>1276</i>&nbsp;                        fontMetrics = null;</b>
<b class="nc"><i>1277</i>&nbsp;                        this.cachedFRC = null;</b>
<b class="nc"><i>1278</i>&nbsp;                        validFontInfo = false;</b>
<b class="nc"><i>1279</i>&nbsp;                        this.glyphVectorFontInfo = null;</b>
<b class="nc"><i>1280</i>&nbsp;                    }</b>
<i>1281</i>&nbsp;                }
<i>1282</i>&nbsp;                if (hints != null) {
<b class="nc"><i>1283</i>&nbsp;                    hints.put(hintKey, hintValue);</b>
<b class="nc"><i>1284</i>&nbsp;                }</b>
<i>1285</i>&nbsp;                return;
<i>1286</i>&nbsp;            }
<i>1287</i>&nbsp;        }
<i>1288</i>&nbsp;        // Nothing we recognize so none of &quot;our state&quot; has changed
<i>1289</i>&nbsp;        if (hints == null) {
<b class="nc"><i>1290</i>&nbsp;            hints = makeHints(null);</b>
<b class="nc"><i>1291</i>&nbsp;        }</b>
<i>1292</i>&nbsp;        hints.put(hintKey, hintValue);
<b class="nc"><i>1293</i>&nbsp;    }</b>
<i>1294</i>&nbsp;
<i>1295</i>&nbsp;
<i>1296</i>&nbsp;    /**
<i>1297</i>&nbsp;     * Returns the preferences for the rendering algorithms.
<i>1298</i>&nbsp;     * @param hintKey The category of hint to be set. The strings
<i>1299</i>&nbsp;     * are defined in the RenderingHints class.
<i>1300</i>&nbsp;     * @return The preferences for rendering algorithms. The strings
<i>1301</i>&nbsp;     * are defined in the RenderingHints class.
<i>1302</i>&nbsp;     * @see RenderingHints
<i>1303</i>&nbsp;     */
<i>1304</i>&nbsp;    public Object getRenderingHint(Key hintKey) {
<i>1305</i>&nbsp;        if (hints != null) {
<b class="nc"><i>1306</i>&nbsp;            return hints.get(hintKey);</b>
<b class="nc"><i>1307</i>&nbsp;        }</b>
<i>1308</i>&nbsp;        if (!(hintKey instanceof SunHints.Key)) {
<b class="nc"><i>1309</i>&nbsp;            return null;</b>
<b class="nc"><i>1310</i>&nbsp;        }</b>
<i>1311</i>&nbsp;        int keyindex = ((SunHints.Key)hintKey).getIndex();
<b class="nc"><i>1312</i>&nbsp;        switch (keyindex) {</b>
<b class="nc"><i>1313</i>&nbsp;        case SunHints.INTKEY_RENDERING:</b>
<i>1314</i>&nbsp;            return SunHints.Value.get(SunHints.INTKEY_RENDERING,
<b class="nc"><i>1315</i>&nbsp;                                      renderHint);</b>
<i>1316</i>&nbsp;        case SunHints.INTKEY_ANTIALIASING:
<i>1317</i>&nbsp;            return SunHints.Value.get(SunHints.INTKEY_ANTIALIASING,
<b class="nc"><i>1318</i>&nbsp;                                      antialiasHint);</b>
<i>1319</i>&nbsp;        case SunHints.INTKEY_TEXT_ANTIALIASING:
<i>1320</i>&nbsp;            return SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING,
<b class="nc"><i>1321</i>&nbsp;                                      textAntialiasHint);</b>
<i>1322</i>&nbsp;        case SunHints.INTKEY_FRACTIONALMETRICS:
<i>1323</i>&nbsp;            return SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,
<b class="nc"><i>1324</i>&nbsp;                                      fractionalMetricsHint);</b>
<i>1325</i>&nbsp;        case SunHints.INTKEY_AATEXT_LCD_CONTRAST:
<i>1326</i>&nbsp;            return lcdTextContrast;
<b class="nc"><i>1327</i>&nbsp;        case SunHints.INTKEY_INTERPOLATION:</b>
<i>1328</i>&nbsp;            switch (interpolationHint) {
<b class="nc"><i>1329</i>&nbsp;            case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:</b>
<i>1330</i>&nbsp;                return SunHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
<b class="nc"><i>1331</i>&nbsp;            case SunHints.INTVAL_INTERPOLATION_BILINEAR:</b>
<i>1332</i>&nbsp;                return SunHints.VALUE_INTERPOLATION_BILINEAR;
<b class="nc"><i>1333</i>&nbsp;            case SunHints.INTVAL_INTERPOLATION_BICUBIC:</b>
<i>1334</i>&nbsp;                return SunHints.VALUE_INTERPOLATION_BICUBIC;
<b class="nc"><i>1335</i>&nbsp;            }</b>
<i>1336</i>&nbsp;            return null;
<b class="nc"><i>1337</i>&nbsp;        case SunHints.INTKEY_STROKE_CONTROL:</b>
<i>1338</i>&nbsp;            return SunHints.Value.get(SunHints.INTKEY_STROKE_CONTROL,
<b class="nc"><i>1339</i>&nbsp;                                      strokeHint);</b>
<i>1340</i>&nbsp;        case SunHints.INTKEY_RESOLUTION_VARIANT:
<i>1341</i>&nbsp;            return SunHints.Value.get(SunHints.INTKEY_RESOLUTION_VARIANT,
<b class="nc"><i>1342</i>&nbsp;                                      resolutionVariantHint);</b>
<i>1343</i>&nbsp;        }
<i>1344</i>&nbsp;        return null;
<b class="nc"><i>1345</i>&nbsp;    }</b>
<i>1346</i>&nbsp;
<i>1347</i>&nbsp;    /**
<i>1348</i>&nbsp;     * Sets the preferences for the rendering algorithms.
<i>1349</i>&nbsp;     * Hint categories include controls for rendering quality and
<i>1350</i>&nbsp;     * overall time/quality trade-off in the rendering process.
<i>1351</i>&nbsp;     * @param hints The rendering hints to be set
<i>1352</i>&nbsp;     * @see RenderingHints
<i>1353</i>&nbsp;     */
<i>1354</i>&nbsp;    public void setRenderingHints(Map&lt;?,?&gt; hints) {
<i>1355</i>&nbsp;        this.hints = null;
<b class="nc"><i>1356</i>&nbsp;        renderHint = SunHints.INTVAL_RENDER_DEFAULT;</b>
<b class="nc"><i>1357</i>&nbsp;        antialiasHint = SunHints.INTVAL_ANTIALIAS_OFF;</b>
<b class="nc"><i>1358</i>&nbsp;        textAntialiasHint = SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT;</b>
<b class="nc"><i>1359</i>&nbsp;        fractionalMetricsHint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;</b>
<b class="nc"><i>1360</i>&nbsp;        lcdTextContrast = lcdTextContrastDefaultValue;</b>
<b class="nc"><i>1361</i>&nbsp;        interpolationHint = -1;</b>
<b class="nc"><i>1362</i>&nbsp;        interpolationType = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;</b>
<b class="nc"><i>1363</i>&nbsp;        boolean customHintPresent = false;</b>
<b class="nc"><i>1364</i>&nbsp;        Iterator&lt;?&gt; iter = hints.keySet().iterator();</b>
<b class="nc"><i>1365</i>&nbsp;        while (iter.hasNext()) {</b>
<b class="nc"><i>1366</i>&nbsp;            Object key = iter.next();</b>
<b class="nc"><i>1367</i>&nbsp;            if (key == SunHints.KEY_RENDERING ||</b>
<b class="nc"><i>1368</i>&nbsp;                key == SunHints.KEY_ANTIALIASING ||</b>
<i>1369</i>&nbsp;                key == SunHints.KEY_TEXT_ANTIALIASING ||
<i>1370</i>&nbsp;                key == SunHints.KEY_FRACTIONALMETRICS ||
<i>1371</i>&nbsp;                key == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST ||
<i>1372</i>&nbsp;                key == SunHints.KEY_STROKE_CONTROL ||
<i>1373</i>&nbsp;                key == SunHints.KEY_INTERPOLATION)
<i>1374</i>&nbsp;            {
<i>1375</i>&nbsp;                setRenderingHint((Key) key, hints.get(key));
<b class="nc"><i>1376</i>&nbsp;            } else {</b>
<i>1377</i>&nbsp;                customHintPresent = true;
<b class="nc"><i>1378</i>&nbsp;            }</b>
<i>1379</i>&nbsp;        }
<b class="nc"><i>1380</i>&nbsp;        if (customHintPresent) {</b>
<b class="nc"><i>1381</i>&nbsp;            this.hints = makeHints(hints);</b>
<b class="nc"><i>1382</i>&nbsp;        }</b>
<i>1383</i>&nbsp;        invalidatePipe();
<b class="nc"><i>1384</i>&nbsp;    }</b>
<i>1385</i>&nbsp;
<i>1386</i>&nbsp;    /**
<i>1387</i>&nbsp;     * Adds a number of preferences for the rendering algorithms.
<i>1388</i>&nbsp;     * Hint categories include controls for rendering quality and
<i>1389</i>&nbsp;     * overall time/quality trade-off in the rendering process.
<i>1390</i>&nbsp;     * @param hints The rendering hints to be set
<i>1391</i>&nbsp;     * @see RenderingHints
<i>1392</i>&nbsp;     */
<i>1393</i>&nbsp;    public void addRenderingHints(Map&lt;?,?&gt; hints) {
<i>1394</i>&nbsp;        boolean customHintPresent = false;
<b class="nc"><i>1395</i>&nbsp;        Iterator&lt;?&gt; iter = hints.keySet().iterator();</b>
<b class="nc"><i>1396</i>&nbsp;        while (iter.hasNext()) {</b>
<b class="nc"><i>1397</i>&nbsp;            Object key = iter.next();</b>
<b class="nc"><i>1398</i>&nbsp;            if (key == SunHints.KEY_RENDERING ||</b>
<b class="nc"><i>1399</i>&nbsp;                key == SunHints.KEY_ANTIALIASING ||</b>
<i>1400</i>&nbsp;                key == SunHints.KEY_TEXT_ANTIALIASING ||
<i>1401</i>&nbsp;                key == SunHints.KEY_FRACTIONALMETRICS ||
<i>1402</i>&nbsp;                key == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST ||
<i>1403</i>&nbsp;                key == SunHints.KEY_STROKE_CONTROL ||
<i>1404</i>&nbsp;                key == SunHints.KEY_INTERPOLATION)
<i>1405</i>&nbsp;            {
<i>1406</i>&nbsp;                setRenderingHint((Key) key, hints.get(key));
<b class="nc"><i>1407</i>&nbsp;            } else {</b>
<i>1408</i>&nbsp;                customHintPresent = true;
<b class="nc"><i>1409</i>&nbsp;            }</b>
<i>1410</i>&nbsp;        }
<b class="nc"><i>1411</i>&nbsp;        if (customHintPresent) {</b>
<b class="nc"><i>1412</i>&nbsp;            if (this.hints == null) {</b>
<b class="nc"><i>1413</i>&nbsp;                this.hints = makeHints(hints);</b>
<b class="nc"><i>1414</i>&nbsp;            } else {</b>
<i>1415</i>&nbsp;                this.hints.putAll(hints);
<b class="nc"><i>1416</i>&nbsp;            }</b>
<i>1417</i>&nbsp;        }
<i>1418</i>&nbsp;    }
<i>1419</i>&nbsp;
<i>1420</i>&nbsp;    /**
<i>1421</i>&nbsp;     * Gets the preferences for the rendering algorithms.
<i>1422</i>&nbsp;     * Hint categories include controls for rendering quality and
<i>1423</i>&nbsp;     * overall time/quality trade-off in the rendering process.
<i>1424</i>&nbsp;     * @see RenderingHints
<i>1425</i>&nbsp;     */
<i>1426</i>&nbsp;    public RenderingHints getRenderingHints() {
<i>1427</i>&nbsp;        if (hints == null) {
<b class="nc"><i>1428</i>&nbsp;            return makeHints(null);</b>
<b class="nc"><i>1429</i>&nbsp;        } else {</b>
<i>1430</i>&nbsp;            return (RenderingHints) hints.clone();
<b class="nc"><i>1431</i>&nbsp;        }</b>
<i>1432</i>&nbsp;    }
<i>1433</i>&nbsp;
<i>1434</i>&nbsp;    RenderingHints makeHints(Map&lt;?,?&gt; hints) {
<i>1435</i>&nbsp;        RenderingHints model = new RenderingHints(null);
<b class="nc"><i>1436</i>&nbsp;        if (hints != null) {</b>
<b class="nc"><i>1437</i>&nbsp;            model.putAll(hints);</b>
<b class="nc"><i>1438</i>&nbsp;        }</b>
<i>1439</i>&nbsp;        model.put(SunHints.KEY_RENDERING,
<b class="nc"><i>1440</i>&nbsp;                  SunHints.Value.get(SunHints.INTKEY_RENDERING,</b>
<b class="nc"><i>1441</i>&nbsp;                                     renderHint));</b>
<i>1442</i>&nbsp;        model.put(SunHints.KEY_ANTIALIASING,
<b class="nc"><i>1443</i>&nbsp;                  SunHints.Value.get(SunHints.INTKEY_ANTIALIASING,</b>
<b class="nc"><i>1444</i>&nbsp;                                     antialiasHint));</b>
<i>1445</i>&nbsp;        model.put(SunHints.KEY_TEXT_ANTIALIASING,
<b class="nc"><i>1446</i>&nbsp;                  SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING,</b>
<b class="nc"><i>1447</i>&nbsp;                                     textAntialiasHint));</b>
<i>1448</i>&nbsp;        model.put(SunHints.KEY_FRACTIONALMETRICS,
<b class="nc"><i>1449</i>&nbsp;                  SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,</b>
<b class="nc"><i>1450</i>&nbsp;                                     fractionalMetricsHint));</b>
<i>1451</i>&nbsp;        model.put(SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST,
<b class="nc"><i>1452</i>&nbsp;                  Integer.valueOf(lcdTextContrast));</b>
<i>1453</i>&nbsp;        Object value;
<b class="nc"><i>1454</i>&nbsp;        switch (interpolationHint) {</b>
<b class="nc"><i>1455</i>&nbsp;        case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:</b>
<i>1456</i>&nbsp;            value = SunHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
<b class="nc"><i>1457</i>&nbsp;            break;</b>
<b class="nc"><i>1458</i>&nbsp;        case SunHints.INTVAL_INTERPOLATION_BILINEAR:</b>
<i>1459</i>&nbsp;            value = SunHints.VALUE_INTERPOLATION_BILINEAR;
<b class="nc"><i>1460</i>&nbsp;            break;</b>
<b class="nc"><i>1461</i>&nbsp;        case SunHints.INTVAL_INTERPOLATION_BICUBIC:</b>
<i>1462</i>&nbsp;            value = SunHints.VALUE_INTERPOLATION_BICUBIC;
<b class="nc"><i>1463</i>&nbsp;            break;</b>
<i>1464</i>&nbsp;        default:
<i>1465</i>&nbsp;            value = null;
<b class="nc"><i>1466</i>&nbsp;            break;</b>
<b class="nc"><i>1467</i>&nbsp;        }</b>
<i>1468</i>&nbsp;        if (value != null) {
<b class="nc"><i>1469</i>&nbsp;            model.put(SunHints.KEY_INTERPOLATION, value);</b>
<b class="nc"><i>1470</i>&nbsp;        }</b>
<i>1471</i>&nbsp;        model.put(SunHints.KEY_STROKE_CONTROL,
<b class="nc"><i>1472</i>&nbsp;                  SunHints.Value.get(SunHints.INTKEY_STROKE_CONTROL,</b>
<i>1473</i>&nbsp;                                     strokeHint));
<i>1474</i>&nbsp;        return model;
<i>1475</i>&nbsp;    }
<i>1476</i>&nbsp;
<i>1477</i>&nbsp;    /**
<i>1478</i>&nbsp;     * Concatenates the current transform of this Graphics2D with a
<i>1479</i>&nbsp;     * translation transformation.
<i>1480</i>&nbsp;     * This is equivalent to calling transform(T), where T is an
<i>1481</i>&nbsp;     * AffineTransform represented by the following matrix:
<i>1482</i>&nbsp;     * &lt;pre&gt;
<i>1483</i>&nbsp;     *          [   1    0    tx  ]
<i>1484</i>&nbsp;     *          [   0    1    ty  ]
<i>1485</i>&nbsp;     *          [   0    0    1   ]
<i>1486</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>1487</i>&nbsp;     */</b>
<b class="nc"><i>1488</i>&nbsp;    public void translate(double tx, double ty) {</b>
<i>1489</i>&nbsp;        transform.translate(tx, ty);
<i>1490</i>&nbsp;        invalidateTransform();
<i>1491</i>&nbsp;    }
<i>1492</i>&nbsp;
<i>1493</i>&nbsp;    /**
<i>1494</i>&nbsp;     * Concatenates the current transform of this Graphics2D with a
<i>1495</i>&nbsp;     * rotation transformation.
<i>1496</i>&nbsp;     * This is equivalent to calling transform(R), where R is an
<i>1497</i>&nbsp;     * AffineTransform represented by the following matrix:
<i>1498</i>&nbsp;     * &lt;pre&gt;
<i>1499</i>&nbsp;     *          [   cos(theta)    -sin(theta)    0   ]
<i>1500</i>&nbsp;     *          [   sin(theta)     cos(theta)    0   ]
<i>1501</i>&nbsp;     *          [       0              0         1   ]
<i>1502</i>&nbsp;     * &lt;/pre&gt;
<i>1503</i>&nbsp;     * Rotating with a positive angle theta rotates points on the positive
<i>1504</i>&nbsp;     * x axis toward the positive y axis.
<i>1505</i>&nbsp;     * @param theta The angle of rotation in radians.
<b class="nc"><i>1506</i>&nbsp;     */</b>
<b class="nc"><i>1507</i>&nbsp;    public void rotate(double theta) {</b>
<i>1508</i>&nbsp;        transform.rotate(theta);
<i>1509</i>&nbsp;        invalidateTransform();
<i>1510</i>&nbsp;    }
<i>1511</i>&nbsp;
<i>1512</i>&nbsp;    /**
<i>1513</i>&nbsp;     * Concatenates the current transform of this Graphics2D with a
<i>1514</i>&nbsp;     * translated rotation transformation.
<i>1515</i>&nbsp;     * This is equivalent to the following sequence of calls:
<i>1516</i>&nbsp;     * &lt;pre&gt;
<i>1517</i>&nbsp;     *          translate(x, y);
<i>1518</i>&nbsp;     *          rotate(theta);
<i>1519</i>&nbsp;     *          translate(-x, -y);
<i>1520</i>&nbsp;     * &lt;/pre&gt;
<i>1521</i>&nbsp;     * Rotating with a positive angle theta rotates points on the positive
<i>1522</i>&nbsp;     * x axis toward the positive y axis.
<i>1523</i>&nbsp;     * @param theta The angle of rotation in radians.
<i>1524</i>&nbsp;     * @param x The x coordinate of the origin of the rotation
<i>1525</i>&nbsp;     * @param y The x coordinate of the origin of the rotation
<b class="nc"><i>1526</i>&nbsp;     */</b>
<b class="nc"><i>1527</i>&nbsp;    public void rotate(double theta, double x, double y) {</b>
<i>1528</i>&nbsp;        transform.rotate(theta, x, y);
<i>1529</i>&nbsp;        invalidateTransform();
<i>1530</i>&nbsp;    }
<i>1531</i>&nbsp;
<i>1532</i>&nbsp;    /**
<i>1533</i>&nbsp;     * Concatenates the current transform of this Graphics2D with a
<i>1534</i>&nbsp;     * scaling transformation.
<i>1535</i>&nbsp;     * This is equivalent to calling transform(S), where S is an
<i>1536</i>&nbsp;     * AffineTransform represented by the following matrix:
<i>1537</i>&nbsp;     * &lt;pre&gt;
<i>1538</i>&nbsp;     *          [   sx   0    0   ]
<i>1539</i>&nbsp;     *          [   0    sy   0   ]
<i>1540</i>&nbsp;     *          [   0    0    1   ]
<i>1541</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>1542</i>&nbsp;     */</b>
<b class="nc"><i>1543</i>&nbsp;    public void scale(double sx, double sy) {</b>
<i>1544</i>&nbsp;        transform.scale(sx, sy);
<i>1545</i>&nbsp;        invalidateTransform();
<i>1546</i>&nbsp;    }
<i>1547</i>&nbsp;
<i>1548</i>&nbsp;    /**
<i>1549</i>&nbsp;     * Concatenates the current transform of this Graphics2D with a
<i>1550</i>&nbsp;     * shearing transformation.
<i>1551</i>&nbsp;     * This is equivalent to calling transform(SH), where SH is an
<i>1552</i>&nbsp;     * AffineTransform represented by the following matrix:
<i>1553</i>&nbsp;     * &lt;pre&gt;
<i>1554</i>&nbsp;     *          [   1   shx   0   ]
<i>1555</i>&nbsp;     *          [  shy   1    0   ]
<i>1556</i>&nbsp;     *          [   0    0    1   ]
<i>1557</i>&nbsp;     * &lt;/pre&gt;
<i>1558</i>&nbsp;     * @param shx The factor by which coordinates are shifted towards the
<i>1559</i>&nbsp;     * positive X axis direction according to their Y coordinate
<i>1560</i>&nbsp;     * @param shy The factor by which coordinates are shifted towards the
<i>1561</i>&nbsp;     * positive Y axis direction according to their X coordinate
<b class="nc"><i>1562</i>&nbsp;     */</b>
<b class="nc"><i>1563</i>&nbsp;    public void shear(double shx, double shy) {</b>
<i>1564</i>&nbsp;        transform.shear(shx, shy);
<i>1565</i>&nbsp;        invalidateTransform();
<i>1566</i>&nbsp;    }
<i>1567</i>&nbsp;
<i>1568</i>&nbsp;    /**
<i>1569</i>&nbsp;     * Composes a Transform object with the transform in this
<i>1570</i>&nbsp;     * Graphics2D according to the rule last-specified-first-applied.
<i>1571</i>&nbsp;     * If the currrent transform is Cx, the result of composition
<i>1572</i>&nbsp;     * with Tx is a new transform Cx&#39;.  Cx&#39; becomes the current
<i>1573</i>&nbsp;     * transform for this Graphics2D.
<i>1574</i>&nbsp;     * Transforming a point p by the updated transform Cx&#39; is
<i>1575</i>&nbsp;     * equivalent to first transforming p by Tx and then transforming
<i>1576</i>&nbsp;     * the result by the original transform Cx.  In other words,
<i>1577</i>&nbsp;     * Cx&#39;(p) = Cx(Tx(p)).
<i>1578</i>&nbsp;     * A copy of the Tx is made, if necessary, so further
<i>1579</i>&nbsp;     * modifications to Tx do not affect rendering.
<i>1580</i>&nbsp;     * @param xform The Transform object to be composed with the current
<i>1581</i>&nbsp;     * transform.
<i>1582</i>&nbsp;     * @see #setTransform
<i>1583</i>&nbsp;     * @see AffineTransform
<b class="nc"><i>1584</i>&nbsp;     */</b>
<b class="nc"><i>1585</i>&nbsp;    public void transform(AffineTransform xform) {</b>
<i>1586</i>&nbsp;        this.transform.concatenate(xform);
<i>1587</i>&nbsp;        invalidateTransform();
<i>1588</i>&nbsp;    }
<i>1589</i>&nbsp;
<i>1590</i>&nbsp;    /**
<i>1591</i>&nbsp;     * Translate
<b class="nc"><i>1592</i>&nbsp;     */</b>
<b class="nc"><i>1593</i>&nbsp;    public void translate(int x, int y) {</b>
<b class="nc"><i>1594</i>&nbsp;        transform.translate(x, y);</b>
<b class="nc"><i>1595</i>&nbsp;        if (transformState &lt;= TRANSFORM_INT_TRANSLATE) {</b>
<b class="nc"><i>1596</i>&nbsp;            transX += x;</b>
<i>1597</i>&nbsp;            transY += y;
<i>1598</i>&nbsp;            transformState = (((transX | transY) == 0) ?
<b class="nc"><i>1599</i>&nbsp;                              TRANSFORM_ISIDENT : TRANSFORM_INT_TRANSLATE);</b>
<i>1600</i>&nbsp;        } else {
<i>1601</i>&nbsp;            invalidateTransform();
<i>1602</i>&nbsp;        }
<i>1603</i>&nbsp;    }
<i>1604</i>&nbsp;
<i>1605</i>&nbsp;    /**
<i>1606</i>&nbsp;     * Sets the Transform in the current graphics state.
<i>1607</i>&nbsp;     * @param Tx The Transform object to be used in the rendering process.
<i>1608</i>&nbsp;     * @see #transform
<i>1609</i>&nbsp;     * @see AffineTransform
<i>1610</i>&nbsp;     */
<i>1611</i>&nbsp;    @Override
<b class="nc"><i>1612</i>&nbsp;    public void setTransform(AffineTransform Tx) {</b>
<b class="nc"><i>1613</i>&nbsp;        if ((constrainX | constrainY) == 0) {</b>
<i>1614</i>&nbsp;            transform.setTransform(Tx);
<b class="nc"><i>1615</i>&nbsp;        } else {</b>
<b class="nc"><i>1616</i>&nbsp;            transform.setToTranslation(constrainX, constrainY);</b>
<i>1617</i>&nbsp;            transform.concatenate(Tx);
<b class="nc"><i>1618</i>&nbsp;        }</b>
<i>1619</i>&nbsp;        invalidateTransform();
<i>1620</i>&nbsp;    }
<i>1621</i>&nbsp;
<b class="nc"><i>1622</i>&nbsp;    protected void invalidateTransform() {</b>
<b class="nc"><i>1623</i>&nbsp;        int type = transform.getType();</b>
<b class="nc"><i>1624</i>&nbsp;        int origTransformState = transformState;</b>
<b class="nc"><i>1625</i>&nbsp;        if (type == AffineTransform.TYPE_IDENTITY) {</b>
<b class="nc"><i>1626</i>&nbsp;            transformState = TRANSFORM_ISIDENT;</b>
<b class="nc"><i>1627</i>&nbsp;            transX = transY = 0;</b>
<b class="nc"><i>1628</i>&nbsp;        } else if (type == AffineTransform.TYPE_TRANSLATION) {</b>
<b class="nc"><i>1629</i>&nbsp;            double dtx = transform.getTranslateX();</b>
<b class="nc"><i>1630</i>&nbsp;            double dty = transform.getTranslateY();</b>
<b class="nc"><i>1631</i>&nbsp;            transX = (int) Math.floor(dtx + 0.5);</b>
<b class="nc"><i>1632</i>&nbsp;            transY = (int) Math.floor(dty + 0.5);</b>
<b class="nc"><i>1633</i>&nbsp;            if (dtx == transX &amp;&amp; dty == transY) {</b>
<i>1634</i>&nbsp;                transformState = TRANSFORM_INT_TRANSLATE;
<b class="nc"><i>1635</i>&nbsp;            } else {</b>
<i>1636</i>&nbsp;                transformState = TRANSFORM_ANY_TRANSLATE;
<b class="nc"><i>1637</i>&nbsp;            }</b>
<i>1638</i>&nbsp;        } else if ((type &amp; (AffineTransform.TYPE_FLIP |
<i>1639</i>&nbsp;                            AffineTransform.TYPE_MASK_ROTATION |
<i>1640</i>&nbsp;                            AffineTransform.TYPE_GENERAL_TRANSFORM)) == 0)
<b class="nc"><i>1641</i>&nbsp;        {</b>
<b class="nc"><i>1642</i>&nbsp;            transformState = TRANSFORM_TRANSLATESCALE;</b>
<i>1643</i>&nbsp;            transX = transY = 0;
<b class="nc"><i>1644</i>&nbsp;        } else {</b>
<b class="nc"><i>1645</i>&nbsp;            transformState = TRANSFORM_GENERIC;</b>
<i>1646</i>&nbsp;            transX = transY = 0;
<i>1647</i>&nbsp;        }
<b class="nc"><i>1648</i>&nbsp;</b>
<i>1649</i>&nbsp;        if (transformState &gt;= TRANSFORM_TRANSLATESCALE ||
<i>1650</i>&nbsp;            origTransformState &gt;= TRANSFORM_TRANSLATESCALE)
<i>1651</i>&nbsp;        {
<i>1652</i>&nbsp;            /* Its only in this case that the previous or current transform
<i>1653</i>&nbsp;             * was more than a translate that font info is invalidated
<b class="nc"><i>1654</i>&nbsp;             */</b>
<b class="nc"><i>1655</i>&nbsp;            cachedFRC = null;</b>
<b class="nc"><i>1656</i>&nbsp;            this.validFontInfo = false;</b>
<b class="nc"><i>1657</i>&nbsp;            this.fontMetrics = null;</b>
<i>1658</i>&nbsp;            this.glyphVectorFontInfo = null;
<b class="nc"><i>1659</i>&nbsp;</b>
<b class="nc"><i>1660</i>&nbsp;            if (transformState != origTransformState) {</b>
<i>1661</i>&nbsp;                invalidatePipe();
<i>1662</i>&nbsp;            }
<b class="nc"><i>1663</i>&nbsp;        }</b>
<b class="nc"><i>1664</i>&nbsp;        if (strokeState != STROKE_CUSTOM) {</b>
<i>1665</i>&nbsp;            validateBasicStroke((BasicStroke) stroke);
<i>1666</i>&nbsp;        }
<i>1667</i>&nbsp;    }
<i>1668</i>&nbsp;
<i>1669</i>&nbsp;    /**
<i>1670</i>&nbsp;     * Returns the current Transform in the Graphics2D state.
<i>1671</i>&nbsp;     * @see #transform
<i>1672</i>&nbsp;     * @see #setTransform
<i>1673</i>&nbsp;     */
<i>1674</i>&nbsp;    @Override
<b class="nc"><i>1675</i>&nbsp;    public AffineTransform getTransform() {</b>
<b class="nc"><i>1676</i>&nbsp;        if ((constrainX | constrainY) == 0) {</b>
<i>1677</i>&nbsp;            return new AffineTransform(transform);
<b class="nc"><i>1678</i>&nbsp;        }</b>
<b class="nc"><i>1679</i>&nbsp;        AffineTransform tx</b>
<b class="nc"><i>1680</i>&nbsp;                = AffineTransform.getTranslateInstance(-constrainX, -constrainY);</b>
<b class="nc"><i>1681</i>&nbsp;        tx.concatenate(transform);</b>
<i>1682</i>&nbsp;        return tx;
<i>1683</i>&nbsp;    }
<i>1684</i>&nbsp;
<i>1685</i>&nbsp;    /**
<i>1686</i>&nbsp;     * Returns the current Transform ignoring the &quot;constrain&quot;
<i>1687</i>&nbsp;     * rectangle.
<i>1688</i>&nbsp;     */
<b class="nc"><i>1689</i>&nbsp;    public AffineTransform cloneTransform() {</b>
<i>1690</i>&nbsp;        return new AffineTransform(transform);
<i>1691</i>&nbsp;    }
<i>1692</i>&nbsp;
<i>1693</i>&nbsp;    /**
<i>1694</i>&nbsp;     * Returns the current Paint in the Graphics2D state.
<i>1695</i>&nbsp;     * @see #setPaint
<i>1696</i>&nbsp;     * @see java.awt.Graphics#setColor
<i>1697</i>&nbsp;     */
<b class="nc"><i>1698</i>&nbsp;    public Paint getPaint() {</b>
<i>1699</i>&nbsp;        return paint;
<i>1700</i>&nbsp;    }
<i>1701</i>&nbsp;
<i>1702</i>&nbsp;    /**
<i>1703</i>&nbsp;     * Returns the current Composite in the Graphics2D state.
<i>1704</i>&nbsp;     * @see #setComposite
<i>1705</i>&nbsp;     */
<b class="nc"><i>1706</i>&nbsp;    public Composite getComposite() {</b>
<i>1707</i>&nbsp;        return composite;
<i>1708</i>&nbsp;    }
<i>1709</i>&nbsp;
<b class="nc"><i>1710</i>&nbsp;    public Color getColor() {</b>
<i>1711</i>&nbsp;        return foregroundColor;
<i>1712</i>&nbsp;    }
<i>1713</i>&nbsp;
<i>1714</i>&nbsp;    /*
<i>1715</i>&nbsp;     * Validate the eargb and pixel fields against the current color.
<i>1716</i>&nbsp;     *
<i>1717</i>&nbsp;     * The eargb field must take into account the extraAlpha
<i>1718</i>&nbsp;     * value of an AlphaComposite.  It may also take into account
<i>1719</i>&nbsp;     * the Fsrc Porter-Duff blending function if such a function is
<i>1720</i>&nbsp;     * a constant (see handling of Clear mode below).  For instance,
<i>1721</i>&nbsp;     * by factoring in the (Fsrc == 0) state of the Clear mode we can
<i>1722</i>&nbsp;     * use a SrcNoEa loop just as easily as a general Alpha loop
<i>1723</i>&nbsp;     * since the math will be the same in both cases.
<i>1724</i>&nbsp;     *
<i>1725</i>&nbsp;     * The pixel field will always be the best pixel data choice for
<i>1726</i>&nbsp;     * the final result of all calculations applied to the eargb field.
<i>1727</i>&nbsp;     *
<i>1728</i>&nbsp;     * Note that this method is only necessary under the following
<i>1729</i>&nbsp;     * conditions:
<i>1730</i>&nbsp;     *     (paintState &lt;= PAINT_ALPHA_COLOR &amp;&amp;
<i>1731</i>&nbsp;     *      compositeState &lt;= COMP_CUSTOM)
<i>1732</i>&nbsp;     * though nothing bad will happen if it is run in other states.
<i>1733</i>&nbsp;     */
<i>1734</i>&nbsp;    void validateColor() {
<b class="nc"><i>1735</i>&nbsp;        int eargb;</b>
<b class="nc"><i>1736</i>&nbsp;        if (imageComp == CompositeType.Clear) {</b>
<i>1737</i>&nbsp;            eargb = 0;
<b class="nc"><i>1738</i>&nbsp;        } else {</b>
<b class="nc"><i>1739</i>&nbsp;            eargb = foregroundColor.getRGB();</b>
<i>1740</i>&nbsp;            if (compositeState &lt;= COMP_ALPHA &amp;&amp;
<i>1741</i>&nbsp;                imageComp != CompositeType.SrcNoEa &amp;&amp;
<i>1742</i>&nbsp;                imageComp != CompositeType.SrcOverNoEa)
<b class="nc"><i>1743</i>&nbsp;            {</b>
<b class="nc"><i>1744</i>&nbsp;                AlphaComposite alphacomp = (AlphaComposite) composite;</b>
<b class="nc"><i>1745</i>&nbsp;                int a = Math.round(alphacomp.getAlpha() * (eargb &gt;&gt;&gt; 24));</b>
<i>1746</i>&nbsp;                eargb = (eargb &amp; 0x00ffffff) | (a &lt;&lt; 24);
<i>1747</i>&nbsp;            }
<b class="nc"><i>1748</i>&nbsp;        }</b>
<b class="nc"><i>1749</i>&nbsp;        this.eargb = eargb;</b>
<i>1750</i>&nbsp;        this.pixel = surfaceData.pixelFor(eargb);
<i>1751</i>&nbsp;    }
<i>1752</i>&nbsp;
<b class="nc"><i>1753</i>&nbsp;    public void setColor(Color color) {</b>
<i>1754</i>&nbsp;        if (color == null || color == paint) {
<i>1755</i>&nbsp;            return;
<b class="nc"><i>1756</i>&nbsp;        }</b>
<b class="nc"><i>1757</i>&nbsp;        this.paint = foregroundColor = color;</b>
<b class="nc"><i>1758</i>&nbsp;        validateColor();</b>
<b class="nc"><i>1759</i>&nbsp;        if ((eargb &gt;&gt; 24) == -1) {</b>
<i>1760</i>&nbsp;            if (paintState == PAINT_OPAQUECOLOR) {
<i>1761</i>&nbsp;                return;
<b class="nc"><i>1762</i>&nbsp;            }</b>
<b class="nc"><i>1763</i>&nbsp;            paintState = PAINT_OPAQUECOLOR;</b>
<i>1764</i>&nbsp;            if (imageComp == CompositeType.SrcOverNoEa) {
<b class="nc"><i>1765</i>&nbsp;                // special case where compState depends on opacity of paint</b>
<i>1766</i>&nbsp;                compositeState = COMP_ISCOPY;
<i>1767</i>&nbsp;            }
<b class="nc"><i>1768</i>&nbsp;        } else {</b>
<i>1769</i>&nbsp;            if (paintState == PAINT_ALPHACOLOR) {
<i>1770</i>&nbsp;                return;
<b class="nc"><i>1771</i>&nbsp;            }</b>
<b class="nc"><i>1772</i>&nbsp;            paintState = PAINT_ALPHACOLOR;</b>
<i>1773</i>&nbsp;            if (imageComp == CompositeType.SrcOverNoEa) {
<b class="nc"><i>1774</i>&nbsp;                // special case where compState depends on opacity of paint</b>
<i>1775</i>&nbsp;                compositeState = COMP_ALPHA;
<i>1776</i>&nbsp;            }
<b class="nc"><i>1777</i>&nbsp;        }</b>
<b class="nc"><i>1778</i>&nbsp;        validFontInfo = false;</b>
<i>1779</i>&nbsp;        invalidatePipe();
<i>1780</i>&nbsp;    }
<i>1781</i>&nbsp;
<i>1782</i>&nbsp;    /**
<i>1783</i>&nbsp;     * Sets the background color in this context used for clearing a region.
<i>1784</i>&nbsp;     * When Graphics2D is constructed for a component, the backgroung color is
<i>1785</i>&nbsp;     * inherited from the component. Setting the background color in the
<i>1786</i>&nbsp;     * Graphics2D context only affects the subsequent clearRect() calls and
<i>1787</i>&nbsp;     * not the background color of the component. To change the background
<i>1788</i>&nbsp;     * of the component, use appropriate methods of the component.
<i>1789</i>&nbsp;     * @param color The background color that should be used in
<i>1790</i>&nbsp;     * subsequent calls to clearRect().
<i>1791</i>&nbsp;     * @see #getBackground
<i>1792</i>&nbsp;     * @see Graphics#clearRect
<i>1793</i>&nbsp;     */
<b class="nc"><i>1794</i>&nbsp;    public void setBackground(Color color) {</b>
<i>1795</i>&nbsp;        backgroundColor = color;
<i>1796</i>&nbsp;    }
<i>1797</i>&nbsp;
<i>1798</i>&nbsp;    /**
<i>1799</i>&nbsp;     * Returns the background color used for clearing a region.
<i>1800</i>&nbsp;     * @see #setBackground
<i>1801</i>&nbsp;     */
<b class="nc"><i>1802</i>&nbsp;    public Color getBackground() {</b>
<i>1803</i>&nbsp;        return backgroundColor;
<i>1804</i>&nbsp;    }
<i>1805</i>&nbsp;
<i>1806</i>&nbsp;    /**
<i>1807</i>&nbsp;     * Returns the current Stroke in the Graphics2D state.
<i>1808</i>&nbsp;     * @see #setStroke
<i>1809</i>&nbsp;     */
<b class="nc"><i>1810</i>&nbsp;    public Stroke getStroke() {</b>
<i>1811</i>&nbsp;        return stroke;
<i>1812</i>&nbsp;    }
<i>1813</i>&nbsp;
<b class="nc"><i>1814</i>&nbsp;    public Rectangle getClipBounds() {</b>
<b class="nc"><i>1815</i>&nbsp;        if (clipState == CLIP_DEVICE) {</b>
<i>1816</i>&nbsp;            return null;
<b class="nc"><i>1817</i>&nbsp;        }</b>
<i>1818</i>&nbsp;        return getClipBounds(new Rectangle());
<i>1819</i>&nbsp;    }
<i>1820</i>&nbsp;
<b class="nc"><i>1821</i>&nbsp;    public Rectangle getClipBounds(Rectangle r) {</b>
<b class="nc"><i>1822</i>&nbsp;        if (clipState != CLIP_DEVICE) {</b>
<b class="nc"><i>1823</i>&nbsp;            if (transformState &lt;= TRANSFORM_INT_TRANSLATE) {</b>
<b class="nc"><i>1824</i>&nbsp;                if (usrClip instanceof Rectangle) {</b>
<i>1825</i>&nbsp;                    r.setBounds((Rectangle) usrClip);
<b class="nc"><i>1826</i>&nbsp;                } else {</b>
<i>1827</i>&nbsp;                    r.setFrame(usrClip.getBounds2D());
<b class="nc"><i>1828</i>&nbsp;                }</b>
<i>1829</i>&nbsp;                r.translate(-transX, -transY);
<b class="nc"><i>1830</i>&nbsp;            } else {</b>
<i>1831</i>&nbsp;                r.setFrame(getClip().getBounds2D());
<b class="nc"><i>1832</i>&nbsp;            }</b>
<b class="nc"><i>1833</i>&nbsp;        } else if (r == null) {</b>
<i>1834</i>&nbsp;            throw new NullPointerException(&quot;null rectangle parameter&quot;);
<b class="nc"><i>1835</i>&nbsp;        }</b>
<i>1836</i>&nbsp;        return r;
<i>1837</i>&nbsp;    }
<i>1838</i>&nbsp;
<b class="nc"><i>1839</i>&nbsp;    public boolean hitClip(int x, int y, int width, int height) {</b>
<b class="nc"><i>1840</i>&nbsp;        if (width &lt;= 0 || height &lt;= 0) {</b>
<i>1841</i>&nbsp;            return false;
<b class="nc"><i>1842</i>&nbsp;        }</b>
<i>1843</i>&nbsp;        if (transformState &gt; TRANSFORM_INT_TRANSLATE) {
<i>1844</i>&nbsp;            // Note: Technically the most accurate test would be to
<i>1845</i>&nbsp;            // raster scan the parallelogram of the transformed rectangle
<i>1846</i>&nbsp;            // and do a span for span hit test against the clip, but for
<i>1847</i>&nbsp;            // speed we approximate the test with a bounding box of the
<i>1848</i>&nbsp;            // transformed rectangle.  The cost of rasterizing the
<i>1849</i>&nbsp;            // transformed rectangle is probably high enough that it is
<i>1850</i>&nbsp;            // not worth doing so to save the caller from having to call
<i>1851</i>&nbsp;            // a rendering method where we will end up discovering the
<i>1852</i>&nbsp;            // same answer in about the same amount of time anyway.
<i>1853</i>&nbsp;            // This logic breaks down if this hit test is being performed
<i>1854</i>&nbsp;            // on the bounds of a group of shapes in which case it might
<i>1855</i>&nbsp;            // be beneficial to be a little more accurate to avoid lots
<i>1856</i>&nbsp;            // of subsequent rendering calls.  In either case, this relaxed
<i>1857</i>&nbsp;            // test should not be significantly less accurate than the
<i>1858</i>&nbsp;            // optimal test for most transforms and so the conservative
<i>1859</i>&nbsp;            // answer should not cause too much extra work.
<b class="nc"><i>1860</i>&nbsp;</b>
<i>1861</i>&nbsp;            double d[] = {
<i>1862</i>&nbsp;                x, y,
<i>1863</i>&nbsp;                x+width, y,
<i>1864</i>&nbsp;                x, y+height,
<i>1865</i>&nbsp;                x+width, y+height
<b class="nc"><i>1866</i>&nbsp;            };</b>
<b class="nc"><i>1867</i>&nbsp;            transform.transform(d, 0, d, 0, 4);</b>
<b class="nc"><i>1868</i>&nbsp;            x = (int) Math.floor(Math.min(Math.min(d[0], d[2]),</b>
<b class="nc"><i>1869</i>&nbsp;                                          Math.min(d[4], d[6])));</b>
<b class="nc"><i>1870</i>&nbsp;            y = (int) Math.floor(Math.min(Math.min(d[1], d[3]),</b>
<b class="nc"><i>1871</i>&nbsp;                                          Math.min(d[5], d[7])));</b>
<b class="nc"><i>1872</i>&nbsp;            width = (int) Math.ceil(Math.max(Math.max(d[0], d[2]),</b>
<b class="nc"><i>1873</i>&nbsp;                                             Math.max(d[4], d[6])));</b>
<b class="nc"><i>1874</i>&nbsp;            height = (int) Math.ceil(Math.max(Math.max(d[1], d[3]),</b>
<b class="nc"><i>1875</i>&nbsp;                                              Math.max(d[5], d[7])));</b>
<b class="nc"><i>1876</i>&nbsp;        } else {</b>
<b class="nc"><i>1877</i>&nbsp;            x += transX;</b>
<b class="nc"><i>1878</i>&nbsp;            y += transY;</b>
<b class="nc"><i>1879</i>&nbsp;            width += x;</b>
<i>1880</i>&nbsp;            height += y;
<i>1881</i>&nbsp;        }
<i>1882</i>&nbsp;
<b class="nc"><i>1883</i>&nbsp;        try {</b>
<b class="nc"><i>1884</i>&nbsp;            if (!getCompClip().intersectsQuickCheckXYXY(x, y, width, height)) {</b>
<i>1885</i>&nbsp;                return false;
<b class="nc"><i>1886</i>&nbsp;            }</b>
<b class="nc"><i>1887</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<b class="nc"><i>1888</i>&nbsp;            return false;</b>
<i>1889</i>&nbsp;        }
<i>1890</i>&nbsp;        // REMIND: We could go one step further here and examine the
<i>1891</i>&nbsp;        // non-rectangular clip shape more closely if there is one.
<i>1892</i>&nbsp;        // Since the clip has already been rasterized, the performance
<i>1893</i>&nbsp;        // penalty of doing the scan is probably still within the bounds
<b class="nc"><i>1894</i>&nbsp;        // of a good tradeoff between speed and quality of the answer.</b>
<i>1895</i>&nbsp;        return true;
<i>1896</i>&nbsp;    }
<i>1897</i>&nbsp;
<b class="nc"><i>1898</i>&nbsp;    protected void validateCompClip() {</b>
<b class="nc"><i>1899</i>&nbsp;        int origClipState = clipState;</b>
<b class="nc"><i>1900</i>&nbsp;        if (usrClip == null) {</b>
<b class="nc"><i>1901</i>&nbsp;            clipState = CLIP_DEVICE;</b>
<b class="nc"><i>1902</i>&nbsp;            clipRegion = devClip;</b>
<b class="nc"><i>1903</i>&nbsp;        } else if (usrClip instanceof Rectangle2D) {</b>
<b class="nc"><i>1904</i>&nbsp;            clipState = CLIP_RECTANGULAR;</b>
<i>1905</i>&nbsp;            clipRegion = devClip.getIntersection((Rectangle2D) usrClip);
<b class="nc"><i>1906</i>&nbsp;        } else {</b>
<b class="nc"><i>1907</i>&nbsp;            PathIterator cpi = usrClip.getPathIterator(null);</b>
<b class="nc"><i>1908</i>&nbsp;            int box[] = new int[4];</b>
<i>1909</i>&nbsp;            ShapeSpanIterator sr = LoopPipe.getFillSSI(this);
<b class="nc"><i>1910</i>&nbsp;            try {</b>
<b class="nc"><i>1911</i>&nbsp;                sr.setOutputArea(devClip);</b>
<b class="nc"><i>1912</i>&nbsp;                sr.appendPath(cpi);</b>
<b class="nc"><i>1913</i>&nbsp;                sr.getPathBox(box);</b>
<b class="nc"><i>1914</i>&nbsp;                Region r = Region.getInstance(box, sr);</b>
<b class="nc"><i>1915</i>&nbsp;                clipRegion = r;</b>
<b class="nc"><i>1916</i>&nbsp;                clipState =</b>
<b class="nc"><i>1917</i>&nbsp;                    r.isRectangular() ? CLIP_RECTANGULAR : CLIP_SHAPE;</b>
<i>1918</i>&nbsp;            } finally {
<b class="nc"><i>1919</i>&nbsp;                sr.dispose();</b>
<b class="nc"><i>1920</i>&nbsp;            }</b>
<i>1921</i>&nbsp;        }
<b class="nc"><i>1922</i>&nbsp;        if (origClipState != clipState &amp;&amp;</b>
<i>1923</i>&nbsp;            (clipState == CLIP_SHAPE || origClipState == CLIP_SHAPE))
<i>1924</i>&nbsp;        {
<b class="nc"><i>1925</i>&nbsp;            validFontInfo = false;</b>
<b class="nc"><i>1926</i>&nbsp;            invalidatePipe();</b>
<i>1927</i>&nbsp;        }
<i>1928</i>&nbsp;    }
<i>1929</i>&nbsp;
<i>1930</i>&nbsp;    static final int NON_RECTILINEAR_TRANSFORM_MASK =
<i>1931</i>&nbsp;        (AffineTransform.TYPE_GENERAL_TRANSFORM |
<i>1932</i>&nbsp;         AffineTransform.TYPE_GENERAL_ROTATION);
<i>1933</i>&nbsp;
<i>1934</i>&nbsp;    protected Shape transformShape(Shape s) {
<b class="nc"><i>1935</i>&nbsp;        if (s == null) {</b>
<b class="nc"><i>1936</i>&nbsp;            return null;</b>
<i>1937</i>&nbsp;        }
<b class="nc"><i>1938</i>&nbsp;        if (transformState &gt; TRANSFORM_INT_TRANSLATE) {</b>
<b class="nc"><i>1939</i>&nbsp;            return transformShape(transform, s);</b>
<i>1940</i>&nbsp;        } else {
<b class="nc"><i>1941</i>&nbsp;            return transformShape(transX, transY, s);</b>
<i>1942</i>&nbsp;        }
<i>1943</i>&nbsp;    }
<i>1944</i>&nbsp;
<i>1945</i>&nbsp;    public Shape untransformShape(Shape s) {
<b class="nc"><i>1946</i>&nbsp;        if (s == null) {</b>
<b class="nc"><i>1947</i>&nbsp;            return null;</b>
<i>1948</i>&nbsp;        }
<b class="nc"><i>1949</i>&nbsp;        if (transformState &gt; TRANSFORM_INT_TRANSLATE) {</b>
<i>1950</i>&nbsp;            try {
<b class="nc"><i>1951</i>&nbsp;                return transformShape(transform.createInverse(), s);</b>
<b class="nc"><i>1952</i>&nbsp;            } catch (NoninvertibleTransformException e) {</b>
<b class="nc"><i>1953</i>&nbsp;                return null;</b>
<i>1954</i>&nbsp;            }
<i>1955</i>&nbsp;        } else {
<b class="nc"><i>1956</i>&nbsp;            return transformShape(-transX, -transY, s);</b>
<i>1957</i>&nbsp;        }
<i>1958</i>&nbsp;    }
<i>1959</i>&nbsp;
<i>1960</i>&nbsp;    protected static Shape transformShape(int tx, int ty, Shape s) {
<b class="nc"><i>1961</i>&nbsp;        if (s == null) {</b>
<b class="nc"><i>1962</i>&nbsp;            return null;</b>
<i>1963</i>&nbsp;        }
<i>1964</i>&nbsp;
<b class="nc"><i>1965</i>&nbsp;        if (s instanceof Rectangle) {</b>
<b class="nc"><i>1966</i>&nbsp;            Rectangle r = s.getBounds();</b>
<b class="nc"><i>1967</i>&nbsp;            r.translate(tx, ty);</b>
<b class="nc"><i>1968</i>&nbsp;            return r;</b>
<i>1969</i>&nbsp;        }
<b class="nc"><i>1970</i>&nbsp;        if (s instanceof Rectangle2D) {</b>
<b class="nc"><i>1971</i>&nbsp;            Rectangle2D rect = (Rectangle2D) s;</b>
<b class="nc"><i>1972</i>&nbsp;            return new Rectangle2D.Double(rect.getX() + tx,</b>
<b class="nc"><i>1973</i>&nbsp;                                          rect.getY() + ty,</b>
<b class="nc"><i>1974</i>&nbsp;                                          rect.getWidth(),</b>
<b class="nc"><i>1975</i>&nbsp;                                          rect.getHeight());</b>
<i>1976</i>&nbsp;        }
<i>1977</i>&nbsp;
<b class="nc"><i>1978</i>&nbsp;        if (tx == 0 &amp;&amp; ty == 0) {</b>
<b class="nc"><i>1979</i>&nbsp;            return cloneShape(s);</b>
<i>1980</i>&nbsp;        }
<i>1981</i>&nbsp;
<b class="nc"><i>1982</i>&nbsp;        AffineTransform mat = AffineTransform.getTranslateInstance(tx, ty);</b>
<b class="nc"><i>1983</i>&nbsp;        return mat.createTransformedShape(s);</b>
<i>1984</i>&nbsp;    }
<i>1985</i>&nbsp;
<i>1986</i>&nbsp;    protected static Shape transformShape(AffineTransform tx, Shape clip) {
<b class="nc"><i>1987</i>&nbsp;        if (clip == null) {</b>
<b class="nc"><i>1988</i>&nbsp;            return null;</b>
<i>1989</i>&nbsp;        }
<i>1990</i>&nbsp;
<b class="nc"><i>1991</i>&nbsp;        if (clip instanceof Rectangle2D &amp;&amp;</b>
<b class="nc"><i>1992</i>&nbsp;            (tx.getType() &amp; NON_RECTILINEAR_TRANSFORM_MASK) == 0)</b>
<i>1993</i>&nbsp;        {
<b class="nc"><i>1994</i>&nbsp;            Rectangle2D rect = (Rectangle2D) clip;</b>
<b class="nc"><i>1995</i>&nbsp;            double matrix[] = new double[4];</b>
<b class="nc"><i>1996</i>&nbsp;            matrix[0] = rect.getX();</b>
<b class="nc"><i>1997</i>&nbsp;            matrix[1] = rect.getY();</b>
<b class="nc"><i>1998</i>&nbsp;            matrix[2] = matrix[0] + rect.getWidth();</b>
<b class="nc"><i>1999</i>&nbsp;            matrix[3] = matrix[1] + rect.getHeight();</b>
<b class="nc"><i>2000</i>&nbsp;            tx.transform(matrix, 0, matrix, 0, 2);</b>
<b class="nc"><i>2001</i>&nbsp;            fixRectangleOrientation(matrix, rect);</b>
<b class="nc"><i>2002</i>&nbsp;            return new Rectangle2D.Double(matrix[0], matrix[1],</b>
<i>2003</i>&nbsp;                                          matrix[2] - matrix[0],
<i>2004</i>&nbsp;                                          matrix[3] - matrix[1]);
<i>2005</i>&nbsp;        }
<i>2006</i>&nbsp;
<b class="nc"><i>2007</i>&nbsp;        if (tx.isIdentity()) {</b>
<b class="nc"><i>2008</i>&nbsp;            return cloneShape(clip);</b>
<i>2009</i>&nbsp;        }
<i>2010</i>&nbsp;
<b class="nc"><i>2011</i>&nbsp;        return tx.createTransformedShape(clip);</b>
<i>2012</i>&nbsp;    }
<i>2013</i>&nbsp;
<i>2014</i>&nbsp;    /**
<i>2015</i>&nbsp;     * Sets orientation of the rectangle according to the clip.
<i>2016</i>&nbsp;     */
<i>2017</i>&nbsp;    private static void fixRectangleOrientation(double[] m, Rectangle2D clip) {
<b class="nc"><i>2018</i>&nbsp;        if (clip.getWidth() &gt; 0 != (m[2] - m[0] &gt; 0)) {</b>
<b class="nc"><i>2019</i>&nbsp;            double t = m[0];</b>
<b class="nc"><i>2020</i>&nbsp;            m[0] = m[2];</b>
<b class="nc"><i>2021</i>&nbsp;            m[2] = t;</b>
<i>2022</i>&nbsp;        }
<b class="nc"><i>2023</i>&nbsp;        if (clip.getHeight() &gt; 0 != (m[3] - m[1] &gt; 0)) {</b>
<b class="nc"><i>2024</i>&nbsp;            double t = m[1];</b>
<b class="nc"><i>2025</i>&nbsp;            m[1] = m[3];</b>
<b class="nc"><i>2026</i>&nbsp;            m[3] = t;</b>
<i>2027</i>&nbsp;        }
<i>2028</i>&nbsp;    }
<i>2029</i>&nbsp;
<i>2030</i>&nbsp;    public void clipRect(int x, int y, int w, int h) {
<b class="nc"><i>2031</i>&nbsp;        clip(new Rectangle(x, y, w, h));</b>
<i>2032</i>&nbsp;    }
<i>2033</i>&nbsp;
<i>2034</i>&nbsp;    public void setClip(int x, int y, int w, int h) {
<b class="nc"><i>2035</i>&nbsp;        setClip(new Rectangle(x, y, w, h));</b>
<i>2036</i>&nbsp;    }
<i>2037</i>&nbsp;
<i>2038</i>&nbsp;    public Shape getClip() {
<b class="nc"><i>2039</i>&nbsp;        return untransformShape(usrClip);</b>
<i>2040</i>&nbsp;    }
<i>2041</i>&nbsp;
<i>2042</i>&nbsp;    public void setClip(Shape sh) {
<b class="nc"><i>2043</i>&nbsp;        usrClip = transformShape(sh);</b>
<b class="nc"><i>2044</i>&nbsp;        validateCompClip();</b>
<i>2045</i>&nbsp;    }
<i>2046</i>&nbsp;
<i>2047</i>&nbsp;    /**
<i>2048</i>&nbsp;     * Intersects the current clip with the specified Path and sets the
<i>2049</i>&nbsp;     * current clip to the resulting intersection. The clip is transformed
<i>2050</i>&nbsp;     * with the current transform in the Graphics2D state before being
<i>2051</i>&nbsp;     * intersected with the current clip. This method is used to make the
<i>2052</i>&nbsp;     * current clip smaller. To make the clip larger, use any setClip method.
<i>2053</i>&nbsp;     * @param s The Path to be intersected with the current clip.
<i>2054</i>&nbsp;     */
<i>2055</i>&nbsp;    public void clip(Shape s) {
<b class="nc"><i>2056</i>&nbsp;        s = transformShape(s);</b>
<b class="nc"><i>2057</i>&nbsp;        if (usrClip != null) {</b>
<b class="nc"><i>2058</i>&nbsp;            s = intersectShapes(usrClip, s, true, true);</b>
<i>2059</i>&nbsp;        }
<b class="nc"><i>2060</i>&nbsp;        usrClip = s;</b>
<b class="nc"><i>2061</i>&nbsp;        validateCompClip();</b>
<i>2062</i>&nbsp;    }
<i>2063</i>&nbsp;
<i>2064</i>&nbsp;    public void setPaintMode() {
<b class="nc"><i>2065</i>&nbsp;        setComposite(AlphaComposite.SrcOver);</b>
<i>2066</i>&nbsp;    }
<i>2067</i>&nbsp;
<i>2068</i>&nbsp;    public void setXORMode(Color c) {
<b class="nc"><i>2069</i>&nbsp;        if (c == null) {</b>
<b class="nc"><i>2070</i>&nbsp;            throw new IllegalArgumentException(&quot;null XORColor&quot;);</b>
<i>2071</i>&nbsp;        }
<b class="nc"><i>2072</i>&nbsp;        setComposite(new XORComposite(c, surfaceData));</b>
<i>2073</i>&nbsp;    }
<i>2074</i>&nbsp;
<i>2075</i>&nbsp;    Blit lastCAblit;
<i>2076</i>&nbsp;    Composite lastCAcomp;
<i>2077</i>&nbsp;
<i>2078</i>&nbsp;    public void copyArea(int x, int y, int w, int h, int dx, int dy) {
<i>2079</i>&nbsp;        try {
<b class="nc"><i>2080</i>&nbsp;            doCopyArea(x, y, w, h, dx, dy);</b>
<b class="nc"><i>2081</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2082</i>&nbsp;            try {
<b class="nc"><i>2083</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2084</i>&nbsp;                doCopyArea(x, y, w, h, dx, dy);</b>
<b class="nc"><i>2085</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2086</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2087</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2088</i>&nbsp;                // try again next time around.
<b class="nc"><i>2089</i>&nbsp;            }</b>
<i>2090</i>&nbsp;        } finally {
<b class="nc"><i>2091</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2092</i>&nbsp;        }</b>
<i>2093</i>&nbsp;    }
<i>2094</i>&nbsp;
<i>2095</i>&nbsp;    private void doCopyArea(int x, int y, int w, int h, int dx, int dy) {
<b class="nc"><i>2096</i>&nbsp;        if (w &lt;= 0 || h &lt;= 0) {</b>
<i>2097</i>&nbsp;            return;
<i>2098</i>&nbsp;        }
<i>2099</i>&nbsp;
<b class="nc"><i>2100</i>&nbsp;        if (transformState == SunGraphics2D.TRANSFORM_ISIDENT) {</b>
<i>2101</i>&nbsp;            // do nothing
<b class="nc"><i>2102</i>&nbsp;        } else if (transformState &lt;= SunGraphics2D.TRANSFORM_ANY_TRANSLATE) {</b>
<b class="nc"><i>2103</i>&nbsp;            x += transX;</b>
<b class="nc"><i>2104</i>&nbsp;            y += transY;</b>
<b class="nc"><i>2105</i>&nbsp;        } else if (transformState == SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</b>
<b class="nc"><i>2106</i>&nbsp;            final double[] coords = {x, y, x + w, y + h, x + dx, y + dy};</b>
<b class="nc"><i>2107</i>&nbsp;            transform.transform(coords, 0, coords, 0, 3);</b>
<b class="nc"><i>2108</i>&nbsp;            x = (int) Math.ceil(coords[0] - 0.5);</b>
<b class="nc"><i>2109</i>&nbsp;            y = (int) Math.ceil(coords[1] - 0.5);</b>
<b class="nc"><i>2110</i>&nbsp;            w = ((int) Math.ceil(coords[2] - 0.5)) - x;</b>
<b class="nc"><i>2111</i>&nbsp;            h = ((int) Math.ceil(coords[3] - 0.5)) - y;</b>
<b class="nc"><i>2112</i>&nbsp;            dx = ((int) Math.ceil(coords[4] - 0.5)) - x;</b>
<b class="nc"><i>2113</i>&nbsp;            dy = ((int) Math.ceil(coords[5] - 0.5)) - y;</b>
<i>2114</i>&nbsp;            // In case of negative scale transform, reflect the rect coords.
<b class="nc"><i>2115</i>&nbsp;            if (w &lt; 0) {</b>
<b class="nc"><i>2116</i>&nbsp;                w = -w;</b>
<b class="nc"><i>2117</i>&nbsp;                x -= w;</b>
<i>2118</i>&nbsp;            }
<b class="nc"><i>2119</i>&nbsp;            if (h &lt; 0) {</b>
<b class="nc"><i>2120</i>&nbsp;                h = -h;</b>
<b class="nc"><i>2121</i>&nbsp;                y -= h;</b>
<i>2122</i>&nbsp;            }
<b class="nc"><i>2123</i>&nbsp;        } else {</b>
<b class="nc"><i>2124</i>&nbsp;            throw new InternalError(&quot;transformed copyArea not implemented yet&quot;);</b>
<i>2125</i>&nbsp;        }
<i>2126</i>&nbsp;
<b class="nc"><i>2127</i>&nbsp;        SurfaceData theData = surfaceData;</b>
<b class="nc"><i>2128</i>&nbsp;        if (theData.copyArea(this, x, y, w, h, dx, dy)) {</b>
<i>2129</i>&nbsp;            return;
<i>2130</i>&nbsp;        }
<i>2131</i>&nbsp;
<i>2132</i>&nbsp;        // REMIND: This method does not deal with missing data from the
<i>2133</i>&nbsp;        // source object (i.e. it does not send exposure events...)
<i>2134</i>&nbsp;
<b class="nc"><i>2135</i>&nbsp;        Region clip = getCompClip();</b>
<i>2136</i>&nbsp;
<b class="nc"><i>2137</i>&nbsp;        Composite comp = composite;</b>
<b class="nc"><i>2138</i>&nbsp;        if (lastCAcomp != comp) {</b>
<b class="nc"><i>2139</i>&nbsp;            SurfaceType dsttype = theData.getSurfaceType();</b>
<b class="nc"><i>2140</i>&nbsp;            CompositeType comptype = imageComp;</b>
<b class="nc"><i>2141</i>&nbsp;            if (CompositeType.SrcOverNoEa.equals(comptype) &amp;&amp;</b>
<b class="nc"><i>2142</i>&nbsp;                theData.getTransparency() == Transparency.OPAQUE)</b>
<i>2143</i>&nbsp;            {
<b class="nc"><i>2144</i>&nbsp;                comptype = CompositeType.SrcNoEa;</b>
<i>2145</i>&nbsp;            }
<b class="nc"><i>2146</i>&nbsp;            lastCAblit = Blit.locate(dsttype, comptype, dsttype);</b>
<b class="nc"><i>2147</i>&nbsp;            lastCAcomp = comp;</b>
<i>2148</i>&nbsp;        }
<i>2149</i>&nbsp;
<b class="nc"><i>2150</i>&nbsp;        Blit ob = lastCAblit;</b>
<b class="nc"><i>2151</i>&nbsp;        if (dy == 0 &amp;&amp; dx &gt; 0 &amp;&amp; dx &lt; w) {</b>
<b class="nc"><i>2152</i>&nbsp;            while (w &gt; 0) {</b>
<b class="nc"><i>2153</i>&nbsp;                int partW = Math.min(w, dx);</b>
<b class="nc"><i>2154</i>&nbsp;                w -= partW;</b>
<b class="nc"><i>2155</i>&nbsp;                int sx = x + w;</b>
<b class="nc"><i>2156</i>&nbsp;                ob.Blit(theData, theData, comp, clip,</b>
<i>2157</i>&nbsp;                        sx, y, sx+dx, y+dy, partW, h);
<b class="nc"><i>2158</i>&nbsp;            }</b>
<i>2159</i>&nbsp;            return;
<i>2160</i>&nbsp;        }
<b class="nc"><i>2161</i>&nbsp;        if (dy &gt; 0 &amp;&amp; dy &lt; h &amp;&amp; dx &gt; -w &amp;&amp; dx &lt; w) {</b>
<b class="nc"><i>2162</i>&nbsp;            while (h &gt; 0) {</b>
<b class="nc"><i>2163</i>&nbsp;                int partH = Math.min(h, dy);</b>
<b class="nc"><i>2164</i>&nbsp;                h -= partH;</b>
<b class="nc"><i>2165</i>&nbsp;                int sy = y + h;</b>
<b class="nc"><i>2166</i>&nbsp;                ob.Blit(theData, theData, comp, clip,</b>
<i>2167</i>&nbsp;                        x, sy, x+dx, sy+dy, w, partH);
<b class="nc"><i>2168</i>&nbsp;            }</b>
<i>2169</i>&nbsp;            return;
<i>2170</i>&nbsp;        }
<b class="nc"><i>2171</i>&nbsp;            ob.Blit(theData, theData, comp, clip, x, y, x+dx, y+dy, w, h);</b>
<i>2172</i>&nbsp;    }
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;    /*
<i>2175</i>&nbsp;    public void XcopyArea(int x, int y, int w, int h, int dx, int dy) {
<i>2176</i>&nbsp;        Rectangle rect = new Rectangle(x, y, w, h);
<i>2177</i>&nbsp;        rect = transformBounds(rect, transform);
<i>2178</i>&nbsp;        Point2D    point = new Point2D.Float(dx, dy);
<i>2179</i>&nbsp;        Point2D    root  = new Point2D.Float(0, 0);
<i>2180</i>&nbsp;        point = transform.transform(point, point);
<i>2181</i>&nbsp;        root  = transform.transform(root, root);
<i>2182</i>&nbsp;        int fdx = (int)(point.getX()-root.getX());
<i>2183</i>&nbsp;        int fdy = (int)(point.getY()-root.getY());
<i>2184</i>&nbsp;
<i>2185</i>&nbsp;        Rectangle r = getCompBounds().intersection(rect.getBounds());
<i>2186</i>&nbsp;
<i>2187</i>&nbsp;        if (r.isEmpty()) {
<i>2188</i>&nbsp;            return;
<i>2189</i>&nbsp;        }
<i>2190</i>&nbsp;
<i>2191</i>&nbsp;        // Begin Rasterizer for Clip Shape
<i>2192</i>&nbsp;        boolean skipClip = true;
<i>2193</i>&nbsp;        byte[] clipAlpha = null;
<i>2194</i>&nbsp;
<i>2195</i>&nbsp;        if (clipState == CLIP_SHAPE) {
<i>2196</i>&nbsp;
<i>2197</i>&nbsp;            int box[] = new int[4];
<i>2198</i>&nbsp;
<i>2199</i>&nbsp;            clipRegion.getBounds(box);
<i>2200</i>&nbsp;            Rectangle devR = new Rectangle(box[0], box[1],
<i>2201</i>&nbsp;                                           box[2] - box[0],
<i>2202</i>&nbsp;                                           box[3] - box[1]);
<i>2203</i>&nbsp;            if (!devR.isEmpty()) {
<i>2204</i>&nbsp;                OutputManager mgr = getOutputManager();
<i>2205</i>&nbsp;                RegionIterator ri = clipRegion.getIterator();
<i>2206</i>&nbsp;                while (ri.nextYRange(box)) {
<i>2207</i>&nbsp;                    int spany = box[1];
<i>2208</i>&nbsp;                    int spanh = box[3] - spany;
<i>2209</i>&nbsp;                    while (ri.nextXBand(box)) {
<i>2210</i>&nbsp;                        int spanx = box[0];
<i>2211</i>&nbsp;                        int spanw = box[2] - spanx;
<i>2212</i>&nbsp;                        mgr.copyArea(this, null,
<i>2213</i>&nbsp;                                     spanw, 0,
<i>2214</i>&nbsp;                                     spanx, spany,
<i>2215</i>&nbsp;                                     spanw, spanh,
<i>2216</i>&nbsp;                                     fdx, fdy,
<i>2217</i>&nbsp;                                     null);
<i>2218</i>&nbsp;                    }
<i>2219</i>&nbsp;                }
<i>2220</i>&nbsp;            }
<i>2221</i>&nbsp;            return;
<i>2222</i>&nbsp;        }
<i>2223</i>&nbsp;        // End Rasterizer for Clip Shape
<i>2224</i>&nbsp;
<i>2225</i>&nbsp;        getOutputManager().copyArea(this, null,
<i>2226</i>&nbsp;                                    r.width, 0,
<i>2227</i>&nbsp;                                    r.x, r.y, r.width,
<i>2228</i>&nbsp;                                    r.height, fdx, fdy,
<i>2229</i>&nbsp;                                    null);
<i>2230</i>&nbsp;    }
<i>2231</i>&nbsp;    */
<i>2232</i>&nbsp;
<i>2233</i>&nbsp;    public void drawLine(int x1, int y1, int x2, int y2) {
<i>2234</i>&nbsp;        try {
<b class="nc"><i>2235</i>&nbsp;            drawpipe.drawLine(this, x1, y1, x2, y2);</b>
<b class="nc"><i>2236</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2237</i>&nbsp;            try {
<b class="nc"><i>2238</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2239</i>&nbsp;                drawpipe.drawLine(this, x1, y1, x2, y2);</b>
<b class="nc"><i>2240</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2241</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2242</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2243</i>&nbsp;                // try again next time around.
<b class="nc"><i>2244</i>&nbsp;            }</b>
<i>2245</i>&nbsp;        } finally {
<b class="nc"><i>2246</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2247</i>&nbsp;        }</b>
<i>2248</i>&nbsp;    }
<i>2249</i>&nbsp;
<i>2250</i>&nbsp;    public void drawRoundRect(int x, int y, int w, int h, int arcW, int arcH) {
<i>2251</i>&nbsp;        try {
<b class="nc"><i>2252</i>&nbsp;            drawpipe.drawRoundRect(this, x, y, w, h, arcW, arcH);</b>
<b class="nc"><i>2253</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2254</i>&nbsp;            try {
<b class="nc"><i>2255</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2256</i>&nbsp;                drawpipe.drawRoundRect(this, x, y, w, h, arcW, arcH);</b>
<b class="nc"><i>2257</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2258</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2259</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2260</i>&nbsp;                // try again next time around.
<b class="nc"><i>2261</i>&nbsp;            }</b>
<i>2262</i>&nbsp;        } finally {
<b class="nc"><i>2263</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2264</i>&nbsp;        }</b>
<i>2265</i>&nbsp;    }
<i>2266</i>&nbsp;
<i>2267</i>&nbsp;    public void fillRoundRect(int x, int y, int w, int h, int arcW, int arcH) {
<i>2268</i>&nbsp;        try {
<b class="nc"><i>2269</i>&nbsp;            fillpipe.fillRoundRect(this, x, y, w, h, arcW, arcH);</b>
<b class="nc"><i>2270</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2271</i>&nbsp;            try {
<b class="nc"><i>2272</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2273</i>&nbsp;                fillpipe.fillRoundRect(this, x, y, w, h, arcW, arcH);</b>
<b class="nc"><i>2274</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2275</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2276</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2277</i>&nbsp;                // try again next time around.
<b class="nc"><i>2278</i>&nbsp;            }</b>
<i>2279</i>&nbsp;        } finally {
<b class="nc"><i>2280</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2281</i>&nbsp;        }</b>
<i>2282</i>&nbsp;    }
<i>2283</i>&nbsp;
<i>2284</i>&nbsp;    public void drawOval(int x, int y, int w, int h) {
<i>2285</i>&nbsp;        try {
<b class="nc"><i>2286</i>&nbsp;            drawpipe.drawOval(this, x, y, w, h);</b>
<b class="nc"><i>2287</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2288</i>&nbsp;            try {
<b class="nc"><i>2289</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2290</i>&nbsp;                drawpipe.drawOval(this, x, y, w, h);</b>
<b class="nc"><i>2291</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2292</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2293</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2294</i>&nbsp;                // try again next time around.
<b class="nc"><i>2295</i>&nbsp;            }</b>
<i>2296</i>&nbsp;        } finally {
<b class="nc"><i>2297</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2298</i>&nbsp;        }</b>
<i>2299</i>&nbsp;    }
<i>2300</i>&nbsp;
<i>2301</i>&nbsp;    public void fillOval(int x, int y, int w, int h) {
<i>2302</i>&nbsp;        try {
<b class="nc"><i>2303</i>&nbsp;            fillpipe.fillOval(this, x, y, w, h);</b>
<b class="nc"><i>2304</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2305</i>&nbsp;            try {
<b class="nc"><i>2306</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2307</i>&nbsp;                fillpipe.fillOval(this, x, y, w, h);</b>
<b class="nc"><i>2308</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2309</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2310</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2311</i>&nbsp;                // try again next time around.
<b class="nc"><i>2312</i>&nbsp;            }</b>
<i>2313</i>&nbsp;        } finally {
<b class="nc"><i>2314</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2315</i>&nbsp;        }</b>
<i>2316</i>&nbsp;    }
<i>2317</i>&nbsp;
<i>2318</i>&nbsp;    public void drawArc(int x, int y, int w, int h,
<i>2319</i>&nbsp;                        int startAngl, int arcAngl) {
<i>2320</i>&nbsp;        try {
<b class="nc"><i>2321</i>&nbsp;            drawpipe.drawArc(this, x, y, w, h, startAngl, arcAngl);</b>
<b class="nc"><i>2322</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2323</i>&nbsp;            try {
<b class="nc"><i>2324</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2325</i>&nbsp;                drawpipe.drawArc(this, x, y, w, h, startAngl, arcAngl);</b>
<b class="nc"><i>2326</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2327</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2328</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2329</i>&nbsp;                // try again next time around.
<b class="nc"><i>2330</i>&nbsp;            }</b>
<i>2331</i>&nbsp;        } finally {
<b class="nc"><i>2332</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2333</i>&nbsp;        }</b>
<i>2334</i>&nbsp;    }
<i>2335</i>&nbsp;
<i>2336</i>&nbsp;    public void fillArc(int x, int y, int w, int h,
<i>2337</i>&nbsp;                        int startAngl, int arcAngl) {
<i>2338</i>&nbsp;        try {
<b class="nc"><i>2339</i>&nbsp;            fillpipe.fillArc(this, x, y, w, h, startAngl, arcAngl);</b>
<b class="nc"><i>2340</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2341</i>&nbsp;            try {
<b class="nc"><i>2342</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2343</i>&nbsp;                fillpipe.fillArc(this, x, y, w, h, startAngl, arcAngl);</b>
<b class="nc"><i>2344</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2345</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2346</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2347</i>&nbsp;                // try again next time around.
<b class="nc"><i>2348</i>&nbsp;            }</b>
<i>2349</i>&nbsp;        } finally {
<b class="nc"><i>2350</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2351</i>&nbsp;        }</b>
<i>2352</i>&nbsp;    }
<i>2353</i>&nbsp;
<i>2354</i>&nbsp;    public void drawPolyline(int xPoints[], int yPoints[], int nPoints) {
<i>2355</i>&nbsp;        try {
<b class="nc"><i>2356</i>&nbsp;            drawpipe.drawPolyline(this, xPoints, yPoints, nPoints);</b>
<b class="nc"><i>2357</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2358</i>&nbsp;            try {
<b class="nc"><i>2359</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2360</i>&nbsp;                drawpipe.drawPolyline(this, xPoints, yPoints, nPoints);</b>
<b class="nc"><i>2361</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2362</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2363</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2364</i>&nbsp;                // try again next time around.
<b class="nc"><i>2365</i>&nbsp;            }</b>
<i>2366</i>&nbsp;        } finally {
<b class="nc"><i>2367</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2368</i>&nbsp;        }</b>
<i>2369</i>&nbsp;    }
<i>2370</i>&nbsp;
<i>2371</i>&nbsp;    public void drawPolygon(int xPoints[], int yPoints[], int nPoints) {
<i>2372</i>&nbsp;        try {
<b class="nc"><i>2373</i>&nbsp;            drawpipe.drawPolygon(this, xPoints, yPoints, nPoints);</b>
<b class="nc"><i>2374</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2375</i>&nbsp;            try {
<b class="nc"><i>2376</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2377</i>&nbsp;                drawpipe.drawPolygon(this, xPoints, yPoints, nPoints);</b>
<b class="nc"><i>2378</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2379</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2380</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2381</i>&nbsp;                // try again next time around.
<b class="nc"><i>2382</i>&nbsp;            }</b>
<i>2383</i>&nbsp;        } finally {
<b class="nc"><i>2384</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2385</i>&nbsp;        }</b>
<i>2386</i>&nbsp;    }
<i>2387</i>&nbsp;
<i>2388</i>&nbsp;    public void fillPolygon(int xPoints[], int yPoints[], int nPoints) {
<i>2389</i>&nbsp;        try {
<b class="nc"><i>2390</i>&nbsp;            fillpipe.fillPolygon(this, xPoints, yPoints, nPoints);</b>
<b class="nc"><i>2391</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2392</i>&nbsp;            try {
<b class="nc"><i>2393</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2394</i>&nbsp;                fillpipe.fillPolygon(this, xPoints, yPoints, nPoints);</b>
<b class="nc"><i>2395</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2396</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2397</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2398</i>&nbsp;                // try again next time around.
<b class="nc"><i>2399</i>&nbsp;            }</b>
<i>2400</i>&nbsp;        } finally {
<b class="nc"><i>2401</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2402</i>&nbsp;        }</b>
<i>2403</i>&nbsp;    }
<i>2404</i>&nbsp;
<i>2405</i>&nbsp;    public void drawRect (int x, int y, int w, int h) {
<i>2406</i>&nbsp;        try {
<b class="nc"><i>2407</i>&nbsp;            drawpipe.drawRect(this, x, y, w, h);</b>
<b class="nc"><i>2408</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2409</i>&nbsp;            try {
<b class="nc"><i>2410</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2411</i>&nbsp;                drawpipe.drawRect(this, x, y, w, h);</b>
<b class="nc"><i>2412</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2413</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2414</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2415</i>&nbsp;                // try again next time around.
<b class="nc"><i>2416</i>&nbsp;            }</b>
<i>2417</i>&nbsp;        } finally {
<b class="nc"><i>2418</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2419</i>&nbsp;        }</b>
<i>2420</i>&nbsp;    }
<i>2421</i>&nbsp;
<i>2422</i>&nbsp;    public void fillRect (int x, int y, int w, int h) {
<i>2423</i>&nbsp;        try {
<b class="nc"><i>2424</i>&nbsp;            fillpipe.fillRect(this, x, y, w, h);</b>
<b class="nc"><i>2425</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2426</i>&nbsp;            try {
<b class="nc"><i>2427</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2428</i>&nbsp;                fillpipe.fillRect(this, x, y, w, h);</b>
<b class="nc"><i>2429</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2430</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2431</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2432</i>&nbsp;                // try again next time around.
<b class="nc"><i>2433</i>&nbsp;            }</b>
<i>2434</i>&nbsp;        } finally {
<b class="nc"><i>2435</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2436</i>&nbsp;        }</b>
<i>2437</i>&nbsp;    }
<i>2438</i>&nbsp;
<i>2439</i>&nbsp;    private void revalidateAll() {
<i>2440</i>&nbsp;        try {
<i>2441</i>&nbsp;            // REMIND: This locking needs to be done around the
<i>2442</i>&nbsp;            // caller of this method so that the pipe stays valid
<i>2443</i>&nbsp;            // long enough to call the new primitive.
<i>2444</i>&nbsp;            // REMIND: No locking yet in screen SurfaceData objects!
<i>2445</i>&nbsp;            // surfaceData.lock();
<b class="nc"><i>2446</i>&nbsp;            surfaceData = surfaceData.getReplacement();</b>
<b class="nc"><i>2447</i>&nbsp;            if (surfaceData == null) {</b>
<b class="nc"><i>2448</i>&nbsp;                surfaceData = NullSurfaceData.theInstance;</b>
<i>2449</i>&nbsp;            }
<i>2450</i>&nbsp;
<b class="nc"><i>2451</i>&nbsp;            invalidatePipe();</b>
<i>2452</i>&nbsp;
<i>2453</i>&nbsp;            // this will recalculate the composite clip
<b class="nc"><i>2454</i>&nbsp;            setDevClip(surfaceData.getBounds());</b>
<i>2455</i>&nbsp;
<b class="nc"><i>2456</i>&nbsp;            if (paintState &lt;= PAINT_ALPHACOLOR) {</b>
<b class="nc"><i>2457</i>&nbsp;                validateColor();</b>
<i>2458</i>&nbsp;            }
<b class="nc"><i>2459</i>&nbsp;            if (composite instanceof XORComposite) {</b>
<b class="nc"><i>2460</i>&nbsp;                Color c = ((XORComposite) composite).getXorColor();</b>
<b class="nc"><i>2461</i>&nbsp;                setComposite(new XORComposite(c, surfaceData));</b>
<i>2462</i>&nbsp;            }
<b class="nc"><i>2463</i>&nbsp;            validatePipe();</b>
<i>2464</i>&nbsp;        } finally {
<i>2465</i>&nbsp;            // REMIND: No locking yet in screen SurfaceData objects!
<i>2466</i>&nbsp;            // surfaceData.unlock();
<i>2467</i>&nbsp;        }
<i>2468</i>&nbsp;    }
<i>2469</i>&nbsp;
<i>2470</i>&nbsp;    public void clearRect(int x, int y, int w, int h) {
<i>2471</i>&nbsp;        // REMIND: has some &quot;interesting&quot; consequences if threads are
<i>2472</i>&nbsp;        // not synchronized
<b class="nc"><i>2473</i>&nbsp;        Composite c = composite;</b>
<b class="nc"><i>2474</i>&nbsp;        Paint p = paint;</b>
<b class="nc"><i>2475</i>&nbsp;        setComposite(AlphaComposite.Src);</b>
<b class="nc"><i>2476</i>&nbsp;        setColor(getBackground());</b>
<b class="nc"><i>2477</i>&nbsp;        fillRect(x, y, w, h);</b>
<b class="nc"><i>2478</i>&nbsp;        setPaint(p);</b>
<b class="nc"><i>2479</i>&nbsp;        setComposite(c);</b>
<i>2480</i>&nbsp;    }
<i>2481</i>&nbsp;
<i>2482</i>&nbsp;    /**
<i>2483</i>&nbsp;     * Strokes the outline of a Path using the settings of the current
<i>2484</i>&nbsp;     * graphics state.  The rendering attributes applied include the
<i>2485</i>&nbsp;     * clip, transform, paint or color, composite and stroke attributes.
<i>2486</i>&nbsp;     * @param s The path to be drawn.
<i>2487</i>&nbsp;     * @see #setStroke
<i>2488</i>&nbsp;     * @see #setPaint
<i>2489</i>&nbsp;     * @see java.awt.Graphics#setColor
<i>2490</i>&nbsp;     * @see #transform
<i>2491</i>&nbsp;     * @see #setTransform
<i>2492</i>&nbsp;     * @see #clip
<i>2493</i>&nbsp;     * @see #setClip
<i>2494</i>&nbsp;     * @see #setComposite
<i>2495</i>&nbsp;     */
<i>2496</i>&nbsp;    public void draw(Shape s) {
<i>2497</i>&nbsp;        try {
<b class="nc"><i>2498</i>&nbsp;            shapepipe.draw(this, s);</b>
<b class="nc"><i>2499</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2500</i>&nbsp;            try {
<b class="nc"><i>2501</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2502</i>&nbsp;                shapepipe.draw(this, s);</b>
<b class="nc"><i>2503</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2504</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2505</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2506</i>&nbsp;                // try again next time around.
<b class="nc"><i>2507</i>&nbsp;            }</b>
<i>2508</i>&nbsp;        } finally {
<b class="nc"><i>2509</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2510</i>&nbsp;        }</b>
<i>2511</i>&nbsp;    }
<i>2512</i>&nbsp;
<i>2513</i>&nbsp;
<i>2514</i>&nbsp;    /**
<i>2515</i>&nbsp;     * Fills the interior of a Path using the settings of the current
<i>2516</i>&nbsp;     * graphics state. The rendering attributes applied include the
<i>2517</i>&nbsp;     * clip, transform, paint or color, and composite.
<i>2518</i>&nbsp;     * @see #setPaint
<i>2519</i>&nbsp;     * @see java.awt.Graphics#setColor
<i>2520</i>&nbsp;     * @see #transform
<i>2521</i>&nbsp;     * @see #setTransform
<i>2522</i>&nbsp;     * @see #setComposite
<i>2523</i>&nbsp;     * @see #clip
<i>2524</i>&nbsp;     * @see #setClip
<i>2525</i>&nbsp;     */
<i>2526</i>&nbsp;    public void fill(Shape s) {
<i>2527</i>&nbsp;        try {
<b class="nc"><i>2528</i>&nbsp;            shapepipe.fill(this, s);</b>
<b class="nc"><i>2529</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2530</i>&nbsp;            try {
<b class="nc"><i>2531</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2532</i>&nbsp;                shapepipe.fill(this, s);</b>
<b class="nc"><i>2533</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2534</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2535</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2536</i>&nbsp;                // try again next time around.
<b class="nc"><i>2537</i>&nbsp;            }</b>
<i>2538</i>&nbsp;        } finally {
<b class="nc"><i>2539</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2540</i>&nbsp;        }</b>
<i>2541</i>&nbsp;    }
<i>2542</i>&nbsp;
<i>2543</i>&nbsp;    /**
<i>2544</i>&nbsp;     * Returns true if the given AffineTransform is an integer
<i>2545</i>&nbsp;     * translation.
<i>2546</i>&nbsp;     */
<i>2547</i>&nbsp;    private static boolean isIntegerTranslation(AffineTransform xform) {
<b class="nc"><i>2548</i>&nbsp;        if (xform.isIdentity()) {</b>
<b class="nc"><i>2549</i>&nbsp;            return true;</b>
<i>2550</i>&nbsp;        }
<b class="nc"><i>2551</i>&nbsp;        if (xform.getType() == AffineTransform.TYPE_TRANSLATION) {</b>
<b class="nc"><i>2552</i>&nbsp;            double tx = xform.getTranslateX();</b>
<b class="nc"><i>2553</i>&nbsp;            double ty = xform.getTranslateY();</b>
<b class="nc"><i>2554</i>&nbsp;            return (tx == (int)tx &amp;&amp; ty == (int)ty);</b>
<i>2555</i>&nbsp;        }
<b class="nc"><i>2556</i>&nbsp;        return false;</b>
<i>2557</i>&nbsp;    }
<i>2558</i>&nbsp;
<i>2559</i>&nbsp;    /**
<i>2560</i>&nbsp;     * Returns the index of the tile corresponding to the supplied position
<i>2561</i>&nbsp;     * given the tile grid offset and size along the same axis.
<i>2562</i>&nbsp;     */
<i>2563</i>&nbsp;    private static int getTileIndex(int p, int tileGridOffset, int tileSize) {
<b class="nc"><i>2564</i>&nbsp;        p -= tileGridOffset;</b>
<b class="nc"><i>2565</i>&nbsp;        if (p &lt; 0) {</b>
<b class="nc"><i>2566</i>&nbsp;            p += 1 - tileSize;          // force round to -infinity (ceiling)</b>
<i>2567</i>&nbsp;        }
<b class="nc"><i>2568</i>&nbsp;        return p/tileSize;</b>
<i>2569</i>&nbsp;    }
<i>2570</i>&nbsp;
<i>2571</i>&nbsp;    /**
<i>2572</i>&nbsp;     * Returns a rectangle in image coordinates that may be required
<i>2573</i>&nbsp;     * in order to draw the given image into the given clipping region
<i>2574</i>&nbsp;     * through a pair of AffineTransforms.  In addition, horizontal and
<i>2575</i>&nbsp;     * vertical padding factors for antialising and interpolation may
<i>2576</i>&nbsp;     * be used.
<i>2577</i>&nbsp;     */
<i>2578</i>&nbsp;    private static Rectangle getImageRegion(RenderedImage img,
<i>2579</i>&nbsp;                                            Region compClip,
<i>2580</i>&nbsp;                                            AffineTransform transform,
<i>2581</i>&nbsp;                                            AffineTransform xform,
<i>2582</i>&nbsp;                                            int padX, int padY) {
<b class="nc"><i>2583</i>&nbsp;        Rectangle imageRect =</b>
<b class="nc"><i>2584</i>&nbsp;            new Rectangle(img.getMinX(), img.getMinY(),</b>
<b class="nc"><i>2585</i>&nbsp;                          img.getWidth(), img.getHeight());</b>
<i>2586</i>&nbsp;
<b class="nc"><i>2587</i>&nbsp;        Rectangle result = null;</b>
<i>2588</i>&nbsp;        try {
<b class="nc"><i>2589</i>&nbsp;            double p[] = new double[8];</b>
<b class="nc"><i>2590</i>&nbsp;            p[0] = p[2] = compClip.getLoX();</b>
<b class="nc"><i>2591</i>&nbsp;            p[4] = p[6] = compClip.getHiX();</b>
<b class="nc"><i>2592</i>&nbsp;            p[1] = p[5] = compClip.getLoY();</b>
<b class="nc"><i>2593</i>&nbsp;            p[3] = p[7] = compClip.getHiY();</b>
<i>2594</i>&nbsp;
<i>2595</i>&nbsp;            // Inverse transform the output bounding rect
<b class="nc"><i>2596</i>&nbsp;            transform.inverseTransform(p, 0, p, 0, 4);</b>
<b class="nc"><i>2597</i>&nbsp;            xform.inverseTransform(p, 0, p, 0, 4);</b>
<i>2598</i>&nbsp;
<i>2599</i>&nbsp;            // Determine a bounding box for the inverse transformed region
<i>2600</i>&nbsp;            double x0,x1,y0,y1;
<b class="nc"><i>2601</i>&nbsp;            x0 = x1 = p[0];</b>
<b class="nc"><i>2602</i>&nbsp;            y0 = y1 = p[1];</b>
<i>2603</i>&nbsp;
<b class="nc"><i>2604</i>&nbsp;            for (int i = 2; i &lt; 8; ) {</b>
<b class="nc"><i>2605</i>&nbsp;                double pt = p[i++];</b>
<b class="nc"><i>2606</i>&nbsp;                if (pt &lt; x0)  {</b>
<b class="nc"><i>2607</i>&nbsp;                    x0 = pt;</b>
<b class="nc"><i>2608</i>&nbsp;                } else if (pt &gt; x1) {</b>
<b class="nc"><i>2609</i>&nbsp;                    x1 = pt;</b>
<i>2610</i>&nbsp;                }
<b class="nc"><i>2611</i>&nbsp;                pt = p[i++];</b>
<b class="nc"><i>2612</i>&nbsp;                if (pt &lt; y0)  {</b>
<b class="nc"><i>2613</i>&nbsp;                    y0 = pt;</b>
<b class="nc"><i>2614</i>&nbsp;                } else if (pt &gt; y1) {</b>
<b class="nc"><i>2615</i>&nbsp;                    y1 = pt;</b>
<i>2616</i>&nbsp;                }
<b class="nc"><i>2617</i>&nbsp;            }</b>
<i>2618</i>&nbsp;
<i>2619</i>&nbsp;            // This is padding for anti-aliasing and such.  It may
<i>2620</i>&nbsp;            // be more than is needed.
<b class="nc"><i>2621</i>&nbsp;            int x = (int)x0 - padX;</b>
<b class="nc"><i>2622</i>&nbsp;            int w = (int)(x1 - x0 + 2*padX);</b>
<b class="nc"><i>2623</i>&nbsp;            int y = (int)y0 - padY;</b>
<b class="nc"><i>2624</i>&nbsp;            int h = (int)(y1 - y0 + 2*padY);</b>
<i>2625</i>&nbsp;
<b class="nc"><i>2626</i>&nbsp;            Rectangle clipRect = new Rectangle(x,y,w,h);</b>
<b class="nc"><i>2627</i>&nbsp;            result = clipRect.intersection(imageRect);</b>
<b class="nc"><i>2628</i>&nbsp;        } catch (NoninvertibleTransformException nte) {</b>
<i>2629</i>&nbsp;            // Worst case bounds are the bounds of the image.
<b class="nc"><i>2630</i>&nbsp;            result = imageRect;</b>
<b class="nc"><i>2631</i>&nbsp;        }</b>
<i>2632</i>&nbsp;
<b class="nc"><i>2633</i>&nbsp;        return result;</b>
<i>2634</i>&nbsp;    }
<i>2635</i>&nbsp;
<i>2636</i>&nbsp;    /**
<i>2637</i>&nbsp;     * Draws an image, applying a transform from image space into user space
<i>2638</i>&nbsp;     * before drawing.
<i>2639</i>&nbsp;     * The transformation from user space into device space is done with
<i>2640</i>&nbsp;     * the current transform in the Graphics2D.
<i>2641</i>&nbsp;     * The given transformation is applied to the image before the
<i>2642</i>&nbsp;     * transform attribute in the Graphics2D state is applied.
<i>2643</i>&nbsp;     * The rendering attributes applied include the clip, transform,
<i>2644</i>&nbsp;     * and composite attributes. Note that the result is
<i>2645</i>&nbsp;     * undefined, if the given transform is noninvertible.
<i>2646</i>&nbsp;     * @param img The image to be drawn. Does nothing if img is null.
<i>2647</i>&nbsp;     * @param xform The transformation from image space into user space.
<i>2648</i>&nbsp;     * @see #transform
<i>2649</i>&nbsp;     * @see #setTransform
<i>2650</i>&nbsp;     * @see #setComposite
<i>2651</i>&nbsp;     * @see #clip
<i>2652</i>&nbsp;     * @see #setClip
<i>2653</i>&nbsp;     */
<i>2654</i>&nbsp;    public void drawRenderedImage(RenderedImage img,
<i>2655</i>&nbsp;                                  AffineTransform xform) {
<i>2656</i>&nbsp;
<b class="nc"><i>2657</i>&nbsp;        if (img == null) {</b>
<i>2658</i>&nbsp;            return;
<i>2659</i>&nbsp;        }
<i>2660</i>&nbsp;
<i>2661</i>&nbsp;        // BufferedImage case: use a simple drawImage call
<b class="nc"><i>2662</i>&nbsp;        if (img instanceof BufferedImage) {</b>
<b class="nc"><i>2663</i>&nbsp;            BufferedImage bufImg = (BufferedImage)img;</b>
<b class="nc"><i>2664</i>&nbsp;            drawImage(bufImg,xform,null);</b>
<i>2665</i>&nbsp;            return;
<i>2666</i>&nbsp;        }
<i>2667</i>&nbsp;
<i>2668</i>&nbsp;        // transformState tracks the state of transform and
<i>2669</i>&nbsp;        // transX, transY contain the integer casts of the
<i>2670</i>&nbsp;        // translation factors
<b class="nc"><i>2671</i>&nbsp;        boolean isIntegerTranslate =</b>
<i>2672</i>&nbsp;            (transformState &lt;= TRANSFORM_INT_TRANSLATE) &amp;&amp;
<b class="nc"><i>2673</i>&nbsp;            isIntegerTranslation(xform);</b>
<i>2674</i>&nbsp;
<i>2675</i>&nbsp;        // Include padding for interpolation/antialiasing if necessary
<b class="nc"><i>2676</i>&nbsp;        int pad = isIntegerTranslate ? 0 : 3;</b>
<i>2677</i>&nbsp;
<i>2678</i>&nbsp;        Region clip;
<i>2679</i>&nbsp;        try {
<b class="nc"><i>2680</i>&nbsp;            clip = getCompClip();</b>
<b class="nc"><i>2681</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2682</i>&nbsp;            return;
<b class="nc"><i>2683</i>&nbsp;        }</b>
<i>2684</i>&nbsp;
<i>2685</i>&nbsp;        // Determine the region of the image that may contribute to
<i>2686</i>&nbsp;        // the clipped drawing area
<b class="nc"><i>2687</i>&nbsp;        Rectangle region = getImageRegion(img,</b>
<i>2688</i>&nbsp;                                          clip,
<i>2689</i>&nbsp;                                          transform,
<i>2690</i>&nbsp;                                          xform,
<i>2691</i>&nbsp;                                          pad, pad);
<b class="nc"><i>2692</i>&nbsp;        if (region.width &lt;= 0 || region.height &lt;= 0) {</b>
<i>2693</i>&nbsp;            return;
<i>2694</i>&nbsp;        }
<i>2695</i>&nbsp;
<i>2696</i>&nbsp;        // Attempt to optimize integer translation of tiled images.
<i>2697</i>&nbsp;        // Although theoretically we are O.K. if the concatenation of
<i>2698</i>&nbsp;        // the user transform and the device transform is an integer
<i>2699</i>&nbsp;        // translation, we&#39;ll play it safe and only optimize the case
<i>2700</i>&nbsp;        // where both are integer translations.
<b class="nc"><i>2701</i>&nbsp;        if (isIntegerTranslate) {</b>
<i>2702</i>&nbsp;            // Use optimized code
<i>2703</i>&nbsp;            // Note that drawTranslatedRenderedImage calls copyImage
<i>2704</i>&nbsp;            // which takes the user space to device space transform into
<i>2705</i>&nbsp;            // account, but we need to provide the image space to user space
<i>2706</i>&nbsp;            // translations.
<i>2707</i>&nbsp;
<b class="nc"><i>2708</i>&nbsp;            drawTranslatedRenderedImage(img, region,</b>
<b class="nc"><i>2709</i>&nbsp;                                        (int) xform.getTranslateX(),</b>
<b class="nc"><i>2710</i>&nbsp;                                        (int) xform.getTranslateY());</b>
<i>2711</i>&nbsp;            return;
<i>2712</i>&nbsp;        }
<i>2713</i>&nbsp;
<i>2714</i>&nbsp;        // General case: cobble the necessary region into a single Raster
<b class="nc"><i>2715</i>&nbsp;        Raster raster = img.getData(region);</b>
<i>2716</i>&nbsp;
<i>2717</i>&nbsp;        // Make a new Raster with the same contents as raster
<i>2718</i>&nbsp;        // but starting at (0, 0).  This raster is thus in the same
<i>2719</i>&nbsp;        // coordinate system as the SampleModel of the original raster.
<b class="nc"><i>2720</i>&nbsp;        WritableRaster wRaster =</b>
<b class="nc"><i>2721</i>&nbsp;              Raster.createWritableRaster(raster.getSampleModel(),</b>
<b class="nc"><i>2722</i>&nbsp;                                          raster.getDataBuffer(),</b>
<i>2723</i>&nbsp;                                          null);
<i>2724</i>&nbsp;
<i>2725</i>&nbsp;        // If the original raster was in a different coordinate
<i>2726</i>&nbsp;        // system than its SampleModel, we need to perform an
<i>2727</i>&nbsp;        // additional translation in order to get the (minX, minY)
<i>2728</i>&nbsp;        // pixel of raster to be pixel (0, 0) of wRaster.  We also
<i>2729</i>&nbsp;        // have to have the correct width and height.
<b class="nc"><i>2730</i>&nbsp;        int minX = raster.getMinX();</b>
<b class="nc"><i>2731</i>&nbsp;        int minY = raster.getMinY();</b>
<b class="nc"><i>2732</i>&nbsp;        int width = raster.getWidth();</b>
<b class="nc"><i>2733</i>&nbsp;        int height = raster.getHeight();</b>
<b class="nc"><i>2734</i>&nbsp;        int px = minX - raster.getSampleModelTranslateX();</b>
<b class="nc"><i>2735</i>&nbsp;        int py = minY - raster.getSampleModelTranslateY();</b>
<b class="nc"><i>2736</i>&nbsp;        if (px != 0 || py != 0 || width != wRaster.getWidth() ||</b>
<b class="nc"><i>2737</i>&nbsp;            height != wRaster.getHeight()) {</b>
<b class="nc"><i>2738</i>&nbsp;            wRaster =</b>
<b class="nc"><i>2739</i>&nbsp;                wRaster.createWritableChild(px,</b>
<i>2740</i>&nbsp;                                            py,
<i>2741</i>&nbsp;                                            width,
<i>2742</i>&nbsp;                                            height,
<i>2743</i>&nbsp;                                            0, 0,
<i>2744</i>&nbsp;                                            null);
<i>2745</i>&nbsp;        }
<i>2746</i>&nbsp;
<i>2747</i>&nbsp;        // Now we have a BufferedImage starting at (0, 0)
<i>2748</i>&nbsp;        // with the same contents that started at (minX, minY)
<i>2749</i>&nbsp;        // in raster.  So we must draw the BufferedImage with a
<i>2750</i>&nbsp;        // translation of (minX, minY).
<b class="nc"><i>2751</i>&nbsp;        AffineTransform transXform = (AffineTransform)xform.clone();</b>
<b class="nc"><i>2752</i>&nbsp;        transXform.translate(minX, minY);</b>
<i>2753</i>&nbsp;
<b class="nc"><i>2754</i>&nbsp;        ColorModel cm = img.getColorModel();</b>
<b class="nc"><i>2755</i>&nbsp;        BufferedImage bufImg = new BufferedImage(cm,</b>
<i>2756</i>&nbsp;                                                 wRaster,
<b class="nc"><i>2757</i>&nbsp;                                                 cm.isAlphaPremultiplied(),</b>
<i>2758</i>&nbsp;                                                 null);
<b class="nc"><i>2759</i>&nbsp;        drawImage(bufImg, transXform, null);</b>
<i>2760</i>&nbsp;    }
<i>2761</i>&nbsp;
<i>2762</i>&nbsp;    /**
<i>2763</i>&nbsp;     * Intersects {@code destRect} with {@code clip} and
<i>2764</i>&nbsp;     * overwrites {@code destRect} with the result.
<i>2765</i>&nbsp;     * Returns false if the intersection was empty, true otherwise.
<i>2766</i>&nbsp;     */
<i>2767</i>&nbsp;    private boolean clipTo(Rectangle destRect, Rectangle clip) {
<b class="nc"><i>2768</i>&nbsp;        int x1 = Math.max(destRect.x, clip.x);</b>
<b class="nc"><i>2769</i>&nbsp;        int x2 = Math.min(destRect.x + destRect.width, clip.x + clip.width);</b>
<b class="nc"><i>2770</i>&nbsp;        int y1 = Math.max(destRect.y, clip.y);</b>
<b class="nc"><i>2771</i>&nbsp;        int y2 = Math.min(destRect.y + destRect.height, clip.y + clip.height);</b>
<b class="nc"><i>2772</i>&nbsp;        if (((x2 - x1) &lt; 0) || ((y2 - y1) &lt; 0)) {</b>
<b class="nc"><i>2773</i>&nbsp;            destRect.width = -1; // Set both just to be safe</b>
<b class="nc"><i>2774</i>&nbsp;            destRect.height = -1;</b>
<b class="nc"><i>2775</i>&nbsp;            return false;</b>
<i>2776</i>&nbsp;        } else {
<b class="nc"><i>2777</i>&nbsp;            destRect.x = x1;</b>
<b class="nc"><i>2778</i>&nbsp;            destRect.y = y1;</b>
<b class="nc"><i>2779</i>&nbsp;            destRect.width = x2 - x1;</b>
<b class="nc"><i>2780</i>&nbsp;            destRect.height = y2 - y1;</b>
<b class="nc"><i>2781</i>&nbsp;            return true;</b>
<i>2782</i>&nbsp;        }
<i>2783</i>&nbsp;    }
<i>2784</i>&nbsp;
<i>2785</i>&nbsp;    /**
<i>2786</i>&nbsp;     * Draw a portion of a RenderedImage tile-by-tile with a given
<i>2787</i>&nbsp;     * integer image to user space translation.  The user to
<i>2788</i>&nbsp;     * device transform must also be an integer translation.
<i>2789</i>&nbsp;     */
<i>2790</i>&nbsp;    private void drawTranslatedRenderedImage(RenderedImage img,
<i>2791</i>&nbsp;                                             Rectangle region,
<i>2792</i>&nbsp;                                             int i2uTransX,
<i>2793</i>&nbsp;                                             int i2uTransY) {
<i>2794</i>&nbsp;        // Cache tile grid info
<b class="nc"><i>2795</i>&nbsp;        int tileGridXOffset = img.getTileGridXOffset();</b>
<b class="nc"><i>2796</i>&nbsp;        int tileGridYOffset = img.getTileGridYOffset();</b>
<b class="nc"><i>2797</i>&nbsp;        int tileWidth = img.getTileWidth();</b>
<b class="nc"><i>2798</i>&nbsp;        int tileHeight = img.getTileHeight();</b>
<i>2799</i>&nbsp;
<i>2800</i>&nbsp;        // Determine the tile index extrema in each direction
<b class="nc"><i>2801</i>&nbsp;        int minTileX =</b>
<b class="nc"><i>2802</i>&nbsp;            getTileIndex(region.x, tileGridXOffset, tileWidth);</b>
<b class="nc"><i>2803</i>&nbsp;        int minTileY =</b>
<b class="nc"><i>2804</i>&nbsp;            getTileIndex(region.y, tileGridYOffset, tileHeight);</b>
<b class="nc"><i>2805</i>&nbsp;        int maxTileX =</b>
<b class="nc"><i>2806</i>&nbsp;            getTileIndex(region.x + region.width - 1,</b>
<i>2807</i>&nbsp;                         tileGridXOffset, tileWidth);
<b class="nc"><i>2808</i>&nbsp;        int maxTileY =</b>
<b class="nc"><i>2809</i>&nbsp;            getTileIndex(region.y + region.height - 1,</b>
<i>2810</i>&nbsp;                         tileGridYOffset, tileHeight);
<i>2811</i>&nbsp;
<i>2812</i>&nbsp;        // Create a single ColorModel to use for all BufferedImages
<b class="nc"><i>2813</i>&nbsp;        ColorModel colorModel = img.getColorModel();</b>
<i>2814</i>&nbsp;
<i>2815</i>&nbsp;        // Reuse the same Rectangle for each iteration
<b class="nc"><i>2816</i>&nbsp;        Rectangle tileRect = new Rectangle();</b>
<i>2817</i>&nbsp;
<b class="nc"><i>2818</i>&nbsp;        for (int ty = minTileY; ty &lt;= maxTileY; ty++) {</b>
<b class="nc"><i>2819</i>&nbsp;            for (int tx = minTileX; tx &lt;= maxTileX; tx++) {</b>
<i>2820</i>&nbsp;                // Get the current tile.
<b class="nc"><i>2821</i>&nbsp;                Raster raster = img.getTile(tx, ty);</b>
<i>2822</i>&nbsp;
<i>2823</i>&nbsp;                // Fill in tileRect with the tile bounds
<b class="nc"><i>2824</i>&nbsp;                tileRect.x = tx*tileWidth + tileGridXOffset;</b>
<b class="nc"><i>2825</i>&nbsp;                tileRect.y = ty*tileHeight + tileGridYOffset;</b>
<b class="nc"><i>2826</i>&nbsp;                tileRect.width = tileWidth;</b>
<b class="nc"><i>2827</i>&nbsp;                tileRect.height = tileHeight;</b>
<i>2828</i>&nbsp;
<i>2829</i>&nbsp;                // Clip the tile against the image bounds and
<i>2830</i>&nbsp;                // backwards mapped clip region
<i>2831</i>&nbsp;                // The result can&#39;t be empty
<b class="nc"><i>2832</i>&nbsp;                clipTo(tileRect, region);</b>
<i>2833</i>&nbsp;
<i>2834</i>&nbsp;                // Create a WritableRaster containing the tile
<b class="nc"><i>2835</i>&nbsp;                WritableRaster wRaster = null;</b>
<b class="nc"><i>2836</i>&nbsp;                if (raster instanceof WritableRaster) {</b>
<b class="nc"><i>2837</i>&nbsp;                    wRaster = (WritableRaster)raster;</b>
<i>2838</i>&nbsp;                } else {
<i>2839</i>&nbsp;                    // Create a WritableRaster in the same coordinate system
<i>2840</i>&nbsp;                    // as the original raster.
<b class="nc"><i>2841</i>&nbsp;                    wRaster =</b>
<b class="nc"><i>2842</i>&nbsp;                        Raster.createWritableRaster(raster.getSampleModel(),</b>
<b class="nc"><i>2843</i>&nbsp;                                                    raster.getDataBuffer(),</b>
<i>2844</i>&nbsp;                                                    null);
<i>2845</i>&nbsp;                }
<i>2846</i>&nbsp;
<i>2847</i>&nbsp;                // Translate wRaster to start at (0, 0) and to contain
<i>2848</i>&nbsp;                // only the relevent portion of the tile
<b class="nc"><i>2849</i>&nbsp;                wRaster = wRaster.createWritableChild(tileRect.x, tileRect.y,</b>
<i>2850</i>&nbsp;                                                      tileRect.width,
<i>2851</i>&nbsp;                                                      tileRect.height,
<i>2852</i>&nbsp;                                                      0, 0,
<i>2853</i>&nbsp;                                                      null);
<i>2854</i>&nbsp;
<i>2855</i>&nbsp;                // Wrap wRaster in a BufferedImage
<b class="nc"><i>2856</i>&nbsp;                BufferedImage bufImg =</b>
<i>2857</i>&nbsp;                    new BufferedImage(colorModel,
<i>2858</i>&nbsp;                                      wRaster,
<b class="nc"><i>2859</i>&nbsp;                                      colorModel.isAlphaPremultiplied(),</b>
<i>2860</i>&nbsp;                                      null);
<i>2861</i>&nbsp;                // Now we have a BufferedImage starting at (0, 0) that
<i>2862</i>&nbsp;                // represents data from a Raster starting at
<i>2863</i>&nbsp;                // (tileRect.x, tileRect.y).  Additionally, it needs
<i>2864</i>&nbsp;                // to be translated by (i2uTransX, i2uTransY).  We call
<i>2865</i>&nbsp;                // copyImage to draw just the region of interest
<i>2866</i>&nbsp;                // without needing to create a child image.
<b class="nc"><i>2867</i>&nbsp;                copyImage(bufImg, tileRect.x + i2uTransX,</b>
<i>2868</i>&nbsp;                          tileRect.y + i2uTransY, 0, 0, tileRect.width,
<i>2869</i>&nbsp;                          tileRect.height, null, null);
<i>2870</i>&nbsp;            }
<i>2871</i>&nbsp;        }
<i>2872</i>&nbsp;    }
<i>2873</i>&nbsp;
<i>2874</i>&nbsp;    public void drawRenderableImage(RenderableImage img,
<i>2875</i>&nbsp;                                    AffineTransform xform) {
<i>2876</i>&nbsp;
<b class="nc"><i>2877</i>&nbsp;        if (img == null) {</b>
<i>2878</i>&nbsp;            return;
<i>2879</i>&nbsp;        }
<i>2880</i>&nbsp;
<b class="nc"><i>2881</i>&nbsp;        AffineTransform pipeTransform = transform;</b>
<b class="nc"><i>2882</i>&nbsp;        AffineTransform concatTransform = new AffineTransform(xform);</b>
<b class="nc"><i>2883</i>&nbsp;        concatTransform.concatenate(pipeTransform);</b>
<i>2884</i>&nbsp;        AffineTransform reverseTransform;
<i>2885</i>&nbsp;
<b class="nc"><i>2886</i>&nbsp;        RenderContext rc = new RenderContext(concatTransform);</b>
<i>2887</i>&nbsp;
<i>2888</i>&nbsp;        try {
<b class="nc"><i>2889</i>&nbsp;            reverseTransform = pipeTransform.createInverse();</b>
<b class="nc"><i>2890</i>&nbsp;        } catch (NoninvertibleTransformException nte) {</b>
<b class="nc"><i>2891</i>&nbsp;            rc = new RenderContext(pipeTransform);</b>
<b class="nc"><i>2892</i>&nbsp;            reverseTransform = new AffineTransform();</b>
<b class="nc"><i>2893</i>&nbsp;        }</b>
<i>2894</i>&nbsp;
<b class="nc"><i>2895</i>&nbsp;        RenderedImage rendering = img.createRendering(rc);</b>
<b class="nc"><i>2896</i>&nbsp;        drawRenderedImage(rendering,reverseTransform);</b>
<i>2897</i>&nbsp;    }
<i>2898</i>&nbsp;
<i>2899</i>&nbsp;
<i>2900</i>&nbsp;
<i>2901</i>&nbsp;    /*
<i>2902</i>&nbsp;     * Transform the bounding box of the BufferedImage
<i>2903</i>&nbsp;     */
<i>2904</i>&nbsp;    protected Rectangle transformBounds(Rectangle rect,
<i>2905</i>&nbsp;                                        AffineTransform tx) {
<b class="nc"><i>2906</i>&nbsp;        if (tx.isIdentity()) {</b>
<b class="nc"><i>2907</i>&nbsp;            return rect;</b>
<i>2908</i>&nbsp;        }
<i>2909</i>&nbsp;
<b class="nc"><i>2910</i>&nbsp;        Shape s = transformShape(tx, rect);</b>
<b class="nc"><i>2911</i>&nbsp;        return s.getBounds();</b>
<i>2912</i>&nbsp;    }
<i>2913</i>&nbsp;
<i>2914</i>&nbsp;    // text rendering methods
<i>2915</i>&nbsp;    public void drawString(String str, int x, int y) {
<b class="nc"><i>2916</i>&nbsp;        if (str == null) {</b>
<b class="nc"><i>2917</i>&nbsp;            throw new NullPointerException(&quot;String is null&quot;);</b>
<i>2918</i>&nbsp;        }
<i>2919</i>&nbsp;
<b class="nc"><i>2920</i>&nbsp;        if (font.hasLayoutAttributes()) {</b>
<b class="nc"><i>2921</i>&nbsp;            if (str.length() == 0) {</b>
<i>2922</i>&nbsp;                return;
<i>2923</i>&nbsp;            }
<b class="nc"><i>2924</i>&nbsp;            new TextLayout(str, font, getFontRenderContext()).draw(this, x, y);</b>
<i>2925</i>&nbsp;            return;
<i>2926</i>&nbsp;        }
<i>2927</i>&nbsp;
<i>2928</i>&nbsp;        try {
<b class="nc"><i>2929</i>&nbsp;            textpipe.drawString(this, str, x, y);</b>
<b class="nc"><i>2930</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2931</i>&nbsp;            try {
<b class="nc"><i>2932</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2933</i>&nbsp;                textpipe.drawString(this, str, x, y);</b>
<b class="nc"><i>2934</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2935</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2936</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2937</i>&nbsp;                // try again next time around.
<b class="nc"><i>2938</i>&nbsp;            }</b>
<i>2939</i>&nbsp;        } finally {
<b class="nc"><i>2940</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2941</i>&nbsp;        }</b>
<i>2942</i>&nbsp;    }
<i>2943</i>&nbsp;
<i>2944</i>&nbsp;    public void drawString(String str, float x, float y) {
<b class="nc"><i>2945</i>&nbsp;        if (str == null) {</b>
<b class="nc"><i>2946</i>&nbsp;            throw new NullPointerException(&quot;String is null&quot;);</b>
<i>2947</i>&nbsp;        }
<i>2948</i>&nbsp;
<b class="nc"><i>2949</i>&nbsp;        if (font.hasLayoutAttributes()) {</b>
<b class="nc"><i>2950</i>&nbsp;            if (str.length() == 0) {</b>
<i>2951</i>&nbsp;                return;
<i>2952</i>&nbsp;            }
<b class="nc"><i>2953</i>&nbsp;            new TextLayout(str, font, getFontRenderContext()).draw(this, x, y);</b>
<i>2954</i>&nbsp;            return;
<i>2955</i>&nbsp;        }
<i>2956</i>&nbsp;
<i>2957</i>&nbsp;        try {
<b class="nc"><i>2958</i>&nbsp;            textpipe.drawString(this, str, x, y);</b>
<b class="nc"><i>2959</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>2960</i>&nbsp;            try {
<b class="nc"><i>2961</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>2962</i>&nbsp;                textpipe.drawString(this, str, x, y);</b>
<b class="nc"><i>2963</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>2964</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>2965</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>2966</i>&nbsp;                // try again next time around.
<b class="nc"><i>2967</i>&nbsp;            }</b>
<i>2968</i>&nbsp;        } finally {
<b class="nc"><i>2969</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>2970</i>&nbsp;        }</b>
<i>2971</i>&nbsp;    }
<i>2972</i>&nbsp;
<i>2973</i>&nbsp;    public void drawString(AttributedCharacterIterator iterator,
<i>2974</i>&nbsp;                           int x, int y) {
<b class="nc"><i>2975</i>&nbsp;        if (iterator == null) {</b>
<b class="nc"><i>2976</i>&nbsp;            throw new NullPointerException(&quot;AttributedCharacterIterator is null&quot;);</b>
<i>2977</i>&nbsp;        }
<b class="nc"><i>2978</i>&nbsp;        if (iterator.getBeginIndex() == iterator.getEndIndex()) {</b>
<i>2979</i>&nbsp;            return; /* nothing to draw */
<i>2980</i>&nbsp;        }
<b class="nc"><i>2981</i>&nbsp;        TextLayout tl = new TextLayout(iterator, getFontRenderContext());</b>
<b class="nc"><i>2982</i>&nbsp;        tl.draw(this, (float) x, (float) y);</b>
<i>2983</i>&nbsp;    }
<i>2984</i>&nbsp;
<i>2985</i>&nbsp;    public void drawString(AttributedCharacterIterator iterator,
<i>2986</i>&nbsp;                           float x, float y) {
<b class="nc"><i>2987</i>&nbsp;        if (iterator == null) {</b>
<b class="nc"><i>2988</i>&nbsp;            throw new NullPointerException(&quot;AttributedCharacterIterator is null&quot;);</b>
<i>2989</i>&nbsp;        }
<b class="nc"><i>2990</i>&nbsp;        if (iterator.getBeginIndex() == iterator.getEndIndex()) {</b>
<i>2991</i>&nbsp;            return; /* nothing to draw */
<i>2992</i>&nbsp;        }
<b class="nc"><i>2993</i>&nbsp;        TextLayout tl = new TextLayout(iterator, getFontRenderContext());</b>
<b class="nc"><i>2994</i>&nbsp;        tl.draw(this, x, y);</b>
<i>2995</i>&nbsp;    }
<i>2996</i>&nbsp;
<i>2997</i>&nbsp;    public void drawGlyphVector(GlyphVector gv, float x, float y)
<i>2998</i>&nbsp;    {
<b class="nc"><i>2999</i>&nbsp;        if (gv == null) {</b>
<b class="nc"><i>3000</i>&nbsp;            throw new NullPointerException(&quot;GlyphVector is null&quot;);</b>
<i>3001</i>&nbsp;        }
<i>3002</i>&nbsp;
<i>3003</i>&nbsp;        try {
<b class="nc"><i>3004</i>&nbsp;            textpipe.drawGlyphVector(this, gv, x, y);</b>
<b class="nc"><i>3005</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>3006</i>&nbsp;            try {
<b class="nc"><i>3007</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>3008</i>&nbsp;                textpipe.drawGlyphVector(this, gv, x, y);</b>
<b class="nc"><i>3009</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3010</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3011</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3012</i>&nbsp;                // try again next time around.
<b class="nc"><i>3013</i>&nbsp;            }</b>
<i>3014</i>&nbsp;        } finally {
<b class="nc"><i>3015</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>3016</i>&nbsp;        }</b>
<i>3017</i>&nbsp;    }
<i>3018</i>&nbsp;
<i>3019</i>&nbsp;    public void drawChars(char data[], int offset, int length, int x, int y) {
<i>3020</i>&nbsp;
<b class="nc"><i>3021</i>&nbsp;        if (data == null) {</b>
<b class="nc"><i>3022</i>&nbsp;            throw new NullPointerException(&quot;char data is null&quot;);</b>
<i>3023</i>&nbsp;        }
<b class="nc"><i>3024</i>&nbsp;        if (offset &lt; 0 || length &lt; 0 || offset + length &gt; data.length) {</b>
<b class="nc"><i>3025</i>&nbsp;            throw new ArrayIndexOutOfBoundsException(&quot;bad offset/length&quot;);</b>
<i>3026</i>&nbsp;        }
<b class="nc"><i>3027</i>&nbsp;        if (font.hasLayoutAttributes()) {</b>
<b class="nc"><i>3028</i>&nbsp;            if (data.length == 0) {</b>
<i>3029</i>&nbsp;                return;
<i>3030</i>&nbsp;            }
<b class="nc"><i>3031</i>&nbsp;            new TextLayout(new String(data, offset, length),</b>
<b class="nc"><i>3032</i>&nbsp;                           font, getFontRenderContext()).draw(this, x, y);</b>
<i>3033</i>&nbsp;            return;
<i>3034</i>&nbsp;        }
<i>3035</i>&nbsp;
<i>3036</i>&nbsp;        try {
<b class="nc"><i>3037</i>&nbsp;            textpipe.drawChars(this, data, offset, length, x, y);</b>
<b class="nc"><i>3038</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>3039</i>&nbsp;            try {
<b class="nc"><i>3040</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>3041</i>&nbsp;                textpipe.drawChars(this, data, offset, length, x, y);</b>
<b class="nc"><i>3042</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3043</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3044</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3045</i>&nbsp;                // try again next time around.
<b class="nc"><i>3046</i>&nbsp;            }</b>
<i>3047</i>&nbsp;        } finally {
<b class="nc"><i>3048</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>3049</i>&nbsp;        }</b>
<i>3050</i>&nbsp;    }
<i>3051</i>&nbsp;
<i>3052</i>&nbsp;    public void drawBytes(byte data[], int offset, int length, int x, int y) {
<b class="nc"><i>3053</i>&nbsp;        if (data == null) {</b>
<b class="nc"><i>3054</i>&nbsp;            throw new NullPointerException(&quot;byte data is null&quot;);</b>
<i>3055</i>&nbsp;        }
<b class="nc"><i>3056</i>&nbsp;        if (offset &lt; 0 || length &lt; 0 || offset + length &gt; data.length) {</b>
<b class="nc"><i>3057</i>&nbsp;            throw new ArrayIndexOutOfBoundsException(&quot;bad offset/length&quot;);</b>
<i>3058</i>&nbsp;        }
<i>3059</i>&nbsp;        /* Byte data is interpreted as 8-bit ASCII. Re-use drawChars loops */
<b class="nc"><i>3060</i>&nbsp;        char chData[] = new char[length];</b>
<b class="nc"><i>3061</i>&nbsp;        for (int i = length; i-- &gt; 0; ) {</b>
<b class="nc"><i>3062</i>&nbsp;            chData[i] = (char)(data[i+offset] &amp; 0xff);</b>
<i>3063</i>&nbsp;        }
<b class="nc"><i>3064</i>&nbsp;        if (font.hasLayoutAttributes()) {</b>
<b class="nc"><i>3065</i>&nbsp;            if (data.length == 0) {</b>
<i>3066</i>&nbsp;                return;
<i>3067</i>&nbsp;            }
<b class="nc"><i>3068</i>&nbsp;            new TextLayout(new String(chData),</b>
<b class="nc"><i>3069</i>&nbsp;                           font, getFontRenderContext()).draw(this, x, y);</b>
<i>3070</i>&nbsp;            return;
<i>3071</i>&nbsp;        }
<i>3072</i>&nbsp;
<i>3073</i>&nbsp;        try {
<b class="nc"><i>3074</i>&nbsp;            textpipe.drawChars(this, chData, 0, length, x, y);</b>
<b class="nc"><i>3075</i>&nbsp;        } catch (InvalidPipeException e) {</b>
<i>3076</i>&nbsp;            try {
<b class="nc"><i>3077</i>&nbsp;                revalidateAll();</b>
<b class="nc"><i>3078</i>&nbsp;                textpipe.drawChars(this, chData, 0, length, x, y);</b>
<b class="nc"><i>3079</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3080</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3081</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3082</i>&nbsp;                // try again next time around.
<b class="nc"><i>3083</i>&nbsp;            }</b>
<i>3084</i>&nbsp;        } finally {
<b class="nc"><i>3085</i>&nbsp;            surfaceData.markDirty();</b>
<b class="nc"><i>3086</i>&nbsp;        }</b>
<i>3087</i>&nbsp;    }
<i>3088</i>&nbsp;// end of text rendering methods
<i>3089</i>&nbsp;
<i>3090</i>&nbsp;    private Boolean drawHiDPIImage(Image img,
<i>3091</i>&nbsp;                                   int dx1, int dy1, int dx2, int dy2,
<i>3092</i>&nbsp;                                   int sx1, int sy1, int sx2, int sy2,
<i>3093</i>&nbsp;                                   Color bgcolor, ImageObserver observer,
<i>3094</i>&nbsp;                                   AffineTransform xform) {
<i>3095</i>&nbsp;
<b class="nc"><i>3096</i>&nbsp;        if (img instanceof VolatileImage) {</b>
<b class="nc"><i>3097</i>&nbsp;            final SurfaceData sd = SurfaceManager.getManager(img)</b>
<b class="nc"><i>3098</i>&nbsp;                    .getPrimarySurfaceData();</b>
<b class="nc"><i>3099</i>&nbsp;            final double scaleX = sd.getDefaultScaleX();</b>
<b class="nc"><i>3100</i>&nbsp;            final double scaleY = sd.getDefaultScaleY();</b>
<b class="nc"><i>3101</i>&nbsp;            if (scaleX == 1 &amp;&amp; scaleY == 1) {</b>
<b class="nc"><i>3102</i>&nbsp;                return null;</b>
<i>3103</i>&nbsp;            }
<b class="nc"><i>3104</i>&nbsp;            sx1 = Region.clipRound(sx1 * scaleX);</b>
<b class="nc"><i>3105</i>&nbsp;            sx2 = Region.clipRound(sx2 * scaleX);</b>
<b class="nc"><i>3106</i>&nbsp;            sy1 = Region.clipRound(sy1 * scaleY);</b>
<b class="nc"><i>3107</i>&nbsp;            sy2 = Region.clipRound(sy2 * scaleY);</b>
<i>3108</i>&nbsp;
<b class="nc"><i>3109</i>&nbsp;            AffineTransform tx = null;</b>
<b class="nc"><i>3110</i>&nbsp;            if (xform != null) {</b>
<b class="nc"><i>3111</i>&nbsp;                tx = new AffineTransform(transform);</b>
<b class="nc"><i>3112</i>&nbsp;                transform(xform);</b>
<i>3113</i>&nbsp;            }
<b class="nc"><i>3114</i>&nbsp;            boolean result = scaleImage(img, dx1, dy1, dx2, dy2,</b>
<i>3115</i>&nbsp;                                        sx1, sy1, sx2, sy2,
<i>3116</i>&nbsp;                                        bgcolor, observer);
<b class="nc"><i>3117</i>&nbsp;            if (tx != null) {</b>
<b class="nc"><i>3118</i>&nbsp;                transform.setTransform(tx);</b>
<b class="nc"><i>3119</i>&nbsp;                invalidateTransform();</b>
<i>3120</i>&nbsp;            }
<b class="nc"><i>3121</i>&nbsp;            return result;</b>
<b class="nc"><i>3122</i>&nbsp;        } else if (img instanceof MultiResolutionImage) {</b>
<i>3123</i>&nbsp;            // get scaled destination image size
<i>3124</i>&nbsp;
<i>3125</i>&nbsp;            int width = img.getWidth(observer);
<b class="nc"><i>3126</i>&nbsp;            int height = img.getHeight(observer);</b>
<b class="nc"><i>3127</i>&nbsp;</b>
<i>3128</i>&nbsp;            MultiResolutionImage mrImage = (MultiResolutionImage) img;
<b class="nc"><i>3129</i>&nbsp;            Image resolutionVariant = getResolutionVariant(mrImage, width, height,</b>
<b class="nc"><i>3130</i>&nbsp;                                                           dx1, dy1, dx2, dy2,</b>
<i>3131</i>&nbsp;                                                           sx1, sy1, sx2, sy2,
<i>3132</i>&nbsp;                                                           xform);
<i>3133</i>&nbsp;
<i>3134</i>&nbsp;            if (resolutionVariant != img &amp;&amp; resolutionVariant != null) {
<b class="nc"><i>3135</i>&nbsp;                // recalculate source region for the resolution variant</b>
<i>3136</i>&nbsp;
<i>3137</i>&nbsp;                ImageObserver rvObserver = MultiResolutionToolkitImage.
<b class="nc"><i>3138</i>&nbsp;                        getResolutionVariantObserver(img, observer,</b>
<b class="nc"><i>3139</i>&nbsp;                                width, height, -1, -1);</b>
<i>3140</i>&nbsp;
<i>3141</i>&nbsp;                int rvWidth = resolutionVariant.getWidth(rvObserver);
<b class="nc"><i>3142</i>&nbsp;                int rvHeight = resolutionVariant.getHeight(rvObserver);</b>
<b class="nc"><i>3143</i>&nbsp;</b>
<i>3144</i>&nbsp;                if (0 &lt; width &amp;&amp; 0 &lt; height &amp;&amp; 0 &lt; rvWidth &amp;&amp; 0 &lt; rvHeight) {
<b class="nc"><i>3145</i>&nbsp;</b>
<i>3146</i>&nbsp;                    double widthScale = ((double) rvWidth) / width;
<b class="nc"><i>3147</i>&nbsp;                    double heightScale = ((double) rvHeight) / height;</b>
<b class="nc"><i>3148</i>&nbsp;</b>
<i>3149</i>&nbsp;                    if (resolutionVariant instanceof VolatileImage) {
<b class="nc"><i>3150</i>&nbsp;                        SurfaceData sd = SurfaceManager</b>
<b class="nc"><i>3151</i>&nbsp;                                .getManager(resolutionVariant)</b>
<b class="nc"><i>3152</i>&nbsp;                                .getPrimarySurfaceData();</b>
<b class="nc"><i>3153</i>&nbsp;                        widthScale *= sd.getDefaultScaleX();</b>
<i>3154</i>&nbsp;                        heightScale *= sd.getDefaultScaleY();
<b class="nc"><i>3155</i>&nbsp;                    }</b>
<b class="nc"><i>3156</i>&nbsp;</b>
<i>3157</i>&nbsp;                    sx1 = Region.clipScale(sx1, widthScale);
<b class="nc"><i>3158</i>&nbsp;                    sy1 = Region.clipScale(sy1, heightScale);</b>
<b class="nc"><i>3159</i>&nbsp;                    sx2 = Region.clipScale(sx2, widthScale);</b>
<b class="nc"><i>3160</i>&nbsp;                    sy2 = Region.clipScale(sy2, heightScale);</b>
<b class="nc"><i>3161</i>&nbsp;</b>
<b class="nc"><i>3162</i>&nbsp;                    observer = rvObserver;</b>
<b class="nc"><i>3163</i>&nbsp;                    img = resolutionVariant;</b>
<b class="nc"><i>3164</i>&nbsp;</b>
<i>3165</i>&nbsp;                    if (xform != null) {
<i>3166</i>&nbsp;                        assert dx1 == 0 &amp;&amp; dy1 == 0;
<b class="nc"><i>3167</i>&nbsp;                        assert dx2 == img.getWidth(observer);</b>
<i>3168</i>&nbsp;                        assert dy2 == img.getHeight(observer);
<i>3169</i>&nbsp;                        AffineTransform renderTX = new AffineTransform(xform);
<i>3170</i>&nbsp;                        renderTX.scale(1 / widthScale, 1 / heightScale);
<i>3171</i>&nbsp;                        return transformImage(img, renderTX, observer);
<i>3172</i>&nbsp;                    }
<b class="nc"><i>3173</i>&nbsp;</b>
<i>3174</i>&nbsp;                    return scaleImage(img, dx1, dy1, dx2, dy2,
<i>3175</i>&nbsp;                                      sx1, sy1, sx2, sy2,
<i>3176</i>&nbsp;                                      bgcolor, observer);
<i>3177</i>&nbsp;                }
<i>3178</i>&nbsp;            }
<i>3179</i>&nbsp;        }
<i>3180</i>&nbsp;        return null;
<b class="nc"><i>3181</i>&nbsp;    }</b>
<i>3182</i>&nbsp;
<b class="nc"><i>3183</i>&nbsp;    private boolean scaleImage(Image img, int dx1, int dy1, int dx2, int dy2,</b>
<i>3184</i>&nbsp;                               int sx1, int sy1, int sx2, int sy2,
<b class="nc"><i>3185</i>&nbsp;                               Color bgcolor, ImageObserver observer)</b>
<b class="nc"><i>3186</i>&nbsp;    {</b>
<i>3187</i>&nbsp;        try {
<b class="nc"><i>3188</i>&nbsp;            return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2, sx1, sy1,</b>
<i>3189</i>&nbsp;                                        sx2, sy2, bgcolor, observer);
<i>3190</i>&nbsp;        } catch (InvalidPipeException e) {
<i>3191</i>&nbsp;            try {
<b class="nc"><i>3192</i>&nbsp;                revalidateAll();</b>
<i>3193</i>&nbsp;                return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2, sx1,
<i>3194</i>&nbsp;                                            sy1, sx2, sy2, bgcolor, observer);
<b class="nc"><i>3195</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3196</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3197</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3198</i>&nbsp;                // try again next time around.
<i>3199</i>&nbsp;                return false;
<i>3200</i>&nbsp;            }
<i>3201</i>&nbsp;        } finally {
<i>3202</i>&nbsp;            surfaceData.markDirty();
<i>3203</i>&nbsp;        }
<b class="nc"><i>3204</i>&nbsp;    }</b>
<b class="nc"><i>3205</i>&nbsp;</b>
<i>3206</i>&nbsp;    private boolean transformImage(Image img,
<b class="nc"><i>3207</i>&nbsp;                                   AffineTransform xform,</b>
<b class="nc"><i>3208</i>&nbsp;                                   ImageObserver observer)</b>
<b class="nc"><i>3209</i>&nbsp;    {</b>
<i>3210</i>&nbsp;        try {
<i>3211</i>&nbsp;            return imagepipe.transformImage(this, img, xform, observer);
<i>3212</i>&nbsp;        } catch (InvalidPipeException e) {
<b class="nc"><i>3213</i>&nbsp;            try {</b>
<i>3214</i>&nbsp;                revalidateAll();
<i>3215</i>&nbsp;                return imagepipe.transformImage(this, img, xform, observer);
<b class="nc"><i>3216</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3217</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3218</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3219</i>&nbsp;                // try again next time around.
<i>3220</i>&nbsp;                return false;
<i>3221</i>&nbsp;            }
<i>3222</i>&nbsp;        } finally {
<i>3223</i>&nbsp;            surfaceData.markDirty();
<b class="nc"><i>3224</i>&nbsp;        }</b>
<b class="nc"><i>3225</i>&nbsp;    }</b>
<i>3226</i>&nbsp;
<i>3227</i>&nbsp;    private Image getResolutionVariant(MultiResolutionImage img,
<b class="nc"><i>3228</i>&nbsp;            int srcWidth, int srcHeight, int dx1, int dy1, int dx2, int dy2,</b>
<b class="nc"><i>3229</i>&nbsp;            int sx1, int sy1, int sx2, int sy2, AffineTransform xform) {</b>
<i>3230</i>&nbsp;
<b class="nc"><i>3231</i>&nbsp;        if (srcWidth &lt;= 0 || srcHeight &lt;= 0) {</b>
<b class="nc"><i>3232</i>&nbsp;            return null;</b>
<i>3233</i>&nbsp;        }
<i>3234</i>&nbsp;
<i>3235</i>&nbsp;        int sw = sx2 - sx1;
<i>3236</i>&nbsp;        int sh = sy2 - sy1;
<b class="nc"><i>3237</i>&nbsp;</b>
<b class="nc"><i>3238</i>&nbsp;        if (sw == 0 || sh == 0) {</b>
<i>3239</i>&nbsp;            return null;
<b class="nc"><i>3240</i>&nbsp;        }</b>
<b class="nc"><i>3241</i>&nbsp;</b>
<i>3242</i>&nbsp;        AffineTransform tx;
<i>3243</i>&nbsp;
<b class="nc"><i>3244</i>&nbsp;        if (xform == null) {</b>
<b class="nc"><i>3245</i>&nbsp;            tx = transform;</b>
<b class="nc"><i>3246</i>&nbsp;        } else {</b>
<i>3247</i>&nbsp;            tx = new AffineTransform(transform);
<i>3248</i>&nbsp;            tx.concatenate(xform);
<i>3249</i>&nbsp;        }
<i>3250</i>&nbsp;
<b class="nc"><i>3251</i>&nbsp;        int type = tx.getType();</b>
<b class="nc"><i>3252</i>&nbsp;        int dw = dx2 - dx1;</b>
<b class="nc"><i>3253</i>&nbsp;        int dh = dy2 - dy1;</b>
<b class="nc"><i>3254</i>&nbsp;</b>
<b class="nc"><i>3255</i>&nbsp;        double destImageWidth;</b>
<b class="nc"><i>3256</i>&nbsp;        double destImageHeight;</b>
<b class="nc"><i>3257</i>&nbsp;</b>
<b class="nc"><i>3258</i>&nbsp;        if (resolutionVariantHint == SunHints.INTVAL_RESOLUTION_VARIANT_BASE) {</b>
<i>3259</i>&nbsp;            destImageWidth = srcWidth;
<b class="nc"><i>3260</i>&nbsp;            destImageHeight = srcHeight;</b>
<b class="nc"><i>3261</i>&nbsp;        } else if (resolutionVariantHint == SunHints.INTVAL_RESOLUTION_VARIANT_DPI_FIT) {</b>
<i>3262</i>&nbsp;            AffineTransform configTransform = getDefaultTransform();
<b class="nc"><i>3263</i>&nbsp;            if (configTransform.isIdentity()) {</b>
<i>3264</i>&nbsp;                destImageWidth = srcWidth;
<i>3265</i>&nbsp;                destImageHeight = srcHeight;
<i>3266</i>&nbsp;            } else {
<b class="nc"><i>3267</i>&nbsp;                destImageWidth = srcWidth * configTransform.getScaleX();</b>
<b class="nc"><i>3268</i>&nbsp;                destImageHeight = srcHeight * configTransform.getScaleY();</b>
<b class="nc"><i>3269</i>&nbsp;            }</b>
<b class="nc"><i>3270</i>&nbsp;        } else {</b>
<b class="nc"><i>3271</i>&nbsp;            double destRegionWidth;</b>
<b class="nc"><i>3272</i>&nbsp;            double destRegionHeight;</b>
<i>3273</i>&nbsp;
<b class="nc"><i>3274</i>&nbsp;            if ((type &amp; ~(TYPE_TRANSLATION | TYPE_FLIP)) == 0) {</b>
<b class="nc"><i>3275</i>&nbsp;                destRegionWidth = dw;</b>
<b class="nc"><i>3276</i>&nbsp;                destRegionHeight = dh;</b>
<b class="nc"><i>3277</i>&nbsp;            } else if ((type &amp; ~(TYPE_TRANSLATION | TYPE_FLIP | TYPE_MASK_SCALE)) == 0) {</b>
<i>3278</i>&nbsp;                destRegionWidth = dw * tx.getScaleX();
<b class="nc"><i>3279</i>&nbsp;                destRegionHeight = dh * tx.getScaleY();</b>
<b class="nc"><i>3280</i>&nbsp;            } else {</b>
<i>3281</i>&nbsp;                destRegionWidth = dw * Math.hypot(
<i>3282</i>&nbsp;                        tx.getScaleX(), tx.getShearY());
<b class="nc"><i>3283</i>&nbsp;                destRegionHeight = dh * Math.hypot(</b>
<b class="nc"><i>3284</i>&nbsp;                        tx.getShearX(), tx.getScaleY());</b>
<i>3285</i>&nbsp;            }
<b class="nc"><i>3286</i>&nbsp;            destImageWidth = Math.abs(srcWidth * destRegionWidth / sw);</b>
<b class="nc"><i>3287</i>&nbsp;            destImageHeight = Math.abs(srcHeight * destRegionHeight / sh);</b>
<b class="nc"><i>3288</i>&nbsp;        }</b>
<i>3289</i>&nbsp;
<i>3290</i>&nbsp;        Image resolutionVariant
<b class="nc"><i>3291</i>&nbsp;                = img.getResolutionVariant(destImageWidth, destImageHeight);</b>
<i>3292</i>&nbsp;
<i>3293</i>&nbsp;        if (resolutionVariant instanceof ToolkitImage
<i>3294</i>&nbsp;                &amp;&amp; ((ToolkitImage) resolutionVariant).hasError()) {
<i>3295</i>&nbsp;            return null;
<i>3296</i>&nbsp;        }
<i>3297</i>&nbsp;
<i>3298</i>&nbsp;        return resolutionVariant;
<i>3299</i>&nbsp;    }
<b class="nc"><i>3300</i>&nbsp;</b>
<i>3301</i>&nbsp;    /**
<i>3302</i>&nbsp;     * Draws an image scaled to x,y,w,h in nonblocking mode with a
<i>3303</i>&nbsp;     * callback object.
<i>3304</i>&nbsp;     */
<i>3305</i>&nbsp;    public boolean drawImage(Image img, int x, int y, int width, int height,
<i>3306</i>&nbsp;                             ImageObserver observer) {
<i>3307</i>&nbsp;        return drawImage(img, x, y, width, height, null, observer);
<i>3308</i>&nbsp;    }
<i>3309</i>&nbsp;
<i>3310</i>&nbsp;    /**
<i>3311</i>&nbsp;     * Not part of the advertised API but a useful utility method
<i>3312</i>&nbsp;     * to call internally.  This is for the case where we are
<i>3313</i>&nbsp;     * drawing to/from given coordinates using a given width/height,
<i>3314</i>&nbsp;     * but we guarantee that the surfaceData&#39;s width/height of the src and dest
<b class="nc"><i>3315</i>&nbsp;     * areas are equal (no scale needed). Note that this method intentionally</b>
<i>3316</i>&nbsp;     * ignore scale factor of the source image, and copy it as is.
<b class="nc"><i>3317</i>&nbsp;     */</b>
<i>3318</i>&nbsp;    public boolean copyImage(Image img, int dx, int dy, int sx, int sy,
<b class="nc"><i>3319</i>&nbsp;                             int width, int height, Color bgcolor,</b>
<b class="nc"><i>3320</i>&nbsp;                             ImageObserver observer) {</b>
<i>3321</i>&nbsp;        try {
<b class="nc"><i>3322</i>&nbsp;            return imagepipe.copyImage(this, img, dx, dy, sx, sy,</b>
<i>3323</i>&nbsp;                                       width, height, bgcolor, observer);
<i>3324</i>&nbsp;        } catch (InvalidPipeException e) {
<i>3325</i>&nbsp;            try {
<b class="nc"><i>3326</i>&nbsp;                revalidateAll();</b>
<i>3327</i>&nbsp;                return imagepipe.copyImage(this, img, dx, dy, sx, sy,
<i>3328</i>&nbsp;                                           width, height, bgcolor, observer);
<b class="nc"><i>3329</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3330</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3331</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3332</i>&nbsp;                // try again next time around.
<i>3333</i>&nbsp;                return false;
<i>3334</i>&nbsp;            }
<i>3335</i>&nbsp;        } finally {
<i>3336</i>&nbsp;            surfaceData.markDirty();
<i>3337</i>&nbsp;        }
<i>3338</i>&nbsp;    }
<i>3339</i>&nbsp;
<b class="nc"><i>3340</i>&nbsp;    /**</b>
<b class="nc"><i>3341</i>&nbsp;     * Draws an image scaled to x,y,w,h in nonblocking mode with a</b>
<i>3342</i>&nbsp;     * solid background color and a callback object.
<i>3343</i>&nbsp;     */
<b class="nc"><i>3344</i>&nbsp;    public boolean drawImage(Image img, int x, int y, int width, int height,</b>
<b class="nc"><i>3345</i>&nbsp;                             Color bg, ImageObserver observer) {</b>
<i>3346</i>&nbsp;
<i>3347</i>&nbsp;        if (img == null) {
<b class="nc"><i>3348</i>&nbsp;            return true;</b>
<b class="nc"><i>3349</i>&nbsp;        }</b>
<b class="nc"><i>3350</i>&nbsp;</b>
<i>3351</i>&nbsp;        if ((width == 0) || (height == 0)) {
<i>3352</i>&nbsp;            return true;
<b class="nc"><i>3353</i>&nbsp;        }</b>
<b class="nc"><i>3354</i>&nbsp;</b>
<i>3355</i>&nbsp;        final int imgW = img.getWidth(null);
<i>3356</i>&nbsp;        final int imgH = img.getHeight(null);
<b class="nc"><i>3357</i>&nbsp;        Boolean hidpiImageDrawn = drawHiDPIImage(img, x, y, x + width, y + height,</b>
<b class="nc"><i>3358</i>&nbsp;                                                 0, 0, imgW, imgH, bg, observer,</b>
<i>3359</i>&nbsp;                                                 null);
<i>3360</i>&nbsp;        if (hidpiImageDrawn != null) {
<i>3361</i>&nbsp;            return hidpiImageDrawn;
<b class="nc"><i>3362</i>&nbsp;        }</b>
<i>3363</i>&nbsp;
<b class="nc"><i>3364</i>&nbsp;        if (width == imgW &amp;&amp; height == imgH) {</b>
<i>3365</i>&nbsp;            return copyImage(img, x, y, 0, 0, width, height, bg, observer);
<b class="nc"><i>3366</i>&nbsp;        }</b>
<b class="nc"><i>3367</i>&nbsp;</b>
<i>3368</i>&nbsp;        try {
<b class="nc"><i>3369</i>&nbsp;            return imagepipe.scaleImage(this, img, x, y, width, height,</b>
<i>3370</i>&nbsp;                                        bg, observer);
<i>3371</i>&nbsp;        } catch (InvalidPipeException e) {
<i>3372</i>&nbsp;            try {
<b class="nc"><i>3373</i>&nbsp;                revalidateAll();</b>
<i>3374</i>&nbsp;                return imagepipe.scaleImage(this, img, x, y, width, height,
<i>3375</i>&nbsp;                                            bg, observer);
<b class="nc"><i>3376</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3377</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3378</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3379</i>&nbsp;                // try again next time around.
<i>3380</i>&nbsp;                return false;
<i>3381</i>&nbsp;            }
<i>3382</i>&nbsp;        } finally {
<i>3383</i>&nbsp;            surfaceData.markDirty();
<b class="nc"><i>3384</i>&nbsp;        }</b>
<i>3385</i>&nbsp;    }
<i>3386</i>&nbsp;
<i>3387</i>&nbsp;    /**
<i>3388</i>&nbsp;     * Draws an image at x,y in nonblocking mode.
<i>3389</i>&nbsp;     */
<i>3390</i>&nbsp;    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
<i>3391</i>&nbsp;        return drawImage(img, x, y, null, observer);
<i>3392</i>&nbsp;    }
<i>3393</i>&nbsp;
<b class="nc"><i>3394</i>&nbsp;    /**</b>
<b class="nc"><i>3395</i>&nbsp;     * Draws an image at x,y in nonblocking mode with a solid background</b>
<i>3396</i>&nbsp;     * color and a callback object.
<i>3397</i>&nbsp;     */
<b class="nc"><i>3398</i>&nbsp;    public boolean drawImage(Image img, int x, int y, Color bg,</b>
<b class="nc"><i>3399</i>&nbsp;                             ImageObserver observer) {</b>
<b class="nc"><i>3400</i>&nbsp;</b>
<i>3401</i>&nbsp;        if (img == null) {
<i>3402</i>&nbsp;            return true;
<b class="nc"><i>3403</i>&nbsp;        }</b>
<b class="nc"><i>3404</i>&nbsp;</b>
<i>3405</i>&nbsp;        final int imgW = img.getWidth(null);
<i>3406</i>&nbsp;        final int imgH = img.getHeight(null);
<i>3407</i>&nbsp;        Boolean hidpiImageDrawn = drawHiDPIImage(img, x, y, x + imgW, y + imgH,
<b class="nc"><i>3408</i>&nbsp;                                                 0, 0, imgW, imgH, bg, observer,</b>
<b class="nc"><i>3409</i>&nbsp;                                                 null);</b>
<i>3410</i>&nbsp;        if (hidpiImageDrawn != null) {
<b class="nc"><i>3411</i>&nbsp;            return hidpiImageDrawn;</b>
<b class="nc"><i>3412</i>&nbsp;        }</b>
<b class="nc"><i>3413</i>&nbsp;</b>
<i>3414</i>&nbsp;        try {
<i>3415</i>&nbsp;            return imagepipe.copyImage(this, img, x, y, bg, observer);
<i>3416</i>&nbsp;        } catch (InvalidPipeException e) {
<b class="nc"><i>3417</i>&nbsp;            try {</b>
<i>3418</i>&nbsp;                revalidateAll();
<i>3419</i>&nbsp;                return imagepipe.copyImage(this, img, x, y, bg, observer);
<b class="nc"><i>3420</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3421</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3422</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3423</i>&nbsp;                // try again next time around.
<i>3424</i>&nbsp;                return false;
<i>3425</i>&nbsp;            }
<i>3426</i>&nbsp;        } finally {
<i>3427</i>&nbsp;            surfaceData.markDirty();
<i>3428</i>&nbsp;        }
<i>3429</i>&nbsp;    }
<i>3430</i>&nbsp;
<i>3431</i>&nbsp;    /**
<b class="nc"><i>3432</i>&nbsp;     * Draws a subrectangle of an image scaled to a destination rectangle</b>
<i>3433</i>&nbsp;     * in nonblocking mode with a callback object.
<i>3434</i>&nbsp;     */
<i>3435</i>&nbsp;    public boolean drawImage(Image img,
<i>3436</i>&nbsp;                             int dx1, int dy1, int dx2, int dy2,
<i>3437</i>&nbsp;                             int sx1, int sy1, int sx2, int sy2,
<i>3438</i>&nbsp;                             ImageObserver observer) {
<i>3439</i>&nbsp;        return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null,
<i>3440</i>&nbsp;                         observer);
<i>3441</i>&nbsp;    }
<i>3442</i>&nbsp;
<i>3443</i>&nbsp;    /**
<i>3444</i>&nbsp;     * Draws a subrectangle of an image scaled to a destination rectangle in
<b class="nc"><i>3445</i>&nbsp;     * nonblocking mode with a solid background color and a callback object.</b>
<b class="nc"><i>3446</i>&nbsp;     */</b>
<i>3447</i>&nbsp;    public boolean drawImage(Image img,
<i>3448</i>&nbsp;                             int dx1, int dy1, int dx2, int dy2,
<b class="nc"><i>3449</i>&nbsp;                             int sx1, int sy1, int sx2, int sy2,</b>
<i>3450</i>&nbsp;                             Color bgcolor, ImageObserver observer) {
<i>3451</i>&nbsp;
<b class="nc"><i>3452</i>&nbsp;        if (img == null) {</b>
<i>3453</i>&nbsp;            return true;
<i>3454</i>&nbsp;        }
<b class="nc"><i>3455</i>&nbsp;</b>
<i>3456</i>&nbsp;        if (dx1 == dx2 || dy1 == dy2 ||
<i>3457</i>&nbsp;            sx1 == sx2 || sy1 == sy2)
<i>3458</i>&nbsp;        {
<b class="nc"><i>3459</i>&nbsp;            return true;</b>
<b class="nc"><i>3460</i>&nbsp;        }</b>
<i>3461</i>&nbsp;
<i>3462</i>&nbsp;        Boolean hidpiImageDrawn = drawHiDPIImage(img, dx1, dy1, dx2, dy2,
<b class="nc"><i>3463</i>&nbsp;                                                 sx1, sy1, sx2, sy2,</b>
<i>3464</i>&nbsp;                                                 bgcolor, observer, null);
<i>3465</i>&nbsp;
<i>3466</i>&nbsp;        if (hidpiImageDrawn != null) {
<i>3467</i>&nbsp;            return hidpiImageDrawn;
<b class="nc"><i>3468</i>&nbsp;        }</b>
<b class="nc"><i>3469</i>&nbsp;</b>
<b class="nc"><i>3470</i>&nbsp;        if (((sx2 - sx1) == (dx2 - dx1)) &amp;&amp;</b>
<b class="nc"><i>3471</i>&nbsp;            ((sy2 - sy1) == (dy2 - dy1)))</b>
<i>3472</i>&nbsp;        {
<b class="nc"><i>3473</i>&nbsp;            // Not a scale - forward it to a copy routine</b>
<b class="nc"><i>3474</i>&nbsp;            int srcX, srcY, dstX, dstY, width, height;</b>
<b class="nc"><i>3475</i>&nbsp;            if (sx2 &gt; sx1) {</b>
<i>3476</i>&nbsp;                width = sx2 - sx1;
<b class="nc"><i>3477</i>&nbsp;                srcX = sx1;</b>
<b class="nc"><i>3478</i>&nbsp;                dstX = dx1;</b>
<b class="nc"><i>3479</i>&nbsp;            } else {</b>
<b class="nc"><i>3480</i>&nbsp;                width = sx1 - sx2;</b>
<i>3481</i>&nbsp;                srcX = sx2;
<b class="nc"><i>3482</i>&nbsp;                dstX = dx2;</b>
<b class="nc"><i>3483</i>&nbsp;            }</b>
<b class="nc"><i>3484</i>&nbsp;            if (sy2 &gt; sy1) {</b>
<i>3485</i>&nbsp;                height = sy2-sy1;
<b class="nc"><i>3486</i>&nbsp;                srcY = sy1;</b>
<i>3487</i>&nbsp;                dstY = dy1;
<i>3488</i>&nbsp;            } else {
<i>3489</i>&nbsp;                height = sy1-sy2;
<i>3490</i>&nbsp;                srcY = sy2;
<b class="nc"><i>3491</i>&nbsp;                dstY = dy2;</b>
<i>3492</i>&nbsp;            }
<i>3493</i>&nbsp;            return copyImage(img, dstX, dstY, srcX, srcY,
<b class="nc"><i>3494</i>&nbsp;                             width, height, bgcolor, observer);</b>
<i>3495</i>&nbsp;        }
<b class="nc"><i>3496</i>&nbsp;</b>
<b class="nc"><i>3497</i>&nbsp;        try {</b>
<i>3498</i>&nbsp;            return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2,
<i>3499</i>&nbsp;                                          sx1, sy1, sx2, sy2, bgcolor,
<b class="nc"><i>3500</i>&nbsp;                                          observer);</b>
<i>3501</i>&nbsp;        } catch (InvalidPipeException e) {
<i>3502</i>&nbsp;            try {
<i>3503</i>&nbsp;                revalidateAll();
<b class="nc"><i>3504</i>&nbsp;                return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2,</b>
<i>3505</i>&nbsp;                                              sx1, sy1, sx2, sy2, bgcolor,
<i>3506</i>&nbsp;                                              observer);
<b class="nc"><i>3507</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3508</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3509</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3510</i>&nbsp;                // try again next time around.
<i>3511</i>&nbsp;                return false;
<i>3512</i>&nbsp;            }
<i>3513</i>&nbsp;        } finally {
<i>3514</i>&nbsp;            surfaceData.markDirty();
<i>3515</i>&nbsp;        }
<i>3516</i>&nbsp;    }
<i>3517</i>&nbsp;
<i>3518</i>&nbsp;    /**
<i>3519</i>&nbsp;     * Draw an image, applying a transform from image space into user space
<i>3520</i>&nbsp;     * before drawing.
<i>3521</i>&nbsp;     * The transformation from user space into device space is done with
<i>3522</i>&nbsp;     * the current transform in the Graphics2D.
<i>3523</i>&nbsp;     * The given transformation is applied to the image before the
<i>3524</i>&nbsp;     * transform attribute in the Graphics2D state is applied.
<i>3525</i>&nbsp;     * The rendering attributes applied include the clip, transform,
<i>3526</i>&nbsp;     * paint or color and composite attributes. Note that the result is
<i>3527</i>&nbsp;     * undefined, if the given transform is non-invertible.
<i>3528</i>&nbsp;     * @param img The image to be drawn.
<i>3529</i>&nbsp;     * @param xform The transformation from image space into user space.
<i>3530</i>&nbsp;     * @param observer The image observer to be notified on the image producing
<i>3531</i>&nbsp;     * progress.
<i>3532</i>&nbsp;     * @see #transform
<b class="nc"><i>3533</i>&nbsp;     * @see #setComposite</b>
<b class="nc"><i>3534</i>&nbsp;     * @see #setClip</b>
<i>3535</i>&nbsp;     */
<i>3536</i>&nbsp;    public boolean drawImage(Image img,
<b class="nc"><i>3537</i>&nbsp;                             AffineTransform xform,</b>
<b class="nc"><i>3538</i>&nbsp;                             ImageObserver observer) {</b>
<i>3539</i>&nbsp;
<i>3540</i>&nbsp;        if (img == null) {
<b class="nc"><i>3541</i>&nbsp;            return true;</b>
<b class="nc"><i>3542</i>&nbsp;        }</b>
<b class="nc"><i>3543</i>&nbsp;</b>
<i>3544</i>&nbsp;        if (xform == null || xform.isIdentity()) {
<i>3545</i>&nbsp;            return drawImage(img, 0, 0, null, observer);
<b class="nc"><i>3546</i>&nbsp;        }</b>
<b class="nc"><i>3547</i>&nbsp;</b>
<i>3548</i>&nbsp;        final int w = img.getWidth(null);
<i>3549</i>&nbsp;        final int h = img.getHeight(null);
<b class="nc"><i>3550</i>&nbsp;        Boolean hidpiImageDrawn = drawHiDPIImage(img, 0, 0, w, h, 0, 0, w, h,</b>
<i>3551</i>&nbsp;                                                 null, observer, xform);
<i>3552</i>&nbsp;
<i>3553</i>&nbsp;        if (hidpiImageDrawn != null) {
<i>3554</i>&nbsp;            return hidpiImageDrawn;
<i>3555</i>&nbsp;        }
<i>3556</i>&nbsp;
<i>3557</i>&nbsp;        return transformImage(img, xform, observer);
<b class="nc"><i>3558</i>&nbsp;    }</b>
<i>3559</i>&nbsp;
<i>3560</i>&nbsp;    public void drawImage(BufferedImage bImg,
<i>3561</i>&nbsp;                          BufferedImageOp op,
<i>3562</i>&nbsp;                          int x,
<b class="nc"><i>3563</i>&nbsp;                          int y)  {</b>
<b class="nc"><i>3564</i>&nbsp;</b>
<i>3565</i>&nbsp;        if (bImg == null) {
<b class="nc"><i>3566</i>&nbsp;            return;</b>
<b class="nc"><i>3567</i>&nbsp;        }</b>
<b class="nc"><i>3568</i>&nbsp;</b>
<i>3569</i>&nbsp;        try {
<i>3570</i>&nbsp;            imagepipe.transformImage(this, bImg, op, x, y);
<i>3571</i>&nbsp;        } catch (InvalidPipeException e) {
<b class="nc"><i>3572</i>&nbsp;            try {</b>
<i>3573</i>&nbsp;                revalidateAll();
<b class="nc"><i>3574</i>&nbsp;                imagepipe.transformImage(this, bImg, op, x, y);</b>
<b class="nc"><i>3575</i>&nbsp;            } catch (InvalidPipeException e2) {</b>
<i>3576</i>&nbsp;                // Still catching the exception; we are not yet ready to
<i>3577</i>&nbsp;                // validate the surfaceData correctly.  Fail for now and
<i>3578</i>&nbsp;                // try again next time around.
<i>3579</i>&nbsp;            }
<i>3580</i>&nbsp;        } finally {
<i>3581</i>&nbsp;            surfaceData.markDirty();
<i>3582</i>&nbsp;        }
<b class="nc"><i>3583</i>&nbsp;    }</b>
<b class="nc"><i>3584</i>&nbsp;</b>
<b class="nc"><i>3585</i>&nbsp;    /**</b>
<i>3586</i>&nbsp;    * Get the rendering context of the font
<b class="nc"><i>3587</i>&nbsp;    * within this Graphics2D context.</b>
<i>3588</i>&nbsp;    */
<i>3589</i>&nbsp;    public FontRenderContext getFontRenderContext() {
<b class="nc"><i>3590</i>&nbsp;        if (cachedFRC == null) {</b>
<b class="nc"><i>3591</i>&nbsp;            int aahint = textAntialiasHint;</b>
<b class="nc"><i>3592</i>&nbsp;            if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT &amp;&amp;</b>
<b class="nc"><i>3593</i>&nbsp;                antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {</b>
<b class="nc"><i>3594</i>&nbsp;                aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;</b>
<i>3595</i>&nbsp;            }
<b class="nc"><i>3596</i>&nbsp;            // Translation components should be excluded from the FRC transform</b>
<b class="nc"><i>3597</i>&nbsp;            AffineTransform tx = null;</b>
<b class="nc"><i>3598</i>&nbsp;            if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {</b>
<b class="nc"><i>3599</i>&nbsp;                if (transform.getTranslateX() == 0 &amp;&amp;</b>
<i>3600</i>&nbsp;                    transform.getTranslateY() == 0) {
<i>3601</i>&nbsp;                    tx = transform;
<i>3602</i>&nbsp;                } else {
<b class="nc"><i>3603</i>&nbsp;                    tx = new AffineTransform(transform.getScaleX(),</b>
<b class="nc"><i>3604</i>&nbsp;                                             transform.getShearY(),</b>
<b class="nc"><i>3605</i>&nbsp;                                             transform.getShearX(),</b>
<i>3606</i>&nbsp;                                             transform.getScaleY(),
<i>3607</i>&nbsp;                                             0, 0);
<b class="nc"><i>3608</i>&nbsp;                }</b>
<i>3609</i>&nbsp;            }
<i>3610</i>&nbsp;            cachedFRC = new FontRenderContext(tx,
<i>3611</i>&nbsp;             SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING, aahint),
<i>3612</i>&nbsp;             SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,
<i>3613</i>&nbsp;                                fractionalMetricsHint));
<i>3614</i>&nbsp;        }
<i>3615</i>&nbsp;        return cachedFRC;
<i>3616</i>&nbsp;    }
<i>3617</i>&nbsp;    private FontRenderContext cachedFRC;
<i>3618</i>&nbsp;
<i>3619</i>&nbsp;    /**
<i>3620</i>&nbsp;     * This object has no resources to dispose of per se, but the
<i>3621</i>&nbsp;     * doc comments for the base method in java.awt.Graphics imply
<b class="nc"><i>3622</i>&nbsp;     * that this object will not be useable after it is disposed.</b>
<b class="nc"><i>3623</i>&nbsp;     * So, we sabotage the object to prevent further use to prevent</b>
<i>3624</i>&nbsp;     * developers from relying on behavior that may not work on
<i>3625</i>&nbsp;     * other, less forgiving, VMs that really need to dispose of
<i>3626</i>&nbsp;     * resources.
<i>3627</i>&nbsp;     */
<i>3628</i>&nbsp;    public void dispose() {
<i>3629</i>&nbsp;        surfaceData = NullSurfaceData.theInstance;
<i>3630</i>&nbsp;        invalidatePipe();
<i>3631</i>&nbsp;    }
<i>3632</i>&nbsp;
<i>3633</i>&nbsp;    /**
<i>3634</i>&nbsp;     * Graphics has a finalize method that automatically calls dispose()
<i>3635</i>&nbsp;     * for subclasses.  For SunGraphics2D we do not need to be finalized
<i>3636</i>&nbsp;     * so that method simply causes us to be enqueued on the Finalizer
<i>3637</i>&nbsp;     * queues for no good reason.  Unfortunately, that method and
<i>3638</i>&nbsp;     * implementation are now considered part of the public contract
<i>3639</i>&nbsp;     * of that base class so we can not remove or gut the method.
<i>3640</i>&nbsp;     * We override it here with an empty method and the VM is smart
<i>3641</i>&nbsp;     * enough to know that if our override is empty then it should not
<i>3642</i>&nbsp;     * mark us as finalizeable.
<i>3643</i>&nbsp;     */
<i>3644</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>3645</i>&nbsp;    public void finalize() {
<i>3646</i>&nbsp;        // DO NOT REMOVE THIS METHOD
<b class="nc"><i>3647</i>&nbsp;    }</b>
<i>3648</i>&nbsp;
<i>3649</i>&nbsp;    /**
<i>3650</i>&nbsp;     * Returns destination that this Graphics renders to.  This could be
<i>3651</i>&nbsp;     * either an Image or a Component; subclasses of SurfaceData are
<i>3652</i>&nbsp;     * responsible for returning the appropriate object.
<i>3653</i>&nbsp;     */
<i>3654</i>&nbsp;    public Object getDestination() {
<i>3655</i>&nbsp;        return surfaceData.getDestination();
<i>3656</i>&nbsp;    }
<b class="nc"><i>3657</i>&nbsp;</b>
<i>3658</i>&nbsp;    /**
<i>3659</i>&nbsp;     * {@inheritDoc}
<i>3660</i>&nbsp;     *
<i>3661</i>&nbsp;     * @see sun.java2d.DestSurfaceProvider#getDestSurface
<i>3662</i>&nbsp;     */
<i>3663</i>&nbsp;    @Override
<i>3664</i>&nbsp;    public Surface getDestSurface() {
<i>3665</i>&nbsp;        return surfaceData;
<i>3666</i>&nbsp;    }
<i>3667</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
