


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: URI</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.net</a> ]
</div>

<h1>Coverage Summary for Class: URI (java.net)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">URI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 75)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 722)
  </span>
</td>
</tr>
  <tr>
    <td class="name">URI$Parser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 306)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 102)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1028)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.net;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.IOException;
<i>29</i>&nbsp;import java.io.InvalidObjectException;
<i>30</i>&nbsp;import java.io.ObjectInputStream;
<i>31</i>&nbsp;import java.io.ObjectOutputStream;
<i>32</i>&nbsp;import java.io.Serializable;
<i>33</i>&nbsp;import java.nio.ByteBuffer;
<i>34</i>&nbsp;import java.nio.CharBuffer;
<i>35</i>&nbsp;import java.nio.charset.CharsetDecoder;
<i>36</i>&nbsp;import java.nio.charset.CoderResult;
<i>37</i>&nbsp;import java.nio.charset.CodingErrorAction;
<i>38</i>&nbsp;import java.nio.charset.CharacterCodingException;
<i>39</i>&nbsp;import java.text.Normalizer;
<i>40</i>&nbsp;import jdk.internal.misc.JavaNetUriAccess;
<i>41</i>&nbsp;import jdk.internal.misc.SharedSecrets;
<i>42</i>&nbsp;import sun.nio.cs.ThreadLocalCoders;
<i>43</i>&nbsp;
<i>44</i>&nbsp;import java.lang.Character;             // for javadoc
<i>45</i>&nbsp;import java.lang.NullPointerException;  // for javadoc
<i>46</i>&nbsp;
<i>47</i>&nbsp;
<i>48</i>&nbsp;/**
<i>49</i>&nbsp; * Represents a Uniform Resource Identifier (URI) reference.
<i>50</i>&nbsp; *
<i>51</i>&nbsp; * &lt;p&gt; Aside from some minor deviations noted below, an instance of this
<i>52</i>&nbsp; * class represents a URI reference as defined by
<i>53</i>&nbsp; * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
<i>54</i>&nbsp; * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
<i>55</i>&nbsp; * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
<i>56</i>&nbsp; * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
<i>57</i>&nbsp; * also supports scope_ids. The syntax and usage of scope_ids is described
<i>58</i>&nbsp; * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
<i>59</i>&nbsp; * This class provides constructors for creating URI instances from
<i>60</i>&nbsp; * their components or by parsing their string forms, methods for accessing the
<i>61</i>&nbsp; * various components of an instance, and methods for normalizing, resolving,
<i>62</i>&nbsp; * and relativizing URI instances.  Instances of this class are immutable.
<i>63</i>&nbsp; *
<i>64</i>&nbsp; *
<i>65</i>&nbsp; * &lt;h3&gt; URI syntax and components &lt;/h3&gt;
<i>66</i>&nbsp; *
<i>67</i>&nbsp; * At the highest level a URI reference (hereinafter simply &quot;URI&quot;) in string
<i>68</i>&nbsp; * form has the syntax
<i>69</i>&nbsp; *
<i>70</i>&nbsp; * &lt;blockquote&gt;
<i>71</i>&nbsp; * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;]&lt;i&gt;scheme-specific-part&lt;/i&gt;[&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
<i>72</i>&nbsp; * &lt;/blockquote&gt;
<i>73</i>&nbsp; *
<i>74</i>&nbsp; * where square brackets [...] delineate optional components and the characters
<i>75</i>&nbsp; * &lt;b&gt;{@code :}&lt;/b&gt; and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.
<i>76</i>&nbsp; *
<i>77</i>&nbsp; * &lt;p&gt; An &lt;i&gt;absolute&lt;/i&gt; URI specifies a scheme; a URI that is not absolute is
<i>78</i>&nbsp; * said to be &lt;i&gt;relative&lt;/i&gt;.  URIs are also classified according to whether
<i>79</i>&nbsp; * they are &lt;i&gt;opaque&lt;/i&gt; or &lt;i&gt;hierarchical&lt;/i&gt;.
<i>80</i>&nbsp; *
<i>81</i>&nbsp; * &lt;p&gt; An &lt;i&gt;opaque&lt;/i&gt; URI is an absolute URI whose scheme-specific part does
<i>82</i>&nbsp; * not begin with a slash character ({@code &#39;/&#39;}).  Opaque URIs are not
<i>83</i>&nbsp; * subject to further parsing.  Some examples of opaque URIs are:
<i>84</i>&nbsp; *
<i>85</i>&nbsp; * &lt;blockquote&gt;&lt;ul style=&quot;list-style-type:none&quot;&gt;
<i>86</i>&nbsp; * &lt;li&gt;{@code mailto:java-net@java.sun.com}&lt;/li&gt;
<i>87</i>&nbsp; * &lt;li&gt;{@code news:comp.lang.java}&lt;/li&gt;
<i>88</i>&nbsp; * &lt;li&gt;{@code urn:isbn:096139210x}&lt;/li&gt;
<i>89</i>&nbsp; * &lt;/ul&gt;&lt;/blockquote&gt;
<i>90</i>&nbsp; *
<i>91</i>&nbsp; * &lt;p&gt; A &lt;i&gt;hierarchical&lt;/i&gt; URI is either an absolute URI whose
<i>92</i>&nbsp; * scheme-specific part begins with a slash character, or a relative URI, that
<i>93</i>&nbsp; * is, a URI that does not specify a scheme.  Some examples of hierarchical
<i>94</i>&nbsp; * URIs are:
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * &lt;blockquote&gt;
<i>97</i>&nbsp; * {@code http://example.com/languages/java/}&lt;br&gt;
<i>98</i>&nbsp; * {@code sample/a/index.html#28}&lt;br&gt;
<i>99</i>&nbsp; * {@code ../../demo/b/index.html}&lt;br&gt;
<i>100</i>&nbsp; * {@code file:///~/calendar}
<i>101</i>&nbsp; * &lt;/blockquote&gt;
<i>102</i>&nbsp; *
<i>103</i>&nbsp; * &lt;p&gt; A hierarchical URI is subject to further parsing according to the syntax
<i>104</i>&nbsp; *
<i>105</i>&nbsp; * &lt;blockquote&gt;
<i>106</i>&nbsp; * [&lt;i&gt;scheme&lt;/i&gt;&lt;b&gt;{@code :}&lt;/b&gt;][&lt;b&gt;{@code //}&lt;/b&gt;&lt;i&gt;authority&lt;/i&gt;][&lt;i&gt;path&lt;/i&gt;][&lt;b&gt;{@code ?}&lt;/b&gt;&lt;i&gt;query&lt;/i&gt;][&lt;b&gt;{@code #}&lt;/b&gt;&lt;i&gt;fragment&lt;/i&gt;]
<i>107</i>&nbsp; * &lt;/blockquote&gt;
<i>108</i>&nbsp; *
<i>109</i>&nbsp; * where the characters &lt;b&gt;{@code :}&lt;/b&gt;, &lt;b&gt;{@code /}&lt;/b&gt;,
<i>110</i>&nbsp; * &lt;b&gt;{@code ?}&lt;/b&gt;, and &lt;b&gt;{@code #}&lt;/b&gt; stand for themselves.  The
<i>111</i>&nbsp; * scheme-specific part of a hierarchical URI consists of the characters
<i>112</i>&nbsp; * between the scheme and fragment components.
<i>113</i>&nbsp; *
<i>114</i>&nbsp; * &lt;p&gt; The authority component of a hierarchical URI is, if specified, either
<i>115</i>&nbsp; * &lt;i&gt;server-based&lt;/i&gt; or &lt;i&gt;registry-based&lt;/i&gt;.  A server-based authority
<i>116</i>&nbsp; * parses according to the familiar syntax
<i>117</i>&nbsp; *
<i>118</i>&nbsp; * &lt;blockquote&gt;
<i>119</i>&nbsp; * [&lt;i&gt;user-info&lt;/i&gt;&lt;b&gt;{@code @}&lt;/b&gt;]&lt;i&gt;host&lt;/i&gt;[&lt;b&gt;{@code :}&lt;/b&gt;&lt;i&gt;port&lt;/i&gt;]
<i>120</i>&nbsp; * &lt;/blockquote&gt;
<i>121</i>&nbsp; *
<i>122</i>&nbsp; * where the characters &lt;b&gt;{@code @}&lt;/b&gt; and &lt;b&gt;{@code :}&lt;/b&gt; stand for
<i>123</i>&nbsp; * themselves.  Nearly all URI schemes currently in use are server-based.  An
<i>124</i>&nbsp; * authority component that does not parse in this way is considered to be
<i>125</i>&nbsp; * registry-based.
<i>126</i>&nbsp; *
<i>127</i>&nbsp; * &lt;p&gt; The path component of a hierarchical URI is itself said to be absolute
<i>128</i>&nbsp; * if it begins with a slash character ({@code &#39;/&#39;}); otherwise it is
<i>129</i>&nbsp; * relative.  The path of a hierarchical URI that is either absolute or
<i>130</i>&nbsp; * specifies an authority is always absolute.
<i>131</i>&nbsp; *
<i>132</i>&nbsp; * &lt;p&gt; All told, then, a URI instance has the following nine components:
<i>133</i>&nbsp; *
<i>134</i>&nbsp; * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
<i>135</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;Describes the components of a URI:scheme,scheme-specific-part,authority,user-info,host,port,path,query,fragment&lt;/caption&gt;
<i>136</i>&nbsp; * &lt;thead&gt;
<i>137</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Component&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;&lt;/tr&gt;
<i>138</i>&nbsp; * &lt;/thead&gt;
<i>139</i>&nbsp; * &lt;tbody style=&quot;text-align:left&quot;&gt;
<i>140</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;scheme&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>141</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;scheme-specific-part&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>142</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;authority&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>143</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;user-info&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>144</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;host&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>145</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;port&lt;/th&gt;&lt;td&gt;{@code int}&lt;/td&gt;&lt;/tr&gt;
<i>146</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;path&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>147</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;query&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>148</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;fragment&lt;/th&gt;&lt;td&gt;{@code String}&lt;/td&gt;&lt;/tr&gt;
<i>149</i>&nbsp; * &lt;/tbody&gt;
<i>150</i>&nbsp; * &lt;/table&gt;
<i>151</i>&nbsp; *
<i>152</i>&nbsp; * In a given instance any particular component is either &lt;i&gt;undefined&lt;/i&gt; or
<i>153</i>&nbsp; * &lt;i&gt;defined&lt;/i&gt; with a distinct value.  Undefined string components are
<i>154</i>&nbsp; * represented by {@code null}, while undefined integer components are
<i>155</i>&nbsp; * represented by {@code -1}.  A string component may be defined to have the
<i>156</i>&nbsp; * empty string as its value; this is not equivalent to that component being
<i>157</i>&nbsp; * undefined.
<i>158</i>&nbsp; *
<i>159</i>&nbsp; * &lt;p&gt; Whether a particular component is or is not defined in an instance
<i>160</i>&nbsp; * depends upon the type of the URI being represented.  An absolute URI has a
<i>161</i>&nbsp; * scheme component.  An opaque URI has a scheme, a scheme-specific part, and
<i>162</i>&nbsp; * possibly a fragment, but has no other components.  A hierarchical URI always
<i>163</i>&nbsp; * has a path (though it may be empty) and a scheme-specific-part (which at
<i>164</i>&nbsp; * least contains the path), and may have any of the other components.  If the
<i>165</i>&nbsp; * authority component is present and is server-based then the host component
<i>166</i>&nbsp; * will be defined and the user-information and port components may be defined.
<i>167</i>&nbsp; *
<i>168</i>&nbsp; *
<i>169</i>&nbsp; * &lt;h4&gt; Operations on URI instances &lt;/h4&gt;
<i>170</i>&nbsp; *
<i>171</i>&nbsp; * The key operations supported by this class are those of
<i>172</i>&nbsp; * &lt;i&gt;normalization&lt;/i&gt;, &lt;i&gt;resolution&lt;/i&gt;, and &lt;i&gt;relativization&lt;/i&gt;.
<i>173</i>&nbsp; *
<i>174</i>&nbsp; * &lt;p&gt; &lt;i&gt;Normalization&lt;/i&gt; is the process of removing unnecessary {@code &quot;.&quot;}
<i>175</i>&nbsp; * and {@code &quot;..&quot;} segments from the path component of a hierarchical URI.
<i>176</i>&nbsp; * Each {@code &quot;.&quot;} segment is simply removed.  A {@code &quot;..&quot;} segment is
<i>177</i>&nbsp; * removed only if it is preceded by a non-{@code &quot;..&quot;} segment.
<i>178</i>&nbsp; * Normalization has no effect upon opaque URIs.
<i>179</i>&nbsp; *
<i>180</i>&nbsp; * &lt;p&gt; &lt;i&gt;Resolution&lt;/i&gt; is the process of resolving one URI against another,
<i>181</i>&nbsp; * &lt;i&gt;base&lt;/i&gt; URI.  The resulting URI is constructed from components of both
<i>182</i>&nbsp; * URIs in the manner specified by RFC&amp;nbsp;2396, taking components from the
<i>183</i>&nbsp; * base URI for those not specified in the original.  For hierarchical URIs,
<i>184</i>&nbsp; * the path of the original is resolved against the path of the base and then
<i>185</i>&nbsp; * normalized.  The result, for example, of resolving
<i>186</i>&nbsp; *
<i>187</i>&nbsp; * &lt;blockquote&gt;
<i>188</i>&nbsp; * {@code sample/a/index.html#28}
<i>189</i>&nbsp; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
<i>190</i>&nbsp; * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)
<i>191</i>&nbsp; * &lt;/blockquote&gt;
<i>192</i>&nbsp; *
<i>193</i>&nbsp; * against the base URI {@code http://example.com/languages/java/} is the result
<i>194</i>&nbsp; * URI
<i>195</i>&nbsp; *
<i>196</i>&nbsp; * &lt;blockquote&gt;
<i>197</i>&nbsp; * {@code http://example.com/languages/java/sample/a/index.html#28}
<i>198</i>&nbsp; * &lt;/blockquote&gt;
<i>199</i>&nbsp; *
<i>200</i>&nbsp; * Resolving the relative URI
<i>201</i>&nbsp; *
<i>202</i>&nbsp; * &lt;blockquote&gt;
<i>203</i>&nbsp; * {@code ../../demo/b/index.html}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(2)
<i>204</i>&nbsp; * &lt;/blockquote&gt;
<i>205</i>&nbsp; *
<i>206</i>&nbsp; * against this result yields, in turn,
<i>207</i>&nbsp; *
<i>208</i>&nbsp; * &lt;blockquote&gt;
<i>209</i>&nbsp; * {@code http://example.com/languages/java/demo/b/index.html}
<i>210</i>&nbsp; * &lt;/blockquote&gt;
<i>211</i>&nbsp; *
<i>212</i>&nbsp; * Resolution of both absolute and relative URIs, and of both absolute and
<i>213</i>&nbsp; * relative paths in the case of hierarchical URIs, is supported.  Resolving
<i>214</i>&nbsp; * the URI {@code file:///~calendar} against any other URI simply yields the
<i>215</i>&nbsp; * original URI, since it is absolute.  Resolving the relative URI (2) above
<i>216</i>&nbsp; * against the relative base URI (1) yields the normalized, but still relative,
<i>217</i>&nbsp; * URI
<i>218</i>&nbsp; *
<i>219</i>&nbsp; * &lt;blockquote&gt;
<i>220</i>&nbsp; * {@code demo/b/index.html}
<i>221</i>&nbsp; * &lt;/blockquote&gt;
<i>222</i>&nbsp; *
<i>223</i>&nbsp; * &lt;p&gt; &lt;i&gt;Relativization&lt;/i&gt;, finally, is the inverse of resolution: For any
<i>224</i>&nbsp; * two normalized URIs &lt;i&gt;u&lt;/i&gt; and&amp;nbsp;&lt;i&gt;v&lt;/i&gt;,
<i>225</i>&nbsp; *
<i>226</i>&nbsp; * &lt;blockquote&gt;
<i>227</i>&nbsp; *   &lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;and&lt;br&gt;
<i>228</i>&nbsp; *   &lt;i&gt;u&lt;/i&gt;{@code .resolve(}&lt;i&gt;u&lt;/i&gt;{@code .relativize(}&lt;i&gt;v&lt;/i&gt;{@code )).equals(}&lt;i&gt;v&lt;/i&gt;{@code )}&amp;nbsp;&amp;nbsp;.&lt;br&gt;
<i>229</i>&nbsp; * &lt;/blockquote&gt;
<i>230</i>&nbsp; *
<i>231</i>&nbsp; * This operation is often useful when constructing a document containing URIs
<i>232</i>&nbsp; * that must be made relative to the base URI of the document wherever
<i>233</i>&nbsp; * possible.  For example, relativizing the URI
<i>234</i>&nbsp; *
<i>235</i>&nbsp; * &lt;blockquote&gt;
<i>236</i>&nbsp; * {@code http://example.com/languages/java/sample/a/index.html#28}
<i>237</i>&nbsp; * &lt;/blockquote&gt;
<i>238</i>&nbsp; *
<i>239</i>&nbsp; * against the base URI
<i>240</i>&nbsp; *
<i>241</i>&nbsp; * &lt;blockquote&gt;
<i>242</i>&nbsp; * {@code http://example.com/languages/java/}
<i>243</i>&nbsp; * &lt;/blockquote&gt;
<i>244</i>&nbsp; *
<i>245</i>&nbsp; * yields the relative URI {@code sample/a/index.html#28}.
<i>246</i>&nbsp; *
<i>247</i>&nbsp; *
<i>248</i>&nbsp; * &lt;h4&gt; Character categories &lt;/h4&gt;
<i>249</i>&nbsp; *
<i>250</i>&nbsp; * RFC&amp;nbsp;2396 specifies precisely which characters are permitted in the
<i>251</i>&nbsp; * various components of a URI reference.  The following categories, most of
<i>252</i>&nbsp; * which are taken from that specification, are used below to describe these
<i>253</i>&nbsp; * constraints:
<i>254</i>&nbsp; *
<i>255</i>&nbsp; * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
<i>256</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;Describes categories alpha,digit,alphanum,unreserved,punct,reserved,escaped,and other&lt;/caption&gt;
<i>257</i>&nbsp; *   &lt;thead&gt;
<i>258</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Category&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;
<i>259</i>&nbsp; *   &lt;/thead&gt;
<i>260</i>&nbsp; *   &lt;tbody style=&quot;text-align:left&quot;&gt;
<i>261</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alpha&lt;/th&gt;
<i>262</i>&nbsp; *       &lt;td&gt;The US-ASCII alphabetic characters,
<i>263</i>&nbsp; *        {@code &#39;A&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;Z&#39;}
<i>264</i>&nbsp; *        and {@code &#39;a&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;z&#39;}&lt;/td&gt;&lt;/tr&gt;
<i>265</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;digit&lt;/th&gt;
<i>266</i>&nbsp; *       &lt;td&gt;The US-ASCII decimal digit characters,
<i>267</i>&nbsp; *       {@code &#39;0&#39;}&amp;nbsp;through&amp;nbsp;{@code &#39;9&#39;}&lt;/td&gt;&lt;/tr&gt;
<i>268</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;alphanum&lt;/th&gt;
<i>269</i>&nbsp; *       &lt;td&gt;All &lt;i&gt;alpha&lt;/i&gt; and &lt;i&gt;digit&lt;/i&gt; characters&lt;/td&gt;&lt;/tr&gt;
<i>270</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;unreserved&lt;/th&gt;
<i>271</i>&nbsp; *       &lt;td&gt;All &lt;i&gt;alphanum&lt;/i&gt; characters together with those in the string
<i>272</i>&nbsp; *        {@code &quot;_-!.~&#39;()*&quot;}&lt;/td&gt;&lt;/tr&gt;
<i>273</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;punct&lt;/th&gt;
<i>274</i>&nbsp; *       &lt;td&gt;The characters in the string {@code &quot;,;:$&amp;+=&quot;}&lt;/td&gt;&lt;/tr&gt;
<i>275</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;reserved&lt;/th&gt;
<i>276</i>&nbsp; *       &lt;td&gt;All &lt;i&gt;punct&lt;/i&gt; characters together with those in the string
<i>277</i>&nbsp; *        {@code &quot;?/[]@&quot;}&lt;/td&gt;&lt;/tr&gt;
<i>278</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;escaped&lt;/th&gt;
<i>279</i>&nbsp; *       &lt;td&gt;Escaped octets, that is, triplets consisting of the percent
<i>280</i>&nbsp; *           character ({@code &#39;%&#39;}) followed by two hexadecimal digits
<i>281</i>&nbsp; *           ({@code &#39;0&#39;}-{@code &#39;9&#39;}, {@code &#39;A&#39;}-{@code &#39;F&#39;}, and
<i>282</i>&nbsp; *           {@code &#39;a&#39;}-{@code &#39;f&#39;})&lt;/td&gt;&lt;/tr&gt;
<i>283</i>&nbsp; *   &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;other&lt;/th&gt;
<i>284</i>&nbsp; *       &lt;td&gt;The Unicode characters that are not in the US-ASCII character set,
<i>285</i>&nbsp; *           are not control characters (according to the {@link
<i>286</i>&nbsp; *           java.lang.Character#isISOControl(char) Character.isISOControl}
<i>287</i>&nbsp; *           method), and are not space characters (according to the {@link
<i>288</i>&nbsp; *           java.lang.Character#isSpaceChar(char) Character.isSpaceChar}
<i>289</i>&nbsp; *           method)&amp;nbsp;&amp;nbsp;&lt;i&gt;(&lt;b&gt;Deviation from RFC 2396&lt;/b&gt;, which is
<i>290</i>&nbsp; *           limited to US-ASCII)&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
<i>291</i>&nbsp; * &lt;/tbody&gt;
<i>292</i>&nbsp; * &lt;/table&gt;
<i>293</i>&nbsp; *
<i>294</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;legal-chars&quot;&gt;&lt;/a&gt; The set of all legal URI characters consists of
<i>295</i>&nbsp; * the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;reserved&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;
<i>296</i>&nbsp; * characters.
<i>297</i>&nbsp; *
<i>298</i>&nbsp; *
<i>299</i>&nbsp; * &lt;h4&gt; Escaped octets, quotation, encoding, and decoding &lt;/h4&gt;
<i>300</i>&nbsp; *
<i>301</i>&nbsp; * RFC 2396 allows escaped octets to appear in the user-info, path, query, and
<i>302</i>&nbsp; * fragment components.  Escaping serves two purposes in URIs:
<i>303</i>&nbsp; *
<i>304</i>&nbsp; * &lt;ul&gt;
<i>305</i>&nbsp; *
<i>306</i>&nbsp; *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;encode&lt;/i&gt; non-US-ASCII characters when a URI is required to
<i>307</i>&nbsp; *   conform strictly to RFC&amp;nbsp;2396 by not containing any &lt;i&gt;other&lt;/i&gt;
<i>308</i>&nbsp; *   characters.  &lt;/p&gt;&lt;/li&gt;
<i>309</i>&nbsp; *
<i>310</i>&nbsp; *   &lt;li&gt;&lt;p&gt; To &lt;i&gt;quote&lt;/i&gt; characters that are otherwise illegal in a
<i>311</i>&nbsp; *   component.  The user-info, path, query, and fragment components differ
<i>312</i>&nbsp; *   slightly in terms of which characters are considered legal and illegal.
<i>313</i>&nbsp; *   &lt;/p&gt;&lt;/li&gt;
<i>314</i>&nbsp; *
<i>315</i>&nbsp; * &lt;/ul&gt;
<i>316</i>&nbsp; *
<i>317</i>&nbsp; * These purposes are served in this class by three related operations:
<i>318</i>&nbsp; *
<i>319</i>&nbsp; * &lt;ul&gt;
<i>320</i>&nbsp; *
<i>321</i>&nbsp; *   &lt;li&gt;&lt;p&gt;&lt;a id=&quot;encode&quot;&gt;&lt;/a&gt; A character is &lt;i&gt;encoded&lt;/i&gt; by replacing it
<i>322</i>&nbsp; *   with the sequence of escaped octets that represent that character in the
<i>323</i>&nbsp; *   UTF-8 character set.  The Euro currency symbol ({@code &#39;\u005Cu20AC&#39;}),
<i>324</i>&nbsp; *   for example, is encoded as {@code &quot;%E2%82%AC&quot;}.  &lt;i&gt;(&lt;b&gt;Deviation from
<i>325</i>&nbsp; *   RFC&amp;nbsp;2396&lt;/b&gt;, which does not specify any particular character
<i>326</i>&nbsp; *   set.)&lt;/i&gt; &lt;/p&gt;&lt;/li&gt;
<i>327</i>&nbsp; *
<i>328</i>&nbsp; *   &lt;li&gt;&lt;p&gt;&lt;a id=&quot;quote&quot;&gt;&lt;/a&gt; An illegal character is &lt;i&gt;quoted&lt;/i&gt; simply by
<i>329</i>&nbsp; *   encoding it.  The space character, for example, is quoted by replacing it
<i>330</i>&nbsp; *   with {@code &quot;%20&quot;}.  UTF-8 contains US-ASCII, hence for US-ASCII
<i>331</i>&nbsp; *   characters this transformation has exactly the effect required by
<i>332</i>&nbsp; *   RFC&amp;nbsp;2396. &lt;/p&gt;&lt;/li&gt;
<i>333</i>&nbsp; *
<i>334</i>&nbsp; *   &lt;li&gt;&lt;p&gt;&lt;a id=&quot;decode&quot;&gt;&lt;/a&gt;
<i>335</i>&nbsp; *   A sequence of escaped octets is &lt;i&gt;decoded&lt;/i&gt; by
<i>336</i>&nbsp; *   replacing it with the sequence of characters that it represents in the
<i>337</i>&nbsp; *   UTF-8 character set.  UTF-8 contains US-ASCII, hence decoding has the
<i>338</i>&nbsp; *   effect of de-quoting any quoted US-ASCII characters as well as that of
<i>339</i>&nbsp; *   decoding any encoded non-US-ASCII characters.  If a &lt;a
<i>340</i>&nbsp; *   href=&quot;../nio/charset/CharsetDecoder.html#ce&quot;&gt;decoding error&lt;/a&gt; occurs
<i>341</i>&nbsp; *   when decoding the escaped octets then the erroneous octets are replaced by
<i>342</i>&nbsp; *   {@code &#39;\u005CuFFFD&#39;}, the Unicode replacement character.  &lt;/p&gt;&lt;/li&gt;
<i>343</i>&nbsp; *
<i>344</i>&nbsp; * &lt;/ul&gt;
<i>345</i>&nbsp; *
<i>346</i>&nbsp; * These operations are exposed in the constructors and methods of this class
<i>347</i>&nbsp; * as follows:
<i>348</i>&nbsp; *
<i>349</i>&nbsp; * &lt;ul&gt;
<i>350</i>&nbsp; *
<i>351</i>&nbsp; *   &lt;li&gt;&lt;p&gt; The {@linkplain #URI(java.lang.String) single-argument
<i>352</i>&nbsp; *   constructor} requires any illegal characters in its argument to be
<i>353</i>&nbsp; *   quoted and preserves any escaped octets and &lt;i&gt;other&lt;/i&gt; characters that
<i>354</i>&nbsp; *   are present.  &lt;/p&gt;&lt;/li&gt;
<i>355</i>&nbsp; *
<i>356</i>&nbsp; *   &lt;li&gt;&lt;p&gt; The {@linkplain
<i>357</i>&nbsp; *   #URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)
<i>358</i>&nbsp; *   multi-argument constructors} quote illegal characters as
<i>359</i>&nbsp; *   required by the components in which they appear.  The percent character
<i>360</i>&nbsp; *   ({@code &#39;%&#39;}) is always quoted by these constructors.  Any &lt;i&gt;other&lt;/i&gt;
<i>361</i>&nbsp; *   characters are preserved.  &lt;/p&gt;&lt;/li&gt;
<i>362</i>&nbsp; *
<i>363</i>&nbsp; *   &lt;li&gt;&lt;p&gt; The {@link #getRawUserInfo() getRawUserInfo}, {@link #getRawPath()
<i>364</i>&nbsp; *   getRawPath}, {@link #getRawQuery() getRawQuery}, {@link #getRawFragment()
<i>365</i>&nbsp; *   getRawFragment}, {@link #getRawAuthority() getRawAuthority}, and {@link
<i>366</i>&nbsp; *   #getRawSchemeSpecificPart() getRawSchemeSpecificPart} methods return the
<i>367</i>&nbsp; *   values of their corresponding components in raw form, without interpreting
<i>368</i>&nbsp; *   any escaped octets.  The strings returned by these methods may contain
<i>369</i>&nbsp; *   both escaped octets and &lt;i&gt;other&lt;/i&gt; characters, and will not contain any
<i>370</i>&nbsp; *   illegal characters.  &lt;/p&gt;&lt;/li&gt;
<i>371</i>&nbsp; *
<i>372</i>&nbsp; *   &lt;li&gt;&lt;p&gt; The {@link #getUserInfo() getUserInfo}, {@link #getPath()
<i>373</i>&nbsp; *   getPath}, {@link #getQuery() getQuery}, {@link #getFragment()
<i>374</i>&nbsp; *   getFragment}, {@link #getAuthority() getAuthority}, and {@link
<i>375</i>&nbsp; *   #getSchemeSpecificPart() getSchemeSpecificPart} methods decode any escaped
<i>376</i>&nbsp; *   octets in their corresponding components.  The strings returned by these
<i>377</i>&nbsp; *   methods may contain both &lt;i&gt;other&lt;/i&gt; characters and illegal characters,
<i>378</i>&nbsp; *   and will not contain any escaped octets.  &lt;/p&gt;&lt;/li&gt;
<i>379</i>&nbsp; *
<i>380</i>&nbsp; *   &lt;li&gt;&lt;p&gt; The {@link #toString() toString} method returns a URI string with
<i>381</i>&nbsp; *   all necessary quotation but which may contain &lt;i&gt;other&lt;/i&gt; characters.
<i>382</i>&nbsp; *   &lt;/p&gt;&lt;/li&gt;
<i>383</i>&nbsp; *
<i>384</i>&nbsp; *   &lt;li&gt;&lt;p&gt; The {@link #toASCIIString() toASCIIString} method returns a fully
<i>385</i>&nbsp; *   quoted and encoded URI string that does not contain any &lt;i&gt;other&lt;/i&gt;
<i>386</i>&nbsp; *   characters.  &lt;/p&gt;&lt;/li&gt;
<i>387</i>&nbsp; *
<i>388</i>&nbsp; * &lt;/ul&gt;
<i>389</i>&nbsp; *
<i>390</i>&nbsp; *
<i>391</i>&nbsp; * &lt;h4&gt; Identities &lt;/h4&gt;
<i>392</i>&nbsp; *
<i>393</i>&nbsp; * For any URI &lt;i&gt;u&lt;/i&gt;, it is always the case that
<i>394</i>&nbsp; *
<i>395</i>&nbsp; * &lt;blockquote&gt;
<i>396</i>&nbsp; * {@code new URI(}&lt;i&gt;u&lt;/i&gt;{@code .toString()).equals(}&lt;i&gt;u&lt;/i&gt;{@code )}&amp;nbsp;.
<i>397</i>&nbsp; * &lt;/blockquote&gt;
<i>398</i>&nbsp; *
<i>399</i>&nbsp; * For any URI &lt;i&gt;u&lt;/i&gt; that does not contain redundant syntax such as two
<i>400</i>&nbsp; * slashes before an empty authority (as in {@code file:///tmp/}&amp;nbsp;) or a
<i>401</i>&nbsp; * colon following a host name but no port (as in
<i>402</i>&nbsp; * {@code http://java.sun.com:}&amp;nbsp;), and that does not encode characters
<i>403</i>&nbsp; * except those that must be quoted, the following identities also hold:
<i>404</i>&nbsp; * &lt;pre&gt;
<i>405</i>&nbsp; *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
<i>406</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getSchemeSpecificPart(),
<i>407</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getFragment())
<i>408</i>&nbsp; *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
<i>409</i>&nbsp; * in all cases,
<i>410</i>&nbsp; * &lt;pre&gt;
<i>411</i>&nbsp; *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
<i>412</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getAuthority(),
<i>413</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
<i>414</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getFragment())
<i>415</i>&nbsp; *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
<i>416</i>&nbsp; * if &lt;i&gt;u&lt;/i&gt; is hierarchical, and
<i>417</i>&nbsp; * &lt;pre&gt;
<i>418</i>&nbsp; *     new URI(&lt;i&gt;u&lt;/i&gt;.getScheme(),
<i>419</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getUserInfo(), &lt;i&gt;u&lt;/i&gt;.getHost(), &lt;i&gt;u&lt;/i&gt;.getPort(),
<i>420</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getPath(), &lt;i&gt;u&lt;/i&gt;.getQuery(),
<i>421</i>&nbsp; *             &lt;i&gt;u&lt;/i&gt;.getFragment())
<i>422</i>&nbsp; *     .equals(&lt;i&gt;u&lt;/i&gt;)&lt;/pre&gt;
<i>423</i>&nbsp; * if &lt;i&gt;u&lt;/i&gt; is hierarchical and has either no authority or a server-based
<i>424</i>&nbsp; * authority.
<i>425</i>&nbsp; *
<i>426</i>&nbsp; *
<i>427</i>&nbsp; * &lt;h4&gt; URIs, URLs, and URNs &lt;/h4&gt;
<i>428</i>&nbsp; *
<i>429</i>&nbsp; * A URI is a uniform resource &lt;i&gt;identifier&lt;/i&gt; while a URL is a uniform
<i>430</i>&nbsp; * resource &lt;i&gt;locator&lt;/i&gt;.  Hence every URL is a URI, abstractly speaking, but
<i>431</i>&nbsp; * not every URI is a URL.  This is because there is another subcategory of
<i>432</i>&nbsp; * URIs, uniform resource &lt;i&gt;names&lt;/i&gt; (URNs), which name resources but do not
<i>433</i>&nbsp; * specify how to locate them.  The {@code mailto}, {@code news}, and
<i>434</i>&nbsp; * {@code isbn} URIs shown above are examples of URNs.
<i>435</i>&nbsp; *
<i>436</i>&nbsp; * &lt;p&gt; The conceptual distinction between URIs and URLs is reflected in the
<i>437</i>&nbsp; * differences between this class and the {@link URL} class.
<i>438</i>&nbsp; *
<i>439</i>&nbsp; * &lt;p&gt; An instance of this class represents a URI reference in the syntactic
<i>440</i>&nbsp; * sense defined by RFC&amp;nbsp;2396.  A URI may be either absolute or relative.
<i>441</i>&nbsp; * A URI string is parsed according to the generic syntax without regard to the
<i>442</i>&nbsp; * scheme, if any, that it specifies.  No lookup of the host, if any, is
<i>443</i>&nbsp; * performed, and no scheme-dependent stream handler is constructed.  Equality,
<i>444</i>&nbsp; * hashing, and comparison are defined strictly in terms of the character
<i>445</i>&nbsp; * content of the instance.  In other words, a URI instance is little more than
<i>446</i>&nbsp; * a structured string that supports the syntactic, scheme-independent
<i>447</i>&nbsp; * operations of comparison, normalization, resolution, and relativization.
<i>448</i>&nbsp; *
<i>449</i>&nbsp; * &lt;p&gt; An instance of the {@link URL} class, by contrast, represents the
<i>450</i>&nbsp; * syntactic components of a URL together with some of the information required
<i>451</i>&nbsp; * to access the resource that it describes.  A URL must be absolute, that is,
<i>452</i>&nbsp; * it must always specify a scheme.  A URL string is parsed according to its
<i>453</i>&nbsp; * scheme.  A stream handler is always established for a URL, and in fact it is
<i>454</i>&nbsp; * impossible to create a URL instance for a scheme for which no handler is
<i>455</i>&nbsp; * available.  Equality and hashing depend upon both the scheme and the
<i>456</i>&nbsp; * Internet address of the host, if any; comparison is not defined.  In other
<i>457</i>&nbsp; * words, a URL is a structured string that supports the syntactic operation of
<i>458</i>&nbsp; * resolution as well as the network I/O operations of looking up the host and
<i>459</i>&nbsp; * opening a connection to the specified resource.
<i>460</i>&nbsp; *
<i>461</i>&nbsp; *
<i>462</i>&nbsp; * @author Mark Reinhold
<i>463</i>&nbsp; * @since 1.4
<b class="nc"><i>464</i>&nbsp; *</b>
<i>465</i>&nbsp; * @see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2279.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2279: UTF-8, a
<i>466</i>&nbsp; * transformation format of ISO 10646&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
<i>467</i>&nbsp; * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6 Addressing
<i>468</i>&nbsp; * Architecture&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
<i>469</i>&nbsp; * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
<i>470</i>&nbsp; * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
<i>471</i>&nbsp; * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
<i>472</i>&nbsp; * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;, &lt;br&gt;&lt;a
<i>473</i>&nbsp; * href=&quot;URISyntaxException.html&quot;&gt;URISyntaxException&lt;/a&gt;
<i>474</i>&nbsp; */
<i>475</i>&nbsp;
<i>476</i>&nbsp;public final class URI
<i>477</i>&nbsp;    implements Comparable&lt;URI&gt;, Serializable
<i>478</i>&nbsp;{
<i>479</i>&nbsp;
<i>480</i>&nbsp;    // Note: Comments containing the word &quot;ASSERT&quot; indicate places where a
<i>481</i>&nbsp;    // throw of an InternalError should be replaced by an appropriate assertion
<i>482</i>&nbsp;    // statement once asserts are enabled in the build.
<i>483</i>&nbsp;
<i>484</i>&nbsp;    static final long serialVersionUID = -6052424284110960213L;
<i>485</i>&nbsp;
<i>486</i>&nbsp;
<b class="nc"><i>487</i>&nbsp;    // -- Properties and components of this instance --</b>
<i>488</i>&nbsp;
<i>489</i>&nbsp;    // Components of all URIs: [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]
<i>490</i>&nbsp;    private transient String scheme;            // null ==&gt; relative URI
<i>491</i>&nbsp;    private transient String fragment;
<i>492</i>&nbsp;
<i>493</i>&nbsp;    // Hierarchical URI components: [//&lt;authority&gt;]&lt;path&gt;[?&lt;query&gt;]
<i>494</i>&nbsp;    private transient String authority;         // Registry or server
<i>495</i>&nbsp;
<i>496</i>&nbsp;    // Server-based authority: [&lt;userInfo&gt;@]&lt;host&gt;[:&lt;port&gt;]
<i>497</i>&nbsp;    private transient String userInfo;
<b class="nc"><i>498</i>&nbsp;    private transient String host;              // null ==&gt; registry-based</b>
<b class="nc"><i>499</i>&nbsp;    private transient int port = -1;            // -1 ==&gt; undefined</b>
<b class="nc"><i>500</i>&nbsp;</b>
<b class="nc"><i>501</i>&nbsp;    // Remaining components of hierarchical URIs</b>
<b class="nc"><i>502</i>&nbsp;    private transient String path;              // null ==&gt; opaque</b>
<b class="nc"><i>503</i>&nbsp;    private transient String query;</b>
<i>504</i>&nbsp;
<i>505</i>&nbsp;    // The remaining fields may be computed on demand, which is safe even in
<i>506</i>&nbsp;    // the face of multiple threads racing to initialize them
<i>507</i>&nbsp;    private transient String schemeSpecificPart;
<i>508</i>&nbsp;    private transient int hash;        // Zero ==&gt; undefined
<i>509</i>&nbsp;
<i>510</i>&nbsp;    private transient String decodedUserInfo;
<i>511</i>&nbsp;    private transient String decodedAuthority;
<i>512</i>&nbsp;    private transient String decodedPath;
<i>513</i>&nbsp;    private transient String decodedQuery;
<i>514</i>&nbsp;    private transient String decodedFragment;
<i>515</i>&nbsp;    private transient String decodedSchemeSpecificPart;
<i>516</i>&nbsp;
<i>517</i>&nbsp;    /**
<i>518</i>&nbsp;     * The string form of this URI.
<i>519</i>&nbsp;     *
<i>520</i>&nbsp;     * @serial
<i>521</i>&nbsp;     */
<i>522</i>&nbsp;    private volatile String string;             // The only serializable field
<i>523</i>&nbsp;
<i>524</i>&nbsp;
<i>525</i>&nbsp;
<i>526</i>&nbsp;    // -- Constructors and factories --
<i>527</i>&nbsp;
<i>528</i>&nbsp;    private URI() { }                           // Used internally
<i>529</i>&nbsp;
<i>530</i>&nbsp;    /**
<i>531</i>&nbsp;     * Constructs a URI by parsing the given string.
<i>532</i>&nbsp;     *
<i>533</i>&nbsp;     * &lt;p&gt; This constructor parses the given string exactly as specified by the
<i>534</i>&nbsp;     * grammar in &lt;a
<i>535</i>&nbsp;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
<i>536</i>&nbsp;     * Appendix&amp;nbsp;A, &lt;b&gt;&lt;i&gt;except for the following deviations:&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;
<i>537</i>&nbsp;     *
<i>538</i>&nbsp;     * &lt;ul&gt;
<i>539</i>&nbsp;     *
<i>540</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; An empty authority component is permitted as long as it is
<i>541</i>&nbsp;     *   followed by a non-empty path, a query component, or a fragment
<i>542</i>&nbsp;     *   component.  This allows the parsing of URIs such as
<i>543</i>&nbsp;     *   {@code &quot;file:///foo/bar&quot;}, which seems to be the intent of
<i>544</i>&nbsp;     *   RFC&amp;nbsp;2396 although the grammar does not permit it.  If the
<i>545</i>&nbsp;     *   authority component is empty then the user-information, host, and port
<i>546</i>&nbsp;     *   components are undefined. &lt;/p&gt;&lt;/li&gt;
<i>547</i>&nbsp;     *
<i>548</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Empty relative paths are permitted; this seems to be the
<i>549</i>&nbsp;     *   intent of RFC&amp;nbsp;2396 although the grammar does not permit it.  The
<i>550</i>&nbsp;     *   primary consequence of this deviation is that a standalone fragment
<i>551</i>&nbsp;     *   such as {@code &quot;#foo&quot;} parses as a relative URI with an empty path
<i>552</i>&nbsp;     *   and the given fragment, and can be usefully &lt;a
<i>553</i>&nbsp;     *   href=&quot;#resolve-frag&quot;&gt;resolved&lt;/a&gt; against a base URI.
<i>554</i>&nbsp;     *
<i>555</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; IPv4 addresses in host components are parsed rigorously, as
<i>556</i>&nbsp;     *   specified by &lt;a
<i>557</i>&nbsp;     *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;: Each
<i>558</i>&nbsp;     *   element of a dotted-quad address must contain no more than three
<i>559</i>&nbsp;     *   decimal digits.  Each element is further constrained to have a value
<i>560</i>&nbsp;     *   no greater than 255. &lt;/p&gt;&lt;/li&gt;
<i>561</i>&nbsp;     *
<i>562</i>&nbsp;     *   &lt;li&gt; &lt;p&gt; Hostnames in host components that comprise only a single
<i>563</i>&nbsp;     *   domain label are permitted to start with an &lt;i&gt;alphanum&lt;/i&gt;
<i>564</i>&nbsp;     *   character. This seems to be the intent of &lt;a
<i>565</i>&nbsp;     *   href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
<i>566</i>&nbsp;     *   section&amp;nbsp;3.2.2 although the grammar does not permit it. The
<i>567</i>&nbsp;     *   consequence of this deviation is that the authority component of a
<i>568</i>&nbsp;     *   hierarchical URI such as {@code s://123}, will parse as a server-based
<i>569</i>&nbsp;     *   authority. &lt;/p&gt;&lt;/li&gt;
<i>570</i>&nbsp;     *
<i>571</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; IPv6 addresses are permitted for the host component.  An IPv6
<i>572</i>&nbsp;     *   address must be enclosed in square brackets ({@code &#39;[&#39;} and
<i>573</i>&nbsp;     *   {@code &#39;]&#39;}) as specified by &lt;a
<i>574</i>&nbsp;     *   href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;.  The
<i>575</i>&nbsp;     *   IPv6 address itself must parse according to &lt;a
<i>576</i>&nbsp;     *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;RFC&amp;nbsp;2373&lt;/a&gt;.  IPv6
<i>577</i>&nbsp;     *   addresses are further constrained to describe no more than sixteen
<i>578</i>&nbsp;     *   bytes of address information, a constraint implicit in RFC&amp;nbsp;2373
<i>579</i>&nbsp;     *   but not expressible in the grammar. &lt;/p&gt;&lt;/li&gt;
<i>580</i>&nbsp;     *
<i>581</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Characters in the &lt;i&gt;other&lt;/i&gt; category are permitted wherever
<i>582</i>&nbsp;     *   RFC&amp;nbsp;2396 permits &lt;i&gt;escaped&lt;/i&gt; octets, that is, in the
<i>583</i>&nbsp;     *   user-information, path, query, and fragment components, as well as in
<i>584</i>&nbsp;     *   the authority component if the authority is registry-based.  This
<i>585</i>&nbsp;     *   allows URIs to contain Unicode characters beyond those in the US-ASCII
<i>586</i>&nbsp;     *   character set. &lt;/p&gt;&lt;/li&gt;
<b class="nc"><i>587</i>&nbsp;     *</b>
<b class="nc"><i>588</i>&nbsp;     * &lt;/ul&gt;</b>
<i>589</i>&nbsp;     *
<i>590</i>&nbsp;     * @param  str   The string to be parsed into a URI
<i>591</i>&nbsp;     *
<i>592</i>&nbsp;     * @throws  NullPointerException
<i>593</i>&nbsp;     *          If {@code str} is {@code null}
<i>594</i>&nbsp;     *
<i>595</i>&nbsp;     * @throws  URISyntaxException
<i>596</i>&nbsp;     *          If the given string violates RFC&amp;nbsp;2396, as augmented
<i>597</i>&nbsp;     *          by the above deviations
<i>598</i>&nbsp;     */
<i>599</i>&nbsp;    public URI(String str) throws URISyntaxException {
<i>600</i>&nbsp;        new Parser(str).parse(false);
<i>601</i>&nbsp;    }
<i>602</i>&nbsp;
<i>603</i>&nbsp;    /**
<i>604</i>&nbsp;     * Constructs a hierarchical URI from the given components.
<i>605</i>&nbsp;     *
<i>606</i>&nbsp;     * &lt;p&gt; If a scheme is given then the path, if also given, must either be
<i>607</i>&nbsp;     * empty or begin with a slash character ({@code &#39;/&#39;}).  Otherwise a
<i>608</i>&nbsp;     * component of the new URI may be left undefined by passing {@code null}
<i>609</i>&nbsp;     * for the corresponding parameter or, in the case of the {@code port}
<i>610</i>&nbsp;     * parameter, by passing {@code -1}.
<i>611</i>&nbsp;     *
<i>612</i>&nbsp;     * &lt;p&gt; This constructor first builds a URI string from the given components
<i>613</i>&nbsp;     * according to the rules specified in &lt;a
<i>614</i>&nbsp;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
<i>615</i>&nbsp;     * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
<i>616</i>&nbsp;     *
<i>617</i>&nbsp;     * &lt;ol&gt;
<i>618</i>&nbsp;     *
<i>619</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty. &lt;/p&gt;&lt;/li&gt;
<i>620</i>&nbsp;     *
<i>621</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
<i>622</i>&nbsp;     *   followed by a colon character ({@code &#39;:&#39;}).  &lt;/p&gt;&lt;/li&gt;
<i>623</i>&nbsp;     *
<i>624</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If user information, a host, or a port are given then the
<i>625</i>&nbsp;     *   string {@code &quot;//&quot;} is appended.  &lt;/p&gt;&lt;/li&gt;
<i>626</i>&nbsp;     *
<i>627</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If user information is given then it is appended, followed by
<i>628</i>&nbsp;     *   a commercial-at character ({@code &#39;@&#39;}).  Any character not in the
<i>629</i>&nbsp;     *   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
<i>630</i>&nbsp;     *   categories is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
<i>631</i>&nbsp;     *
<i>632</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a host is given then it is appended.  If the host is a
<i>633</i>&nbsp;     *   literal IPv6 address but is not enclosed in square brackets
<i>634</i>&nbsp;     *   ({@code &#39;[&#39;} and {@code &#39;]&#39;}) then the square brackets are added.
<i>635</i>&nbsp;     *   &lt;/p&gt;&lt;/li&gt;
<i>636</i>&nbsp;     *
<i>637</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a port number is given then a colon character
<i>638</i>&nbsp;     *   ({@code &#39;:&#39;}) is appended, followed by the port number in decimal.
<i>639</i>&nbsp;     *   &lt;/p&gt;&lt;/li&gt;
<i>640</i>&nbsp;     *
<i>641</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
<i>642</i>&nbsp;     *   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
<i>643</i>&nbsp;     *   categories, and not equal to the slash character ({@code &#39;/&#39;}) or the
<i>644</i>&nbsp;     *   commercial-at character ({@code &#39;@&#39;}), is quoted.  &lt;/p&gt;&lt;/li&gt;
<i>645</i>&nbsp;     *
<i>646</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
<i>647</i>&nbsp;     *   ({@code &#39;?&#39;}) is appended, followed by the query.  Any character that
<i>648</i>&nbsp;     *   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
<i>649</i>&nbsp;     *   &lt;/p&gt;&lt;/li&gt;
<i>650</i>&nbsp;     *
<i>651</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
<i>652</i>&nbsp;     *   ({@code &#39;#&#39;}) is appended, followed by the fragment.  Any character
<i>653</i>&nbsp;     *   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
<i>654</i>&nbsp;     *
<i>655</i>&nbsp;     * &lt;/ol&gt;
<i>656</i>&nbsp;     *
<i>657</i>&nbsp;     * &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
<i>658</i>&nbsp;     * #URI(String)} constructor and then invoking the {@link
<i>659</i>&nbsp;     * #parseServerAuthority()} method upon the result; this may cause a {@link
<i>660</i>&nbsp;     * URISyntaxException} to be thrown.  &lt;/p&gt;
<i>661</i>&nbsp;     *
<i>662</i>&nbsp;     * @param   scheme    Scheme name
<i>663</i>&nbsp;     * @param   userInfo  User name and authorization information
<i>664</i>&nbsp;     * @param   host      Host name
<i>665</i>&nbsp;     * @param   port      Port number
<i>666</i>&nbsp;     * @param   path      Path
<i>667</i>&nbsp;     * @param   query     Query
<b class="nc"><i>668</i>&nbsp;     * @param   fragment  Fragment</b>
<b class="nc"><i>669</i>&nbsp;     *</b>
<i>670</i>&nbsp;     * @throws URISyntaxException
<i>671</i>&nbsp;     *         If both a scheme and a path are given but the path is relative,
<b class="nc"><i>672</i>&nbsp;     *         if the URI string constructed from the given components violates</b>
<b class="nc"><i>673</i>&nbsp;     *         RFC&amp;nbsp;2396, or if the authority component of the string is</b>
<i>674</i>&nbsp;     *         present but cannot be parsed as a server-based authority
<i>675</i>&nbsp;     */
<i>676</i>&nbsp;    public URI(String scheme,
<i>677</i>&nbsp;               String userInfo, String host, int port,
<i>678</i>&nbsp;               String path, String query, String fragment)
<i>679</i>&nbsp;        throws URISyntaxException
<i>680</i>&nbsp;    {
<i>681</i>&nbsp;        String s = toString(scheme, null,
<i>682</i>&nbsp;                            null, userInfo, host, port,
<i>683</i>&nbsp;                            path, query, fragment);
<i>684</i>&nbsp;        checkPath(s, scheme, path);
<i>685</i>&nbsp;        new Parser(s).parse(true);
<i>686</i>&nbsp;    }
<i>687</i>&nbsp;
<i>688</i>&nbsp;    /**
<i>689</i>&nbsp;     * Constructs a hierarchical URI from the given components.
<i>690</i>&nbsp;     *
<i>691</i>&nbsp;     * &lt;p&gt; If a scheme is given then the path, if also given, must either be
<i>692</i>&nbsp;     * empty or begin with a slash character ({@code &#39;/&#39;}).  Otherwise a
<i>693</i>&nbsp;     * component of the new URI may be left undefined by passing {@code null}
<i>694</i>&nbsp;     * for the corresponding parameter.
<i>695</i>&nbsp;     *
<i>696</i>&nbsp;     * &lt;p&gt; This constructor first builds a URI string from the given components
<i>697</i>&nbsp;     * according to the rules specified in &lt;a
<i>698</i>&nbsp;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
<i>699</i>&nbsp;     * section&amp;nbsp;5.2, step&amp;nbsp;7: &lt;/p&gt;
<i>700</i>&nbsp;     *
<i>701</i>&nbsp;     * &lt;ol&gt;
<i>702</i>&nbsp;     *
<i>703</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
<i>704</i>&nbsp;     *
<i>705</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
<i>706</i>&nbsp;     *   followed by a colon character ({@code &#39;:&#39;}).  &lt;/p&gt;&lt;/li&gt;
<i>707</i>&nbsp;     *
<i>708</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If an authority is given then the string {@code &quot;//&quot;} is
<i>709</i>&nbsp;     *   appended, followed by the authority.  If the authority contains a
<i>710</i>&nbsp;     *   literal IPv6 address then the address must be enclosed in square
<i>711</i>&nbsp;     *   brackets ({@code &#39;[&#39;} and {@code &#39;]&#39;}).  Any character not in the
<i>712</i>&nbsp;     *   &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
<i>713</i>&nbsp;     *   categories, and not equal to the commercial-at character
<i>714</i>&nbsp;     *   ({@code &#39;@&#39;}), is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
<i>715</i>&nbsp;     *
<i>716</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a path is given then it is appended.  Any character not in
<i>717</i>&nbsp;     *   the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, or &lt;i&gt;other&lt;/i&gt;
<i>718</i>&nbsp;     *   categories, and not equal to the slash character ({@code &#39;/&#39;}) or the
<i>719</i>&nbsp;     *   commercial-at character ({@code &#39;@&#39;}), is quoted.  &lt;/p&gt;&lt;/li&gt;
<i>720</i>&nbsp;     *
<i>721</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a query is given then a question-mark character
<i>722</i>&nbsp;     *   ({@code &#39;?&#39;}) is appended, followed by the query.  Any character that
<i>723</i>&nbsp;     *   is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt; is quoted.
<i>724</i>&nbsp;     *   &lt;/p&gt;&lt;/li&gt;
<i>725</i>&nbsp;     *
<i>726</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
<i>727</i>&nbsp;     *   ({@code &#39;#&#39;}) is appended, followed by the fragment.  Any character
<i>728</i>&nbsp;     *   that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
<i>729</i>&nbsp;     *
<i>730</i>&nbsp;     * &lt;/ol&gt;
<i>731</i>&nbsp;     *
<i>732</i>&nbsp;     * &lt;p&gt; The resulting URI string is then parsed as if by invoking the {@link
<i>733</i>&nbsp;     * #URI(String)} constructor and then invoking the {@link
<i>734</i>&nbsp;     * #parseServerAuthority()} method upon the result; this may cause a {@link
<i>735</i>&nbsp;     * URISyntaxException} to be thrown.  &lt;/p&gt;
<i>736</i>&nbsp;     *
<i>737</i>&nbsp;     * @param   scheme     Scheme name
<i>738</i>&nbsp;     * @param   authority  Authority
<i>739</i>&nbsp;     * @param   path       Path
<i>740</i>&nbsp;     * @param   query      Query
<b class="nc"><i>741</i>&nbsp;     * @param   fragment   Fragment</b>
<b class="nc"><i>742</i>&nbsp;     *</b>
<i>743</i>&nbsp;     * @throws URISyntaxException
<i>744</i>&nbsp;     *         If both a scheme and a path are given but the path is relative,
<b class="nc"><i>745</i>&nbsp;     *         if the URI string constructed from the given components violates</b>
<b class="nc"><i>746</i>&nbsp;     *         RFC&amp;nbsp;2396, or if the authority component of the string is</b>
<i>747</i>&nbsp;     *         present but cannot be parsed as a server-based authority
<i>748</i>&nbsp;     */
<i>749</i>&nbsp;    public URI(String scheme,
<i>750</i>&nbsp;               String authority,
<i>751</i>&nbsp;               String path, String query, String fragment)
<i>752</i>&nbsp;        throws URISyntaxException
<i>753</i>&nbsp;    {
<i>754</i>&nbsp;        String s = toString(scheme, null,
<i>755</i>&nbsp;                            authority, null, null, -1,
<i>756</i>&nbsp;                            path, query, fragment);
<i>757</i>&nbsp;        checkPath(s, scheme, path);
<i>758</i>&nbsp;        new Parser(s).parse(false);
<i>759</i>&nbsp;    }
<i>760</i>&nbsp;
<i>761</i>&nbsp;    /**
<i>762</i>&nbsp;     * Constructs a hierarchical URI from the given components.
<i>763</i>&nbsp;     *
<i>764</i>&nbsp;     * &lt;p&gt; A component may be left undefined by passing {@code null}.
<i>765</i>&nbsp;     *
<i>766</i>&nbsp;     * &lt;p&gt; This convenience constructor works as if by invoking the
<i>767</i>&nbsp;     * seven-argument constructor as follows:
<i>768</i>&nbsp;     *
<i>769</i>&nbsp;     * &lt;blockquote&gt;
<i>770</i>&nbsp;     * {@code new} {@link #URI(String, String, String, int, String, String, String)
<i>771</i>&nbsp;     * URI}{@code (scheme, null, host, -1, path, null, fragment);}
<i>772</i>&nbsp;     * &lt;/blockquote&gt;
<i>773</i>&nbsp;     *
<b class="nc"><i>774</i>&nbsp;     * @param   scheme    Scheme name</b>
<i>775</i>&nbsp;     * @param   host      Host name
<i>776</i>&nbsp;     * @param   path      Path
<i>777</i>&nbsp;     * @param   fragment  Fragment
<i>778</i>&nbsp;     *
<i>779</i>&nbsp;     * @throws  URISyntaxException
<i>780</i>&nbsp;     *          If the URI string constructed from the given components
<i>781</i>&nbsp;     *          violates RFC&amp;nbsp;2396
<i>782</i>&nbsp;     */
<i>783</i>&nbsp;    public URI(String scheme, String host, String path, String fragment)
<i>784</i>&nbsp;        throws URISyntaxException
<i>785</i>&nbsp;    {
<i>786</i>&nbsp;        this(scheme, null, host, -1, path, null, fragment);
<i>787</i>&nbsp;    }
<i>788</i>&nbsp;
<i>789</i>&nbsp;    /**
<i>790</i>&nbsp;     * Constructs a URI from the given components.
<i>791</i>&nbsp;     *
<i>792</i>&nbsp;     * &lt;p&gt; A component may be left undefined by passing {@code null}.
<i>793</i>&nbsp;     *
<i>794</i>&nbsp;     * &lt;p&gt; This constructor first builds a URI in string form using the given
<i>795</i>&nbsp;     * components as follows:  &lt;/p&gt;
<i>796</i>&nbsp;     *
<i>797</i>&nbsp;     * &lt;ol&gt;
<i>798</i>&nbsp;     *
<i>799</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Initially, the result string is empty.  &lt;/p&gt;&lt;/li&gt;
<i>800</i>&nbsp;     *
<i>801</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a scheme is given then it is appended to the result,
<i>802</i>&nbsp;     *   followed by a colon character ({@code &#39;:&#39;}).  &lt;/p&gt;&lt;/li&gt;
<i>803</i>&nbsp;     *
<i>804</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a scheme-specific part is given then it is appended.  Any
<i>805</i>&nbsp;     *   character that is not a &lt;a href=&quot;#legal-chars&quot;&gt;legal URI character&lt;/a&gt;
<i>806</i>&nbsp;     *   is &lt;a href=&quot;#quote&quot;&gt;quoted&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
<i>807</i>&nbsp;     *
<i>808</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Finally, if a fragment is given then a hash character
<i>809</i>&nbsp;     *   ({@code &#39;#&#39;}) is appended to the string, followed by the fragment.
<i>810</i>&nbsp;     *   Any character that is not a legal URI character is quoted.  &lt;/p&gt;&lt;/li&gt;
<i>811</i>&nbsp;     *
<i>812</i>&nbsp;     * &lt;/ol&gt;
<i>813</i>&nbsp;     *
<i>814</i>&nbsp;     * &lt;p&gt; The resulting URI string is then parsed in order to create the new
<i>815</i>&nbsp;     * URI instance as if by invoking the {@link #URI(String)} constructor;
<b class="nc"><i>816</i>&nbsp;     * this may cause a {@link URISyntaxException} to be thrown.  &lt;/p&gt;</b>
<b class="nc"><i>817</i>&nbsp;     *</b>
<i>818</i>&nbsp;     * @param   scheme    Scheme name
<i>819</i>&nbsp;     * @param   ssp       Scheme-specific part
<b class="nc"><i>820</i>&nbsp;     * @param   fragment  Fragment</b>
<i>821</i>&nbsp;     *
<i>822</i>&nbsp;     * @throws  URISyntaxException
<i>823</i>&nbsp;     *          If the URI string constructed from the given components
<i>824</i>&nbsp;     *          violates RFC&amp;nbsp;2396
<i>825</i>&nbsp;     */
<i>826</i>&nbsp;    public URI(String scheme, String ssp, String fragment)
<i>827</i>&nbsp;        throws URISyntaxException
<i>828</i>&nbsp;    {
<i>829</i>&nbsp;        new Parser(toString(scheme, ssp,
<i>830</i>&nbsp;                            null, null, null, -1,
<i>831</i>&nbsp;                            null, null, fragment))
<i>832</i>&nbsp;            .parse(false);
<i>833</i>&nbsp;    }
<i>834</i>&nbsp;
<i>835</i>&nbsp;    /**
<i>836</i>&nbsp;     * Constructs a simple URI consisting of only a scheme and a pre-validated
<i>837</i>&nbsp;     * path. Provides a fast-path for some internal cases.
<i>838</i>&nbsp;     */
<i>839</i>&nbsp;    URI(String scheme, String path) {
<i>840</i>&nbsp;        assert validSchemeAndPath(scheme, path);
<i>841</i>&nbsp;        this.scheme = scheme;
<i>842</i>&nbsp;        this.path = path;
<i>843</i>&nbsp;    }
<i>844</i>&nbsp;
<i>845</i>&nbsp;    private static boolean validSchemeAndPath(String scheme, String path) {
<i>846</i>&nbsp;        try {
<i>847</i>&nbsp;            URI u = new URI(scheme + &quot;:&quot; + path);
<i>848</i>&nbsp;            return scheme.equals(u.scheme) &amp;&amp; path.equals(u.path);
<i>849</i>&nbsp;        } catch (URISyntaxException e) {
<b class="nc"><i>850</i>&nbsp;            return false;</b>
<b class="nc"><i>851</i>&nbsp;        }</b>
<b class="nc"><i>852</i>&nbsp;    }</b>
<i>853</i>&nbsp;
<i>854</i>&nbsp;    /**
<i>855</i>&nbsp;     * Creates a URI by parsing the given string.
<i>856</i>&nbsp;     *
<i>857</i>&nbsp;     * &lt;p&gt; This convenience factory method works as if by invoking the {@link
<i>858</i>&nbsp;     * #URI(String)} constructor; any {@link URISyntaxException} thrown by the
<i>859</i>&nbsp;     * constructor is caught and wrapped in a new {@link
<i>860</i>&nbsp;     * IllegalArgumentException} object, which is then thrown.
<i>861</i>&nbsp;     *
<i>862</i>&nbsp;     * &lt;p&gt; This method is provided for use in situations where it is known that
<i>863</i>&nbsp;     * the given string is a legal URI, for example for URI constants declared
<i>864</i>&nbsp;     * within in a program, and so it would be considered a programming error
<i>865</i>&nbsp;     * for the string not to parse as such.  The constructors, which throw
<i>866</i>&nbsp;     * {@link URISyntaxException} directly, should be used situations where a
<i>867</i>&nbsp;     * URI is being constructed from user input or from some other source that
<i>868</i>&nbsp;     * may be prone to errors.  &lt;/p&gt;
<i>869</i>&nbsp;     *
<i>870</i>&nbsp;     * @param  str   The string to be parsed into a URI
<i>871</i>&nbsp;     * @return The new URI
<i>872</i>&nbsp;     *
<i>873</i>&nbsp;     * @throws  NullPointerException
<i>874</i>&nbsp;     *          If {@code str} is {@code null}
<i>875</i>&nbsp;     *
<i>876</i>&nbsp;     * @throws  IllegalArgumentException
<i>877</i>&nbsp;     *          If the given string violates RFC&amp;nbsp;2396
<i>878</i>&nbsp;     */
<i>879</i>&nbsp;    public static URI create(String str) {
<i>880</i>&nbsp;        try {
<i>881</i>&nbsp;            return new URI(str);
<i>882</i>&nbsp;        } catch (URISyntaxException x) {
<i>883</i>&nbsp;            throw new IllegalArgumentException(x.getMessage(), x);
<i>884</i>&nbsp;        }
<i>885</i>&nbsp;    }
<i>886</i>&nbsp;
<i>887</i>&nbsp;
<i>888</i>&nbsp;    // -- Operations --
<i>889</i>&nbsp;
<i>890</i>&nbsp;    /**
<i>891</i>&nbsp;     * Attempts to parse this URI&#39;s authority component, if defined, into
<i>892</i>&nbsp;     * user-information, host, and port components.
<i>893</i>&nbsp;     *
<i>894</i>&nbsp;     * &lt;p&gt; If this URI&#39;s authority component has already been recognized as
<i>895</i>&nbsp;     * being server-based then it will already have been parsed into
<i>896</i>&nbsp;     * user-information, host, and port components.  In this case, or if this
<i>897</i>&nbsp;     * URI has no authority component, this method simply returns this URI.
<i>898</i>&nbsp;     *
<i>899</i>&nbsp;     * &lt;p&gt; Otherwise this method attempts once more to parse the authority
<i>900</i>&nbsp;     * component into user-information, host, and port components, and throws
<i>901</i>&nbsp;     * an exception describing why the authority component could not be parsed
<i>902</i>&nbsp;     * in that way.
<i>903</i>&nbsp;     *
<i>904</i>&nbsp;     * &lt;p&gt; This method is provided because the generic URI syntax specified in
<i>905</i>&nbsp;     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;
<i>906</i>&nbsp;     * cannot always distinguish a malformed server-based authority from a
<i>907</i>&nbsp;     * legitimate registry-based authority.  It must therefore treat some
<i>908</i>&nbsp;     * instances of the former as instances of the latter.  The authority
<i>909</i>&nbsp;     * component in the URI string {@code &quot;//foo:bar&quot;}, for example, is not a
<i>910</i>&nbsp;     * legal server-based authority but it is legal as a registry-based
<i>911</i>&nbsp;     * authority.
<b class="nc"><i>912</i>&nbsp;     *</b>
<b class="nc"><i>913</i>&nbsp;     * &lt;p&gt; In many common situations, for example when working URIs that are</b>
<b class="nc"><i>914</i>&nbsp;     * known to be either URNs or URLs, the hierarchical URIs being used will</b>
<b class="nc"><i>915</i>&nbsp;     * always be server-based.  They therefore must either be parsed as such or</b>
<b class="nc"><i>916</i>&nbsp;     * treated as an error.  In these cases a statement such as</b>
<i>917</i>&nbsp;     *
<i>918</i>&nbsp;     * &lt;blockquote&gt;
<i>919</i>&nbsp;     * {@code URI }&lt;i&gt;u&lt;/i&gt;{@code  = new URI(str).parseServerAuthority();}
<i>920</i>&nbsp;     * &lt;/blockquote&gt;
<i>921</i>&nbsp;     *
<i>922</i>&nbsp;     * &lt;p&gt; can be used to ensure that &lt;i&gt;u&lt;/i&gt; always refers to a URI that, if
<i>923</i>&nbsp;     * it has an authority component, has a server-based authority with proper
<i>924</i>&nbsp;     * user-information, host, and port components.  Invoking this method also
<i>925</i>&nbsp;     * ensures that if the authority could not be parsed in that way then an
<i>926</i>&nbsp;     * appropriate diagnostic message can be issued based upon the exception
<i>927</i>&nbsp;     * that is thrown. &lt;/p&gt;
<i>928</i>&nbsp;     *
<i>929</i>&nbsp;     * @return  A URI whose authority field has been parsed
<i>930</i>&nbsp;     *          as a server-based authority
<i>931</i>&nbsp;     *
<i>932</i>&nbsp;     * @throws  URISyntaxException
<i>933</i>&nbsp;     *          If the authority component of this URI is defined
<i>934</i>&nbsp;     *          but cannot be parsed as a server-based authority
<i>935</i>&nbsp;     *          according to RFC&amp;nbsp;2396
<i>936</i>&nbsp;     */
<i>937</i>&nbsp;    public URI parseServerAuthority()
<i>938</i>&nbsp;        throws URISyntaxException
<i>939</i>&nbsp;    {
<i>940</i>&nbsp;        // We could be clever and cache the error message and index from the
<i>941</i>&nbsp;        // exception thrown during the original parse, but that would require
<i>942</i>&nbsp;        // either more fields or a more-obscure representation.
<i>943</i>&nbsp;        if ((host != null) || (authority == null))
<i>944</i>&nbsp;            return this;
<i>945</i>&nbsp;        new Parser(toString()).parse(true);
<i>946</i>&nbsp;        return this;
<i>947</i>&nbsp;    }
<i>948</i>&nbsp;
<i>949</i>&nbsp;    /**
<i>950</i>&nbsp;     * Normalizes this URI&#39;s path.
<i>951</i>&nbsp;     *
<i>952</i>&nbsp;     * &lt;p&gt; If this URI is opaque, or if its path is already in normal form,
<i>953</i>&nbsp;     * then this URI is returned.  Otherwise a new URI is constructed that is
<i>954</i>&nbsp;     * identical to this URI except that its path is computed by normalizing
<i>955</i>&nbsp;     * this URI&#39;s path in a manner consistent with &lt;a
<i>956</i>&nbsp;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
<b class="nc"><i>957</i>&nbsp;     * section&amp;nbsp;5.2, step&amp;nbsp;6, sub-steps&amp;nbsp;c through&amp;nbsp;f; that is:</b>
<i>958</i>&nbsp;     * &lt;/p&gt;
<i>959</i>&nbsp;     *
<i>960</i>&nbsp;     * &lt;ol&gt;
<i>961</i>&nbsp;     *
<i>962</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; All {@code &quot;.&quot;} segments are removed. &lt;/p&gt;&lt;/li&gt;
<i>963</i>&nbsp;     *
<i>964</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If a {@code &quot;..&quot;} segment is preceded by a non-{@code &quot;..&quot;}
<i>965</i>&nbsp;     *   segment then both of these segments are removed.  This step is
<i>966</i>&nbsp;     *   repeated until it is no longer applicable. &lt;/p&gt;&lt;/li&gt;
<i>967</i>&nbsp;     *
<i>968</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If the path is relative, and if its first segment contains a
<i>969</i>&nbsp;     *   colon character ({@code &#39;:&#39;}), then a {@code &quot;.&quot;} segment is
<i>970</i>&nbsp;     *   prepended.  This prevents a relative URI with a path such as
<i>971</i>&nbsp;     *   {@code &quot;a:b/c/d&quot;} from later being re-parsed as an opaque URI with a
<i>972</i>&nbsp;     *   scheme of {@code &quot;a&quot;} and a scheme-specific part of {@code &quot;b/c/d&quot;}.
<i>973</i>&nbsp;     *   &lt;b&gt;&lt;i&gt;(Deviation from RFC&amp;nbsp;2396)&lt;/i&gt;&lt;/b&gt; &lt;/p&gt;&lt;/li&gt;
<i>974</i>&nbsp;     *
<i>975</i>&nbsp;     * &lt;/ol&gt;
<i>976</i>&nbsp;     *
<i>977</i>&nbsp;     * &lt;p&gt; A normalized path will begin with one or more {@code &quot;..&quot;} segments
<i>978</i>&nbsp;     * if there were insufficient non-{@code &quot;..&quot;} segments preceding them to
<i>979</i>&nbsp;     * allow their removal.  A normalized path will begin with a {@code &quot;.&quot;}
<i>980</i>&nbsp;     * segment if one was inserted by step 3 above.  Otherwise, a normalized
<i>981</i>&nbsp;     * path will not contain any {@code &quot;.&quot;} or {@code &quot;..&quot;} segments. &lt;/p&gt;
<i>982</i>&nbsp;     *
<i>983</i>&nbsp;     * @return  A URI equivalent to this URI,
<i>984</i>&nbsp;     *          but whose path is in normal form
<i>985</i>&nbsp;     */
<i>986</i>&nbsp;    public URI normalize() {
<i>987</i>&nbsp;        return normalize(this);
<i>988</i>&nbsp;    }
<i>989</i>&nbsp;
<i>990</i>&nbsp;    /**
<i>991</i>&nbsp;     * Resolves the given URI against this URI.
<i>992</i>&nbsp;     *
<i>993</i>&nbsp;     * &lt;p&gt; If the given URI is already absolute, or if this URI is opaque, then
<i>994</i>&nbsp;     * the given URI is returned.
<i>995</i>&nbsp;     *
<i>996</i>&nbsp;     * &lt;p&gt;&lt;a id=&quot;resolve-frag&quot;&gt;&lt;/a&gt; If the given URI&#39;s fragment component is
<i>997</i>&nbsp;     * defined, its path component is empty, and its scheme, authority, and
<i>998</i>&nbsp;     * query components are undefined, then a URI with the given fragment but
<i>999</i>&nbsp;     * with all other components equal to those of this URI is returned.  This
<i>1000</i>&nbsp;     * allows a URI representing a standalone fragment reference, such as
<i>1001</i>&nbsp;     * {@code &quot;#foo&quot;}, to be usefully resolved against a base URI.
<i>1002</i>&nbsp;     *
<i>1003</i>&nbsp;     * &lt;p&gt; Otherwise this method constructs a new hierarchical URI in a manner
<i>1004</i>&nbsp;     * consistent with &lt;a
<i>1005</i>&nbsp;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,
<i>1006</i>&nbsp;     * section&amp;nbsp;5.2; that is: &lt;/p&gt;
<i>1007</i>&nbsp;     *
<i>1008</i>&nbsp;     * &lt;ol&gt;
<i>1009</i>&nbsp;     *
<i>1010</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; A new URI is constructed with this URI&#39;s scheme and the given
<i>1011</i>&nbsp;     *   URI&#39;s query and fragment components. &lt;/p&gt;&lt;/li&gt;
<i>1012</i>&nbsp;     *
<i>1013</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If the given URI has an authority component then the new URI&#39;s
<i>1014</i>&nbsp;     *   authority and path are taken from the given URI. &lt;/p&gt;&lt;/li&gt;
<b class="nc"><i>1015</i>&nbsp;     *</b>
<i>1016</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Otherwise the new URI&#39;s authority component is copied from
<i>1017</i>&nbsp;     *   this URI, and its path is computed as follows: &lt;/p&gt;
<i>1018</i>&nbsp;     *
<i>1019</i>&nbsp;     *   &lt;ol&gt;
<i>1020</i>&nbsp;     *
<i>1021</i>&nbsp;     *     &lt;li&gt;&lt;p&gt; If the given URI&#39;s path is absolute then the new URI&#39;s path
<i>1022</i>&nbsp;     *     is taken from the given URI. &lt;/p&gt;&lt;/li&gt;
<i>1023</i>&nbsp;     *
<i>1024</i>&nbsp;     *     &lt;li&gt;&lt;p&gt; Otherwise the given URI&#39;s path is relative, and so the new
<i>1025</i>&nbsp;     *     URI&#39;s path is computed by resolving the path of the given URI
<i>1026</i>&nbsp;     *     against the path of this URI.  This is done by concatenating all but
<i>1027</i>&nbsp;     *     the last segment of this URI&#39;s path, if any, with the given URI&#39;s
<i>1028</i>&nbsp;     *     path and then normalizing the result as if by invoking the {@link
<i>1029</i>&nbsp;     *     #normalize() normalize} method. &lt;/p&gt;&lt;/li&gt;
<i>1030</i>&nbsp;     *
<i>1031</i>&nbsp;     *   &lt;/ol&gt;&lt;/li&gt;
<i>1032</i>&nbsp;     *
<i>1033</i>&nbsp;     * &lt;/ol&gt;
<i>1034</i>&nbsp;     *
<i>1035</i>&nbsp;     * &lt;p&gt; The result of this method is absolute if, and only if, either this
<b class="nc"><i>1036</i>&nbsp;     * URI is absolute or the given URI is absolute.  &lt;/p&gt;</b>
<i>1037</i>&nbsp;     *
<i>1038</i>&nbsp;     * @param  uri  The URI to be resolved against this URI
<i>1039</i>&nbsp;     * @return The resulting URI
<i>1040</i>&nbsp;     *
<i>1041</i>&nbsp;     * @throws  NullPointerException
<i>1042</i>&nbsp;     *          If {@code uri} is {@code null}
<i>1043</i>&nbsp;     */
<i>1044</i>&nbsp;    public URI resolve(URI uri) {
<i>1045</i>&nbsp;        return resolve(this, uri);
<i>1046</i>&nbsp;    }
<i>1047</i>&nbsp;
<i>1048</i>&nbsp;    /**
<i>1049</i>&nbsp;     * Constructs a new URI by parsing the given string and then resolving it
<i>1050</i>&nbsp;     * against this URI.
<i>1051</i>&nbsp;     *
<i>1052</i>&nbsp;     * &lt;p&gt; This convenience method works as if invoking it were equivalent to
<i>1053</i>&nbsp;     * evaluating the expression {@link #resolve(java.net.URI)
<i>1054</i>&nbsp;     * resolve}{@code (URI.}{@link #create(String) create}{@code (str))}. &lt;/p&gt;
<i>1055</i>&nbsp;     *
<i>1056</i>&nbsp;     * @param  str   The string to be parsed into a URI
<i>1057</i>&nbsp;     * @return The resulting URI
<i>1058</i>&nbsp;     *
<i>1059</i>&nbsp;     * @throws  NullPointerException
<i>1060</i>&nbsp;     *          If {@code str} is {@code null}
<i>1061</i>&nbsp;     *
<i>1062</i>&nbsp;     * @throws  IllegalArgumentException
<i>1063</i>&nbsp;     *          If the given string violates RFC&amp;nbsp;2396
<i>1064</i>&nbsp;     */
<i>1065</i>&nbsp;    public URI resolve(String str) {
<b class="nc"><i>1066</i>&nbsp;        return resolve(URI.create(str));</b>
<i>1067</i>&nbsp;    }
<i>1068</i>&nbsp;
<i>1069</i>&nbsp;    /**
<i>1070</i>&nbsp;     * Relativizes the given URI against this URI.
<i>1071</i>&nbsp;     *
<i>1072</i>&nbsp;     * &lt;p&gt; The relativization of the given URI against this URI is computed as
<i>1073</i>&nbsp;     * follows: &lt;/p&gt;
<i>1074</i>&nbsp;     *
<i>1075</i>&nbsp;     * &lt;ol&gt;
<i>1076</i>&nbsp;     *
<i>1077</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; If either this URI or the given URI are opaque, or if the
<i>1078</i>&nbsp;     *   scheme and authority components of the two URIs are not identical, or
<i>1079</i>&nbsp;     *   if the path of this URI is not a prefix of the path of the given URI,
<i>1080</i>&nbsp;     *   then the given URI is returned. &lt;/p&gt;&lt;/li&gt;
<i>1081</i>&nbsp;     *
<i>1082</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Otherwise a new relative hierarchical URI is constructed with
<i>1083</i>&nbsp;     *   query and fragment components taken from the given URI and with a path
<i>1084</i>&nbsp;     *   component computed by removing this URI&#39;s path from the beginning of
<i>1085</i>&nbsp;     *   the given URI&#39;s path. &lt;/p&gt;&lt;/li&gt;
<i>1086</i>&nbsp;     *
<b class="nc"><i>1087</i>&nbsp;     * &lt;/ol&gt;</b>
<b class="nc"><i>1088</i>&nbsp;     *</b>
<b class="nc"><i>1089</i>&nbsp;     * @param  uri  The URI to be relativized against this URI</b>
<i>1090</i>&nbsp;     * @return The resulting URI
<i>1091</i>&nbsp;     *
<i>1092</i>&nbsp;     * @throws  NullPointerException
<i>1093</i>&nbsp;     *          If {@code uri} is {@code null}
<i>1094</i>&nbsp;     */
<i>1095</i>&nbsp;    public URI relativize(URI uri) {
<i>1096</i>&nbsp;        return relativize(this, uri);
<i>1097</i>&nbsp;    }
<i>1098</i>&nbsp;
<i>1099</i>&nbsp;    /**
<i>1100</i>&nbsp;     * Constructs a URL from this URI.
<i>1101</i>&nbsp;     *
<i>1102</i>&nbsp;     * &lt;p&gt; This convenience method works as if invoking it were equivalent to
<i>1103</i>&nbsp;     * evaluating the expression {@code new URL(this.toString())} after
<i>1104</i>&nbsp;     * first checking that this URI is absolute. &lt;/p&gt;
<i>1105</i>&nbsp;     *
<i>1106</i>&nbsp;     * @return  A URL constructed from this URI
<i>1107</i>&nbsp;     *
<b class="nc"><i>1108</i>&nbsp;     * @throws  IllegalArgumentException</b>
<i>1109</i>&nbsp;     *          If this URL is not absolute
<i>1110</i>&nbsp;     *
<i>1111</i>&nbsp;     * @throws  MalformedURLException
<i>1112</i>&nbsp;     *          If a protocol handler for the URL could not be found,
<i>1113</i>&nbsp;     *          or if some other error occurred while constructing the URL
<i>1114</i>&nbsp;     */
<i>1115</i>&nbsp;    public URL toURL() throws MalformedURLException {
<i>1116</i>&nbsp;        return URL.fromURI(this);
<i>1117</i>&nbsp;    }
<i>1118</i>&nbsp;
<b class="nc"><i>1119</i>&nbsp;    // -- Component access methods --</b>
<i>1120</i>&nbsp;
<i>1121</i>&nbsp;    /**
<i>1122</i>&nbsp;     * Returns the scheme component of this URI.
<i>1123</i>&nbsp;     *
<i>1124</i>&nbsp;     * &lt;p&gt; The scheme component of a URI, if defined, only contains characters
<i>1125</i>&nbsp;     * in the &lt;i&gt;alphanum&lt;/i&gt; category and in the string {@code &quot;-.+&quot;}.  A
<i>1126</i>&nbsp;     * scheme always starts with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;p&gt;
<i>1127</i>&nbsp;     *
<i>1128</i>&nbsp;     * The scheme component of a URI cannot contain escaped octets, hence this
<i>1129</i>&nbsp;     * method does not perform any decoding.
<i>1130</i>&nbsp;     *
<i>1131</i>&nbsp;     * @return  The scheme component of this URI,
<i>1132</i>&nbsp;     *          or {@code null} if the scheme is undefined
<b class="nc"><i>1133</i>&nbsp;     */</b>
<i>1134</i>&nbsp;    public String getScheme() {
<i>1135</i>&nbsp;        return scheme;
<i>1136</i>&nbsp;    }
<i>1137</i>&nbsp;
<i>1138</i>&nbsp;    /**
<i>1139</i>&nbsp;     * Tells whether or not this URI is absolute.
<i>1140</i>&nbsp;     *
<i>1141</i>&nbsp;     * &lt;p&gt; A URI is absolute if, and only if, it has a scheme component. &lt;/p&gt;
<i>1142</i>&nbsp;     *
<i>1143</i>&nbsp;     * @return  {@code true} if, and only if, this URI is absolute
<i>1144</i>&nbsp;     */
<i>1145</i>&nbsp;    public boolean isAbsolute() {
<i>1146</i>&nbsp;        return scheme != null;
<b class="nc"><i>1147</i>&nbsp;    }</b>
<b class="nc"><i>1148</i>&nbsp;</b>
<i>1149</i>&nbsp;    /**
<i>1150</i>&nbsp;     * Tells whether or not this URI is opaque.
<i>1151</i>&nbsp;     *
<i>1152</i>&nbsp;     * &lt;p&gt; A URI is opaque if, and only if, it is absolute and its
<i>1153</i>&nbsp;     * scheme-specific part does not begin with a slash character (&#39;/&#39;).
<i>1154</i>&nbsp;     * An opaque URI has a scheme, a scheme-specific part, and possibly
<i>1155</i>&nbsp;     * a fragment; all other components are undefined. &lt;/p&gt;
<i>1156</i>&nbsp;     *
<i>1157</i>&nbsp;     * @return  {@code true} if, and only if, this URI is opaque
<i>1158</i>&nbsp;     */
<i>1159</i>&nbsp;    public boolean isOpaque() {
<i>1160</i>&nbsp;        return path == null;
<i>1161</i>&nbsp;    }
<i>1162</i>&nbsp;
<b class="nc"><i>1163</i>&nbsp;    /**</b>
<b class="nc"><i>1164</i>&nbsp;     * Returns the raw scheme-specific part of this URI.  The scheme-specific</b>
<b class="nc"><i>1165</i>&nbsp;     * part is never undefined, though it may be empty.</b>
<i>1166</i>&nbsp;     *
<i>1167</i>&nbsp;     * &lt;p&gt; The scheme-specific part of a URI only contains legal URI
<i>1168</i>&nbsp;     * characters. &lt;/p&gt;
<i>1169</i>&nbsp;     *
<i>1170</i>&nbsp;     * @return  The raw scheme-specific part of this URI
<i>1171</i>&nbsp;     *          (never {@code null})
<i>1172</i>&nbsp;     */
<i>1173</i>&nbsp;    public String getRawSchemeSpecificPart() {
<i>1174</i>&nbsp;        String part = schemeSpecificPart;
<i>1175</i>&nbsp;        if (part != null) {
<i>1176</i>&nbsp;            return part;
<i>1177</i>&nbsp;        }
<i>1178</i>&nbsp;
<i>1179</i>&nbsp;        String s = string;
<i>1180</i>&nbsp;        if (s != null) {
<i>1181</i>&nbsp;            // if string is defined, components will have been parsed
<b class="nc"><i>1182</i>&nbsp;            int start = 0;</b>
<i>1183</i>&nbsp;            int end = s.length();
<i>1184</i>&nbsp;            if (scheme != null) {
<i>1185</i>&nbsp;                start = scheme.length() + 1;
<i>1186</i>&nbsp;            }
<i>1187</i>&nbsp;            if (fragment != null) {
<i>1188</i>&nbsp;                end -= fragment.length() + 1;
<i>1189</i>&nbsp;            }
<i>1190</i>&nbsp;            if (path != null &amp;&amp; path.length() == end - start) {
<i>1191</i>&nbsp;                part = path;
<i>1192</i>&nbsp;            } else {
<i>1193</i>&nbsp;                part = s.substring(start, end);
<i>1194</i>&nbsp;            }
<i>1195</i>&nbsp;        } else {
<b class="nc"><i>1196</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>1197</i>&nbsp;            appendSchemeSpecificPart(sb, null, getAuthority(), getUserInfo(),</b>
<b class="nc"><i>1198</i>&nbsp;                                 host, port, getPath(), getQuery());</b>
<i>1199</i>&nbsp;            part = sb.toString();
<i>1200</i>&nbsp;        }
<i>1201</i>&nbsp;        return schemeSpecificPart = part;
<i>1202</i>&nbsp;    }
<i>1203</i>&nbsp;
<i>1204</i>&nbsp;    /**
<i>1205</i>&nbsp;     * Returns the decoded scheme-specific part of this URI.
<i>1206</i>&nbsp;     *
<i>1207</i>&nbsp;     * &lt;p&gt; The string returned by this method is equal to that returned by the
<i>1208</i>&nbsp;     * {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method
<i>1209</i>&nbsp;     * except that all sequences of escaped octets are &lt;a
<i>1210</i>&nbsp;     * href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
<i>1211</i>&nbsp;     *
<b class="nc"><i>1212</i>&nbsp;     * @return  The decoded scheme-specific part of this URI</b>
<i>1213</i>&nbsp;     *          (never {@code null})
<i>1214</i>&nbsp;     */
<i>1215</i>&nbsp;    public String getSchemeSpecificPart() {
<i>1216</i>&nbsp;        String part = decodedSchemeSpecificPart;
<i>1217</i>&nbsp;        if (part == null) {
<i>1218</i>&nbsp;            decodedSchemeSpecificPart = part = decode(getRawSchemeSpecificPart());
<i>1219</i>&nbsp;        }
<i>1220</i>&nbsp;        return part;
<i>1221</i>&nbsp;    }
<i>1222</i>&nbsp;
<i>1223</i>&nbsp;    /**
<i>1224</i>&nbsp;     * Returns the raw authority component of this URI.
<i>1225</i>&nbsp;     *
<b class="nc"><i>1226</i>&nbsp;     * &lt;p&gt; The authority component of a URI, if defined, only contains the</b>
<b class="nc"><i>1227</i>&nbsp;     * commercial-at character ({@code &#39;@&#39;}) and characters in the</b>
<b class="nc"><i>1228</i>&nbsp;     * &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and &lt;i&gt;other&lt;/i&gt;</b>
<i>1229</i>&nbsp;     * categories.  If the authority is server-based then it is further
<i>1230</i>&nbsp;     * constrained to have valid user-information, host, and port
<i>1231</i>&nbsp;     * components. &lt;/p&gt;
<i>1232</i>&nbsp;     *
<i>1233</i>&nbsp;     * @return  The raw authority component of this URI,
<i>1234</i>&nbsp;     *          or {@code null} if the authority is undefined
<i>1235</i>&nbsp;     */
<i>1236</i>&nbsp;    public String getRawAuthority() {
<i>1237</i>&nbsp;        return authority;
<i>1238</i>&nbsp;    }
<i>1239</i>&nbsp;
<i>1240</i>&nbsp;    /**
<i>1241</i>&nbsp;     * Returns the decoded authority component of this URI.
<i>1242</i>&nbsp;     *
<i>1243</i>&nbsp;     * &lt;p&gt; The string returned by this method is equal to that returned by the
<i>1244</i>&nbsp;     * {@link #getRawAuthority() getRawAuthority} method except that all
<i>1245</i>&nbsp;     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
<i>1246</i>&nbsp;     *
<i>1247</i>&nbsp;     * @return  The decoded authority component of this URI,
<i>1248</i>&nbsp;     *          or {@code null} if the authority is undefined
<i>1249</i>&nbsp;     */
<i>1250</i>&nbsp;    public String getAuthority() {
<i>1251</i>&nbsp;        String auth = decodedAuthority;
<i>1252</i>&nbsp;        if ((auth == null) &amp;&amp; (authority != null)) {
<i>1253</i>&nbsp;            decodedAuthority = auth = decode(authority);
<i>1254</i>&nbsp;        }
<i>1255</i>&nbsp;        return auth;
<i>1256</i>&nbsp;    }
<i>1257</i>&nbsp;
<i>1258</i>&nbsp;    /**
<i>1259</i>&nbsp;     * Returns the raw user-information component of this URI.
<i>1260</i>&nbsp;     *
<i>1261</i>&nbsp;     * &lt;p&gt; The user-information component of a URI, if defined, only contains
<i>1262</i>&nbsp;     * characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;, and
<i>1263</i>&nbsp;     * &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;
<i>1264</i>&nbsp;     *
<i>1265</i>&nbsp;     * @return  The raw user-information component of this URI,
<i>1266</i>&nbsp;     *          or {@code null} if the user information is undefined
<i>1267</i>&nbsp;     */
<b class="nc"><i>1268</i>&nbsp;    public String getRawUserInfo() {</b>
<i>1269</i>&nbsp;        return userInfo;
<i>1270</i>&nbsp;    }
<i>1271</i>&nbsp;
<i>1272</i>&nbsp;    /**
<i>1273</i>&nbsp;     * Returns the decoded user-information component of this URI.
<i>1274</i>&nbsp;     *
<i>1275</i>&nbsp;     * &lt;p&gt; The string returned by this method is equal to that returned by the
<i>1276</i>&nbsp;     * {@link #getRawUserInfo() getRawUserInfo} method except that all
<i>1277</i>&nbsp;     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
<i>1278</i>&nbsp;     *
<i>1279</i>&nbsp;     * @return  The decoded user-information component of this URI,
<i>1280</i>&nbsp;     *          or {@code null} if the user information is undefined
<b class="nc"><i>1281</i>&nbsp;     */</b>
<i>1282</i>&nbsp;    public String getUserInfo() {
<i>1283</i>&nbsp;        String user = decodedUserInfo;
<i>1284</i>&nbsp;        if ((user == null) &amp;&amp; (userInfo != null)) {
<i>1285</i>&nbsp;            decodedUserInfo = user = decode(userInfo);
<i>1286</i>&nbsp;        }
<i>1287</i>&nbsp;        return user;
<i>1288</i>&nbsp;    }
<i>1289</i>&nbsp;
<i>1290</i>&nbsp;    /**
<i>1291</i>&nbsp;     * Returns the host component of this URI.
<i>1292</i>&nbsp;     *
<i>1293</i>&nbsp;     * &lt;p&gt; The host component of a URI, if defined, will have one of the
<i>1294</i>&nbsp;     * following forms: &lt;/p&gt;
<i>1295</i>&nbsp;     *
<b class="nc"><i>1296</i>&nbsp;     * &lt;ul&gt;</b>
<i>1297</i>&nbsp;     *
<i>1298</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; A domain name consisting of one or more &lt;i&gt;labels&lt;/i&gt;
<i>1299</i>&nbsp;     *   separated by period characters ({@code &#39;.&#39;}), optionally followed by
<i>1300</i>&nbsp;     *   a period character.  Each label consists of &lt;i&gt;alphanum&lt;/i&gt; characters
<i>1301</i>&nbsp;     *   as well as hyphen characters ({@code &#39;-&#39;}), though hyphens never
<i>1302</i>&nbsp;     *   occur as the first or last characters in a label. The rightmost
<i>1303</i>&nbsp;     *   label of a domain name consisting of two or more labels, begins
<i>1304</i>&nbsp;     *   with an &lt;i&gt;alpha&lt;/i&gt; character. &lt;/li&gt;
<i>1305</i>&nbsp;     *
<i>1306</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; A dotted-quad IPv4 address of the form
<i>1307</i>&nbsp;     *   &lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +.}&lt;i&gt;digit&lt;/i&gt;{@code +},
<i>1308</i>&nbsp;     *   where no &lt;i&gt;digit&lt;/i&gt; sequence is longer than three characters and no
<i>1309</i>&nbsp;     *   sequence has a value larger than 255. &lt;/p&gt;&lt;/li&gt;
<b class="nc"><i>1310</i>&nbsp;     *</b>
<b class="nc"><i>1311</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; An IPv6 address enclosed in square brackets ({@code &#39;[&#39;} and</b>
<b class="nc"><i>1312</i>&nbsp;     *   {@code &#39;]&#39;}) and consisting of hexadecimal digits, colon characters</b>
<i>1313</i>&nbsp;     *   ({@code &#39;:&#39;}), and possibly an embedded IPv4 address.  The full
<i>1314</i>&nbsp;     *   syntax of IPv6 addresses is specified in &lt;a
<i>1315</i>&nbsp;     *   href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IPv6
<i>1316</i>&nbsp;     *   Addressing Architecture&lt;/i&gt;&lt;/a&gt;.  &lt;/p&gt;&lt;/li&gt;
<i>1317</i>&nbsp;     *
<i>1318</i>&nbsp;     * &lt;/ul&gt;
<i>1319</i>&nbsp;     *
<i>1320</i>&nbsp;     * The host component of a URI cannot contain escaped octets, hence this
<i>1321</i>&nbsp;     * method does not perform any decoding.
<i>1322</i>&nbsp;     *
<i>1323</i>&nbsp;     * @return  The host component of this URI,
<i>1324</i>&nbsp;     *          or {@code null} if the host is undefined
<b class="nc"><i>1325</i>&nbsp;     */</b>
<i>1326</i>&nbsp;    public String getHost() {
<i>1327</i>&nbsp;        return host;
<i>1328</i>&nbsp;    }
<i>1329</i>&nbsp;
<i>1330</i>&nbsp;    /**
<i>1331</i>&nbsp;     * Returns the port number of this URI.
<i>1332</i>&nbsp;     *
<i>1333</i>&nbsp;     * &lt;p&gt; The port component of a URI, if defined, is a non-negative
<i>1334</i>&nbsp;     * integer. &lt;/p&gt;
<i>1335</i>&nbsp;     *
<i>1336</i>&nbsp;     * @return  The port component of this URI,
<i>1337</i>&nbsp;     *          or {@code -1} if the port is undefined
<i>1338</i>&nbsp;     */
<b class="nc"><i>1339</i>&nbsp;    public int getPort() {</b>
<b class="nc"><i>1340</i>&nbsp;        return port;</b>
<b class="nc"><i>1341</i>&nbsp;    }</b>
<i>1342</i>&nbsp;
<i>1343</i>&nbsp;    /**
<i>1344</i>&nbsp;     * Returns the raw path component of this URI.
<i>1345</i>&nbsp;     *
<i>1346</i>&nbsp;     * &lt;p&gt; The path component of a URI, if defined, only contains the slash
<i>1347</i>&nbsp;     * character ({@code &#39;/&#39;}), the commercial-at character ({@code &#39;@&#39;}),
<i>1348</i>&nbsp;     * and characters in the &lt;i&gt;unreserved&lt;/i&gt;, &lt;i&gt;punct&lt;/i&gt;, &lt;i&gt;escaped&lt;/i&gt;,
<i>1349</i>&nbsp;     * and &lt;i&gt;other&lt;/i&gt; categories. &lt;/p&gt;
<i>1350</i>&nbsp;     *
<i>1351</i>&nbsp;     * @return  The path component of this URI,
<i>1352</i>&nbsp;     *          or {@code null} if the path is undefined
<i>1353</i>&nbsp;     */
<b class="nc"><i>1354</i>&nbsp;    public String getRawPath() {</b>
<i>1355</i>&nbsp;        return path;
<i>1356</i>&nbsp;    }
<i>1357</i>&nbsp;
<i>1358</i>&nbsp;    /**
<i>1359</i>&nbsp;     * Returns the decoded path component of this URI.
<i>1360</i>&nbsp;     *
<i>1361</i>&nbsp;     * &lt;p&gt; The string returned by this method is equal to that returned by the
<i>1362</i>&nbsp;     * {@link #getRawPath() getRawPath} method except that all sequences of
<i>1363</i>&nbsp;     * escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
<i>1364</i>&nbsp;     *
<i>1365</i>&nbsp;     * @return  The decoded path component of this URI,
<i>1366</i>&nbsp;     *          or {@code null} if the path is undefined
<i>1367</i>&nbsp;     */
<b class="nc"><i>1368</i>&nbsp;    public String getPath() {</b>
<b class="nc"><i>1369</i>&nbsp;        String decoded = decodedPath;</b>
<b class="nc"><i>1370</i>&nbsp;        if ((decoded == null) &amp;&amp; (path != null)) {</b>
<i>1371</i>&nbsp;            decodedPath = decoded = decode(path);
<i>1372</i>&nbsp;        }
<i>1373</i>&nbsp;        return decoded;
<i>1374</i>&nbsp;    }
<i>1375</i>&nbsp;
<i>1376</i>&nbsp;    /**
<i>1377</i>&nbsp;     * Returns the raw query component of this URI.
<i>1378</i>&nbsp;     *
<i>1379</i>&nbsp;     * &lt;p&gt; The query component of a URI, if defined, only contains legal URI
<i>1380</i>&nbsp;     * characters. &lt;/p&gt;
<i>1381</i>&nbsp;     *
<i>1382</i>&nbsp;     * @return  The raw query component of this URI,
<i>1383</i>&nbsp;     *          or {@code null} if the query is undefined
<i>1384</i>&nbsp;     */
<i>1385</i>&nbsp;    public String getRawQuery() {
<i>1386</i>&nbsp;        return query;
<i>1387</i>&nbsp;    }
<i>1388</i>&nbsp;
<i>1389</i>&nbsp;    /**
<i>1390</i>&nbsp;     * Returns the decoded query component of this URI.
<i>1391</i>&nbsp;     *
<i>1392</i>&nbsp;     * &lt;p&gt; The string returned by this method is equal to that returned by the
<i>1393</i>&nbsp;     * {@link #getRawQuery() getRawQuery} method except that all sequences of
<i>1394</i>&nbsp;     * escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;
<i>1395</i>&nbsp;     *
<i>1396</i>&nbsp;     * @return  The decoded query component of this URI,
<i>1397</i>&nbsp;     *          or {@code null} if the query is undefined
<i>1398</i>&nbsp;     */
<i>1399</i>&nbsp;    public String getQuery() {
<i>1400</i>&nbsp;        String decoded = decodedQuery;
<i>1401</i>&nbsp;        if ((decoded == null) &amp;&amp; (query != null)) {
<i>1402</i>&nbsp;            decodedQuery = decoded = decode(query, false);
<i>1403</i>&nbsp;        }
<i>1404</i>&nbsp;        return decoded;
<i>1405</i>&nbsp;    }
<i>1406</i>&nbsp;
<i>1407</i>&nbsp;    /**
<i>1408</i>&nbsp;     * Returns the raw fragment component of this URI.
<i>1409</i>&nbsp;     *
<i>1410</i>&nbsp;     * &lt;p&gt; The fragment component of a URI, if defined, only contains legal URI
<i>1411</i>&nbsp;     * characters. &lt;/p&gt;
<i>1412</i>&nbsp;     *
<i>1413</i>&nbsp;     * @return  The raw fragment component of this URI,
<b class="nc"><i>1414</i>&nbsp;     *          or {@code null} if the fragment is undefined</b>
<b class="nc"><i>1415</i>&nbsp;     */</b>
<b class="nc"><i>1416</i>&nbsp;    public String getRawFragment() {</b>
<b class="nc"><i>1417</i>&nbsp;        return fragment;</b>
<b class="nc"><i>1418</i>&nbsp;    }</b>
<b class="nc"><i>1419</i>&nbsp;</b>
<b class="nc"><i>1420</i>&nbsp;    /**</b>
<b class="nc"><i>1421</i>&nbsp;     * Returns the decoded fragment component of this URI.</b>
<i>1422</i>&nbsp;     *
<i>1423</i>&nbsp;     * &lt;p&gt; The string returned by this method is equal to that returned by the
<b class="nc"><i>1424</i>&nbsp;     * {@link #getRawFragment() getRawFragment} method except that all</b>
<b class="nc"><i>1425</i>&nbsp;     * sequences of escaped octets are &lt;a href=&quot;#decode&quot;&gt;decoded&lt;/a&gt;.  &lt;/p&gt;</b>
<i>1426</i>&nbsp;     *
<i>1427</i>&nbsp;     * @return  The decoded fragment component of this URI,
<b class="nc"><i>1428</i>&nbsp;     *          or {@code null} if the fragment is undefined</b>
<b class="nc"><i>1429</i>&nbsp;     */</b>
<i>1430</i>&nbsp;    public String getFragment() {
<i>1431</i>&nbsp;        String decoded = decodedFragment;
<b class="nc"><i>1432</i>&nbsp;        if ((decoded == null) &amp;&amp; (fragment != null)) {</b>
<b class="nc"><i>1433</i>&nbsp;            decodedFragment = decoded = decode(fragment, false);</b>
<i>1434</i>&nbsp;        }
<b class="nc"><i>1435</i>&nbsp;        return decoded;</b>
<b class="nc"><i>1436</i>&nbsp;    }</b>
<b class="nc"><i>1437</i>&nbsp;</b>
<b class="nc"><i>1438</i>&nbsp;</b>
<i>1439</i>&nbsp;    // -- Equality, comparison, hash code, toString, and serialization --
<b class="nc"><i>1440</i>&nbsp;</b>
<b class="nc"><i>1441</i>&nbsp;    /**</b>
<b class="nc"><i>1442</i>&nbsp;     * Tests this URI for equality with another object.</b>
<i>1443</i>&nbsp;     *
<i>1444</i>&nbsp;     * &lt;p&gt; If the given object is not a URI then this method immediately
<b class="nc"><i>1445</i>&nbsp;     * returns {@code false}.</b>
<i>1446</i>&nbsp;     *
<i>1447</i>&nbsp;     * &lt;p&gt; For two URIs to be considered equal requires that either both are
<i>1448</i>&nbsp;     * opaque or both are hierarchical.  Their schemes must either both be
<i>1449</i>&nbsp;     * undefined or else be equal without regard to case. Their fragments
<i>1450</i>&nbsp;     * must either both be undefined or else be equal.
<i>1451</i>&nbsp;     *
<i>1452</i>&nbsp;     * &lt;p&gt; For two opaque URIs to be considered equal, their scheme-specific
<i>1453</i>&nbsp;     * parts must be equal.
<i>1454</i>&nbsp;     *
<i>1455</i>&nbsp;     * &lt;p&gt; For two hierarchical URIs to be considered equal, their paths must
<b class="nc"><i>1456</i>&nbsp;     * be equal and their queries must either both be undefined or else be</b>
<b class="nc"><i>1457</i>&nbsp;     * equal.  Their authorities must either both be undefined, or both be</b>
<b class="nc"><i>1458</i>&nbsp;     * registry-based, or both be server-based.  If their authorities are</b>
<b class="nc"><i>1459</i>&nbsp;     * defined and are registry-based, then they must be equal.  If their</b>
<b class="nc"><i>1460</i>&nbsp;     * authorities are defined and are server-based, then their hosts must be</b>
<b class="nc"><i>1461</i>&nbsp;     * equal without regard to case, their port numbers must be equal, and</b>
<i>1462</i>&nbsp;     * their user-information components must be equal.
<b class="nc"><i>1463</i>&nbsp;     *</b>
<b class="nc"><i>1464</i>&nbsp;     * &lt;p&gt; When testing the user-information, path, query, fragment, authority,</b>
<b class="nc"><i>1465</i>&nbsp;     * or scheme-specific parts of two URIs for equality, the raw forms rather</b>
<b class="nc"><i>1466</i>&nbsp;     * than the encoded forms of these components are compared and the</b>
<b class="nc"><i>1467</i>&nbsp;     * hexadecimal digits of escaped octets are compared without regard to</b>
<b class="nc"><i>1468</i>&nbsp;     * case.</b>
<i>1469</i>&nbsp;     *
<b class="nc"><i>1470</i>&nbsp;     * &lt;p&gt; This method satisfies the general contract of the {@link</b>
<i>1471</i>&nbsp;     * java.lang.Object#equals(Object) Object.equals} method. &lt;/p&gt;
<i>1472</i>&nbsp;     *
<b class="nc"><i>1473</i>&nbsp;     * @param   ob   The object to which this object is to be compared</b>
<b class="nc"><i>1474</i>&nbsp;     *</b>
<i>1475</i>&nbsp;     * @return  {@code true} if, and only if, the given object is a URI that
<i>1476</i>&nbsp;     *          is identical to this URI
<i>1477</i>&nbsp;     */
<i>1478</i>&nbsp;    public boolean equals(Object ob) {
<i>1479</i>&nbsp;        if (ob == this)
<i>1480</i>&nbsp;            return true;
<i>1481</i>&nbsp;        if (!(ob instanceof URI))
<i>1482</i>&nbsp;            return false;
<i>1483</i>&nbsp;        URI that = (URI)ob;
<i>1484</i>&nbsp;        if (this.isOpaque() != that.isOpaque()) return false;
<i>1485</i>&nbsp;        if (!equalIgnoringCase(this.scheme, that.scheme)) return false;
<i>1486</i>&nbsp;        if (!equal(this.fragment, that.fragment)) return false;
<i>1487</i>&nbsp;
<i>1488</i>&nbsp;        // Opaque
<i>1489</i>&nbsp;        if (this.isOpaque())
<i>1490</i>&nbsp;            return equal(this.schemeSpecificPart, that.schemeSpecificPart);
<i>1491</i>&nbsp;
<i>1492</i>&nbsp;        // Hierarchical
<i>1493</i>&nbsp;        if (!equal(this.path, that.path)) return false;
<i>1494</i>&nbsp;        if (!equal(this.query, that.query)) return false;
<i>1495</i>&nbsp;
<i>1496</i>&nbsp;        // Authorities
<i>1497</i>&nbsp;        if (this.authority == that.authority) return true;
<i>1498</i>&nbsp;        if (this.host != null) {
<i>1499</i>&nbsp;            // Server-based
<i>1500</i>&nbsp;            if (!equal(this.userInfo, that.userInfo)) return false;
<i>1501</i>&nbsp;            if (!equalIgnoringCase(this.host, that.host)) return false;
<i>1502</i>&nbsp;            if (this.port != that.port) return false;
<i>1503</i>&nbsp;        } else if (this.authority != null) {
<i>1504</i>&nbsp;            // Registry-based
<i>1505</i>&nbsp;            if (!equal(this.authority, that.authority)) return false;
<i>1506</i>&nbsp;        } else if (this.authority != that.authority) {
<i>1507</i>&nbsp;            return false;
<i>1508</i>&nbsp;        }
<i>1509</i>&nbsp;
<i>1510</i>&nbsp;        return true;
<i>1511</i>&nbsp;    }
<i>1512</i>&nbsp;
<i>1513</i>&nbsp;    /**
<i>1514</i>&nbsp;     * Returns a hash-code value for this URI.  The hash code is based upon all
<i>1515</i>&nbsp;     * of the URI&#39;s components, and satisfies the general contract of the
<i>1516</i>&nbsp;     * {@link java.lang.Object#hashCode() Object.hashCode} method.
<i>1517</i>&nbsp;     *
<i>1518</i>&nbsp;     * @return  A hash-code value for this URI
<i>1519</i>&nbsp;     */
<i>1520</i>&nbsp;    public int hashCode() {
<i>1521</i>&nbsp;        int h = hash;
<i>1522</i>&nbsp;        if (h == 0) {
<i>1523</i>&nbsp;            h = hashIgnoringCase(0, scheme);
<i>1524</i>&nbsp;            h = hash(h, fragment);
<i>1525</i>&nbsp;            if (isOpaque()) {
<i>1526</i>&nbsp;                h = hash(h, schemeSpecificPart);
<i>1527</i>&nbsp;            } else {
<i>1528</i>&nbsp;                h = hash(h, path);
<i>1529</i>&nbsp;                h = hash(h, query);
<i>1530</i>&nbsp;                if (host != null) {
<i>1531</i>&nbsp;                    h = hash(h, userInfo);
<i>1532</i>&nbsp;                    h = hashIgnoringCase(h, host);
<i>1533</i>&nbsp;                    h += 1949 * port;
<i>1534</i>&nbsp;                } else {
<i>1535</i>&nbsp;                    h = hash(h, authority);
<i>1536</i>&nbsp;                }
<i>1537</i>&nbsp;            }
<i>1538</i>&nbsp;            if (h != 0) {
<i>1539</i>&nbsp;                hash = h;
<i>1540</i>&nbsp;            }
<i>1541</i>&nbsp;        }
<i>1542</i>&nbsp;        return h;
<i>1543</i>&nbsp;    }
<i>1544</i>&nbsp;
<i>1545</i>&nbsp;    /**
<i>1546</i>&nbsp;     * Compares this URI to another object, which must be a URI.
<i>1547</i>&nbsp;     *
<b class="nc"><i>1548</i>&nbsp;     * &lt;p&gt; When comparing corresponding components of two URIs, if one</b>
<b class="nc"><i>1549</i>&nbsp;     * component is undefined but the other is defined then the first is</b>
<i>1550</i>&nbsp;     * considered to be less than the second.  Unless otherwise noted, string
<b class="nc"><i>1551</i>&nbsp;     * components are ordered according to their natural, case-sensitive</b>
<b class="nc"><i>1552</i>&nbsp;     * ordering as defined by the {@link java.lang.String#compareTo(Object)</b>
<i>1553</i>&nbsp;     * String.compareTo} method.  String components that are subject to
<b class="nc"><i>1554</i>&nbsp;     * encoding are compared by comparing their raw forms rather than their</b>
<i>1555</i>&nbsp;     * encoded forms.
<b class="nc"><i>1556</i>&nbsp;     *</b>
<b class="nc"><i>1557</i>&nbsp;     * &lt;p&gt; The ordering of URIs is defined as follows: &lt;/p&gt;</b>
<i>1558</i>&nbsp;     *
<b class="nc"><i>1559</i>&nbsp;     * &lt;ul&gt;</b>
<b class="nc"><i>1560</i>&nbsp;     *</b>
<b class="nc"><i>1561</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Two URIs with different schemes are ordered according the</b>
<i>1562</i>&nbsp;     *   ordering of their schemes, without regard to case. &lt;/p&gt;&lt;/li&gt;
<i>1563</i>&nbsp;     *
<i>1564</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; A hierarchical URI is considered to be less than an opaque URI
<b class="nc"><i>1565</i>&nbsp;     *   with an identical scheme. &lt;/p&gt;&lt;/li&gt;</b>
<i>1566</i>&nbsp;     *
<b class="nc"><i>1567</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes are ordered according</b>
<b class="nc"><i>1568</i>&nbsp;     *   to the ordering of their scheme-specific parts. &lt;/p&gt;&lt;/li&gt;</b>
<b class="nc"><i>1569</i>&nbsp;     *</b>
<b class="nc"><i>1570</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Two opaque URIs with identical schemes and scheme-specific</b>
<b class="nc"><i>1571</i>&nbsp;     *   parts are ordered according to the ordering of their</b>
<b class="nc"><i>1572</i>&nbsp;     *   fragments. &lt;/p&gt;&lt;/li&gt;</b>
<i>1573</i>&nbsp;     *
<i>1574</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Two hierarchical URIs with identical schemes are ordered
<i>1575</i>&nbsp;     *   according to the ordering of their authority components: &lt;/p&gt;
<i>1576</i>&nbsp;     *
<i>1577</i>&nbsp;     *   &lt;ul&gt;
<i>1578</i>&nbsp;     *
<i>1579</i>&nbsp;     *     &lt;li&gt;&lt;p&gt; If both authority components are server-based then the URIs
<b class="nc"><i>1580</i>&nbsp;     *     are ordered according to their user-information components; if these</b>
<i>1581</i>&nbsp;     *     components are identical then the URIs are ordered according to the
<i>1582</i>&nbsp;     *     ordering of their hosts, without regard to case; if the hosts are
<b class="nc"><i>1583</i>&nbsp;     *     identical then the URIs are ordered according to the ordering of</b>
<b class="nc"><i>1584</i>&nbsp;     *     their ports. &lt;/p&gt;&lt;/li&gt;</b>
<b class="nc"><i>1585</i>&nbsp;     *</b>
<i>1586</i>&nbsp;     *     &lt;li&gt;&lt;p&gt; If one or both authority components are registry-based then
<i>1587</i>&nbsp;     *     the URIs are ordered according to the ordering of their authority
<i>1588</i>&nbsp;     *     components. &lt;/p&gt;&lt;/li&gt;
<i>1589</i>&nbsp;     *
<i>1590</i>&nbsp;     *   &lt;/ul&gt;&lt;/li&gt;
<i>1591</i>&nbsp;     *
<i>1592</i>&nbsp;     *   &lt;li&gt;&lt;p&gt; Finally, two hierarchical URIs with identical schemes and
<i>1593</i>&nbsp;     *   authority components are ordered according to the ordering of their
<i>1594</i>&nbsp;     *   paths; if their paths are identical then they are ordered according to
<i>1595</i>&nbsp;     *   the ordering of their queries; if the queries are identical then they
<i>1596</i>&nbsp;     *   are ordered according to the order of their fragments. &lt;/p&gt;&lt;/li&gt;
<i>1597</i>&nbsp;     *
<i>1598</i>&nbsp;     * &lt;/ul&gt;
<i>1599</i>&nbsp;     *
<i>1600</i>&nbsp;     * &lt;p&gt; This method satisfies the general contract of the {@link
<i>1601</i>&nbsp;     * java.lang.Comparable#compareTo(Object) Comparable.compareTo}
<i>1602</i>&nbsp;     * method. &lt;/p&gt;
<b class="nc"><i>1603</i>&nbsp;     *</b>
<b class="nc"><i>1604</i>&nbsp;     * @param   that</b>
<i>1605</i>&nbsp;     *          The object to which this URI is to be compared
<i>1606</i>&nbsp;     *
<i>1607</i>&nbsp;     * @return  A negative integer, zero, or a positive integer as this URI is
<i>1608</i>&nbsp;     *          less than, equal to, or greater than the given URI
<i>1609</i>&nbsp;     *
<i>1610</i>&nbsp;     * @throws  ClassCastException
<i>1611</i>&nbsp;     *          If the given object is not a URI
<i>1612</i>&nbsp;     */
<i>1613</i>&nbsp;    public int compareTo(URI that) {
<i>1614</i>&nbsp;        int c;
<i>1615</i>&nbsp;
<i>1616</i>&nbsp;        if ((c = compareIgnoringCase(this.scheme, that.scheme)) != 0)
<i>1617</i>&nbsp;            return c;
<i>1618</i>&nbsp;
<i>1619</i>&nbsp;        if (this.isOpaque()) {
<i>1620</i>&nbsp;            if (that.isOpaque()) {
<b class="nc"><i>1621</i>&nbsp;                // Both opaque</b>
<b class="nc"><i>1622</i>&nbsp;                if ((c = compare(this.schemeSpecificPart,</b>
<i>1623</i>&nbsp;                                 that.schemeSpecificPart)) != 0)
<i>1624</i>&nbsp;                    return c;
<i>1625</i>&nbsp;                return compare(this.fragment, that.fragment);
<i>1626</i>&nbsp;            }
<i>1627</i>&nbsp;            return +1;                  // Opaque &gt; hierarchical
<i>1628</i>&nbsp;        } else if (that.isOpaque()) {
<i>1629</i>&nbsp;            return -1;                  // Hierarchical &lt; opaque
<i>1630</i>&nbsp;        }
<i>1631</i>&nbsp;
<i>1632</i>&nbsp;        // Hierarchical
<i>1633</i>&nbsp;        if ((this.host != null) &amp;&amp; (that.host != null)) {
<i>1634</i>&nbsp;            // Both server-based
<i>1635</i>&nbsp;            if ((c = compare(this.userInfo, that.userInfo)) != 0)
<i>1636</i>&nbsp;                return c;
<i>1637</i>&nbsp;            if ((c = compareIgnoringCase(this.host, that.host)) != 0)
<i>1638</i>&nbsp;                return c;
<i>1639</i>&nbsp;            if ((c = this.port - that.port) != 0)
<i>1640</i>&nbsp;                return c;
<i>1641</i>&nbsp;        } else {
<b class="nc"><i>1642</i>&nbsp;            // If one or both authorities are registry-based then we simply</b>
<b class="nc"><i>1643</i>&nbsp;            // compare them in the usual, case-sensitive way.  If one is</b>
<i>1644</i>&nbsp;            // registry-based and one is server-based then the strings are
<i>1645</i>&nbsp;            // guaranteed to be unequal, hence the comparison will never return
<i>1646</i>&nbsp;            // zero and the compareTo and equals methods will remain
<i>1647</i>&nbsp;            // consistent.
<i>1648</i>&nbsp;            if ((c = compare(this.authority, that.authority)) != 0) return c;
<i>1649</i>&nbsp;        }
<i>1650</i>&nbsp;
<i>1651</i>&nbsp;        if ((c = compare(this.path, that.path)) != 0) return c;
<i>1652</i>&nbsp;        if ((c = compare(this.query, that.query)) != 0) return c;
<i>1653</i>&nbsp;        return compare(this.fragment, that.fragment);
<i>1654</i>&nbsp;    }
<i>1655</i>&nbsp;
<i>1656</i>&nbsp;    /**
<i>1657</i>&nbsp;     * Returns the content of this URI as a string.
<i>1658</i>&nbsp;     *
<b class="nc"><i>1659</i>&nbsp;     * &lt;p&gt; If this URI was created by invoking one of the constructors in this</b>
<b class="nc"><i>1660</i>&nbsp;     * class then a string equivalent to the original input string, or to the</b>
<i>1661</i>&nbsp;     * string computed from the originally-given components, as appropriate, is
<b class="nc"><i>1662</i>&nbsp;     * returned.  Otherwise this URI was created by normalization, resolution,</b>
<b class="nc"><i>1663</i>&nbsp;     * or relativization, and so a string is constructed from this URI&#39;s</b>
<b class="nc"><i>1664</i>&nbsp;     * components according to the rules specified in &lt;a</b>
<b class="nc"><i>1665</i>&nbsp;     * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC&amp;nbsp;2396&lt;/a&gt;,</b>
<b class="nc"><i>1666</i>&nbsp;     * section&amp;nbsp;5.2, step&amp;nbsp;7. &lt;/p&gt;</b>
<b class="nc"><i>1667</i>&nbsp;     *</b>
<i>1668</i>&nbsp;     * @return  The string form of this URI
<i>1669</i>&nbsp;     */
<i>1670</i>&nbsp;    public String toString() {
<i>1671</i>&nbsp;        String s = string;
<i>1672</i>&nbsp;        if (s == null) {
<i>1673</i>&nbsp;            s = defineString();
<i>1674</i>&nbsp;        }
<i>1675</i>&nbsp;        return s;
<i>1676</i>&nbsp;    }
<i>1677</i>&nbsp;
<i>1678</i>&nbsp;    private String defineString() {
<i>1679</i>&nbsp;        String s = string;
<i>1680</i>&nbsp;        if (s != null) {
<i>1681</i>&nbsp;            return s;
<i>1682</i>&nbsp;        }
<i>1683</i>&nbsp;
<i>1684</i>&nbsp;        StringBuilder sb = new StringBuilder();
<b class="nc"><i>1685</i>&nbsp;        if (scheme != null) {</b>
<b class="nc"><i>1686</i>&nbsp;            sb.append(scheme);</b>
<b class="nc"><i>1687</i>&nbsp;            sb.append(&#39;:&#39;);</b>
<i>1688</i>&nbsp;        }
<i>1689</i>&nbsp;        if (isOpaque()) {
<i>1690</i>&nbsp;            sb.append(schemeSpecificPart);
<i>1691</i>&nbsp;        } else {
<b class="nc"><i>1692</i>&nbsp;            if (host != null) {</b>
<b class="nc"><i>1693</i>&nbsp;                sb.append(&quot;//&quot;);</b>
<b class="nc"><i>1694</i>&nbsp;                if (userInfo != null) {</b>
<i>1695</i>&nbsp;                    sb.append(userInfo);
<i>1696</i>&nbsp;                    sb.append(&#39;@&#39;);
<i>1697</i>&nbsp;                }
<b class="nc"><i>1698</i>&nbsp;                boolean needBrackets = ((host.indexOf(&#39;:&#39;) &gt;= 0)</b>
<b class="nc"><i>1699</i>&nbsp;                        &amp;&amp; !host.startsWith(&quot;[&quot;)</b>
<b class="nc"><i>1700</i>&nbsp;                        &amp;&amp; !host.endsWith(&quot;]&quot;));</b>
<b class="nc"><i>1701</i>&nbsp;                if (needBrackets) sb.append(&#39;[&#39;);</b>
<b class="nc"><i>1702</i>&nbsp;                sb.append(host);</b>
<b class="nc"><i>1703</i>&nbsp;                if (needBrackets) sb.append(&#39;]&#39;);</b>
<b class="nc"><i>1704</i>&nbsp;                if (port != -1) {</b>
<b class="nc"><i>1705</i>&nbsp;                    sb.append(&#39;:&#39;);</b>
<b class="nc"><i>1706</i>&nbsp;                    sb.append(port);</b>
<b class="nc"><i>1707</i>&nbsp;                }</b>
<b class="nc"><i>1708</i>&nbsp;            } else if (authority != null) {</b>
<b class="nc"><i>1709</i>&nbsp;                sb.append(&quot;//&quot;);</b>
<b class="nc"><i>1710</i>&nbsp;                sb.append(authority);</b>
<b class="nc"><i>1711</i>&nbsp;            }</b>
<b class="nc"><i>1712</i>&nbsp;            if (path != null)</b>
<i>1713</i>&nbsp;                sb.append(path);
<b class="nc"><i>1714</i>&nbsp;            if (query != null) {</b>
<b class="nc"><i>1715</i>&nbsp;                sb.append(&#39;?&#39;);</b>
<b class="nc"><i>1716</i>&nbsp;                sb.append(query);</b>
<b class="nc"><i>1717</i>&nbsp;            }</b>
<b class="nc"><i>1718</i>&nbsp;        }</b>
<b class="nc"><i>1719</i>&nbsp;        if (fragment != null) {</b>
<b class="nc"><i>1720</i>&nbsp;            sb.append(&#39;#&#39;);</b>
<b class="nc"><i>1721</i>&nbsp;            sb.append(fragment);</b>
<b class="nc"><i>1722</i>&nbsp;        }</b>
<b class="nc"><i>1723</i>&nbsp;        return string = sb.toString();</b>
<b class="nc"><i>1724</i>&nbsp;    }</b>
<i>1725</i>&nbsp;
<b class="nc"><i>1726</i>&nbsp;    /**</b>
<i>1727</i>&nbsp;     * Returns the content of this URI as a US-ASCII string.
<i>1728</i>&nbsp;     *
<i>1729</i>&nbsp;     * &lt;p&gt; If this URI does not contain any characters in the &lt;i&gt;other&lt;/i&gt;
<i>1730</i>&nbsp;     * category then an invocation of this method will return the same value as
<b class="nc"><i>1731</i>&nbsp;     * an invocation of the {@link #toString() toString} method.  Otherwise</b>
<b class="nc"><i>1732</i>&nbsp;     * this method works as if by invoking that method and then &lt;a</b>
<b class="nc"><i>1733</i>&nbsp;     * href=&quot;#encode&quot;&gt;encoding&lt;/a&gt; the result.  &lt;/p&gt;</b>
<b class="nc"><i>1734</i>&nbsp;     *</b>
<b class="nc"><i>1735</i>&nbsp;     * @return  The string form of this URI, encoded as needed</b>
<b class="nc"><i>1736</i>&nbsp;     *          so that it only contains characters in the US-ASCII</b>
<b class="nc"><i>1737</i>&nbsp;     *          charset</b>
<b class="nc"><i>1738</i>&nbsp;     */</b>
<i>1739</i>&nbsp;    public String toASCIIString() {
<b class="nc"><i>1740</i>&nbsp;        return encode(toString());</b>
<i>1741</i>&nbsp;    }
<b class="nc"><i>1742</i>&nbsp;</b>
<i>1743</i>&nbsp;
<i>1744</i>&nbsp;    // -- Serialization support --
<i>1745</i>&nbsp;
<b class="nc"><i>1746</i>&nbsp;    /**</b>
<b class="nc"><i>1747</i>&nbsp;     * Saves the content of this URI to the given serial stream.</b>
<b class="nc"><i>1748</i>&nbsp;     *</b>
<i>1749</i>&nbsp;     * &lt;p&gt; The only serializable field of a URI instance is its {@code string}
<i>1750</i>&nbsp;     * field.  That field is given a value, if it does not have one already,
<i>1751</i>&nbsp;     * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}
<i>1752</i>&nbsp;     * method of the given object-output stream is invoked. &lt;/p&gt;
<b class="nc"><i>1753</i>&nbsp;     *</b>
<b class="nc"><i>1754</i>&nbsp;     * @param  os  The object-output stream to which this object</b>
<b class="nc"><i>1755</i>&nbsp;     *             is to be written</b>
<b class="nc"><i>1756</i>&nbsp;     */</b>
<b class="nc"><i>1757</i>&nbsp;    private void writeObject(ObjectOutputStream os)</b>
<i>1758</i>&nbsp;        throws IOException
<i>1759</i>&nbsp;    {
<i>1760</i>&nbsp;        defineString();
<b class="nc"><i>1761</i>&nbsp;        os.defaultWriteObject();        // Writes the string field only</b>
<b class="nc"><i>1762</i>&nbsp;    }</b>
<b class="nc"><i>1763</i>&nbsp;</b>
<i>1764</i>&nbsp;    /**
<i>1765</i>&nbsp;     * Reconstitutes a URI from the given serial stream.
<b class="nc"><i>1766</i>&nbsp;     *</b>
<i>1767</i>&nbsp;     * &lt;p&gt; The {@link java.io.ObjectInputStream#defaultReadObject()} method is
<i>1768</i>&nbsp;     * invoked to read the value of the {@code string} field.  The result is
<i>1769</i>&nbsp;     * then parsed in the usual way.
<i>1770</i>&nbsp;     *
<b class="nc"><i>1771</i>&nbsp;     * @param  is  The object-input stream from which this object</b>
<b class="nc"><i>1772</i>&nbsp;     *             is being read</b>
<b class="nc"><i>1773</i>&nbsp;     */</b>
<b class="nc"><i>1774</i>&nbsp;    private void readObject(ObjectInputStream is)</b>
<b class="nc"><i>1775</i>&nbsp;        throws ClassNotFoundException, IOException</b>
<b class="nc"><i>1776</i>&nbsp;    {</b>
<i>1777</i>&nbsp;        port = -1;                      // Argh
<i>1778</i>&nbsp;        is.defaultReadObject();
<i>1779</i>&nbsp;        try {
<b class="nc"><i>1780</i>&nbsp;            new Parser(string).parse(false);</b>
<b class="nc"><i>1781</i>&nbsp;        } catch (URISyntaxException x) {</b>
<b class="nc"><i>1782</i>&nbsp;            IOException y = new InvalidObjectException(&quot;Invalid URI&quot;);</b>
<b class="nc"><i>1783</i>&nbsp;            y.initCause(x);</b>
<i>1784</i>&nbsp;            throw y;
<b class="nc"><i>1785</i>&nbsp;        }</b>
<i>1786</i>&nbsp;    }
<b class="nc"><i>1787</i>&nbsp;</b>
<i>1788</i>&nbsp;
<i>1789</i>&nbsp;    // -- End of public methods --
<i>1790</i>&nbsp;
<i>1791</i>&nbsp;
<i>1792</i>&nbsp;    // -- Utility methods for string-field comparison and hashing --
<b class="nc"><i>1793</i>&nbsp;</b>
<b class="nc"><i>1794</i>&nbsp;    // These methods return appropriate values for null string arguments,</b>
<b class="nc"><i>1795</i>&nbsp;    // thereby simplifying the equals, hashCode, and compareTo methods.</b>
<b class="nc"><i>1796</i>&nbsp;    //</b>
<b class="nc"><i>1797</i>&nbsp;    // The case-ignoring methods should only be applied to strings whose</b>
<b class="nc"><i>1798</i>&nbsp;    // characters are all known to be US-ASCII.  Because of this restriction,</b>
<b class="nc"><i>1799</i>&nbsp;    // these methods are faster than the similar methods in the String class.</b>
<b class="nc"><i>1800</i>&nbsp;</b>
<b class="nc"><i>1801</i>&nbsp;    // US-ASCII only</b>
<b class="nc"><i>1802</i>&nbsp;    private static int toLower(char c) {</b>
<i>1803</i>&nbsp;        if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;))
<b class="nc"><i>1804</i>&nbsp;            return c + (&#39;a&#39; - &#39;A&#39;);</b>
<i>1805</i>&nbsp;        return c;
<b class="nc"><i>1806</i>&nbsp;    }</b>
<i>1807</i>&nbsp;
<b class="nc"><i>1808</i>&nbsp;    // US-ASCII only</b>
<i>1809</i>&nbsp;    private static int toUpper(char c) {
<i>1810</i>&nbsp;        if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;))
<i>1811</i>&nbsp;            return c - (&#39;a&#39; - &#39;A&#39;);
<i>1812</i>&nbsp;        return c;
<i>1813</i>&nbsp;    }
<i>1814</i>&nbsp;
<i>1815</i>&nbsp;    private static boolean equal(String s, String t) {
<i>1816</i>&nbsp;        if (s == t) return true;
<i>1817</i>&nbsp;        if ((s != null) &amp;&amp; (t != null)) {
<i>1818</i>&nbsp;            if (s.length() != t.length())
<i>1819</i>&nbsp;                return false;
<b class="nc"><i>1820</i>&nbsp;            if (s.indexOf(&#39;%&#39;) &lt; 0)</b>
<b class="nc"><i>1821</i>&nbsp;                return s.equals(t);</b>
<b class="nc"><i>1822</i>&nbsp;            int n = s.length();</b>
<b class="nc"><i>1823</i>&nbsp;            for (int i = 0; i &lt; n;) {</b>
<i>1824</i>&nbsp;                char c = s.charAt(i);
<i>1825</i>&nbsp;                char d = t.charAt(i);
<i>1826</i>&nbsp;                if (c != &#39;%&#39;) {
<i>1827</i>&nbsp;                    if (c != d)
<i>1828</i>&nbsp;                        return false;
<i>1829</i>&nbsp;                    i++;
<i>1830</i>&nbsp;                    continue;
<i>1831</i>&nbsp;                }
<i>1832</i>&nbsp;                if (d != &#39;%&#39;)
<i>1833</i>&nbsp;                    return false;
<b class="nc"><i>1834</i>&nbsp;                i++;</b>
<b class="nc"><i>1835</i>&nbsp;                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</b>
<b class="nc"><i>1836</i>&nbsp;                    return false;</b>
<b class="nc"><i>1837</i>&nbsp;                i++;</b>
<b class="nc"><i>1838</i>&nbsp;                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</b>
<i>1839</i>&nbsp;                    return false;
<b class="nc"><i>1840</i>&nbsp;                i++;</b>
<b class="nc"><i>1841</i>&nbsp;            }</b>
<b class="nc"><i>1842</i>&nbsp;            return true;</b>
<b class="nc"><i>1843</i>&nbsp;        }</b>
<b class="nc"><i>1844</i>&nbsp;        return false;</b>
<b class="nc"><i>1845</i>&nbsp;    }</b>
<b class="nc"><i>1846</i>&nbsp;</b>
<b class="nc"><i>1847</i>&nbsp;    // US-ASCII only</b>
<b class="nc"><i>1848</i>&nbsp;    private static boolean equalIgnoringCase(String s, String t) {</b>
<i>1849</i>&nbsp;        if (s == t) return true;
<b class="nc"><i>1850</i>&nbsp;        if ((s != null) &amp;&amp; (t != null)) {</b>
<b class="nc"><i>1851</i>&nbsp;            int n = s.length();</b>
<b class="nc"><i>1852</i>&nbsp;            if (t.length() != n)</b>
<i>1853</i>&nbsp;                return false;
<b class="nc"><i>1854</i>&nbsp;            for (int i = 0; i &lt; n; i++) {</b>
<b class="nc"><i>1855</i>&nbsp;                if (toLower(s.charAt(i)) != toLower(t.charAt(i)))</b>
<b class="nc"><i>1856</i>&nbsp;                    return false;</b>
<i>1857</i>&nbsp;            }
<b class="nc"><i>1858</i>&nbsp;            return true;</b>
<b class="nc"><i>1859</i>&nbsp;        }</b>
<b class="nc"><i>1860</i>&nbsp;        return false;</b>
<i>1861</i>&nbsp;    }
<b class="nc"><i>1862</i>&nbsp;</b>
<b class="nc"><i>1863</i>&nbsp;    private static int hash(int hash, String s) {</b>
<i>1864</i>&nbsp;        if (s == null) return hash;
<i>1865</i>&nbsp;        return s.indexOf(&#39;%&#39;) &lt; 0 ? hash * 127 + s.hashCode()
<b class="nc"><i>1866</i>&nbsp;                                  : normalizedHash(hash, s);</b>
<b class="nc"><i>1867</i>&nbsp;    }</b>
<i>1868</i>&nbsp;
<i>1869</i>&nbsp;
<b class="nc"><i>1870</i>&nbsp;    private static int normalizedHash(int hash, String s) {</b>
<b class="nc"><i>1871</i>&nbsp;        int h = 0;</b>
<i>1872</i>&nbsp;        for (int index = 0; index &lt; s.length(); index++) {
<i>1873</i>&nbsp;            char ch = s.charAt(index);
<i>1874</i>&nbsp;            h = 31 * h + ch;
<i>1875</i>&nbsp;            if (ch == &#39;%&#39;) {
<i>1876</i>&nbsp;                /*
<i>1877</i>&nbsp;                 * Process the next two encoded characters
<i>1878</i>&nbsp;                 */
<i>1879</i>&nbsp;                for (int i = index + 1; i &lt; index + 3; i++)
<i>1880</i>&nbsp;                    h = 31 * h + toUpper(s.charAt(i));
<i>1881</i>&nbsp;                index += 2;
<i>1882</i>&nbsp;            }
<i>1883</i>&nbsp;        }
<i>1884</i>&nbsp;        return hash * 127 + h;
<i>1885</i>&nbsp;    }
<i>1886</i>&nbsp;
<b class="nc"><i>1887</i>&nbsp;    // US-ASCII only</b>
<i>1888</i>&nbsp;    private static int hashIgnoringCase(int hash, String s) {
<i>1889</i>&nbsp;        if (s == null) return hash;
<i>1890</i>&nbsp;        int h = hash;
<b class="nc"><i>1891</i>&nbsp;        int n = s.length();</b>
<b class="nc"><i>1892</i>&nbsp;        for (int i = 0; i &lt; n; i++)</b>
<b class="nc"><i>1893</i>&nbsp;            h = 31 * h + toLower(s.charAt(i));</b>
<i>1894</i>&nbsp;        return h;
<b class="nc"><i>1895</i>&nbsp;    }</b>
<b class="nc"><i>1896</i>&nbsp;</b>
<b class="nc"><i>1897</i>&nbsp;    private static int compare(String s, String t) {</b>
<i>1898</i>&nbsp;        if (s == t) return 0;
<b class="nc"><i>1899</i>&nbsp;        if (s != null) {</b>
<b class="nc"><i>1900</i>&nbsp;            if (t != null)</b>
<i>1901</i>&nbsp;                return s.compareTo(t);
<b class="nc"><i>1902</i>&nbsp;            else</b>
<b class="nc"><i>1903</i>&nbsp;                return +1;</b>
<i>1904</i>&nbsp;        } else {
<b class="nc"><i>1905</i>&nbsp;            return -1;</b>
<b class="nc"><i>1906</i>&nbsp;        }</b>
<i>1907</i>&nbsp;    }
<i>1908</i>&nbsp;
<b class="nc"><i>1909</i>&nbsp;    // US-ASCII only</b>
<b class="nc"><i>1910</i>&nbsp;    private static int compareIgnoringCase(String s, String t) {</b>
<b class="nc"><i>1911</i>&nbsp;        if (s == t) return 0;</b>
<b class="nc"><i>1912</i>&nbsp;        if (s != null) {</b>
<b class="nc"><i>1913</i>&nbsp;            if (t != null) {</b>
<b class="nc"><i>1914</i>&nbsp;                int sn = s.length();</b>
<i>1915</i>&nbsp;                int tn = t.length();
<i>1916</i>&nbsp;                int n = sn &lt; tn ? sn : tn;
<i>1917</i>&nbsp;                for (int i = 0; i &lt; n; i++) {
<i>1918</i>&nbsp;                    int c = toLower(s.charAt(i)) - toLower(t.charAt(i));
<i>1919</i>&nbsp;                    if (c != 0)
<b class="nc"><i>1920</i>&nbsp;                        return c;</b>
<b class="nc"><i>1921</i>&nbsp;                }</b>
<b class="nc"><i>1922</i>&nbsp;                return sn - tn;</b>
<i>1923</i>&nbsp;            }
<i>1924</i>&nbsp;            return +1;
<i>1925</i>&nbsp;        } else {
<i>1926</i>&nbsp;            return -1;
<i>1927</i>&nbsp;        }
<i>1928</i>&nbsp;    }
<i>1929</i>&nbsp;
<i>1930</i>&nbsp;
<i>1931</i>&nbsp;    // -- String construction --
<i>1932</i>&nbsp;
<i>1933</i>&nbsp;    // If a scheme is given then the path, if given, must be absolute
<i>1934</i>&nbsp;    //
<i>1935</i>&nbsp;    private static void checkPath(String s, String scheme, String path)
<b class="nc"><i>1936</i>&nbsp;        throws URISyntaxException</b>
<b class="nc"><i>1937</i>&nbsp;    {</b>
<b class="nc"><i>1938</i>&nbsp;        if (scheme != null) {</b>
<b class="nc"><i>1939</i>&nbsp;            if ((path != null)</b>
<i>1940</i>&nbsp;                &amp;&amp; ((path.length() &gt; 0) &amp;&amp; (path.charAt(0) != &#39;/&#39;)))
<b class="nc"><i>1941</i>&nbsp;                throw new URISyntaxException(s,</b>
<i>1942</i>&nbsp;                                             &quot;Relative path in absolute URI&quot;);
<i>1943</i>&nbsp;        }
<b class="nc"><i>1944</i>&nbsp;    }</b>
<b class="nc"><i>1945</i>&nbsp;</b>
<i>1946</i>&nbsp;    private void appendAuthority(StringBuilder sb,
<i>1947</i>&nbsp;                                 String authority,
<i>1948</i>&nbsp;                                 String userInfo,
<b class="nc"><i>1949</i>&nbsp;                                 String host,</b>
<b class="nc"><i>1950</i>&nbsp;                                 int port)</b>
<b class="nc"><i>1951</i>&nbsp;    {</b>
<b class="nc"><i>1952</i>&nbsp;        if (host != null) {</b>
<b class="nc"><i>1953</i>&nbsp;            sb.append(&quot;//&quot;);</b>
<b class="nc"><i>1954</i>&nbsp;            if (userInfo != null) {</b>
<i>1955</i>&nbsp;                sb.append(quote(userInfo, L_USERINFO, H_USERINFO));
<i>1956</i>&nbsp;                sb.append(&#39;@&#39;);
<i>1957</i>&nbsp;            }
<b class="nc"><i>1958</i>&nbsp;            boolean needBrackets = ((host.indexOf(&#39;:&#39;) &gt;= 0)</b>
<i>1959</i>&nbsp;                                    &amp;&amp; !host.startsWith(&quot;[&quot;)
<b class="nc"><i>1960</i>&nbsp;                                    &amp;&amp; !host.endsWith(&quot;]&quot;));</b>
<b class="nc"><i>1961</i>&nbsp;            if (needBrackets) sb.append(&#39;[&#39;);</b>
<b class="nc"><i>1962</i>&nbsp;            sb.append(host);</b>
<b class="nc"><i>1963</i>&nbsp;            if (needBrackets) sb.append(&#39;]&#39;);</b>
<i>1964</i>&nbsp;            if (port != -1) {
<b class="nc"><i>1965</i>&nbsp;                sb.append(&#39;:&#39;);</b>
<b class="nc"><i>1966</i>&nbsp;                sb.append(port);</b>
<i>1967</i>&nbsp;            }
<b class="nc"><i>1968</i>&nbsp;        } else if (authority != null) {</b>
<b class="nc"><i>1969</i>&nbsp;            sb.append(&quot;//&quot;);</b>
<b class="nc"><i>1970</i>&nbsp;            if (authority.startsWith(&quot;[&quot;)) {</b>
<b class="nc"><i>1971</i>&nbsp;                // authority should (but may not) contain an embedded IPv6 address</b>
<b class="nc"><i>1972</i>&nbsp;                int end = authority.indexOf(&#39;]&#39;);</b>
<i>1973</i>&nbsp;                String doquote = authority, dontquote = &quot;&quot;;
<b class="nc"><i>1974</i>&nbsp;                if (end != -1 &amp;&amp; authority.indexOf(&#39;:&#39;) != -1) {</b>
<b class="nc"><i>1975</i>&nbsp;                    // the authority contains an IPv6 address</b>
<b class="nc"><i>1976</i>&nbsp;                    if (end == authority.length()) {</b>
<b class="nc"><i>1977</i>&nbsp;                        dontquote = authority;</b>
<b class="nc"><i>1978</i>&nbsp;                        doquote = &quot;&quot;;</b>
<b class="nc"><i>1979</i>&nbsp;                    } else {</b>
<b class="nc"><i>1980</i>&nbsp;                        dontquote = authority.substring(0 , end + 1);</b>
<b class="nc"><i>1981</i>&nbsp;                        doquote = authority.substring(end + 1);</b>
<b class="nc"><i>1982</i>&nbsp;                    }</b>
<i>1983</i>&nbsp;                }
<b class="nc"><i>1984</i>&nbsp;                sb.append(dontquote);</b>
<b class="nc"><i>1985</i>&nbsp;                sb.append(quote(doquote,</b>
<b class="nc"><i>1986</i>&nbsp;                            L_REG_NAME | L_SERVER,</b>
<i>1987</i>&nbsp;                            H_REG_NAME | H_SERVER));
<b class="nc"><i>1988</i>&nbsp;            } else {</b>
<b class="nc"><i>1989</i>&nbsp;                sb.append(quote(authority,</b>
<b class="nc"><i>1990</i>&nbsp;                            L_REG_NAME | L_SERVER,</b>
<b class="nc"><i>1991</i>&nbsp;                            H_REG_NAME | H_SERVER));</b>
<b class="nc"><i>1992</i>&nbsp;            }</b>
<i>1993</i>&nbsp;        }
<i>1994</i>&nbsp;    }
<b class="nc"><i>1995</i>&nbsp;</b>
<b class="nc"><i>1996</i>&nbsp;    private void appendSchemeSpecificPart(StringBuilder sb,</b>
<b class="nc"><i>1997</i>&nbsp;                                          String opaquePart,</b>
<i>1998</i>&nbsp;                                          String authority,
<b class="nc"><i>1999</i>&nbsp;                                          String userInfo,</b>
<i>2000</i>&nbsp;                                          String host,
<i>2001</i>&nbsp;                                          int port,
<i>2002</i>&nbsp;                                          String path,
<i>2003</i>&nbsp;                                          String query)
<i>2004</i>&nbsp;    {
<i>2005</i>&nbsp;        if (opaquePart != null) {
<i>2006</i>&nbsp;            /* check if SSP begins with an IPv6 address
<i>2007</i>&nbsp;             * because we must not quote a literal IPv6 address
<i>2008</i>&nbsp;             */
<b class="nc"><i>2009</i>&nbsp;            if (opaquePart.startsWith(&quot;//[&quot;)) {</b>
<b class="nc"><i>2010</i>&nbsp;                int end =  opaquePart.indexOf(&#39;]&#39;);</b>
<b class="nc"><i>2011</i>&nbsp;                if (end != -1 &amp;&amp; opaquePart.indexOf(&#39;:&#39;)!=-1) {</b>
<i>2012</i>&nbsp;                    String doquote, dontquote;
<b class="nc"><i>2013</i>&nbsp;                    if (end == opaquePart.length()) {</b>
<i>2014</i>&nbsp;                        dontquote = opaquePart;
<b class="nc"><i>2015</i>&nbsp;                        doquote = &quot;&quot;;</b>
<b class="nc"><i>2016</i>&nbsp;                    } else {</b>
<i>2017</i>&nbsp;                        dontquote = opaquePart.substring(0,end+1);
<b class="nc"><i>2018</i>&nbsp;                        doquote = opaquePart.substring(end+1);</b>
<i>2019</i>&nbsp;                    }
<b class="nc"><i>2020</i>&nbsp;                    sb.append (dontquote);</b>
<b class="nc"><i>2021</i>&nbsp;                    sb.append(quote(doquote, L_URIC, H_URIC));</b>
<i>2022</i>&nbsp;                }
<b class="nc"><i>2023</i>&nbsp;            } else {</b>
<b class="nc"><i>2024</i>&nbsp;                sb.append(quote(opaquePart, L_URIC, H_URIC));</b>
<i>2025</i>&nbsp;            }
<i>2026</i>&nbsp;        } else {
<i>2027</i>&nbsp;            appendAuthority(sb, authority, userInfo, host, port);
<b class="nc"><i>2028</i>&nbsp;            if (path != null)</b>
<i>2029</i>&nbsp;                sb.append(quote(path, L_PATH, H_PATH));
<i>2030</i>&nbsp;            if (query != null) {
<i>2031</i>&nbsp;                sb.append(&#39;?&#39;);
<i>2032</i>&nbsp;                sb.append(quote(query, L_URIC, H_URIC));
<b class="nc"><i>2033</i>&nbsp;            }</b>
<i>2034</i>&nbsp;        }
<i>2035</i>&nbsp;    }
<i>2036</i>&nbsp;
<i>2037</i>&nbsp;    private void appendFragment(StringBuilder sb, String fragment) {
<i>2038</i>&nbsp;        if (fragment != null) {
<i>2039</i>&nbsp;            sb.append(&#39;#&#39;);
<b class="nc"><i>2040</i>&nbsp;            sb.append(quote(fragment, L_URIC, H_URIC));</b>
<b class="nc"><i>2041</i>&nbsp;        }</b>
<i>2042</i>&nbsp;    }
<i>2043</i>&nbsp;
<b class="nc"><i>2044</i>&nbsp;    private String toString(String scheme,</b>
<b class="nc"><i>2045</i>&nbsp;                            String opaquePart,</b>
<i>2046</i>&nbsp;                            String authority,
<b class="nc"><i>2047</i>&nbsp;                            String userInfo,</b>
<b class="nc"><i>2048</i>&nbsp;                            String host,</b>
<b class="nc"><i>2049</i>&nbsp;                            int port,</b>
<i>2050</i>&nbsp;                            String path,
<b class="nc"><i>2051</i>&nbsp;                            String query,</b>
<b class="nc"><i>2052</i>&nbsp;                            String fragment)</b>
<b class="nc"><i>2053</i>&nbsp;    {</b>
<b class="nc"><i>2054</i>&nbsp;        StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>2055</i>&nbsp;        if (scheme != null) {</b>
<b class="nc"><i>2056</i>&nbsp;            sb.append(scheme);</b>
<b class="nc"><i>2057</i>&nbsp;            sb.append(&#39;:&#39;);</b>
<b class="nc"><i>2058</i>&nbsp;        }</b>
<b class="nc"><i>2059</i>&nbsp;        appendSchemeSpecificPart(sb, opaquePart,</b>
<b class="nc"><i>2060</i>&nbsp;                                 authority, userInfo, host, port,</b>
<i>2061</i>&nbsp;                                 path, query);
<i>2062</i>&nbsp;        appendFragment(sb, fragment);
<i>2063</i>&nbsp;        return sb.toString();
<b class="nc"><i>2064</i>&nbsp;    }</b>
<b class="nc"><i>2065</i>&nbsp;</b>
<i>2066</i>&nbsp;    // -- Normalization, resolution, and relativization --
<b class="nc"><i>2067</i>&nbsp;</b>
<b class="nc"><i>2068</i>&nbsp;    // RFC2396 5.2 (6)</b>
<b class="nc"><i>2069</i>&nbsp;    private static String resolvePath(String base, String child,</b>
<b class="nc"><i>2070</i>&nbsp;                                      boolean absolute)</b>
<i>2071</i>&nbsp;    {
<i>2072</i>&nbsp;        int i = base.lastIndexOf(&#39;/&#39;);
<b class="nc"><i>2073</i>&nbsp;        int cn = child.length();</b>
<b class="nc"><i>2074</i>&nbsp;        String path = &quot;&quot;;</b>
<b class="nc"><i>2075</i>&nbsp;</b>
<b class="nc"><i>2076</i>&nbsp;        if (cn == 0) {</b>
<b class="nc"><i>2077</i>&nbsp;            // 5.2 (6a)</b>
<i>2078</i>&nbsp;            if (i &gt;= 0)
<b class="nc"><i>2079</i>&nbsp;                path = base.substring(0, i + 1);</b>
<b class="nc"><i>2080</i>&nbsp;        } else {</b>
<i>2081</i>&nbsp;            StringBuilder sb = new StringBuilder(base.length() + cn);
<b class="nc"><i>2082</i>&nbsp;            // 5.2 (6a)</b>
<i>2083</i>&nbsp;            if (i &gt;= 0)
<i>2084</i>&nbsp;                sb.append(base, 0, i + 1);
<b class="nc"><i>2085</i>&nbsp;            // 5.2 (6b)</b>
<i>2086</i>&nbsp;            sb.append(child);
<b class="nc"><i>2087</i>&nbsp;            path = sb.toString();</b>
<b class="nc"><i>2088</i>&nbsp;        }</b>
<b class="nc"><i>2089</i>&nbsp;</b>
<b class="nc"><i>2090</i>&nbsp;        // 5.2 (6c-f)</b>
<b class="nc"><i>2091</i>&nbsp;        String np = normalize(path);</b>
<b class="nc"><i>2092</i>&nbsp;</b>
<b class="nc"><i>2093</i>&nbsp;        // 5.2 (6g): If the result is absolute but the path begins with &quot;../&quot;,</b>
<i>2094</i>&nbsp;        // then we simply leave the path as-is
<i>2095</i>&nbsp;
<i>2096</i>&nbsp;        return np;
<b class="nc"><i>2097</i>&nbsp;    }</b>
<i>2098</i>&nbsp;
<i>2099</i>&nbsp;    // RFC2396 5.2
<i>2100</i>&nbsp;    private static URI resolve(URI base, URI child) {
<i>2101</i>&nbsp;        // check if child if opaque first so that NPE is thrown
<i>2102</i>&nbsp;        // if child is null.
<i>2103</i>&nbsp;        if (child.isOpaque() || base.isOpaque())
<b class="nc"><i>2104</i>&nbsp;            return child;</b>
<b class="nc"><i>2105</i>&nbsp;</b>
<i>2106</i>&nbsp;        // 5.2 (2): Reference to current document (lone fragment)
<b class="nc"><i>2107</i>&nbsp;        if ((child.scheme == null) &amp;&amp; (child.authority == null)</b>
<b class="nc"><i>2108</i>&nbsp;            &amp;&amp; child.path.isEmpty() &amp;&amp; (child.fragment != null)</b>
<b class="nc"><i>2109</i>&nbsp;            &amp;&amp; (child.query == null)) {</b>
<i>2110</i>&nbsp;            if ((base.fragment != null)
<b class="nc"><i>2111</i>&nbsp;                &amp;&amp; child.fragment.equals(base.fragment)) {</b>
<b class="nc"><i>2112</i>&nbsp;                return base;</b>
<b class="nc"><i>2113</i>&nbsp;            }</b>
<b class="nc"><i>2114</i>&nbsp;            URI ru = new URI();</b>
<b class="nc"><i>2115</i>&nbsp;            ru.scheme = base.scheme;</b>
<b class="nc"><i>2116</i>&nbsp;            ru.authority = base.authority;</b>
<b class="nc"><i>2117</i>&nbsp;            ru.userInfo = base.userInfo;</b>
<b class="nc"><i>2118</i>&nbsp;            ru.host = base.host;</b>
<b class="nc"><i>2119</i>&nbsp;            ru.port = base.port;</b>
<b class="nc"><i>2120</i>&nbsp;            ru.path = base.path;</b>
<i>2121</i>&nbsp;            ru.fragment = child.fragment;
<i>2122</i>&nbsp;            ru.query = base.query;
<i>2123</i>&nbsp;            return ru;
<i>2124</i>&nbsp;        }
<i>2125</i>&nbsp;
<i>2126</i>&nbsp;        // 5.2 (3): Child is absolute
<i>2127</i>&nbsp;        if (child.scheme != null)
<i>2128</i>&nbsp;            return child;
<i>2129</i>&nbsp;
<i>2130</i>&nbsp;        URI ru = new URI();             // Resolved URI
<b class="nc"><i>2131</i>&nbsp;        ru.scheme = base.scheme;</b>
<b class="nc"><i>2132</i>&nbsp;        ru.query = child.query;</b>
<b class="nc"><i>2133</i>&nbsp;        ru.fragment = child.fragment;</b>
<b class="nc"><i>2134</i>&nbsp;</b>
<b class="nc"><i>2135</i>&nbsp;        // 5.2 (4): Authority</b>
<i>2136</i>&nbsp;        if (child.authority == null) {
<b class="nc"><i>2137</i>&nbsp;            ru.authority = base.authority;</b>
<b class="nc"><i>2138</i>&nbsp;            ru.host = base.host;</b>
<b class="nc"><i>2139</i>&nbsp;            ru.userInfo = base.userInfo;</b>
<b class="nc"><i>2140</i>&nbsp;            ru.port = base.port;</b>
<b class="nc"><i>2141</i>&nbsp;</b>
<b class="nc"><i>2142</i>&nbsp;            String cp = (child.path == null) ? &quot;&quot; : child.path;</b>
<b class="nc"><i>2143</i>&nbsp;            if ((cp.length() &gt; 0) &amp;&amp; (cp.charAt(0) == &#39;/&#39;)) {</b>
<i>2144</i>&nbsp;                // 5.2 (5): Child path is absolute
<i>2145</i>&nbsp;                ru.path = child.path;
<b class="nc"><i>2146</i>&nbsp;            } else {</b>
<b class="nc"><i>2147</i>&nbsp;                // 5.2 (6): Resolve relative path</b>
<b class="nc"><i>2148</i>&nbsp;                ru.path = resolvePath(base.path, cp, base.isAbsolute());</b>
<b class="nc"><i>2149</i>&nbsp;            }</b>
<b class="nc"><i>2150</i>&nbsp;        } else {</b>
<i>2151</i>&nbsp;            ru.authority = child.authority;
<i>2152</i>&nbsp;            ru.host = child.host;
<i>2153</i>&nbsp;            ru.userInfo = child.userInfo;
<i>2154</i>&nbsp;            ru.host = child.host;
<i>2155</i>&nbsp;            ru.port = child.port;
<i>2156</i>&nbsp;            ru.path = child.path;
<i>2157</i>&nbsp;        }
<i>2158</i>&nbsp;
<i>2159</i>&nbsp;        // 5.2 (7): Recombine (nothing to do here)
<i>2160</i>&nbsp;        return ru;
<i>2161</i>&nbsp;    }
<i>2162</i>&nbsp;
<i>2163</i>&nbsp;    // If the given URI&#39;s path is normal then return the URI;
<i>2164</i>&nbsp;    // o.w., return a new URI containing the normalized path.
<i>2165</i>&nbsp;    //
<i>2166</i>&nbsp;    private static URI normalize(URI u) {
<i>2167</i>&nbsp;        if (u.isOpaque() || (u.path == null) || (u.path.length() == 0))
<i>2168</i>&nbsp;            return u;
<i>2169</i>&nbsp;
<i>2170</i>&nbsp;        String np = normalize(u.path);
<i>2171</i>&nbsp;        if (np == u.path)
<i>2172</i>&nbsp;            return u;
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;        URI v = new URI();
<i>2175</i>&nbsp;        v.scheme = u.scheme;
<i>2176</i>&nbsp;        v.fragment = u.fragment;
<i>2177</i>&nbsp;        v.authority = u.authority;
<i>2178</i>&nbsp;        v.userInfo = u.userInfo;
<b class="nc"><i>2179</i>&nbsp;        v.host = u.host;</b>
<b class="nc"><i>2180</i>&nbsp;        v.port = u.port;</b>
<b class="nc"><i>2181</i>&nbsp;        v.path = np;</b>
<b class="nc"><i>2182</i>&nbsp;        v.query = u.query;</b>
<i>2183</i>&nbsp;        return v;
<i>2184</i>&nbsp;    }
<b class="nc"><i>2185</i>&nbsp;</b>
<b class="nc"><i>2186</i>&nbsp;    // If both URIs are hierarchical, their scheme and authority components are</b>
<b class="nc"><i>2187</i>&nbsp;    // identical, and the base path is a prefix of the child&#39;s path, then</b>
<i>2188</i>&nbsp;    // return a relative URI that, when resolved against the base, yields the
<b class="nc"><i>2189</i>&nbsp;    // child; otherwise, return the child.</b>
<i>2190</i>&nbsp;    //
<i>2191</i>&nbsp;    private static URI relativize(URI base, URI child) {
<b class="nc"><i>2192</i>&nbsp;        // check if child if opaque first so that NPE is thrown</b>
<i>2193</i>&nbsp;        // if child is null.
<i>2194</i>&nbsp;        if (child.isOpaque() || base.isOpaque())
<b class="nc"><i>2195</i>&nbsp;            return child;</b>
<i>2196</i>&nbsp;        if (!equalIgnoringCase(base.scheme, child.scheme)
<b class="nc"><i>2197</i>&nbsp;            || !equal(base.authority, child.authority))</b>
<b class="nc"><i>2198</i>&nbsp;            return child;</b>
<i>2199</i>&nbsp;
<b class="nc"><i>2200</i>&nbsp;        String bp = normalize(base.path);</b>
<b class="nc"><i>2201</i>&nbsp;        String cp = normalize(child.path);</b>
<i>2202</i>&nbsp;        if (!bp.equals(cp)) {
<b class="nc"><i>2203</i>&nbsp;            if (!bp.endsWith(&quot;/&quot;))</b>
<i>2204</i>&nbsp;                bp = bp + &quot;/&quot;;
<i>2205</i>&nbsp;            if (!cp.startsWith(bp))
<b class="nc"><i>2206</i>&nbsp;                return child;</b>
<b class="nc"><i>2207</i>&nbsp;        }</b>
<b class="nc"><i>2208</i>&nbsp;</b>
<i>2209</i>&nbsp;        URI v = new URI();
<i>2210</i>&nbsp;        v.path = cp.substring(bp.length());
<b class="nc"><i>2211</i>&nbsp;        v.query = child.query;</b>
<b class="nc"><i>2212</i>&nbsp;        v.fragment = child.fragment;</b>
<b class="nc"><i>2213</i>&nbsp;        return v;</b>
<b class="nc"><i>2214</i>&nbsp;    }</b>
<i>2215</i>&nbsp;
<i>2216</i>&nbsp;
<i>2217</i>&nbsp;
<i>2218</i>&nbsp;    // -- Path normalization --
<i>2219</i>&nbsp;
<i>2220</i>&nbsp;    // The following algorithm for path normalization avoids the creation of a
<b class="nc"><i>2221</i>&nbsp;    // string object for each segment, as well as the use of a string buffer to</b>
<i>2222</i>&nbsp;    // compute the final result, by using a single char array and editing it in
<i>2223</i>&nbsp;    // place.  The array is first split into segments, replacing each slash
<i>2224</i>&nbsp;    // with &#39;\0&#39; and creating a segment-index array, each element of which is
<i>2225</i>&nbsp;    // the index of the first char in the corresponding segment.  We then walk
<i>2226</i>&nbsp;    // through both arrays, removing &quot;.&quot;, &quot;..&quot;, and other segments as necessary
<i>2227</i>&nbsp;    // by setting their entries in the index array to -1.  Finally, the two
<i>2228</i>&nbsp;    // arrays are used to rejoin the segments and compute the final result.
<i>2229</i>&nbsp;    //
<i>2230</i>&nbsp;    // This code is based upon src/solaris/native/java/io/canonicalize_md.c
<i>2231</i>&nbsp;
<i>2232</i>&nbsp;
<i>2233</i>&nbsp;    // Check the given path to see if it might need normalization.  A path
<i>2234</i>&nbsp;    // might need normalization if it contains duplicate slashes, a &quot;.&quot;
<i>2235</i>&nbsp;    // segment, or a &quot;..&quot; segment.  Return -1 if no further normalization is
<b class="nc"><i>2236</i>&nbsp;    // possible, otherwise return the number of segments found.</b>
<b class="nc"><i>2237</i>&nbsp;    //</b>
<b class="nc"><i>2238</i>&nbsp;    // This method takes a string argument rather than a char array so that</b>
<i>2239</i>&nbsp;    // this test can be performed without invoking path.toCharArray().
<i>2240</i>&nbsp;    //
<b class="nc"><i>2241</i>&nbsp;    private static int needsNormalization(String path) {</b>
<b class="nc"><i>2242</i>&nbsp;        boolean normal = true;</b>
<b class="nc"><i>2243</i>&nbsp;        int ns = 0;                     // Number of segments</b>
<b class="nc"><i>2244</i>&nbsp;        int end = path.length() - 1;    // Index of last char in path</b>
<i>2245</i>&nbsp;        int p = 0;                      // Index of next char in path
<i>2246</i>&nbsp;
<b class="nc"><i>2247</i>&nbsp;        // Skip initial slashes</b>
<i>2248</i>&nbsp;        while (p &lt;= end) {
<i>2249</i>&nbsp;            if (path.charAt(p) != &#39;/&#39;) break;
<b class="nc"><i>2250</i>&nbsp;            p++;</b>
<i>2251</i>&nbsp;        }
<i>2252</i>&nbsp;        if (p &gt; 1) normal = false;
<b class="nc"><i>2253</i>&nbsp;</b>
<b class="nc"><i>2254</i>&nbsp;        // Scan segments</b>
<b class="nc"><i>2255</i>&nbsp;        while (p &lt;= end) {</b>
<b class="nc"><i>2256</i>&nbsp;</b>
<i>2257</i>&nbsp;            // Looking at &quot;.&quot; or &quot;..&quot; ?
<i>2258</i>&nbsp;            if ((path.charAt(p) == &#39;.&#39;)
<b class="nc"><i>2259</i>&nbsp;                &amp;&amp; ((p == end)</b>
<b class="nc"><i>2260</i>&nbsp;                    || ((path.charAt(p + 1) == &#39;/&#39;)</b>
<b class="nc"><i>2261</i>&nbsp;                        || ((path.charAt(p + 1) == &#39;.&#39;)</b>
<i>2262</i>&nbsp;                            &amp;&amp; ((p + 1 == end)
<i>2263</i>&nbsp;                                || (path.charAt(p + 2) == &#39;/&#39;)))))) {
<i>2264</i>&nbsp;                normal = false;
<i>2265</i>&nbsp;            }
<i>2266</i>&nbsp;            ns++;
<b class="nc"><i>2267</i>&nbsp;</b>
<b class="nc"><i>2268</i>&nbsp;            // Find beginning of next segment</b>
<i>2269</i>&nbsp;            while (p &lt;= end) {
<i>2270</i>&nbsp;                if (path.charAt(p++) != &#39;/&#39;)
<i>2271</i>&nbsp;                    continue;
<i>2272</i>&nbsp;
<i>2273</i>&nbsp;                // Skip redundant slashes
<i>2274</i>&nbsp;                while (p &lt;= end) {
<i>2275</i>&nbsp;                    if (path.charAt(p) != &#39;/&#39;) break;
<i>2276</i>&nbsp;                    normal = false;
<i>2277</i>&nbsp;                    p++;
<i>2278</i>&nbsp;                }
<i>2279</i>&nbsp;
<i>2280</i>&nbsp;                break;
<i>2281</i>&nbsp;            }
<i>2282</i>&nbsp;        }
<i>2283</i>&nbsp;
<i>2284</i>&nbsp;        return normal ? -1 : ns;
<b class="nc"><i>2285</i>&nbsp;    }</b>
<b class="nc"><i>2286</i>&nbsp;</b>
<b class="nc"><i>2287</i>&nbsp;</b>
<i>2288</i>&nbsp;    // Split the given path into segments, replacing slashes with nulls and
<b class="nc"><i>2289</i>&nbsp;    // filling in the given segment-index array.</b>
<i>2290</i>&nbsp;    //
<b class="nc"><i>2291</i>&nbsp;    // Preconditions:</b>
<i>2292</i>&nbsp;    //   segs.length == Number of segments in path
<i>2293</i>&nbsp;    //
<b class="nc"><i>2294</i>&nbsp;    // Postconditions:</b>
<b class="nc"><i>2295</i>&nbsp;    //   All slashes in path replaced by &#39;\0&#39;</b>
<b class="nc"><i>2296</i>&nbsp;    //   segs[i] == Index of first char in segment i (0 &lt;= i &lt; segs.length)</b>
<i>2297</i>&nbsp;    //
<b class="nc"><i>2298</i>&nbsp;    private static void split(char[] path, int[] segs) {</b>
<i>2299</i>&nbsp;        int end = path.length - 1;      // Index of last char in path
<b class="nc"><i>2300</i>&nbsp;        int p = 0;                      // Index of next char in path</b>
<i>2301</i>&nbsp;        int i = 0;                      // Index of current segment
<b class="nc"><i>2302</i>&nbsp;</b>
<b class="nc"><i>2303</i>&nbsp;        // Skip initial slashes</b>
<b class="nc"><i>2304</i>&nbsp;        while (p &lt;= end) {</b>
<i>2305</i>&nbsp;            if (path[p] != &#39;/&#39;) break;
<b class="nc"><i>2306</i>&nbsp;            path[p] = &#39;\0&#39;;</b>
<i>2307</i>&nbsp;            p++;
<b class="nc"><i>2308</i>&nbsp;        }</b>
<i>2309</i>&nbsp;
<b class="nc"><i>2310</i>&nbsp;        while (p &lt;= end) {</b>
<b class="nc"><i>2311</i>&nbsp;</b>
<b class="nc"><i>2312</i>&nbsp;            // Note start of segment</b>
<i>2313</i>&nbsp;            segs[i++] = p++;
<b class="nc"><i>2314</i>&nbsp;</b>
<i>2315</i>&nbsp;            // Find beginning of next segment
<i>2316</i>&nbsp;            while (p &lt;= end) {
<b class="nc"><i>2317</i>&nbsp;                if (path[p++] != &#39;/&#39;)</b>
<i>2318</i>&nbsp;                    continue;
<i>2319</i>&nbsp;                path[p - 1] = &#39;\0&#39;;
<b class="nc"><i>2320</i>&nbsp;</b>
<i>2321</i>&nbsp;                // Skip redundant slashes
<i>2322</i>&nbsp;                while (p &lt;= end) {
<i>2323</i>&nbsp;                    if (path[p] != &#39;/&#39;) break;
<i>2324</i>&nbsp;                    path[p++] = &#39;\0&#39;;
<i>2325</i>&nbsp;                }
<i>2326</i>&nbsp;                break;
<i>2327</i>&nbsp;            }
<b class="nc"><i>2328</i>&nbsp;        }</b>
<b class="nc"><i>2329</i>&nbsp;</b>
<i>2330</i>&nbsp;        if (i != segs.length)
<b class="nc"><i>2331</i>&nbsp;            throw new InternalError();  // ASSERT</b>
<b class="nc"><i>2332</i>&nbsp;    }</b>
<i>2333</i>&nbsp;
<i>2334</i>&nbsp;
<i>2335</i>&nbsp;    // Join the segments in the given path according to the given segment-index
<b class="nc"><i>2336</i>&nbsp;    // array, ignoring those segments whose index entries have been set to -1,</b>
<b class="nc"><i>2337</i>&nbsp;    // and inserting slashes as needed.  Return the length of the resulting</b>
<b class="nc"><i>2338</i>&nbsp;    // path.</b>
<b class="nc"><i>2339</i>&nbsp;    //</b>
<b class="nc"><i>2340</i>&nbsp;    // Preconditions:</b>
<b class="nc"><i>2341</i>&nbsp;    //   segs[i] == -1 implies segment i is to be ignored</b>
<b class="nc"><i>2342</i>&nbsp;    //   path computed by split, as above, with &#39;\0&#39; having replaced &#39;/&#39;</b>
<b class="nc"><i>2343</i>&nbsp;    //</b>
<b class="nc"><i>2344</i>&nbsp;    // Postconditions:</b>
<i>2345</i>&nbsp;    //   path[0] .. path[return value] == Resulting path
<i>2346</i>&nbsp;    //
<b class="nc"><i>2347</i>&nbsp;    private static int join(char[] path, int[] segs) {</b>
<b class="nc"><i>2348</i>&nbsp;        int ns = segs.length;           // Number of segments</b>
<i>2349</i>&nbsp;        int end = path.length - 1;      // Index of last char in path
<i>2350</i>&nbsp;        int p = 0;                      // Index of next path char to write
<b class="nc"><i>2351</i>&nbsp;</b>
<b class="nc"><i>2352</i>&nbsp;        if (path[p] == &#39;\0&#39;) {</b>
<b class="nc"><i>2353</i>&nbsp;            // Restore initial slash for absolute paths</b>
<b class="nc"><i>2354</i>&nbsp;            path[p++] = &#39;/&#39;;</b>
<i>2355</i>&nbsp;        }
<b class="nc"><i>2356</i>&nbsp;</b>
<i>2357</i>&nbsp;        for (int i = 0; i &lt; ns; i++) {
<b class="nc"><i>2358</i>&nbsp;            int q = segs[i];            // Current segment</b>
<i>2359</i>&nbsp;            if (q == -1)
<i>2360</i>&nbsp;                // Ignore this segment
<i>2361</i>&nbsp;                continue;
<i>2362</i>&nbsp;
<i>2363</i>&nbsp;            if (p == q) {
<b class="nc"><i>2364</i>&nbsp;                // We&#39;re already at this segment, so just skip to its end</b>
<b class="nc"><i>2365</i>&nbsp;                while ((p &lt;= end) &amp;&amp; (path[p] != &#39;\0&#39;))</b>
<i>2366</i>&nbsp;                    p++;
<b class="nc"><i>2367</i>&nbsp;                if (p &lt;= end) {</b>
<b class="nc"><i>2368</i>&nbsp;                    // Preserve trailing slash</b>
<b class="nc"><i>2369</i>&nbsp;                    path[p++] = &#39;/&#39;;</b>
<i>2370</i>&nbsp;                }
<i>2371</i>&nbsp;            } else if (p &lt; q) {
<b class="nc"><i>2372</i>&nbsp;                // Copy q down to p</b>
<b class="nc"><i>2373</i>&nbsp;                while ((q &lt;= end) &amp;&amp; (path[q] != &#39;\0&#39;))</b>
<i>2374</i>&nbsp;                    path[p++] = path[q++];
<i>2375</i>&nbsp;                if (q &lt;= end) {
<i>2376</i>&nbsp;                    // Preserve trailing slash
<i>2377</i>&nbsp;                    path[p++] = &#39;/&#39;;
<i>2378</i>&nbsp;                }
<i>2379</i>&nbsp;            } else
<i>2380</i>&nbsp;                throw new InternalError(); // ASSERT false
<i>2381</i>&nbsp;        }
<i>2382</i>&nbsp;
<i>2383</i>&nbsp;        return p;
<i>2384</i>&nbsp;    }
<i>2385</i>&nbsp;
<b class="nc"><i>2386</i>&nbsp;</b>
<i>2387</i>&nbsp;    // Remove &quot;.&quot; segments from the given path, and remove segment pairs
<i>2388</i>&nbsp;    // consisting of a non-&quot;..&quot; segment followed by a &quot;..&quot; segment.
<i>2389</i>&nbsp;    //
<b class="nc"><i>2390</i>&nbsp;    private static void removeDots(char[] path, int[] segs) {</b>
<b class="nc"><i>2391</i>&nbsp;        int ns = segs.length;</b>
<b class="nc"><i>2392</i>&nbsp;        int end = path.length - 1;</b>
<b class="nc"><i>2393</i>&nbsp;</b>
<b class="nc"><i>2394</i>&nbsp;        for (int i = 0; i &lt; ns; i++) {</b>
<b class="nc"><i>2395</i>&nbsp;            int dots = 0;               // Number of dots found (0, 1, or 2)</b>
<i>2396</i>&nbsp;
<b class="nc"><i>2397</i>&nbsp;            // Find next occurrence of &quot;.&quot; or &quot;..&quot;</b>
<i>2398</i>&nbsp;            do {
<i>2399</i>&nbsp;                int p = segs[i];
<i>2400</i>&nbsp;                if (path[p] == &#39;.&#39;) {
<i>2401</i>&nbsp;                    if (p == end) {
<b class="nc"><i>2402</i>&nbsp;                        dots = 1;</b>
<b class="nc"><i>2403</i>&nbsp;                        break;</b>
<b class="nc"><i>2404</i>&nbsp;                    } else if (path[p + 1] == &#39;\0&#39;) {</b>
<i>2405</i>&nbsp;                        dots = 1;
<i>2406</i>&nbsp;                        break;
<i>2407</i>&nbsp;                    } else if ((path[p + 1] == &#39;.&#39;)
<i>2408</i>&nbsp;                               &amp;&amp; ((p + 1 == end)
<i>2409</i>&nbsp;                                   || (path[p + 2] == &#39;\0&#39;))) {
<b class="nc"><i>2410</i>&nbsp;                        dots = 2;</b>
<b class="nc"><i>2411</i>&nbsp;                        break;</b>
<b class="nc"><i>2412</i>&nbsp;                    }</b>
<i>2413</i>&nbsp;                }
<i>2414</i>&nbsp;                i++;
<i>2415</i>&nbsp;            } while (i &lt; ns);
<i>2416</i>&nbsp;            if ((i &gt; ns) || (dots == 0))
<i>2417</i>&nbsp;                break;
<i>2418</i>&nbsp;
<i>2419</i>&nbsp;            if (dots == 1) {
<i>2420</i>&nbsp;                // Remove this occurrence of &quot;.&quot;
<i>2421</i>&nbsp;                segs[i] = -1;
<i>2422</i>&nbsp;            } else {
<i>2423</i>&nbsp;                // If there is a preceding non-&quot;..&quot; segment, remove both that
<i>2424</i>&nbsp;                // segment and this occurrence of &quot;..&quot;; otherwise, leave this
<b class="nc"><i>2425</i>&nbsp;                // &quot;..&quot; segment as-is.</b>
<b class="nc"><i>2426</i>&nbsp;                int j;</b>
<i>2427</i>&nbsp;                for (j = i - 1; j &gt;= 0; j--) {
<b class="nc"><i>2428</i>&nbsp;                    if (segs[j] != -1) break;</b>
<i>2429</i>&nbsp;                }
<b class="nc"><i>2430</i>&nbsp;                if (j &gt;= 0) {</b>
<i>2431</i>&nbsp;                    int q = segs[j];
<i>2432</i>&nbsp;                    if (!((path[q] == &#39;.&#39;)
<b class="nc"><i>2433</i>&nbsp;                          &amp;&amp; (path[q + 1] == &#39;.&#39;)</b>
<b class="nc"><i>2434</i>&nbsp;                          &amp;&amp; (path[q + 2] == &#39;\0&#39;))) {</b>
<i>2435</i>&nbsp;                        segs[i] = -1;
<i>2436</i>&nbsp;                        segs[j] = -1;
<b class="nc"><i>2437</i>&nbsp;                    }</b>
<i>2438</i>&nbsp;                }
<i>2439</i>&nbsp;            }
<b class="nc"><i>2440</i>&nbsp;        }</b>
<i>2441</i>&nbsp;    }
<i>2442</i>&nbsp;
<b class="nc"><i>2443</i>&nbsp;</b>
<b class="nc"><i>2444</i>&nbsp;    // DEVIATION: If the normalized path is relative, and if the first</b>
<i>2445</i>&nbsp;    // segment could be parsed as a scheme name, then prepend a &quot;.&quot; segment
<b class="nc"><i>2446</i>&nbsp;    //</b>
<i>2447</i>&nbsp;    private static void maybeAddLeadingDot(char[] path, int[] segs) {
<b class="nc"><i>2448</i>&nbsp;</b>
<i>2449</i>&nbsp;        if (path[0] == &#39;\0&#39;)
<i>2450</i>&nbsp;            // The path is absolute
<i>2451</i>&nbsp;            return;
<i>2452</i>&nbsp;
<i>2453</i>&nbsp;        int ns = segs.length;
<i>2454</i>&nbsp;        int f = 0;                      // Index of first segment
<i>2455</i>&nbsp;        while (f &lt; ns) {
<i>2456</i>&nbsp;            if (segs[f] &gt;= 0)
<i>2457</i>&nbsp;                break;
<i>2458</i>&nbsp;            f++;
<i>2459</i>&nbsp;        }
<i>2460</i>&nbsp;        if ((f &gt;= ns) || (f == 0))
<i>2461</i>&nbsp;            // The path is empty, or else the original first segment survived,
<i>2462</i>&nbsp;            // in which case we already know that no leading &quot;.&quot; is needed
<i>2463</i>&nbsp;            return;
<i>2464</i>&nbsp;
<i>2465</i>&nbsp;        int p = segs[f];
<i>2466</i>&nbsp;        while ((p &lt; path.length) &amp;&amp; (path[p] != &#39;:&#39;) &amp;&amp; (path[p] != &#39;\0&#39;)) p++;
<i>2467</i>&nbsp;        if (p &gt;= path.length || path[p] == &#39;\0&#39;)
<i>2468</i>&nbsp;            // No colon in first segment, so no &quot;.&quot; needed
<b class="nc"><i>2469</i>&nbsp;            return;</b>
<b class="nc"><i>2470</i>&nbsp;</b>
<b class="nc"><i>2471</i>&nbsp;        // At this point we know that the first segment is unused,</b>
<b class="nc"><i>2472</i>&nbsp;        // hence we can insert a &quot;.&quot; segment at that position</b>
<b class="nc"><i>2473</i>&nbsp;        path[0] = &#39;.&#39;;</b>
<b class="nc"><i>2474</i>&nbsp;        path[1] = &#39;\0&#39;;</b>
<i>2475</i>&nbsp;        segs[0] = 0;
<b class="nc"><i>2476</i>&nbsp;    }</b>
<i>2477</i>&nbsp;
<i>2478</i>&nbsp;
<i>2479</i>&nbsp;    // Normalize the given path string.  A normal path string has no empty
<i>2480</i>&nbsp;    // segments (i.e., occurrences of &quot;//&quot;), no segments equal to &quot;.&quot;, and no
<b class="nc"><i>2481</i>&nbsp;    // segments equal to &quot;..&quot; that are preceded by a segment not equal to &quot;..&quot;.</b>
<b class="nc"><i>2482</i>&nbsp;    // In contrast to Unix-style pathname normalization, for URI paths we</b>
<b class="nc"><i>2483</i>&nbsp;    // always retain trailing slashes.</b>
<b class="nc"><i>2484</i>&nbsp;    //</b>
<b class="nc"><i>2485</i>&nbsp;    private static String normalize(String ps) {</b>
<b class="nc"><i>2486</i>&nbsp;</b>
<i>2487</i>&nbsp;        // Does this path need normalization?
<b class="nc"><i>2488</i>&nbsp;        int ns = needsNormalization(ps);        // Number of segments</b>
<i>2489</i>&nbsp;        if (ns &lt; 0)
<i>2490</i>&nbsp;            // Nope -- just return it
<i>2491</i>&nbsp;            return ps;
<i>2492</i>&nbsp;
<i>2493</i>&nbsp;        char[] path = ps.toCharArray();         // Path in char-array form
<b class="nc"><i>2494</i>&nbsp;</b>
<b class="nc"><i>2495</i>&nbsp;        // Split path into segments</b>
<b class="nc"><i>2496</i>&nbsp;        int[] segs = new int[ns];               // Segment-index array</b>
<b class="nc"><i>2497</i>&nbsp;        split(path, segs);</b>
<b class="nc"><i>2498</i>&nbsp;</b>
<b class="nc"><i>2499</i>&nbsp;        // Remove dots</b>
<i>2500</i>&nbsp;        removeDots(path, segs);
<i>2501</i>&nbsp;
<i>2502</i>&nbsp;        // Prevent scheme-name confusion
<i>2503</i>&nbsp;        maybeAddLeadingDot(path, segs);
<i>2504</i>&nbsp;
<b class="nc"><i>2505</i>&nbsp;        // Join the remaining segments and return the result</b>
<b class="nc"><i>2506</i>&nbsp;        String s = new String(path, 0, join(path, segs));</b>
<b class="nc"><i>2507</i>&nbsp;        if (s.equals(ps)) {</b>
<b class="nc"><i>2508</i>&nbsp;            // string was already normalized</b>
<b class="nc"><i>2509</i>&nbsp;            return ps;</b>
<b class="nc"><i>2510</i>&nbsp;        }</b>
<i>2511</i>&nbsp;        return s;
<i>2512</i>&nbsp;    }
<i>2513</i>&nbsp;
<i>2514</i>&nbsp;
<b class="nc"><i>2515</i>&nbsp;</b>
<b class="nc"><i>2516</i>&nbsp;    // -- Character classes for parsing --</b>
<b class="nc"><i>2517</i>&nbsp;</b>
<b class="nc"><i>2518</i>&nbsp;    // RFC2396 precisely specifies which characters in the US-ASCII charset are</b>
<b class="nc"><i>2519</i>&nbsp;    // permissible in the various components of a URI reference.  We here</b>
<b class="nc"><i>2520</i>&nbsp;    // define a set of mask pairs to aid in enforcing these restrictions.  Each</b>
<b class="nc"><i>2521</i>&nbsp;    // mask pair consists of two longs, a low mask and a high mask.  Taken</b>
<i>2522</i>&nbsp;    // together they represent a 128-bit mask, where bit i is set iff the
<i>2523</i>&nbsp;    // character with value i is permitted.
<i>2524</i>&nbsp;    //
<i>2525</i>&nbsp;    // This approach is more efficient than sequentially searching arrays of
<i>2526</i>&nbsp;    // permitted characters.  It could be made still more efficient by
<i>2527</i>&nbsp;    // precompiling the mask information so that a character&#39;s presence in a
<i>2528</i>&nbsp;    // given mask could be determined by a single table lookup.
<b class="nc"><i>2529</i>&nbsp;</b>
<i>2530</i>&nbsp;    // To save startup time, we manually calculate the low-/highMask constants.
<i>2531</i>&nbsp;    // For reference, the following methods were used to calculate the values:
<i>2532</i>&nbsp;
<i>2533</i>&nbsp;    // Compute the low-order mask for the characters in the given string
<i>2534</i>&nbsp;    //     private static long lowMask(String chars) {
<i>2535</i>&nbsp;    //        int n = chars.length();
<b class="nc"><i>2536</i>&nbsp;    //        long m = 0;</b>
<i>2537</i>&nbsp;    //        for (int i = 0; i &lt; n; i++) {
<i>2538</i>&nbsp;    //            char c = chars.charAt(i);
<i>2539</i>&nbsp;    //            if (c &lt; 64)
<i>2540</i>&nbsp;    //                m |= (1L &lt;&lt; c);
<i>2541</i>&nbsp;    //        }
<b class="nc"><i>2542</i>&nbsp;    //        return m;</b>
<i>2543</i>&nbsp;    //    }
<i>2544</i>&nbsp;
<i>2545</i>&nbsp;    // Compute the high-order mask for the characters in the given string
<b class="nc"><i>2546</i>&nbsp;    //    private static long highMask(String chars) {</b>
<i>2547</i>&nbsp;    //        int n = chars.length();
<i>2548</i>&nbsp;    //        long m = 0;
<b class="nc"><i>2549</i>&nbsp;    //        for (int i = 0; i &lt; n; i++) {</b>
<b class="nc"><i>2550</i>&nbsp;    //            char c = chars.charAt(i);</b>
<i>2551</i>&nbsp;    //            if ((c &gt;= 64) &amp;&amp; (c &lt; 128))
<i>2552</i>&nbsp;    //                m |= (1L &lt;&lt; (c - 64));
<i>2553</i>&nbsp;    //        }
<b class="nc"><i>2554</i>&nbsp;    //        return m;</b>
<b class="nc"><i>2555</i>&nbsp;    //    }</b>
<i>2556</i>&nbsp;
<i>2557</i>&nbsp;    // Compute a low-order mask for the characters
<i>2558</i>&nbsp;    // between first and last, inclusive
<b class="nc"><i>2559</i>&nbsp;    //    private static long lowMask(char first, char last) {</b>
<b class="nc"><i>2560</i>&nbsp;    //        long m = 0;</b>
<i>2561</i>&nbsp;    //        int f = Math.max(Math.min(first, 63), 0);
<i>2562</i>&nbsp;    //        int l = Math.max(Math.min(last, 63), 0);
<b class="nc"><i>2563</i>&nbsp;    //        for (int i = f; i &lt;= l; i++)</b>
<b class="nc"><i>2564</i>&nbsp;    //            m |= 1L &lt;&lt; i;</b>
<i>2565</i>&nbsp;    //        return m;
<i>2566</i>&nbsp;    //    }
<i>2567</i>&nbsp;
<i>2568</i>&nbsp;    // Compute a high-order mask for the characters
<b class="nc"><i>2569</i>&nbsp;    // between first and last, inclusive</b>
<b class="nc"><i>2570</i>&nbsp;    //    private static long highMask(char first, char last) {</b>
<i>2571</i>&nbsp;    //        long m = 0;
<i>2572</i>&nbsp;    //        int f = Math.max(Math.min(first, 127), 64) - 64;
<i>2573</i>&nbsp;    //        int l = Math.max(Math.min(last, 127), 64) - 64;
<i>2574</i>&nbsp;    //        for (int i = f; i &lt;= l; i++)
<i>2575</i>&nbsp;    //            m |= 1L &lt;&lt; i;
<i>2576</i>&nbsp;    //        return m;
<i>2577</i>&nbsp;    //    }
<b class="nc"><i>2578</i>&nbsp;</b>
<b class="nc"><i>2579</i>&nbsp;    // Tell whether the given character is permitted by the given mask pair</b>
<i>2580</i>&nbsp;    private static boolean match(char c, long lowMask, long highMask) {
<i>2581</i>&nbsp;        if (c == 0) // 0 doesn&#39;t have a slot in the mask. So, it never matches.
<i>2582</i>&nbsp;            return false;
<b class="nc"><i>2583</i>&nbsp;        if (c &lt; 64)</b>
<b class="nc"><i>2584</i>&nbsp;            return ((1L &lt;&lt; c) &amp; lowMask) != 0;</b>
<b class="nc"><i>2585</i>&nbsp;        if (c &lt; 128)</b>
<b class="nc"><i>2586</i>&nbsp;            return ((1L &lt;&lt; (c - 64)) &amp; highMask) != 0;</b>
<i>2587</i>&nbsp;        return false;
<i>2588</i>&nbsp;    }
<b class="nc"><i>2589</i>&nbsp;</b>
<b class="nc"><i>2590</i>&nbsp;    // Character-class masks, in reverse order from RFC2396 because</b>
<i>2591</i>&nbsp;    // initializers for static fields cannot make forward references.
<i>2592</i>&nbsp;
<b class="nc"><i>2593</i>&nbsp;    // digit    = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |</b>
<b class="nc"><i>2594</i>&nbsp;    //            &quot;8&quot; | &quot;9&quot;</b>
<i>2595</i>&nbsp;    private static final long L_DIGIT = 0x3FF000000000000L; // lowMask(&#39;0&#39;, &#39;9&#39;);
<i>2596</i>&nbsp;    private static final long H_DIGIT = 0L;
<b class="nc"><i>2597</i>&nbsp;</b>
<b class="nc"><i>2598</i>&nbsp;    // upalpha  = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; |</b>
<i>2599</i>&nbsp;    //            &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; |
<i>2600</i>&nbsp;    //            &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;
<i>2601</i>&nbsp;    private static final long L_UPALPHA = 0L;
<b class="nc"><i>2602</i>&nbsp;    private static final long H_UPALPHA = 0x7FFFFFEL; // highMask(&#39;A&#39;, &#39;Z&#39;);</b>
<b class="nc"><i>2603</i>&nbsp;</b>
<b class="nc"><i>2604</i>&nbsp;    // lowalpha = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; |</b>
<b class="nc"><i>2605</i>&nbsp;    //            &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; |</b>
<i>2606</i>&nbsp;    //            &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;
<i>2607</i>&nbsp;    private static final long L_LOWALPHA = 0L;
<i>2608</i>&nbsp;    private static final long H_LOWALPHA = 0x7FFFFFE00000000L; // highMask(&#39;a&#39;, &#39;z&#39;);
<b class="nc"><i>2609</i>&nbsp;</b>
<b class="nc"><i>2610</i>&nbsp;    // alpha         = lowalpha | upalpha</b>
<b class="nc"><i>2611</i>&nbsp;    private static final long L_ALPHA = L_LOWALPHA | L_UPALPHA;</b>
<b class="nc"><i>2612</i>&nbsp;    private static final long H_ALPHA = H_LOWALPHA | H_UPALPHA;</b>
<i>2613</i>&nbsp;
<i>2614</i>&nbsp;    // alphanum      = alpha | digit
<b class="nc"><i>2615</i>&nbsp;    private static final long L_ALPHANUM = L_DIGIT | L_ALPHA;</b>
<b class="nc"><i>2616</i>&nbsp;    private static final long H_ALPHANUM = H_DIGIT | H_ALPHA;</b>
<b class="nc"><i>2617</i>&nbsp;</b>
<b class="nc"><i>2618</i>&nbsp;    // hex           = digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |</b>
<i>2619</i>&nbsp;    //                         &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
<i>2620</i>&nbsp;    private static final long L_HEX = L_DIGIT;
<i>2621</i>&nbsp;    private static final long H_HEX = 0x7E0000007EL; // highMask(&#39;A&#39;, &#39;F&#39;) | highMask(&#39;a&#39;, &#39;f&#39;);
<b class="nc"><i>2622</i>&nbsp;</b>
<b class="nc"><i>2623</i>&nbsp;    // mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;&#39;&quot; |</b>
<b class="nc"><i>2624</i>&nbsp;    //                 &quot;(&quot; | &quot;)&quot;</b>
<b class="nc"><i>2625</i>&nbsp;    private static final long L_MARK = 0x678200000000L; // lowMask(&quot;-_.!~*&#39;()&quot;);</b>
<b class="nc"><i>2626</i>&nbsp;    private static final long H_MARK = 0x4000000080000000L; // highMask(&quot;-_.!~*&#39;()&quot;);</b>
<b class="nc"><i>2627</i>&nbsp;</b>
<i>2628</i>&nbsp;    // unreserved    = alphanum | mark
<i>2629</i>&nbsp;    private static final long L_UNRESERVED = L_ALPHANUM | L_MARK;
<b class="nc"><i>2630</i>&nbsp;    private static final long H_UNRESERVED = H_ALPHANUM | H_MARK;</b>
<b class="nc"><i>2631</i>&nbsp;</b>
<i>2632</i>&nbsp;    // reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |
<i>2633</i>&nbsp;    //                 &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot;
<i>2634</i>&nbsp;    // Added per RFC2732: &quot;[&quot;, &quot;]&quot;
<b class="nc"><i>2635</i>&nbsp;    private static final long L_RESERVED = 0xAC00985000000000L; // lowMask(&quot;;/?:@&amp;=+$,[]&quot;);</b>
<b class="nc"><i>2636</i>&nbsp;    private static final long H_RESERVED = 0x28000001L; // highMask(&quot;;/?:@&amp;=+$,[]&quot;);</b>
<b class="nc"><i>2637</i>&nbsp;</b>
<b class="nc"><i>2638</i>&nbsp;    // The zero&#39;th bit is used to indicate that escape pairs and non-US-ASCII</b>
<i>2639</i>&nbsp;    // characters are allowed; this is handled by the scanEscape method below.
<i>2640</i>&nbsp;    private static final long L_ESCAPED = 1L;
<i>2641</i>&nbsp;    private static final long H_ESCAPED = 0L;
<i>2642</i>&nbsp;
<b class="nc"><i>2643</i>&nbsp;    // uric          = reserved | unreserved | escaped</b>
<i>2644</i>&nbsp;    private static final long L_URIC = L_RESERVED | L_UNRESERVED | L_ESCAPED;
<i>2645</i>&nbsp;    private static final long H_URIC = H_RESERVED | H_UNRESERVED | H_ESCAPED;
<i>2646</i>&nbsp;
<i>2647</i>&nbsp;    // pchar         = unreserved | escaped |
<i>2648</i>&nbsp;    //                 &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
<b class="nc"><i>2649</i>&nbsp;    private static final long L_PCHAR</b>
<b class="nc"><i>2650</i>&nbsp;        = L_UNRESERVED | L_ESCAPED | 0x2400185000000000L; // lowMask(&quot;:@&amp;=+$,&quot;);</b>
<b class="nc"><i>2651</i>&nbsp;    private static final long H_PCHAR</b>
<i>2652</i>&nbsp;        = H_UNRESERVED | H_ESCAPED | 0x1L; // highMask(&quot;:@&amp;=+$,&quot;);
<i>2653</i>&nbsp;
<i>2654</i>&nbsp;    // All valid path characters
<b class="nc"><i>2655</i>&nbsp;    private static final long L_PATH = L_PCHAR | 0x800800000000000L; // lowMask(&quot;;/&quot;);</b>
<i>2656</i>&nbsp;    private static final long H_PATH = H_PCHAR; // highMask(&quot;;/&quot;) == 0x0L;
<b class="nc"><i>2657</i>&nbsp;</b>
<b class="nc"><i>2658</i>&nbsp;    // Dash, for use in domainlabel and toplabel</b>
<b class="nc"><i>2659</i>&nbsp;    private static final long L_DASH = 0x200000000000L; // lowMask(&quot;-&quot;);</b>
<b class="nc"><i>2660</i>&nbsp;    private static final long H_DASH = 0x0L; // highMask(&quot;-&quot;);</b>
<b class="nc"><i>2661</i>&nbsp;</b>
<b class="nc"><i>2662</i>&nbsp;    // Dot, for use in hostnames</b>
<b class="nc"><i>2663</i>&nbsp;    private static final long L_DOT = 0x400000000000L; // lowMask(&quot;.&quot;);</b>
<b class="nc"><i>2664</i>&nbsp;    private static final long H_DOT = 0x0L; // highMask(&quot;.&quot;);</b>
<b class="nc"><i>2665</i>&nbsp;</b>
<i>2666</i>&nbsp;    // userinfo      = *( unreserved | escaped |
<b class="nc"><i>2667</i>&nbsp;    //                    &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )</b>
<b class="nc"><i>2668</i>&nbsp;    private static final long L_USERINFO</b>
<i>2669</i>&nbsp;        = L_UNRESERVED | L_ESCAPED | 0x2C00185000000000L; // lowMask(&quot;;:&amp;=+$,&quot;);
<i>2670</i>&nbsp;    private static final long H_USERINFO
<i>2671</i>&nbsp;        = H_UNRESERVED | H_ESCAPED; // | highMask(&quot;;:&amp;=+$,&quot;) == 0L;
<i>2672</i>&nbsp;
<i>2673</i>&nbsp;    // reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |
<i>2674</i>&nbsp;    //                     &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )
<b class="nc"><i>2675</i>&nbsp;    private static final long L_REG_NAME</b>
<b class="nc"><i>2676</i>&nbsp;        = L_UNRESERVED | L_ESCAPED | 0x2C00185000000000L; // lowMask(&quot;$,;:@&amp;=+&quot;);</b>
<b class="nc"><i>2677</i>&nbsp;    private static final long H_REG_NAME</b>
<b class="nc"><i>2678</i>&nbsp;        = H_UNRESERVED | H_ESCAPED | 0x1L; // highMask(&quot;$,;:@&amp;=+&quot;);</b>
<b class="nc"><i>2679</i>&nbsp;</b>
<b class="nc"><i>2680</i>&nbsp;    // All valid characters for server-based authorities</b>
<b class="nc"><i>2681</i>&nbsp;    private static final long L_SERVER</b>
<b class="nc"><i>2682</i>&nbsp;        = L_USERINFO | L_ALPHANUM | L_DASH | 0x400400000000000L; // lowMask(&quot;.:@[]&quot;);</b>
<b class="nc"><i>2683</i>&nbsp;    private static final long H_SERVER</b>
<b class="nc"><i>2684</i>&nbsp;        = H_USERINFO | H_ALPHANUM | H_DASH | 0x28000001L; // highMask(&quot;.:@[]&quot;);</b>
<i>2685</i>&nbsp;
<b class="nc"><i>2686</i>&nbsp;    // Special case of server authority that represents an IPv6 address</b>
<i>2687</i>&nbsp;    // In this case, a % does not signify an escape sequence
<b class="nc"><i>2688</i>&nbsp;    private static final long L_SERVER_PERCENT</b>
<b class="nc"><i>2689</i>&nbsp;        = L_SERVER | 0x2000000000L; // lowMask(&quot;%&quot;);</b>
<i>2690</i>&nbsp;    private static final long H_SERVER_PERCENT
<b class="nc"><i>2691</i>&nbsp;        = H_SERVER; // | highMask(&quot;%&quot;) == 0L;</b>
<b class="nc"><i>2692</i>&nbsp;</b>
<b class="nc"><i>2693</i>&nbsp;    // scheme        = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )</b>
<b class="nc"><i>2694</i>&nbsp;    private static final long L_SCHEME = L_ALPHA | L_DIGIT | 0x680000000000L; // lowMask(&quot;+-.&quot;);</b>
<b class="nc"><i>2695</i>&nbsp;    private static final long H_SCHEME = H_ALPHA | H_DIGIT; // | highMask(&quot;+-.&quot;) == 0L</b>
<b class="nc"><i>2696</i>&nbsp;</b>
<i>2697</i>&nbsp;    // scope_id = alpha | digit | &quot;_&quot; | &quot;.&quot;
<b class="nc"><i>2698</i>&nbsp;    private static final long L_SCOPE_ID</b>
<i>2699</i>&nbsp;        = L_ALPHANUM | 0x400000000000L; // lowMask(&quot;_.&quot;);
<b class="nc"><i>2700</i>&nbsp;    private static final long H_SCOPE_ID</b>
<b class="nc"><i>2701</i>&nbsp;        = H_ALPHANUM | 0x80000000L; // highMask(&quot;_.&quot;);</b>
<i>2702</i>&nbsp;
<i>2703</i>&nbsp;    // -- Escaping and encoding --
<b class="nc"><i>2704</i>&nbsp;</b>
<i>2705</i>&nbsp;    private static final char[] hexDigits = {
<i>2706</i>&nbsp;        &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
<i>2707</i>&nbsp;        &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
<i>2708</i>&nbsp;    };
<i>2709</i>&nbsp;
<i>2710</i>&nbsp;    private static void appendEscape(StringBuilder sb, byte b) {
<b class="nc"><i>2711</i>&nbsp;        sb.append(&#39;%&#39;);</b>
<b class="nc"><i>2712</i>&nbsp;        sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);</b>
<b class="nc"><i>2713</i>&nbsp;        sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);</b>
<i>2714</i>&nbsp;    }
<i>2715</i>&nbsp;
<b class="nc"><i>2716</i>&nbsp;    private static void appendEncoded(StringBuilder sb, char c) {</b>
<b class="nc"><i>2717</i>&nbsp;        ByteBuffer bb = null;</b>
<b class="nc"><i>2718</i>&nbsp;        try {</b>
<b class="nc"><i>2719</i>&nbsp;            bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</b>
<b class="nc"><i>2720</i>&nbsp;                .encode(CharBuffer.wrap(&quot;&quot; + c));</b>
<i>2721</i>&nbsp;        } catch (CharacterCodingException x) {
<i>2722</i>&nbsp;            assert false;
<b class="nc"><i>2723</i>&nbsp;        }</b>
<b class="nc"><i>2724</i>&nbsp;        while (bb.hasRemaining()) {</b>
<i>2725</i>&nbsp;            int b = bb.get() &amp; 0xff;
<b class="nc"><i>2726</i>&nbsp;            if (b &gt;= 0x80)</b>
<b class="nc"><i>2727</i>&nbsp;                appendEscape(sb, (byte)b);</b>
<b class="nc"><i>2728</i>&nbsp;            else</b>
<b class="nc"><i>2729</i>&nbsp;                sb.append((char)b);</b>
<b class="nc"><i>2730</i>&nbsp;        }</b>
<i>2731</i>&nbsp;    }
<b class="nc"><i>2732</i>&nbsp;</b>
<b class="nc"><i>2733</i>&nbsp;    // Quote any characters in s that are not permitted</b>
<b class="nc"><i>2734</i>&nbsp;    // by the given mask pair</b>
<b class="nc"><i>2735</i>&nbsp;    //</b>
<b class="nc"><i>2736</i>&nbsp;    private static String quote(String s, long lowMask, long highMask) {</b>
<i>2737</i>&nbsp;        StringBuilder sb = null;
<b class="nc"><i>2738</i>&nbsp;        boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);</b>
<b class="nc"><i>2739</i>&nbsp;        for (int i = 0; i &lt; s.length(); i++) {</b>
<b class="nc"><i>2740</i>&nbsp;            char c = s.charAt(i);</b>
<i>2741</i>&nbsp;            if (c &lt; &#39;\u0080&#39;) {
<i>2742</i>&nbsp;                if (!match(c, lowMask, highMask)) {
<i>2743</i>&nbsp;                    if (sb == null) {
<b class="nc"><i>2744</i>&nbsp;                        sb = new StringBuilder();</b>
<b class="nc"><i>2745</i>&nbsp;                        sb.append(s, 0, i);</b>
<b class="nc"><i>2746</i>&nbsp;                    }</b>
<b class="nc"><i>2747</i>&nbsp;                    appendEscape(sb, (byte)c);</b>
<b class="nc"><i>2748</i>&nbsp;                } else {</b>
<b class="nc"><i>2749</i>&nbsp;                    if (sb != null)</b>
<b class="nc"><i>2750</i>&nbsp;                        sb.append(c);</b>
<b class="nc"><i>2751</i>&nbsp;                }</b>
<i>2752</i>&nbsp;            } else if (allowNonASCII
<i>2753</i>&nbsp;                       &amp;&amp; (Character.isSpaceChar(c)
<i>2754</i>&nbsp;                           || Character.isISOControl(c))) {
<b class="nc"><i>2755</i>&nbsp;                if (sb == null) {</b>
<b class="nc"><i>2756</i>&nbsp;                    sb = new StringBuilder();</b>
<i>2757</i>&nbsp;                    sb.append(s, 0, i);
<i>2758</i>&nbsp;                }
<i>2759</i>&nbsp;                appendEncoded(sb, c);
<i>2760</i>&nbsp;            } else {
<i>2761</i>&nbsp;                if (sb != null)
<i>2762</i>&nbsp;                    sb.append(c);
<i>2763</i>&nbsp;            }
<i>2764</i>&nbsp;        }
<i>2765</i>&nbsp;        return (sb == null) ? s : sb.toString();
<i>2766</i>&nbsp;    }
<b class="nc"><i>2767</i>&nbsp;</b>
<b class="nc"><i>2768</i>&nbsp;    // Encodes all characters &gt;= \u0080 into escaped, normalized UTF-8 octets,</b>
<b class="nc"><i>2769</i>&nbsp;    // assuming that s is otherwise legal</b>
<b class="nc"><i>2770</i>&nbsp;    //</b>
<b class="nc"><i>2771</i>&nbsp;    private static String encode(String s) {</b>
<b class="nc"><i>2772</i>&nbsp;        int n = s.length();</b>
<b class="nc"><i>2773</i>&nbsp;        if (n == 0)</b>
<i>2774</i>&nbsp;            return s;
<b class="nc"><i>2775</i>&nbsp;</b>
<b class="nc"><i>2776</i>&nbsp;        // First check whether we actually need to encode</b>
<b class="nc"><i>2777</i>&nbsp;        for (int i = 0;;) {</b>
<b class="nc"><i>2778</i>&nbsp;            if (s.charAt(i) &gt;= &#39;\u0080&#39;)</b>
<b class="nc"><i>2779</i>&nbsp;                break;</b>
<b class="nc"><i>2780</i>&nbsp;            if (++i &gt;= n)</b>
<i>2781</i>&nbsp;                return s;
<i>2782</i>&nbsp;        }
<b class="nc"><i>2783</i>&nbsp;</b>
<b class="nc"><i>2784</i>&nbsp;        String ns = Normalizer.normalize(s, Normalizer.Form.NFC);</b>
<i>2785</i>&nbsp;        ByteBuffer bb = null;
<b class="nc"><i>2786</i>&nbsp;        try {</b>
<b class="nc"><i>2787</i>&nbsp;            bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</b>
<b class="nc"><i>2788</i>&nbsp;                .encode(CharBuffer.wrap(ns));</b>
<b class="nc"><i>2789</i>&nbsp;        } catch (CharacterCodingException x) {</b>
<b class="nc"><i>2790</i>&nbsp;            assert false;</b>
<b class="nc"><i>2791</i>&nbsp;        }</b>
<i>2792</i>&nbsp;
<b class="nc"><i>2793</i>&nbsp;        StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>2794</i>&nbsp;        while (bb.hasRemaining()) {</b>
<b class="nc"><i>2795</i>&nbsp;            int b = bb.get() &amp; 0xff;</b>
<b class="nc"><i>2796</i>&nbsp;            if (b &gt;= 0x80)</b>
<b class="nc"><i>2797</i>&nbsp;                appendEscape(sb, (byte)b);</b>
<b class="nc"><i>2798</i>&nbsp;            else</b>
<i>2799</i>&nbsp;                sb.append((char)b);
<b class="nc"><i>2800</i>&nbsp;        }</b>
<b class="nc"><i>2801</i>&nbsp;        return sb.toString();</b>
<i>2802</i>&nbsp;    }
<b class="nc"><i>2803</i>&nbsp;</b>
<b class="nc"><i>2804</i>&nbsp;    private static int decode(char c) {</b>
<b class="nc"><i>2805</i>&nbsp;        if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))</b>
<b class="nc"><i>2806</i>&nbsp;            return c - &#39;0&#39;;</b>
<b class="nc"><i>2807</i>&nbsp;        if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))</b>
<b class="nc"><i>2808</i>&nbsp;            return c - &#39;a&#39; + 10;</b>
<b class="nc"><i>2809</i>&nbsp;        if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;F&#39;))</b>
<i>2810</i>&nbsp;            return c - &#39;A&#39; + 10;
<b class="nc"><i>2811</i>&nbsp;        assert false;</b>
<b class="nc"><i>2812</i>&nbsp;        return -1;</b>
<b class="nc"><i>2813</i>&nbsp;    }</b>
<b class="nc"><i>2814</i>&nbsp;</b>
<b class="nc"><i>2815</i>&nbsp;    private static byte decode(char c1, char c2) {</b>
<b class="nc"><i>2816</i>&nbsp;        return (byte)(  ((decode(c1) &amp; 0xf) &lt;&lt; 4)</b>
<b class="nc"><i>2817</i>&nbsp;                      | ((decode(c2) &amp; 0xf) &lt;&lt; 0));</b>
<b class="nc"><i>2818</i>&nbsp;    }</b>
<b class="nc"><i>2819</i>&nbsp;</b>
<i>2820</i>&nbsp;    // Evaluates all escapes in s, applying UTF-8 decoding if needed.  Assumes
<b class="nc"><i>2821</i>&nbsp;    // that escapes are well-formed syntactically, i.e., of the form %XX.  If a</b>
<i>2822</i>&nbsp;    // sequence of escaped octets is not valid UTF-8 then the erroneous octets
<i>2823</i>&nbsp;    // are replaced with &#39;\uFFFD&#39;.
<i>2824</i>&nbsp;    // Exception: any &quot;%&quot; found between &quot;[]&quot; is left alone. It is an IPv6 literal
<i>2825</i>&nbsp;    //            with a scope_id
<i>2826</i>&nbsp;    //
<i>2827</i>&nbsp;    private static String decode(String s) {
<i>2828</i>&nbsp;        return decode(s, true);
<i>2829</i>&nbsp;    }
<i>2830</i>&nbsp;
<i>2831</i>&nbsp;    // This method was introduced as a generalization of URI.decode method
<i>2832</i>&nbsp;    // to provide a fix for JDK-8037396
<i>2833</i>&nbsp;    private static String decode(String s, boolean ignorePercentInBrackets) {
<b class="nc"><i>2834</i>&nbsp;        if (s == null)</b>
<i>2835</i>&nbsp;            return s;
<b class="nc"><i>2836</i>&nbsp;        int n = s.length();</b>
<b class="nc"><i>2837</i>&nbsp;        if (n == 0)</b>
<b class="nc"><i>2838</i>&nbsp;            return s;</b>
<i>2839</i>&nbsp;        if (s.indexOf(&#39;%&#39;) &lt; 0)
<i>2840</i>&nbsp;            return s;
<i>2841</i>&nbsp;
<i>2842</i>&nbsp;        StringBuilder sb = new StringBuilder(n);
<i>2843</i>&nbsp;        ByteBuffer bb = ByteBuffer.allocate(n);
<b class="nc"><i>2844</i>&nbsp;        CharBuffer cb = CharBuffer.allocate(n);</b>
<i>2845</i>&nbsp;        CharsetDecoder dec = ThreadLocalCoders.decoderFor(&quot;UTF-8&quot;)
<i>2846</i>&nbsp;                .onMalformedInput(CodingErrorAction.REPLACE)
<i>2847</i>&nbsp;                .onUnmappableCharacter(CodingErrorAction.REPLACE);
<b class="nc"><i>2848</i>&nbsp;</b>
<i>2849</i>&nbsp;        // This is not horribly efficient, but it will do for now
<i>2850</i>&nbsp;        char c = s.charAt(0);
<i>2851</i>&nbsp;        boolean betweenBrackets = false;
<i>2852</i>&nbsp;
<i>2853</i>&nbsp;        for (int i = 0; i &lt; n;) {
<b class="nc"><i>2854</i>&nbsp;            assert c == s.charAt(i);    // Loop invariant</b>
<i>2855</i>&nbsp;            if (c == &#39;[&#39;) {
<i>2856</i>&nbsp;                betweenBrackets = true;
<i>2857</i>&nbsp;            } else if (betweenBrackets &amp;&amp; c == &#39;]&#39;) {
<i>2858</i>&nbsp;                betweenBrackets = false;
<i>2859</i>&nbsp;            }
<b class="nc"><i>2860</i>&nbsp;            if (c != &#39;%&#39; || (betweenBrackets &amp;&amp; ignorePercentInBrackets)) {</b>
<i>2861</i>&nbsp;                sb.append(c);
<i>2862</i>&nbsp;                if (++i &gt;= n)
<i>2863</i>&nbsp;                    break;
<i>2864</i>&nbsp;                c = s.charAt(i);
<i>2865</i>&nbsp;                continue;
<i>2866</i>&nbsp;            }
<i>2867</i>&nbsp;            bb.clear();
<i>2868</i>&nbsp;            int ui = i;
<b class="nc"><i>2869</i>&nbsp;            for (;;) {</b>
<i>2870</i>&nbsp;                assert (n - i &gt;= 2);
<i>2871</i>&nbsp;                bb.put(decode(s.charAt(++i), s.charAt(++i)));
<i>2872</i>&nbsp;                if (++i &gt;= n)
<i>2873</i>&nbsp;                    break;
<i>2874</i>&nbsp;                c = s.charAt(i);
<i>2875</i>&nbsp;                if (c != &#39;%&#39;)
<b class="nc"><i>2876</i>&nbsp;                    break;</b>
<i>2877</i>&nbsp;            }
<i>2878</i>&nbsp;            bb.flip();
<i>2879</i>&nbsp;            cb.clear();
<i>2880</i>&nbsp;            dec.reset();
<i>2881</i>&nbsp;            CoderResult cr = dec.decode(bb, cb, true);
<b class="nc"><i>2882</i>&nbsp;            assert cr.isUnderflow();</b>
<i>2883</i>&nbsp;            cr = dec.flush(cb);
<i>2884</i>&nbsp;            assert cr.isUnderflow();
<i>2885</i>&nbsp;            sb.append(cb.flip().toString());
<i>2886</i>&nbsp;        }
<i>2887</i>&nbsp;
<i>2888</i>&nbsp;        return sb.toString();
<b class="nc"><i>2889</i>&nbsp;    }</b>
<b class="nc"><i>2890</i>&nbsp;</b>
<b class="nc"><i>2891</i>&nbsp;</b>
<b class="nc"><i>2892</i>&nbsp;    // -- Parsing --</b>
<b class="nc"><i>2893</i>&nbsp;</b>
<b class="nc"><i>2894</i>&nbsp;    // For convenience we wrap the input URI string in a new instance of the</b>
<b class="nc"><i>2895</i>&nbsp;    // following internal class.  This saves always having to pass the input</b>
<b class="nc"><i>2896</i>&nbsp;    // string as an argument to each internal scan/parse method.</b>
<i>2897</i>&nbsp;
<b class="nc"><i>2898</i>&nbsp;    private class Parser {</b>
<i>2899</i>&nbsp;
<b class="nc"><i>2900</i>&nbsp;        private String input;           // URI input string</b>
<i>2901</i>&nbsp;        private boolean requireServerAuthority = false;
<i>2902</i>&nbsp;
<i>2903</i>&nbsp;        Parser(String s) {
<i>2904</i>&nbsp;            input = s;
<i>2905</i>&nbsp;            string = s;
<i>2906</i>&nbsp;        }
<i>2907</i>&nbsp;
<i>2908</i>&nbsp;        // -- Methods for throwing URISyntaxException in various ways --
<i>2909</i>&nbsp;
<i>2910</i>&nbsp;        private void fail(String reason) throws URISyntaxException {
<i>2911</i>&nbsp;            throw new URISyntaxException(input, reason);
<i>2912</i>&nbsp;        }
<i>2913</i>&nbsp;
<i>2914</i>&nbsp;        private void fail(String reason, int p) throws URISyntaxException {
<i>2915</i>&nbsp;            throw new URISyntaxException(input, reason, p);
<i>2916</i>&nbsp;        }
<i>2917</i>&nbsp;
<i>2918</i>&nbsp;        private void failExpecting(String expected, int p)
<i>2919</i>&nbsp;            throws URISyntaxException
<i>2920</i>&nbsp;        {
<i>2921</i>&nbsp;            fail(&quot;Expected &quot; + expected, p);
<i>2922</i>&nbsp;        }
<i>2923</i>&nbsp;
<i>2924</i>&nbsp;
<i>2925</i>&nbsp;        // -- Simple access to the input string --
<i>2926</i>&nbsp;
<i>2927</i>&nbsp;        // Tells whether start &lt; end and, if so, whether charAt(start) == c
<i>2928</i>&nbsp;        //
<i>2929</i>&nbsp;        private boolean at(int start, int end, char c) {
<i>2930</i>&nbsp;            return (start &lt; end) &amp;&amp; (input.charAt(start) == c);
<i>2931</i>&nbsp;        }
<i>2932</i>&nbsp;
<i>2933</i>&nbsp;        // Tells whether start + s.length() &lt; end and, if so,
<i>2934</i>&nbsp;        // whether the chars at the start position match s exactly
<b class="nc"><i>2935</i>&nbsp;        //</b>
<b class="nc"><i>2936</i>&nbsp;        private boolean at(int start, int end, String s) {</b>
<b class="nc"><i>2937</i>&nbsp;            int p = start;</b>
<i>2938</i>&nbsp;            int sn = s.length();
<i>2939</i>&nbsp;            if (sn &gt; end - p)
<i>2940</i>&nbsp;                return false;
<i>2941</i>&nbsp;            int i = 0;
<i>2942</i>&nbsp;            while (i &lt; sn) {
<i>2943</i>&nbsp;                if (input.charAt(p++) != s.charAt(i)) {
<i>2944</i>&nbsp;                    break;
<i>2945</i>&nbsp;                }
<i>2946</i>&nbsp;                i++;
<i>2947</i>&nbsp;            }
<b class="nc"><i>2948</i>&nbsp;            return (i == sn);</b>
<b class="nc"><i>2949</i>&nbsp;        }</b>
<b class="nc"><i>2950</i>&nbsp;</b>
<b class="nc"><i>2951</i>&nbsp;</b>
<b class="nc"><i>2952</i>&nbsp;        // -- Scanning --</b>
<b class="nc"><i>2953</i>&nbsp;</b>
<b class="nc"><i>2954</i>&nbsp;        // The various scan and parse methods that follow use a uniform</b>
<b class="nc"><i>2955</i>&nbsp;        // convention of taking the current start position and end index as</b>
<b class="nc"><i>2956</i>&nbsp;        // their first two arguments.  The start is inclusive while the end is</b>
<b class="nc"><i>2957</i>&nbsp;        // exclusive, just as in the String class, i.e., a start/end pair</b>
<i>2958</i>&nbsp;        // denotes the left-open interval [start, end) of the input string.
<i>2959</i>&nbsp;        //
<i>2960</i>&nbsp;        // These methods never proceed past the end position.  They may return
<i>2961</i>&nbsp;        // -1 to indicate outright failure, but more often they simply return
<i>2962</i>&nbsp;        // the position of the first char after the last char scanned.  Thus
<i>2963</i>&nbsp;        // a typical idiom is
<i>2964</i>&nbsp;        //
<i>2965</i>&nbsp;        //     int p = start;
<i>2966</i>&nbsp;        //     int q = scan(p, end, ...);
<i>2967</i>&nbsp;        //     if (q &gt; p)
<i>2968</i>&nbsp;        //         // We scanned something
<b class="nc"><i>2969</i>&nbsp;        //         ...;</b>
<b class="nc"><i>2970</i>&nbsp;        //     else if (q == p)</b>
<b class="nc"><i>2971</i>&nbsp;        //         // We scanned nothing</b>
<i>2972</i>&nbsp;        //         ...;
<b class="nc"><i>2973</i>&nbsp;        //     else if (q == -1)</b>
<b class="nc"><i>2974</i>&nbsp;        //         // Something went wrong</b>
<b class="nc"><i>2975</i>&nbsp;        //         ...;</b>
<b class="nc"><i>2976</i>&nbsp;</b>
<i>2977</i>&nbsp;
<b class="nc"><i>2978</i>&nbsp;        // Scan a specific char: If the char at the given start position is</b>
<b class="nc"><i>2979</i>&nbsp;        // equal to c, return the index of the next char; otherwise, return the</b>
<b class="nc"><i>2980</i>&nbsp;        // start position.</b>
<b class="nc"><i>2981</i>&nbsp;        //</b>
<i>2982</i>&nbsp;        private int scan(int start, int end, char c) {
<b class="nc"><i>2983</i>&nbsp;            if ((start &lt; end) &amp;&amp; (input.charAt(start) == c))</b>
<i>2984</i>&nbsp;                return start + 1;
<b class="nc"><i>2985</i>&nbsp;            return start;</b>
<i>2986</i>&nbsp;        }
<i>2987</i>&nbsp;
<i>2988</i>&nbsp;        // Scan forward from the given start position.  Stop at the first char
<i>2989</i>&nbsp;        // in the err string (in which case -1 is returned), or the first char
<i>2990</i>&nbsp;        // in the stop string (in which case the index of the preceding char is
<i>2991</i>&nbsp;        // returned), or the end of the input string (in which case the length
<i>2992</i>&nbsp;        // of the input string is returned).  May return the start position if
<b class="nc"><i>2993</i>&nbsp;        // nothing matches.</b>
<b class="nc"><i>2994</i>&nbsp;        //</b>
<b class="nc"><i>2995</i>&nbsp;        private int scan(int start, int end, String err, String stop) {</b>
<b class="nc"><i>2996</i>&nbsp;            int p = start;</b>
<b class="nc"><i>2997</i>&nbsp;            while (p &lt; end) {</b>
<b class="nc"><i>2998</i>&nbsp;                char c = input.charAt(p);</b>
<i>2999</i>&nbsp;                if (err.indexOf(c) &gt;= 0)
<b class="nc"><i>3000</i>&nbsp;                    return -1;</b>
<b class="nc"><i>3001</i>&nbsp;                if (stop.indexOf(c) &gt;= 0)</b>
<b class="nc"><i>3002</i>&nbsp;                    break;</b>
<b class="nc"><i>3003</i>&nbsp;                p++;</b>
<b class="nc"><i>3004</i>&nbsp;            }</b>
<i>3005</i>&nbsp;            return p;
<b class="nc"><i>3006</i>&nbsp;        }</b>
<i>3007</i>&nbsp;
<i>3008</i>&nbsp;        // Scan forward from the given start position.  Stop at the first char
<b class="nc"><i>3009</i>&nbsp;        // in the stop string (in which case the index of the preceding char is</b>
<i>3010</i>&nbsp;        // returned), or the end of the input string (in which case the length
<i>3011</i>&nbsp;        // of the input string is returned).  May return the start position if
<i>3012</i>&nbsp;        // nothing matches.
<i>3013</i>&nbsp;        //
<i>3014</i>&nbsp;        private int scan(int start, int end, String stop) {
<i>3015</i>&nbsp;            int p = start;
<i>3016</i>&nbsp;            while (p &lt; end) {
<i>3017</i>&nbsp;                char c = input.charAt(p);
<i>3018</i>&nbsp;                if (stop.indexOf(c) &gt;= 0)
<b class="nc"><i>3019</i>&nbsp;                    break;</b>
<b class="nc"><i>3020</i>&nbsp;                p++;</b>
<b class="nc"><i>3021</i>&nbsp;            }</b>
<i>3022</i>&nbsp;            return p;
<i>3023</i>&nbsp;        }
<i>3024</i>&nbsp;
<i>3025</i>&nbsp;        // Scan a potential escape sequence, starting at the given position,
<i>3026</i>&nbsp;        // with the given first char (i.e., charAt(start) == c).
<i>3027</i>&nbsp;        //
<i>3028</i>&nbsp;        // This method assumes that if escapes are allowed then visible
<i>3029</i>&nbsp;        // non-US-ASCII chars are also allowed.
<i>3030</i>&nbsp;        //
<b class="nc"><i>3031</i>&nbsp;        private int scanEscape(int start, int n, char first)</b>
<i>3032</i>&nbsp;            throws URISyntaxException
<i>3033</i>&nbsp;        {
<i>3034</i>&nbsp;            int p = start;
<i>3035</i>&nbsp;            char c = first;
<i>3036</i>&nbsp;            if (c == &#39;%&#39;) {
<i>3037</i>&nbsp;                // Process escape pair
<i>3038</i>&nbsp;                if ((p + 3 &lt;= n)
<i>3039</i>&nbsp;                    &amp;&amp; match(input.charAt(p + 1), L_HEX, H_HEX)
<b class="nc"><i>3040</i>&nbsp;                    &amp;&amp; match(input.charAt(p + 2), L_HEX, H_HEX)) {</b>
<i>3041</i>&nbsp;                    return p + 3;
<b class="nc"><i>3042</i>&nbsp;                }</b>
<b class="nc"><i>3043</i>&nbsp;                fail(&quot;Malformed escape pair&quot;, p);</b>
<b class="nc"><i>3044</i>&nbsp;            } else if ((c &gt; 128)</b>
<b class="nc"><i>3045</i>&nbsp;                       &amp;&amp; !Character.isSpaceChar(c)</b>
<b class="nc"><i>3046</i>&nbsp;                       &amp;&amp; !Character.isISOControl(c)) {</b>
<b class="nc"><i>3047</i>&nbsp;                // Allow unescaped but visible non-US-ASCII chars</b>
<b class="nc"><i>3048</i>&nbsp;                return p + 1;</b>
<b class="nc"><i>3049</i>&nbsp;            }</b>
<b class="nc"><i>3050</i>&nbsp;            return p;</b>
<b class="nc"><i>3051</i>&nbsp;        }</b>
<b class="nc"><i>3052</i>&nbsp;</b>
<b class="nc"><i>3053</i>&nbsp;        // Scan chars that match the given mask pair</b>
<i>3054</i>&nbsp;        //
<b class="nc"><i>3055</i>&nbsp;        private int scan(int start, int n, long lowMask, long highMask)</b>
<b class="nc"><i>3056</i>&nbsp;            throws URISyntaxException</b>
<b class="nc"><i>3057</i>&nbsp;        {</b>
<b class="nc"><i>3058</i>&nbsp;            int p = start;</b>
<b class="nc"><i>3059</i>&nbsp;            while (p &lt; n) {</b>
<b class="nc"><i>3060</i>&nbsp;                char c = input.charAt(p);</b>
<i>3061</i>&nbsp;                if (match(c, lowMask, highMask)) {
<b class="nc"><i>3062</i>&nbsp;                    p++;</b>
<b class="nc"><i>3063</i>&nbsp;                    continue;</b>
<i>3064</i>&nbsp;                }
<b class="nc"><i>3065</i>&nbsp;                if ((lowMask &amp; L_ESCAPED) != 0) {</b>
<b class="nc"><i>3066</i>&nbsp;                    int q = scanEscape(p, n, c);</b>
<b class="nc"><i>3067</i>&nbsp;                    if (q &gt; p) {</b>
<b class="nc"><i>3068</i>&nbsp;                        p = q;</b>
<b class="nc"><i>3069</i>&nbsp;                        continue;</b>
<i>3070</i>&nbsp;                    }
<b class="nc"><i>3071</i>&nbsp;                }</b>
<b class="nc"><i>3072</i>&nbsp;                break;</b>
<i>3073</i>&nbsp;            }
<i>3074</i>&nbsp;            return p;
<i>3075</i>&nbsp;        }
<i>3076</i>&nbsp;
<i>3077</i>&nbsp;        // Check that each of the chars in [start, end) matches the given mask
<i>3078</i>&nbsp;        //
<i>3079</i>&nbsp;        private void checkChars(int start, int end,
<i>3080</i>&nbsp;                                long lowMask, long highMask,
<i>3081</i>&nbsp;                                String what)
<i>3082</i>&nbsp;            throws URISyntaxException
<i>3083</i>&nbsp;        {
<i>3084</i>&nbsp;            int p = scan(start, end, lowMask, highMask);
<i>3085</i>&nbsp;            if (p &lt; end)
<i>3086</i>&nbsp;                fail(&quot;Illegal character in &quot; + what, p);
<i>3087</i>&nbsp;        }
<i>3088</i>&nbsp;
<i>3089</i>&nbsp;        // Check that the char at position p matches the given mask
<i>3090</i>&nbsp;        //
<i>3091</i>&nbsp;        private void checkChar(int p,
<b class="nc"><i>3092</i>&nbsp;                               long lowMask, long highMask,</b>
<b class="nc"><i>3093</i>&nbsp;                               String what)</b>
<b class="nc"><i>3094</i>&nbsp;            throws URISyntaxException</b>
<b class="nc"><i>3095</i>&nbsp;        {</b>
<b class="nc"><i>3096</i>&nbsp;            checkChars(p, p + 1, lowMask, highMask, what);</b>
<b class="nc"><i>3097</i>&nbsp;        }</b>
<b class="nc"><i>3098</i>&nbsp;</b>
<i>3099</i>&nbsp;
<i>3100</i>&nbsp;        // -- Parsing --
<i>3101</i>&nbsp;
<b class="nc"><i>3102</i>&nbsp;        // [&lt;scheme&gt;:]&lt;scheme-specific-part&gt;[#&lt;fragment&gt;]</b>
<i>3103</i>&nbsp;        //
<b class="nc"><i>3104</i>&nbsp;        void parse(boolean rsa) throws URISyntaxException {</b>
<b class="nc"><i>3105</i>&nbsp;            requireServerAuthority = rsa;</b>
<b class="nc"><i>3106</i>&nbsp;            int n = input.length();</b>
<b class="nc"><i>3107</i>&nbsp;            int p = scan(0, n, &quot;/?#&quot;, &quot;:&quot;);</b>
<b class="nc"><i>3108</i>&nbsp;            if ((p &gt;= 0) &amp;&amp; at(p, n, &#39;:&#39;)) {</b>
<b class="nc"><i>3109</i>&nbsp;                if (p == 0)</b>
<b class="nc"><i>3110</i>&nbsp;                    failExpecting(&quot;scheme name&quot;, 0);</b>
<b class="nc"><i>3111</i>&nbsp;                checkChar(0, L_ALPHA, H_ALPHA, &quot;scheme name&quot;);</b>
<b class="nc"><i>3112</i>&nbsp;                checkChars(1, p, L_SCHEME, H_SCHEME, &quot;scheme name&quot;);</b>
<b class="nc"><i>3113</i>&nbsp;                scheme = input.substring(0, p);</b>
<i>3114</i>&nbsp;                p++;                    // Skip &#39;:&#39;
<b class="nc"><i>3115</i>&nbsp;                if (at(p, n, &#39;/&#39;)) {</b>
<i>3116</i>&nbsp;                    p = parseHierarchical(p, n);
<i>3117</i>&nbsp;                } else {
<i>3118</i>&nbsp;                    // opaque; need to create the schemeSpecificPart
<i>3119</i>&nbsp;                    int q = scan(p, n, &quot;#&quot;);
<i>3120</i>&nbsp;                    if (q &lt;= p)
<i>3121</i>&nbsp;                        failExpecting(&quot;scheme-specific part&quot;, p);
<i>3122</i>&nbsp;                    checkChars(p, q, L_URIC, H_URIC, &quot;opaque part&quot;);
<i>3123</i>&nbsp;                    schemeSpecificPart = input.substring(p, q);
<i>3124</i>&nbsp;                    p = q;
<i>3125</i>&nbsp;                }
<i>3126</i>&nbsp;            } else {
<i>3127</i>&nbsp;                p = parseHierarchical(0, n);
<i>3128</i>&nbsp;            }
<b class="nc"><i>3129</i>&nbsp;            if (at(p, n, &#39;#&#39;)) {</b>
<b class="nc"><i>3130</i>&nbsp;                checkChars(p + 1, n, L_URIC, H_URIC, &quot;fragment&quot;);</b>
<b class="nc"><i>3131</i>&nbsp;                fragment = input.substring(p + 1, n);</b>
<i>3132</i>&nbsp;                p = n;
<i>3133</i>&nbsp;            }
<i>3134</i>&nbsp;            if (p &lt; n)
<i>3135</i>&nbsp;                fail(&quot;end of URI&quot;, p);
<b class="nc"><i>3136</i>&nbsp;        }</b>
<i>3137</i>&nbsp;
<b class="nc"><i>3138</i>&nbsp;        // [//authority]&lt;path&gt;[?&lt;query&gt;]</b>
<i>3139</i>&nbsp;        //
<b class="nc"><i>3140</i>&nbsp;        // DEVIATION from RFC2396: We allow an empty authority component as</b>
<i>3141</i>&nbsp;        // long as it&#39;s followed by a non-empty path, query component, or
<b class="nc"><i>3142</i>&nbsp;        // fragment component.  This is so that URIs such as &quot;file:///foo/bar&quot;</b>
<i>3143</i>&nbsp;        // will parse.  This seems to be the intent of RFC2396, though the
<b class="nc"><i>3144</i>&nbsp;        // grammar does not permit it.  If the authority is empty then the</b>
<i>3145</i>&nbsp;        // userInfo, host, and port components are undefined.
<b class="nc"><i>3146</i>&nbsp;        //</b>
<b class="nc"><i>3147</i>&nbsp;        // DEVIATION from RFC2396: We allow empty relative paths.  This seems</b>
<i>3148</i>&nbsp;        // to be the intent of RFC2396, but the grammar does not permit it.
<i>3149</i>&nbsp;        // The primary consequence of this deviation is that &quot;#f&quot; parses as a
<b class="nc"><i>3150</i>&nbsp;        // relative URI with an empty path.</b>
<i>3151</i>&nbsp;        //
<i>3152</i>&nbsp;        private int parseHierarchical(int start, int n)
<i>3153</i>&nbsp;            throws URISyntaxException
<i>3154</i>&nbsp;        {
<b class="nc"><i>3155</i>&nbsp;            int p = start;</b>
<b class="nc"><i>3156</i>&nbsp;            if (at(p, n, &#39;/&#39;) &amp;&amp; at(p + 1, n, &#39;/&#39;)) {</b>
<b class="nc"><i>3157</i>&nbsp;                p += 2;</b>
<b class="nc"><i>3158</i>&nbsp;                int q = scan(p, n, &quot;/?#&quot;);</b>
<b class="nc"><i>3159</i>&nbsp;                if (q &gt; p) {</b>
<i>3160</i>&nbsp;                    p = parseAuthority(p, q);
<b class="nc"><i>3161</i>&nbsp;                } else if (q &lt; n) {</b>
<b class="nc"><i>3162</i>&nbsp;                    // DEVIATION: Allow empty authority prior to non-empty</b>
<b class="nc"><i>3163</i>&nbsp;                    // path, query component or fragment identifier</b>
<b class="nc"><i>3164</i>&nbsp;                } else</b>
<i>3165</i>&nbsp;                    failExpecting(&quot;authority&quot;, p);
<i>3166</i>&nbsp;            }
<b class="nc"><i>3167</i>&nbsp;            int q = scan(p, n, &quot;?#&quot;); // DEVIATION: May be empty</b>
<i>3168</i>&nbsp;            checkChars(p, q, L_PATH, H_PATH, &quot;path&quot;);
<i>3169</i>&nbsp;            path = input.substring(p, q);
<i>3170</i>&nbsp;            p = q;
<b class="nc"><i>3171</i>&nbsp;            if (at(p, n, &#39;?&#39;)) {</b>
<b class="nc"><i>3172</i>&nbsp;                p++;</b>
<i>3173</i>&nbsp;                q = scan(p, n, &quot;#&quot;);
<b class="nc"><i>3174</i>&nbsp;                checkChars(p, q, L_URIC, H_URIC, &quot;query&quot;);</b>
<i>3175</i>&nbsp;                query = input.substring(p, q);
<i>3176</i>&nbsp;                p = q;
<b class="nc"><i>3177</i>&nbsp;            }</b>
<b class="nc"><i>3178</i>&nbsp;            return p;</b>
<i>3179</i>&nbsp;        }
<b class="nc"><i>3180</i>&nbsp;</b>
<b class="nc"><i>3181</i>&nbsp;        // authority     = server | reg_name</b>
<i>3182</i>&nbsp;        //
<i>3183</i>&nbsp;        // Ambiguity: An authority that is a registry name rather than a server
<b class="nc"><i>3184</i>&nbsp;        // might have a prefix that parses as a server.  We use the fact that</b>
<i>3185</i>&nbsp;        // the authority component is always followed by &#39;/&#39; or the end of the
<b class="nc"><i>3186</i>&nbsp;        // input string to resolve this: If the complete authority did not</b>
<i>3187</i>&nbsp;        // parse as a server then we try to parse it as a registry name.
<i>3188</i>&nbsp;        //
<i>3189</i>&nbsp;        private int parseAuthority(int start, int n)
<b class="nc"><i>3190</i>&nbsp;            throws URISyntaxException</b>
<i>3191</i>&nbsp;        {
<i>3192</i>&nbsp;            int p = start;
<i>3193</i>&nbsp;            int q = p;
<i>3194</i>&nbsp;            URISyntaxException ex = null;
<i>3195</i>&nbsp;
<i>3196</i>&nbsp;            boolean serverChars;
<i>3197</i>&nbsp;            boolean regChars;
<i>3198</i>&nbsp;
<b class="nc"><i>3199</i>&nbsp;            if (scan(p, n, &quot;]&quot;) &gt; p) {</b>
<i>3200</i>&nbsp;                // contains a literal IPv6 address, therefore % is allowed
<i>3201</i>&nbsp;                serverChars = (scan(p, n, L_SERVER_PERCENT, H_SERVER_PERCENT) == n);
<i>3202</i>&nbsp;            } else {
<b class="nc"><i>3203</i>&nbsp;                serverChars = (scan(p, n, L_SERVER, H_SERVER) == n);</b>
<b class="nc"><i>3204</i>&nbsp;            }</b>
<b class="nc"><i>3205</i>&nbsp;            regChars = (scan(p, n, L_REG_NAME, H_REG_NAME) == n);</b>
<b class="nc"><i>3206</i>&nbsp;</b>
<b class="nc"><i>3207</i>&nbsp;            if (regChars &amp;&amp; !serverChars) {</b>
<i>3208</i>&nbsp;                // Must be a registry-based authority
<i>3209</i>&nbsp;                authority = input.substring(p, n);
<i>3210</i>&nbsp;                return n;
<b class="nc"><i>3211</i>&nbsp;            }</b>
<i>3212</i>&nbsp;
<b class="nc"><i>3213</i>&nbsp;            if (serverChars) {</b>
<b class="nc"><i>3214</i>&nbsp;                // Might be (probably is) a server-based authority, so attempt</b>
<b class="nc"><i>3215</i>&nbsp;                // to parse it as such.  If the attempt fails, try to treat it</b>
<i>3216</i>&nbsp;                // as a registry-based authority.
<b class="nc"><i>3217</i>&nbsp;                try {</b>
<b class="nc"><i>3218</i>&nbsp;                    q = parseServer(p, n);</b>
<b class="nc"><i>3219</i>&nbsp;                    if (q &lt; n)</b>
<b class="nc"><i>3220</i>&nbsp;                        failExpecting(&quot;end of authority&quot;, q);</b>
<b class="nc"><i>3221</i>&nbsp;                    authority = input.substring(p, n);</b>
<i>3222</i>&nbsp;                } catch (URISyntaxException x) {
<b class="nc"><i>3223</i>&nbsp;                    // Undo results of failed parse</b>
<i>3224</i>&nbsp;                    userInfo = null;
<i>3225</i>&nbsp;                    host = null;
<b class="nc"><i>3226</i>&nbsp;                    port = -1;</b>
<i>3227</i>&nbsp;                    if (requireServerAuthority) {
<b class="nc"><i>3228</i>&nbsp;                        // If we&#39;re insisting upon a server-based authority,</b>
<b class="nc"><i>3229</i>&nbsp;                        // then just re-throw the exception</b>
<b class="nc"><i>3230</i>&nbsp;                        throw x;</b>
<b class="nc"><i>3231</i>&nbsp;                    } else {</b>
<i>3232</i>&nbsp;                        // Save the exception in case it doesn&#39;t parse as a
<i>3233</i>&nbsp;                        // registry either
<b class="nc"><i>3234</i>&nbsp;                        ex = x;</b>
<b class="nc"><i>3235</i>&nbsp;                        q = p;</b>
<b class="nc"><i>3236</i>&nbsp;                    }</b>
<b class="nc"><i>3237</i>&nbsp;                }</b>
<i>3238</i>&nbsp;            }
<i>3239</i>&nbsp;
<i>3240</i>&nbsp;            if (q &lt; n) {
<b class="nc"><i>3241</i>&nbsp;                if (regChars) {</b>
<b class="nc"><i>3242</i>&nbsp;                    // Registry-based authority</b>
<b class="nc"><i>3243</i>&nbsp;                    authority = input.substring(p, n);</b>
<b class="nc"><i>3244</i>&nbsp;                } else if (ex != null) {</b>
<b class="nc"><i>3245</i>&nbsp;                    // Re-throw exception; it was probably due to</b>
<i>3246</i>&nbsp;                    // a malformed IPv6 address
<b class="nc"><i>3247</i>&nbsp;                    throw ex;</b>
<b class="nc"><i>3248</i>&nbsp;                } else {</b>
<b class="nc"><i>3249</i>&nbsp;                    fail(&quot;Illegal character in authority&quot;, q);</b>
<b class="nc"><i>3250</i>&nbsp;                }</b>
<b class="nc"><i>3251</i>&nbsp;            }</b>
<i>3252</i>&nbsp;
<i>3253</i>&nbsp;            return n;
<b class="nc"><i>3254</i>&nbsp;        }</b>
<b class="nc"><i>3255</i>&nbsp;</b>
<i>3256</i>&nbsp;
<b class="nc"><i>3257</i>&nbsp;        // [&lt;userinfo&gt;@]&lt;host&gt;[:&lt;port&gt;]</b>
<i>3258</i>&nbsp;        //
<i>3259</i>&nbsp;        private int parseServer(int start, int n)
<i>3260</i>&nbsp;            throws URISyntaxException
<i>3261</i>&nbsp;        {
<i>3262</i>&nbsp;            int p = start;
<i>3263</i>&nbsp;            int q;
<i>3264</i>&nbsp;
<b class="nc"><i>3265</i>&nbsp;            // userinfo</b>
<b class="nc"><i>3266</i>&nbsp;            q = scan(p, n, &quot;/?#&quot;, &quot;@&quot;);</b>
<b class="nc"><i>3267</i>&nbsp;            if ((q &gt;= p) &amp;&amp; at(q, n, &#39;@&#39;)) {</b>
<b class="nc"><i>3268</i>&nbsp;                checkChars(p, q, L_USERINFO, H_USERINFO, &quot;user info&quot;);</b>
<b class="nc"><i>3269</i>&nbsp;                userInfo = input.substring(p, q);</b>
<i>3270</i>&nbsp;                p = q + 1;              // Skip &#39;@&#39;
<i>3271</i>&nbsp;            }
<i>3272</i>&nbsp;
<i>3273</i>&nbsp;            // hostname, IPv4 address, or IPv6 address
<i>3274</i>&nbsp;            if (at(p, n, &#39;[&#39;)) {
<i>3275</i>&nbsp;                // DEVIATION from RFC2396: Support IPv6 addresses, per RFC2732
<i>3276</i>&nbsp;                p++;
<i>3277</i>&nbsp;                q = scan(p, n, &quot;/?#&quot;, &quot;]&quot;);
<i>3278</i>&nbsp;                if ((q &gt; p) &amp;&amp; at(q, n, &#39;]&#39;)) {
<i>3279</i>&nbsp;                    // look for a &quot;%&quot; scope id
<i>3280</i>&nbsp;                    int r = scan (p, q, &quot;%&quot;);
<i>3281</i>&nbsp;                    if (r &gt; p) {
<i>3282</i>&nbsp;                        parseIPv6Reference(p, r);
<i>3283</i>&nbsp;                        if (r+1 == q) {
<i>3284</i>&nbsp;                            fail (&quot;scope id expected&quot;);
<i>3285</i>&nbsp;                        }
<i>3286</i>&nbsp;                        checkChars (r+1, q, L_SCOPE_ID, H_SCOPE_ID,
<i>3287</i>&nbsp;                                                &quot;scope id&quot;);
<i>3288</i>&nbsp;                    } else {
<i>3289</i>&nbsp;                        parseIPv6Reference(p, q);
<b class="nc"><i>3290</i>&nbsp;                    }</b>
<i>3291</i>&nbsp;                    host = input.substring(p-1, q+1);
<b class="nc"><i>3292</i>&nbsp;                    p = q + 1;</b>
<b class="nc"><i>3293</i>&nbsp;                } else {</b>
<b class="nc"><i>3294</i>&nbsp;                    failExpecting(&quot;closing bracket for IPv6 address&quot;, q);</b>
<i>3295</i>&nbsp;                }
<i>3296</i>&nbsp;            } else {
<i>3297</i>&nbsp;                q = parseIPv4Address(p, n);
<b class="nc"><i>3298</i>&nbsp;                if (q &lt;= p)</b>
<b class="nc"><i>3299</i>&nbsp;                    q = parseHostname(p, n);</b>
<b class="nc"><i>3300</i>&nbsp;                p = q;</b>
<b class="nc"><i>3301</i>&nbsp;            }</b>
<b class="nc"><i>3302</i>&nbsp;</b>
<b class="nc"><i>3303</i>&nbsp;            // port</b>
<b class="nc"><i>3304</i>&nbsp;            if (at(p, n, &#39;:&#39;)) {</b>
<b class="nc"><i>3305</i>&nbsp;                p++;</b>
<b class="nc"><i>3306</i>&nbsp;                q = scan(p, n, &quot;/&quot;);</b>
<i>3307</i>&nbsp;                if (q &gt; p) {
<b class="nc"><i>3308</i>&nbsp;                    checkChars(p, q, L_DIGIT, H_DIGIT, &quot;port number&quot;);</b>
<b class="nc"><i>3309</i>&nbsp;                    try {</b>
<i>3310</i>&nbsp;                        port = Integer.parseInt(input, p, q, 10);
<i>3311</i>&nbsp;                    } catch (NumberFormatException x) {
<i>3312</i>&nbsp;                        fail(&quot;Malformed port number&quot;, p);
<i>3313</i>&nbsp;                    }
<i>3314</i>&nbsp;                    p = q;
<i>3315</i>&nbsp;                }
<i>3316</i>&nbsp;            }
<i>3317</i>&nbsp;            if (p &lt; n)
<b class="nc"><i>3318</i>&nbsp;                failExpecting(&quot;port number&quot;, p);</b>
<b class="nc"><i>3319</i>&nbsp;</b>
<b class="nc"><i>3320</i>&nbsp;            return p;</b>
<b class="nc"><i>3321</i>&nbsp;        }</b>
<i>3322</i>&nbsp;
<i>3323</i>&nbsp;        // Scan a string of decimal digits whose value fits in a byte
<i>3324</i>&nbsp;        //
<i>3325</i>&nbsp;        private int scanByte(int start, int n)
<i>3326</i>&nbsp;            throws URISyntaxException
<i>3327</i>&nbsp;        {
<i>3328</i>&nbsp;            int p = start;
<i>3329</i>&nbsp;            int q = scan(p, n, L_DIGIT, H_DIGIT);
<i>3330</i>&nbsp;            if (q &lt;= p) return q;
<i>3331</i>&nbsp;            if (Integer.parseInt(input, p, q, 10) &gt; 255) return p;
<b class="nc"><i>3332</i>&nbsp;            return q;</b>
<b class="nc"><i>3333</i>&nbsp;        }</b>
<b class="nc"><i>3334</i>&nbsp;</b>
<b class="nc"><i>3335</i>&nbsp;        // Scan an IPv4 address.</b>
<b class="nc"><i>3336</i>&nbsp;        //</b>
<b class="nc"><i>3337</i>&nbsp;        // If the strict argument is true then we require that the given</b>
<i>3338</i>&nbsp;        // interval contain nothing besides an IPv4 address; if it is false
<b class="nc"><i>3339</i>&nbsp;        // then we only require that it start with an IPv4 address.</b>
<i>3340</i>&nbsp;        //
<i>3341</i>&nbsp;        // If the interval does not contain or start with (depending upon the
<i>3342</i>&nbsp;        // strict argument) a legal IPv4 address characters then we return -1
<b class="nc"><i>3343</i>&nbsp;        // immediately; otherwise we insist that these characters parse as a</b>
<b class="nc"><i>3344</i>&nbsp;        // legal IPv4 address and throw an exception on failure.</b>
<i>3345</i>&nbsp;        //
<i>3346</i>&nbsp;        // We assume that any string of decimal digits and dots must be an IPv4
<i>3347</i>&nbsp;        // address.  It won&#39;t parse as a hostname anyway, so making that
<b class="nc"><i>3348</i>&nbsp;        // assumption here allows more meaningful exceptions to be thrown.</b>
<b class="nc"><i>3349</i>&nbsp;        //</b>
<i>3350</i>&nbsp;        private int scanIPv4Address(int start, int n, boolean strict)
<b class="nc"><i>3351</i>&nbsp;            throws URISyntaxException</b>
<i>3352</i>&nbsp;        {
<i>3353</i>&nbsp;            int p = start;
<i>3354</i>&nbsp;            int q;
<i>3355</i>&nbsp;            int m = scan(p, n, L_DIGIT | L_DOT, H_DIGIT | H_DOT);
<i>3356</i>&nbsp;            if ((m &lt;= p) || (strict &amp;&amp; (m != n)))
<i>3357</i>&nbsp;                return -1;
<i>3358</i>&nbsp;            for (;;) {
<i>3359</i>&nbsp;                // Per RFC2732: At most three digits per byte
<i>3360</i>&nbsp;                // Further constraint: Each element fits in a byte
<b class="nc"><i>3361</i>&nbsp;                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;</b>
<i>3362</i>&nbsp;                if ((q = scan(p, m, &#39;.&#39;)) &lt;= p) break;  p = q;
<b class="nc"><i>3363</i>&nbsp;                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;</b>
<i>3364</i>&nbsp;                if ((q = scan(p, m, &#39;.&#39;)) &lt;= p) break;  p = q;
<i>3365</i>&nbsp;                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;
<i>3366</i>&nbsp;                if ((q = scan(p, m, &#39;.&#39;)) &lt;= p) break;  p = q;
<b class="nc"><i>3367</i>&nbsp;                if ((q = scanByte(p, m)) &lt;= p) break;   p = q;</b>
<b class="nc"><i>3368</i>&nbsp;                if (q &lt; m) break;</b>
<b class="nc"><i>3369</i>&nbsp;                return q;</b>
<b class="nc"><i>3370</i>&nbsp;            }</b>
<b class="nc"><i>3371</i>&nbsp;            fail(&quot;Malformed IPv4 address&quot;, q);</b>
<b class="nc"><i>3372</i>&nbsp;            return -1;</b>
<b class="nc"><i>3373</i>&nbsp;        }</b>
<b class="nc"><i>3374</i>&nbsp;</b>
<b class="nc"><i>3375</i>&nbsp;        // Take an IPv4 address: Throw an exception if the given interval</b>
<b class="nc"><i>3376</i>&nbsp;        // contains anything except an IPv4 address</b>
<b class="nc"><i>3377</i>&nbsp;        //</b>
<i>3378</i>&nbsp;        private int takeIPv4Address(int start, int n, String expected)
<i>3379</i>&nbsp;            throws URISyntaxException
<b class="nc"><i>3380</i>&nbsp;        {</b>
<b class="nc"><i>3381</i>&nbsp;            int p = scanIPv4Address(start, n, true);</b>
<b class="nc"><i>3382</i>&nbsp;            if (p &lt;= start)</b>
<b class="nc"><i>3383</i>&nbsp;                failExpecting(expected, start);</b>
<b class="nc"><i>3384</i>&nbsp;            return p;</b>
<i>3385</i>&nbsp;        }
<b class="nc"><i>3386</i>&nbsp;</b>
<b class="nc"><i>3387</i>&nbsp;        // Attempt to parse an IPv4 address, returning -1 on failure but</b>
<i>3388</i>&nbsp;        // allowing the given interval to contain [:&lt;characters&gt;] after
<b class="nc"><i>3389</i>&nbsp;        // the IPv4 address.</b>
<b class="nc"><i>3390</i>&nbsp;        //</b>
<i>3391</i>&nbsp;        private int parseIPv4Address(int start, int n) {
<i>3392</i>&nbsp;            int p;
<i>3393</i>&nbsp;
<b class="nc"><i>3394</i>&nbsp;            try {</b>
<b class="nc"><i>3395</i>&nbsp;                p = scanIPv4Address(start, n, false);</b>
<i>3396</i>&nbsp;            } catch (URISyntaxException x) {
<i>3397</i>&nbsp;                return -1;
<b class="nc"><i>3398</i>&nbsp;            } catch (NumberFormatException nfe) {</b>
<b class="nc"><i>3399</i>&nbsp;                return -1;</b>
<i>3400</i>&nbsp;            }
<i>3401</i>&nbsp;
<i>3402</i>&nbsp;            if (p &gt; start &amp;&amp; p &lt; n) {
<i>3403</i>&nbsp;                // IPv4 address is followed by something - check that
<i>3404</i>&nbsp;                // it&#39;s a &quot;:&quot; as this is the only valid character to
<i>3405</i>&nbsp;                // follow an address.
<i>3406</i>&nbsp;                if (input.charAt(p) != &#39;:&#39;) {
<i>3407</i>&nbsp;                    p = -1;
<i>3408</i>&nbsp;                }
<i>3409</i>&nbsp;            }
<i>3410</i>&nbsp;
<i>3411</i>&nbsp;            if (p &gt; start)
<i>3412</i>&nbsp;                host = input.substring(start, p);
<i>3413</i>&nbsp;
<i>3414</i>&nbsp;            return p;
<i>3415</i>&nbsp;        }
<i>3416</i>&nbsp;
<i>3417</i>&nbsp;        // hostname      = domainlabel [ &quot;.&quot; ] | 1*( domainlabel &quot;.&quot; ) toplabel [ &quot;.&quot; ]
<i>3418</i>&nbsp;        // domainlabel   = alphanum | alphanum *( alphanum | &quot;-&quot; ) alphanum
<i>3419</i>&nbsp;        // toplabel      = alpha | alpha *( alphanum | &quot;-&quot; ) alphanum
<i>3420</i>&nbsp;        //
<i>3421</i>&nbsp;        private int parseHostname(int start, int n)
<i>3422</i>&nbsp;            throws URISyntaxException
<i>3423</i>&nbsp;        {
<i>3424</i>&nbsp;            int p = start;
<i>3425</i>&nbsp;            int q;
<i>3426</i>&nbsp;            int l = -1;                 // Start of last parsed label
<i>3427</i>&nbsp;
<i>3428</i>&nbsp;            do {
<i>3429</i>&nbsp;                // domainlabel = alphanum [ *( alphanum | &quot;-&quot; ) alphanum ]
<i>3430</i>&nbsp;                q = scan(p, n, L_ALPHANUM, H_ALPHANUM);
<i>3431</i>&nbsp;                if (q &lt;= p)
<i>3432</i>&nbsp;                    break;
<i>3433</i>&nbsp;                l = p;
<i>3434</i>&nbsp;                if (q &gt; p) {
<i>3435</i>&nbsp;                    p = q;
<i>3436</i>&nbsp;                    q = scan(p, n, L_ALPHANUM | L_DASH, H_ALPHANUM | H_DASH);
<i>3437</i>&nbsp;                    if (q &gt; p) {
<i>3438</i>&nbsp;                        if (input.charAt(q - 1) == &#39;-&#39;)
<i>3439</i>&nbsp;                            fail(&quot;Illegal character in hostname&quot;, q - 1);
<i>3440</i>&nbsp;                        p = q;
<i>3441</i>&nbsp;                    }
<i>3442</i>&nbsp;                }
<i>3443</i>&nbsp;                q = scan(p, n, &#39;.&#39;);
<b class="nc"><i>3444</i>&nbsp;                if (q &lt;= p)</b>
<i>3445</i>&nbsp;                    break;
<i>3446</i>&nbsp;                p = q;
<i>3447</i>&nbsp;            } while (p &lt; n);
<i>3448</i>&nbsp;
<b class="nc"><i>3449</i>&nbsp;            if ((p &lt; n) &amp;&amp; !at(p, n, &#39;:&#39;))</b>
<i>3450</i>&nbsp;                fail(&quot;Illegal character in hostname&quot;, p);
<b class="nc"><i>3451</i>&nbsp;</b>
<i>3452</i>&nbsp;            if (l &lt; 0)
<b class="nc"><i>3453</i>&nbsp;                failExpecting(&quot;hostname&quot;, start);</b>
<i>3454</i>&nbsp;
<b class="nc"><i>3455</i>&nbsp;            // for a fully qualified hostname check that the rightmost</b>
<b class="nc"><i>3456</i>&nbsp;            // label starts with an alpha character.</b>
<b class="nc"><i>3457</i>&nbsp;            if (l &gt; start &amp;&amp; !match(input.charAt(l), L_ALPHA, H_ALPHA)) {</b>
<b class="nc"><i>3458</i>&nbsp;                fail(&quot;Illegal character in hostname&quot;, l);</b>
<b class="nc"><i>3459</i>&nbsp;            }</b>
<b class="nc"><i>3460</i>&nbsp;</b>
<b class="nc"><i>3461</i>&nbsp;            host = input.substring(start, p);</b>
<b class="nc"><i>3462</i>&nbsp;            return p;</b>
<i>3463</i>&nbsp;        }
<b class="nc"><i>3464</i>&nbsp;</b>
<b class="nc"><i>3465</i>&nbsp;</b>
<b class="nc"><i>3466</i>&nbsp;        // IPv6 address parsing, from RFC2373: IPv6 Addressing Architecture</b>
<i>3467</i>&nbsp;        //
<b class="nc"><i>3468</i>&nbsp;        // Bug: The grammar in RFC2373 Appendix B does not allow addresses of</b>
<b class="nc"><i>3469</i>&nbsp;        // the form ::12.34.56.78, which are clearly shown in the examples</b>
<b class="nc"><i>3470</i>&nbsp;        // earlier in the document.  Here is the original grammar:</b>
<b class="nc"><i>3471</i>&nbsp;        //</b>
<b class="nc"><i>3472</i>&nbsp;        //   IPv6address = hexpart [ &quot;:&quot; IPv4address ]</b>
<b class="nc"><i>3473</i>&nbsp;        //   hexpart     = hexseq | hexseq &quot;::&quot; [ hexseq ] | &quot;::&quot; [ hexseq ]</b>
<b class="nc"><i>3474</i>&nbsp;        //   hexseq      = hex4 *( &quot;:&quot; hex4)</b>
<b class="nc"><i>3475</i>&nbsp;        //   hex4        = 1*4HEXDIG</b>
<i>3476</i>&nbsp;        //
<b class="nc"><i>3477</i>&nbsp;        // We therefore use the following revised grammar:</b>
<i>3478</i>&nbsp;        //
<i>3479</i>&nbsp;        //   IPv6address = hexseq [ &quot;:&quot; IPv4address ]
<i>3480</i>&nbsp;        //                 | hexseq [ &quot;::&quot; [ hexpost ] ]
<i>3481</i>&nbsp;        //                 | &quot;::&quot; [ hexpost ]
<i>3482</i>&nbsp;        //   hexpost     = hexseq | hexseq &quot;:&quot; IPv4address | IPv4address
<b class="nc"><i>3483</i>&nbsp;        //   hexseq      = hex4 *( &quot;:&quot; hex4)</b>
<i>3484</i>&nbsp;        //   hex4        = 1*4HEXDIG
<i>3485</i>&nbsp;        //
<b class="nc"><i>3486</i>&nbsp;        // This covers all and only the following cases:</b>
<b class="nc"><i>3487</i>&nbsp;        //</b>
<i>3488</i>&nbsp;        //   hexseq
<b class="nc"><i>3489</i>&nbsp;        //   hexseq : IPv4address</b>
<b class="nc"><i>3490</i>&nbsp;        //   hexseq ::</b>
<b class="nc"><i>3491</i>&nbsp;        //   hexseq :: hexseq</b>
<b class="nc"><i>3492</i>&nbsp;        //   hexseq :: hexseq : IPv4address</b>
<b class="nc"><i>3493</i>&nbsp;        //   hexseq :: IPv4address</b>
<b class="nc"><i>3494</i>&nbsp;        //   :: hexseq</b>
<b class="nc"><i>3495</i>&nbsp;        //   :: hexseq : IPv4address</b>
<i>3496</i>&nbsp;        //   :: IPv4address
<i>3497</i>&nbsp;        //   ::
<b class="nc"><i>3498</i>&nbsp;        //</b>
<b class="nc"><i>3499</i>&nbsp;        // Additionally we constrain the IPv6 address as follows :-</b>
<i>3500</i>&nbsp;        //
<b class="nc"><i>3501</i>&nbsp;        //  i.  IPv6 addresses without compressed zeros should contain</b>
<i>3502</i>&nbsp;        //      exactly 16 bytes.
<i>3503</i>&nbsp;        //
<i>3504</i>&nbsp;        //  ii. IPv6 addresses with compressed zeros should contain
<i>3505</i>&nbsp;        //      less than 16 bytes.
<i>3506</i>&nbsp;
<i>3507</i>&nbsp;        private int ipv6byteCount = 0;
<i>3508</i>&nbsp;
<b class="nc"><i>3509</i>&nbsp;        private int parseIPv6Reference(int start, int n)</b>
<i>3510</i>&nbsp;            throws URISyntaxException
<i>3511</i>&nbsp;        {
<b class="nc"><i>3512</i>&nbsp;            int p = start;</b>
<b class="nc"><i>3513</i>&nbsp;            int q;</b>
<b class="nc"><i>3514</i>&nbsp;            boolean compressedZeros = false;</b>
<b class="nc"><i>3515</i>&nbsp;</b>
<b class="nc"><i>3516</i>&nbsp;            q = scanHexSeq(p, n);</b>
<b class="nc"><i>3517</i>&nbsp;</b>
<b class="nc"><i>3518</i>&nbsp;            if (q &gt; p) {</b>
<b class="nc"><i>3519</i>&nbsp;                p = q;</b>
<b class="nc"><i>3520</i>&nbsp;                if (at(p, n, &quot;::&quot;)) {</b>
<b class="nc"><i>3521</i>&nbsp;                    compressedZeros = true;</b>
<b class="nc"><i>3522</i>&nbsp;                    p = scanHexPost(p + 2, n);</b>
<b class="nc"><i>3523</i>&nbsp;                } else if (at(p, n, &#39;:&#39;)) {</b>
<b class="nc"><i>3524</i>&nbsp;                    p = takeIPv4Address(p + 1,  n, &quot;IPv4 address&quot;);</b>
<b class="nc"><i>3525</i>&nbsp;                    ipv6byteCount += 4;</b>
<b class="nc"><i>3526</i>&nbsp;                }</b>
<b class="nc"><i>3527</i>&nbsp;            } else if (at(p, n, &quot;::&quot;)) {</b>
<b class="nc"><i>3528</i>&nbsp;                compressedZeros = true;</b>
<b class="nc"><i>3529</i>&nbsp;                p = scanHexPost(p + 2, n);</b>
<b class="nc"><i>3530</i>&nbsp;            }</b>
<b class="nc"><i>3531</i>&nbsp;            if (p &lt; n)</b>
<b class="nc"><i>3532</i>&nbsp;                fail(&quot;Malformed IPv6 address&quot;, start);</b>
<i>3533</i>&nbsp;            if (ipv6byteCount &gt; 16)
<b class="nc"><i>3534</i>&nbsp;                fail(&quot;IPv6 address too long&quot;, start);</b>
<b class="nc"><i>3535</i>&nbsp;            if (!compressedZeros &amp;&amp; ipv6byteCount &lt; 16)</b>
<b class="nc"><i>3536</i>&nbsp;                fail(&quot;IPv6 address too short&quot;, start);</b>
<b class="nc"><i>3537</i>&nbsp;            if (compressedZeros &amp;&amp; ipv6byteCount == 16)</b>
<i>3538</i>&nbsp;                fail(&quot;Malformed IPv6 address&quot;, start);
<i>3539</i>&nbsp;
<b class="nc"><i>3540</i>&nbsp;            return p;</b>
<i>3541</i>&nbsp;        }
<i>3542</i>&nbsp;
<i>3543</i>&nbsp;        private int scanHexPost(int start, int n)
<i>3544</i>&nbsp;            throws URISyntaxException
<i>3545</i>&nbsp;        {
<i>3546</i>&nbsp;            int p = start;
<i>3547</i>&nbsp;            int q;
<i>3548</i>&nbsp;
<i>3549</i>&nbsp;            if (p == n)
<i>3550</i>&nbsp;                return p;
<i>3551</i>&nbsp;
<i>3552</i>&nbsp;            q = scanHexSeq(p, n);
<i>3553</i>&nbsp;            if (q &gt; p) {
<i>3554</i>&nbsp;                p = q;
<i>3555</i>&nbsp;                if (at(p, n, &#39;:&#39;)) {
<i>3556</i>&nbsp;                    p++;
<i>3557</i>&nbsp;                    p = takeIPv4Address(p, n, &quot;hex digits or IPv4 address&quot;);
<i>3558</i>&nbsp;                    ipv6byteCount += 4;
<i>3559</i>&nbsp;                }
<i>3560</i>&nbsp;            } else {
<i>3561</i>&nbsp;                p = takeIPv4Address(p, n, &quot;hex digits or IPv4 address&quot;);
<i>3562</i>&nbsp;                ipv6byteCount += 4;
<i>3563</i>&nbsp;            }
<i>3564</i>&nbsp;            return p;
<i>3565</i>&nbsp;        }
<i>3566</i>&nbsp;
<i>3567</i>&nbsp;        // Scan a hex sequence; return -1 if one could not be scanned
<i>3568</i>&nbsp;        //
<i>3569</i>&nbsp;        private int scanHexSeq(int start, int n)
<i>3570</i>&nbsp;            throws URISyntaxException
<i>3571</i>&nbsp;        {
<i>3572</i>&nbsp;            int p = start;
<i>3573</i>&nbsp;            int q;
<i>3574</i>&nbsp;
<i>3575</i>&nbsp;            q = scan(p, n, L_HEX, H_HEX);
<i>3576</i>&nbsp;            if (q &lt;= p)
<i>3577</i>&nbsp;                return -1;
<i>3578</i>&nbsp;            if (at(q, n, &#39;.&#39;))          // Beginning of IPv4 address
<i>3579</i>&nbsp;                return -1;
<i>3580</i>&nbsp;            if (q &gt; p + 4)
<i>3581</i>&nbsp;                fail(&quot;IPv6 hexadecimal digit sequence too long&quot;, p);
<i>3582</i>&nbsp;            ipv6byteCount += 2;
<i>3583</i>&nbsp;            p = q;
<i>3584</i>&nbsp;            while (p &lt; n) {
<i>3585</i>&nbsp;                if (!at(p, n, &#39;:&#39;))
<i>3586</i>&nbsp;                    break;
<i>3587</i>&nbsp;                if (at(p + 1, n, &#39;:&#39;))
<i>3588</i>&nbsp;                    break;              // &quot;::&quot;
<i>3589</i>&nbsp;                p++;
<i>3590</i>&nbsp;                q = scan(p, n, L_HEX, H_HEX);
<i>3591</i>&nbsp;                if (q &lt;= p)
<i>3592</i>&nbsp;                    failExpecting(&quot;digits for an IPv6 address&quot;, p);
<i>3593</i>&nbsp;                if (at(q, n, &#39;.&#39;)) {    // Beginning of IPv4 address
<i>3594</i>&nbsp;                    p--;
<i>3595</i>&nbsp;                    break;
<i>3596</i>&nbsp;                }
<i>3597</i>&nbsp;                if (q &gt; p + 4)
<i>3598</i>&nbsp;                    fail(&quot;IPv6 hexadecimal digit sequence too long&quot;, p);
<i>3599</i>&nbsp;                ipv6byteCount += 2;
<i>3600</i>&nbsp;                p = q;
<i>3601</i>&nbsp;            }
<i>3602</i>&nbsp;
<i>3603</i>&nbsp;            return p;
<i>3604</i>&nbsp;        }
<i>3605</i>&nbsp;
<i>3606</i>&nbsp;    }
<i>3607</i>&nbsp;    static {
<i>3608</i>&nbsp;        SharedSecrets.setJavaNetUriAccess(
<i>3609</i>&nbsp;            new JavaNetUriAccess() {
<i>3610</i>&nbsp;                public URI create(String scheme, String path) {
<i>3611</i>&nbsp;                    return new URI(scheme, path);
<i>3612</i>&nbsp;                }
<i>3613</i>&nbsp;            }
<i>3614</i>&nbsp;        );
<i>3615</i>&nbsp;    }
<i>3616</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
