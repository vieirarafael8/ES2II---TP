


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Window</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.awt</a> ]
</div>

<h1>Coverage Summary for Class: Window (java.awt)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Window</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 142)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 841)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Window$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$1DisposeAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$AccessibleAWTWindow</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$Type</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Window$WindowDisposerRecord</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 167)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 918)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1995, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.awt;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.awt.event.ComponentEvent;
<i>29</i>&nbsp;import java.awt.event.FocusEvent;
<i>30</i>&nbsp;import java.awt.event.KeyEvent;
<i>31</i>&nbsp;import java.awt.event.MouseWheelEvent;
<i>32</i>&nbsp;import java.awt.event.WindowEvent;
<i>33</i>&nbsp;import java.awt.event.WindowFocusListener;
<i>34</i>&nbsp;import java.awt.event.WindowListener;
<i>35</i>&nbsp;import java.awt.event.WindowStateListener;
<i>36</i>&nbsp;import java.awt.geom.Path2D;
<i>37</i>&nbsp;import java.awt.geom.Point2D;
<i>38</i>&nbsp;import java.awt.im.InputContext;
<i>39</i>&nbsp;import java.awt.image.BufferStrategy;
<i>40</i>&nbsp;import java.awt.peer.ComponentPeer;
<i>41</i>&nbsp;import java.awt.peer.WindowPeer;
<i>42</i>&nbsp;import java.beans.PropertyChangeListener;
<i>43</i>&nbsp;import java.io.IOException;
<i>44</i>&nbsp;import java.io.ObjectInputStream;
<i>45</i>&nbsp;import java.io.ObjectOutputStream;
<i>46</i>&nbsp;import java.io.OptionalDataException;
<i>47</i>&nbsp;import java.io.Serializable;
<i>48</i>&nbsp;import java.lang.ref.WeakReference;
<i>49</i>&nbsp;import java.lang.reflect.InvocationTargetException;
<i>50</i>&nbsp;import java.security.AccessController;
<i>51</i>&nbsp;import java.util.ArrayList;
<i>52</i>&nbsp;import java.util.Arrays;
<i>53</i>&nbsp;import java.util.EventListener;
<i>54</i>&nbsp;import java.util.Locale;
<i>55</i>&nbsp;import java.util.ResourceBundle;
<i>56</i>&nbsp;import java.util.Set;
<i>57</i>&nbsp;import java.util.Vector;
<i>58</i>&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
<i>59</i>&nbsp;
<i>60</i>&nbsp;import javax.accessibility.Accessible;
<i>61</i>&nbsp;import javax.accessibility.AccessibleContext;
<i>62</i>&nbsp;import javax.accessibility.AccessibleRole;
<i>63</i>&nbsp;import javax.accessibility.AccessibleState;
<i>64</i>&nbsp;import javax.accessibility.AccessibleStateSet;
<i>65</i>&nbsp;
<i>66</i>&nbsp;import sun.awt.AWTAccessor;
<i>67</i>&nbsp;import sun.awt.AWTPermissions;
<i>68</i>&nbsp;import sun.awt.AppContext;
<i>69</i>&nbsp;import sun.awt.DebugSettings;
<i>70</i>&nbsp;import sun.awt.SunToolkit;
<i>71</i>&nbsp;import sun.awt.util.IdentityArrayList;
<i>72</i>&nbsp;import sun.java2d.pipe.Region;
<i>73</i>&nbsp;import sun.security.action.GetPropertyAction;
<i>74</i>&nbsp;import sun.util.logging.PlatformLogger;
<i>75</i>&nbsp;
<i>76</i>&nbsp;/**
<i>77</i>&nbsp; * A {@code Window} object is a top-level window with no borders and no
<i>78</i>&nbsp; * menubar.
<i>79</i>&nbsp; * The default layout for a window is {@code BorderLayout}.
<i>80</i>&nbsp; * &lt;p&gt;
<i>81</i>&nbsp; * A window must have either a frame, dialog, or another window defined as its
<i>82</i>&nbsp; * owner when it&#39;s constructed.
<i>83</i>&nbsp; * &lt;p&gt;
<i>84</i>&nbsp; * In a multi-screen environment, you can create a {@code Window}
<i>85</i>&nbsp; * on a different screen device by constructing the {@code Window}
<i>86</i>&nbsp; * with {@link #Window(Window, GraphicsConfiguration)}.  The
<i>87</i>&nbsp; * {@code GraphicsConfiguration} object is one of the
<i>88</i>&nbsp; * {@code GraphicsConfiguration} objects of the target screen device.
<i>89</i>&nbsp; * &lt;p&gt;
<i>90</i>&nbsp; * In a virtual device multi-screen environment in which the desktop
<i>91</i>&nbsp; * area could span multiple physical screen devices, the bounds of all
<i>92</i>&nbsp; * configurations are relative to the virtual device coordinate system.
<i>93</i>&nbsp; * The origin of the virtual-coordinate system is at the upper left-hand
<i>94</i>&nbsp; * corner of the primary physical screen.  Depending on the location of
<i>95</i>&nbsp; * the primary screen in the virtual device, negative coordinates are
<i>96</i>&nbsp; * possible, as shown in the following figure.
<i>97</i>&nbsp; * &lt;p&gt;
<i>98</i>&nbsp; * &lt;img src=&quot;doc-files/MultiScreen.gif&quot;
<i>99</i>&nbsp; * alt=&quot;Diagram shows virtual device containing 4 physical screens. Primary physical screen shows coords (0,0), other screen shows (-80,-100).&quot;
<i>100</i>&nbsp; * style=&quot;float:center; margin: 7px 10px;&quot;&gt;
<i>101</i>&nbsp; * &lt;p&gt;
<i>102</i>&nbsp; * In such an environment, when calling {@code setLocation},
<i>103</i>&nbsp; * you must pass a virtual coordinate to this method.  Similarly,
<i>104</i>&nbsp; * calling {@code getLocationOnScreen} on a {@code Window} returns
<i>105</i>&nbsp; * virtual device coordinates.  Call the {@code getBounds} method
<i>106</i>&nbsp; * of a {@code GraphicsConfiguration} to find its origin in the virtual
<i>107</i>&nbsp; * coordinate system.
<i>108</i>&nbsp; * &lt;p&gt;
<i>109</i>&nbsp; * The following code sets the location of a {@code Window}
<i>110</i>&nbsp; * at (10, 10) relative to the origin of the physical screen
<i>111</i>&nbsp; * of the corresponding {@code GraphicsConfiguration}.  If the
<i>112</i>&nbsp; * bounds of the {@code GraphicsConfiguration} is not taken
<i>113</i>&nbsp; * into account, the {@code Window} location would be set
<i>114</i>&nbsp; * at (10, 10) relative to the virtual-coordinate system and would appear
<i>115</i>&nbsp; * on the primary physical screen, which might be different from the
<i>116</i>&nbsp; * physical screen of the specified {@code GraphicsConfiguration}.
<i>117</i>&nbsp; *
<i>118</i>&nbsp; * &lt;pre&gt;
<i>119</i>&nbsp; *      Window w = new Window(Window owner, GraphicsConfiguration gc);
<i>120</i>&nbsp; *      Rectangle bounds = gc.getBounds();
<i>121</i>&nbsp; *      w.setLocation(10 + bounds.x, 10 + bounds.y);
<i>122</i>&nbsp; * &lt;/pre&gt;
<i>123</i>&nbsp; *
<i>124</i>&nbsp; * &lt;p&gt;
<i>125</i>&nbsp; * Note: the location and size of top-level windows (including
<i>126</i>&nbsp; * {@code Window}s, {@code Frame}s, and {@code Dialog}s)
<i>127</i>&nbsp; * are under the control of the desktop&#39;s window management system.
<i>128</i>&nbsp; * Calls to {@code setLocation}, {@code setSize}, and
<i>129</i>&nbsp; * {@code setBounds} are requests (not directives) which are
<i>130</i>&nbsp; * forwarded to the window management system.  Every effort will be
<i>131</i>&nbsp; * made to honor such requests.  However, in some cases the window
<i>132</i>&nbsp; * management system may ignore such requests, or modify the requested
<i>133</i>&nbsp; * geometry in order to place and size the {@code Window} in a way
<i>134</i>&nbsp; * that more closely matches the desktop settings.
<i>135</i>&nbsp; * &lt;p&gt;
<i>136</i>&nbsp; * Due to the asynchronous nature of native event handling, the results
<i>137</i>&nbsp; * returned by {@code getBounds}, {@code getLocation},
<i>138</i>&nbsp; * {@code getLocationOnScreen}, and {@code getSize} might not
<i>139</i>&nbsp; * reflect the actual geometry of the Window on screen until the last
<i>140</i>&nbsp; * request has been processed.  During the processing of subsequent
<i>141</i>&nbsp; * requests these values might change accordingly while the window
<i>142</i>&nbsp; * management system fulfills the requests.
<i>143</i>&nbsp; * &lt;p&gt;
<i>144</i>&nbsp; * An application may set the size and location of an invisible
<i>145</i>&nbsp; * {@code Window} arbitrarily, but the window management system may
<i>146</i>&nbsp; * subsequently change its size and/or location when the
<i>147</i>&nbsp; * {@code Window} is made visible. One or more {@code ComponentEvent}s
<b class="nc"><i>148</i>&nbsp; * will be generated to indicate the new geometry.</b>
<i>149</i>&nbsp; * &lt;p&gt;
<i>150</i>&nbsp; * Windows are capable of generating the following WindowEvents:
<i>151</i>&nbsp; * WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.
<i>152</i>&nbsp; *
<i>153</i>&nbsp; * @author      Sami Shaio
<i>154</i>&nbsp; * @author      Arthur van Hoff
<i>155</i>&nbsp; * @see WindowEvent
<i>156</i>&nbsp; * @see #addWindowListener
<i>157</i>&nbsp; * @see java.awt.BorderLayout
<i>158</i>&nbsp; * @since       1.0
<i>159</i>&nbsp; */
<i>160</i>&nbsp;public class Window extends Container implements Accessible {
<i>161</i>&nbsp;
<i>162</i>&nbsp;    /**
<i>163</i>&nbsp;     * Enumeration of available &lt;i&gt;window types&lt;/i&gt;.
<i>164</i>&nbsp;     *
<b class="nc"><i>165</i>&nbsp;     * A window type defines the generic visual appearance and behavior of a</b>
<i>166</i>&nbsp;     * top-level window. For example, the type may affect the kind of
<i>167</i>&nbsp;     * decorations of a decorated {@code Frame} or {@code Dialog} instance.
<i>168</i>&nbsp;     * &lt;p&gt;
<i>169</i>&nbsp;     * Some platforms may not fully support a certain window type. Depending on
<i>170</i>&nbsp;     * the level of support, some properties of the window type may be
<i>171</i>&nbsp;     * disobeyed.
<b class="nc"><i>172</i>&nbsp;     *</b>
<i>173</i>&nbsp;     * @see   #getType
<i>174</i>&nbsp;     * @see   #setType
<i>175</i>&nbsp;     * @since 1.7
<i>176</i>&nbsp;     */
<i>177</i>&nbsp;    public static enum Type {
<i>178</i>&nbsp;        /**
<i>179</i>&nbsp;         * Represents a &lt;i&gt;normal&lt;/i&gt; window.
<i>180</i>&nbsp;         *
<i>181</i>&nbsp;         * This is the default type for objects of the {@code Window} class or
<b class="nc"><i>182</i>&nbsp;         * its descendants. Use this type for regular top-level windows.</b>
<i>183</i>&nbsp;         */
<i>184</i>&nbsp;        NORMAL,
<i>185</i>&nbsp;
<i>186</i>&nbsp;        /**
<i>187</i>&nbsp;         * Represents a &lt;i&gt;utility&lt;/i&gt; window.
<i>188</i>&nbsp;         *
<i>189</i>&nbsp;         * A utility window is usually a small window such as a toolbar or a
<i>190</i>&nbsp;         * palette. The native system may render the window with smaller
<i>191</i>&nbsp;         * title-bar if the window is either a {@code Frame} or a {@code
<b class="nc"><i>192</i>&nbsp;         * Dialog} object, and if it has its decorations enabled.</b>
<i>193</i>&nbsp;         */
<i>194</i>&nbsp;        UTILITY,
<i>195</i>&nbsp;
<i>196</i>&nbsp;        /**
<i>197</i>&nbsp;         * Represents a &lt;i&gt;popup&lt;/i&gt; window.
<i>198</i>&nbsp;         *
<i>199</i>&nbsp;         * A popup window is a temporary window such as a drop-down menu or a
<i>200</i>&nbsp;         * tooltip. On some platforms, windows of that type may be forcibly
<i>201</i>&nbsp;         * made undecorated even if they are instances of the {@code Frame} or
<i>202</i>&nbsp;         * {@code Dialog} class, and have decorations enabled.
<i>203</i>&nbsp;         */
<i>204</i>&nbsp;        POPUP
<i>205</i>&nbsp;    }
<i>206</i>&nbsp;
<i>207</i>&nbsp;    /**
<i>208</i>&nbsp;     * This represents the warning message that is
<i>209</i>&nbsp;     * to be displayed in a non secure window. ie :
<i>210</i>&nbsp;     * a window that has a security manager installed that denies
<i>211</i>&nbsp;     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
<i>212</i>&nbsp;     * This message can be displayed anywhere in the window.
<i>213</i>&nbsp;     *
<i>214</i>&nbsp;     * @serial
<i>215</i>&nbsp;     * @see #getWarningString
<i>216</i>&nbsp;     */
<i>217</i>&nbsp;    String      warningString;
<i>218</i>&nbsp;
<i>219</i>&nbsp;    /**
<i>220</i>&nbsp;     * {@code icons} is the graphical way we can
<i>221</i>&nbsp;     * represent the frames and dialogs.
<i>222</i>&nbsp;     * {@code Window} can&#39;t display icon but it&#39;s
<i>223</i>&nbsp;     * being inherited by owned {@code Dialog}s.
<i>224</i>&nbsp;     *
<b class="nc"><i>225</i>&nbsp;     * @serial</b>
<b class="nc"><i>226</i>&nbsp;     * @see #getIconImages</b>
<b class="nc"><i>227</i>&nbsp;     * @see #setIconImages</b>
<b class="nc"><i>228</i>&nbsp;     */</b>
<b class="nc"><i>229</i>&nbsp;    transient java.util.List&lt;Image&gt; icons;</b>
<i>230</i>&nbsp;
<i>231</i>&nbsp;    /**
<i>232</i>&nbsp;     * Holds the reference to the component which last had focus in this window
<i>233</i>&nbsp;     * before it lost focus.
<i>234</i>&nbsp;     */
<i>235</i>&nbsp;    private transient Component temporaryLostComponent;
<i>236</i>&nbsp;
<i>237</i>&nbsp;    static boolean systemSyncLWRequests = false;
<i>238</i>&nbsp;    boolean     syncLWRequests = false;
<i>239</i>&nbsp;    transient boolean beforeFirstShow = true;
<i>240</i>&nbsp;    private transient boolean disposing = false;
<i>241</i>&nbsp;    transient WindowDisposerRecord disposerRecord = null;
<i>242</i>&nbsp;
<i>243</i>&nbsp;    static final int OPENED = 0x01;
<i>244</i>&nbsp;
<i>245</i>&nbsp;    /**
<i>246</i>&nbsp;     * An Integer value representing the Window State.
<i>247</i>&nbsp;     *
<i>248</i>&nbsp;     * @serial
<i>249</i>&nbsp;     * @since 1.2
<i>250</i>&nbsp;     * @see #show
<i>251</i>&nbsp;     */
<i>252</i>&nbsp;    int state;
<i>253</i>&nbsp;
<i>254</i>&nbsp;    /**
<i>255</i>&nbsp;     * A boolean value representing Window always-on-top state
<i>256</i>&nbsp;     * @since 1.5
<i>257</i>&nbsp;     * @serial
<b class="nc"><i>258</i>&nbsp;     * @see #setAlwaysOnTop</b>
<i>259</i>&nbsp;     * @see #isAlwaysOnTop
<i>260</i>&nbsp;     */
<i>261</i>&nbsp;    private boolean alwaysOnTop;
<i>262</i>&nbsp;
<i>263</i>&nbsp;    /**
<i>264</i>&nbsp;     * Contains all the windows that have a peer object associated,
<i>265</i>&nbsp;     * i. e. between addNotify() and removeNotify() calls. The list
<b class="nc"><i>266</i>&nbsp;     * of all Window instances can be obtained from AppContext object.</b>
<i>267</i>&nbsp;     *
<i>268</i>&nbsp;     * @since 1.6
<i>269</i>&nbsp;     */
<i>270</i>&nbsp;    private static final IdentityArrayList&lt;Window&gt; allWindows = new IdentityArrayList&lt;Window&gt;();
<i>271</i>&nbsp;
<i>272</i>&nbsp;    /**
<i>273</i>&nbsp;     * A vector containing all the windows this
<i>274</i>&nbsp;     * window currently owns.
<i>275</i>&nbsp;     * @since 1.2
<i>276</i>&nbsp;     * @see #getOwnedWindows
<i>277</i>&nbsp;     */
<i>278</i>&nbsp;    transient Vector&lt;WeakReference&lt;Window&gt;&gt; ownedWindowList =
<i>279</i>&nbsp;                                            new Vector&lt;WeakReference&lt;Window&gt;&gt;();
<i>280</i>&nbsp;
<i>281</i>&nbsp;    /*
<i>282</i>&nbsp;     * We insert a weak reference into the Vector of all Windows in AppContext
<i>283</i>&nbsp;     * instead of &#39;this&#39; so that garbage collection can still take place
<i>284</i>&nbsp;     * correctly.
<i>285</i>&nbsp;     */
<i>286</i>&nbsp;    private transient WeakReference&lt;Window&gt; weakThis;
<i>287</i>&nbsp;
<i>288</i>&nbsp;    transient boolean showWithParent;
<i>289</i>&nbsp;
<i>290</i>&nbsp;    /**
<i>291</i>&nbsp;     * Contains the modal dialog that blocks this window, or null
<i>292</i>&nbsp;     * if the window is unblocked.
<i>293</i>&nbsp;     *
<i>294</i>&nbsp;     * @since 1.6
<i>295</i>&nbsp;     */
<i>296</i>&nbsp;    transient Dialog modalBlocker;
<i>297</i>&nbsp;
<i>298</i>&nbsp;    /**
<i>299</i>&nbsp;     * @serial
<i>300</i>&nbsp;     *
<i>301</i>&nbsp;     * @see java.awt.Dialog.ModalExclusionType
<b class="nc"><i>302</i>&nbsp;     * @see #getModalExclusionType</b>
<i>303</i>&nbsp;     * @see #setModalExclusionType
<i>304</i>&nbsp;     *
<i>305</i>&nbsp;     * @since 1.6
<i>306</i>&nbsp;     */
<i>307</i>&nbsp;    Dialog.ModalExclusionType modalExclusionType;
<i>308</i>&nbsp;
<i>309</i>&nbsp;    transient WindowListener windowListener;
<i>310</i>&nbsp;    transient WindowStateListener windowStateListener;
<i>311</i>&nbsp;    transient WindowFocusListener windowFocusListener;
<i>312</i>&nbsp;
<i>313</i>&nbsp;    transient InputContext inputContext;
<i>314</i>&nbsp;    private transient Object inputContextLock = new Object();
<i>315</i>&nbsp;
<i>316</i>&nbsp;    /**
<i>317</i>&nbsp;     * Unused. Maintained for serialization backward-compatibility.
<i>318</i>&nbsp;     *
<i>319</i>&nbsp;     * @serial
<b class="nc"><i>320</i>&nbsp;     * @since 1.2</b>
<i>321</i>&nbsp;     */
<i>322</i>&nbsp;    private FocusManager focusMgr;
<i>323</i>&nbsp;
<i>324</i>&nbsp;    /**
<i>325</i>&nbsp;     * Indicates whether this Window can become the focused Window.
<i>326</i>&nbsp;     *
<i>327</i>&nbsp;     * @serial
<i>328</i>&nbsp;     * @see #getFocusableWindowState
<i>329</i>&nbsp;     * @see #setFocusableWindowState
<i>330</i>&nbsp;     * @since 1.4
<i>331</i>&nbsp;     */
<b class="nc"><i>332</i>&nbsp;    private boolean focusableWindowState = true;</b>
<i>333</i>&nbsp;
<i>334</i>&nbsp;    /**
<i>335</i>&nbsp;     * Indicates whether this window should receive focus on
<i>336</i>&nbsp;     * subsequently being shown (with a call to {@code setVisible(true)}), or
<i>337</i>&nbsp;     * being moved to the front (with a call to {@code toFront()}).
<i>338</i>&nbsp;     *
<i>339</i>&nbsp;     * @serial
<i>340</i>&nbsp;     * @see #setAutoRequestFocus
<b class="nc"><i>341</i>&nbsp;     * @see #isAutoRequestFocus</b>
<i>342</i>&nbsp;     * @since 1.7
<i>343</i>&nbsp;     */
<i>344</i>&nbsp;    private volatile boolean autoRequestFocus = true;
<i>345</i>&nbsp;
<i>346</i>&nbsp;    /*
<i>347</i>&nbsp;     * Indicates that this window is being shown. This flag is set to true at
<i>348</i>&nbsp;     * the beginning of show() and to false at the end of show().
<i>349</i>&nbsp;     *
<i>350</i>&nbsp;     * @see #show()
<b class="nc"><i>351</i>&nbsp;     * @see Dialog#shouldBlock</b>
<i>352</i>&nbsp;     */
<i>353</i>&nbsp;    transient boolean isInShow = false;
<i>354</i>&nbsp;
<i>355</i>&nbsp;    /**
<i>356</i>&nbsp;     * The opacity level of the window
<i>357</i>&nbsp;     *
<i>358</i>&nbsp;     * @serial
<i>359</i>&nbsp;     * @see #setOpacity(float)
<i>360</i>&nbsp;     * @see #getOpacity()
<i>361</i>&nbsp;     * @since 1.7
<b class="nc"><i>362</i>&nbsp;     */</b>
<i>363</i>&nbsp;    private volatile float opacity = 1.0f;
<i>364</i>&nbsp;
<b class="nc"><i>365</i>&nbsp;    /**</b>
<i>366</i>&nbsp;     * The shape assigned to this window. This field is set to {@code null} if
<i>367</i>&nbsp;     * no shape is set (rectangular window).
<i>368</i>&nbsp;     *
<i>369</i>&nbsp;     * @serial
<i>370</i>&nbsp;     * @see #getShape()
<i>371</i>&nbsp;     * @see #setShape(Shape)
<b class="nc"><i>372</i>&nbsp;     * @since 1.7</b>
<i>373</i>&nbsp;     */
<i>374</i>&nbsp;    private Shape shape = null;
<i>375</i>&nbsp;
<b class="nc"><i>376</i>&nbsp;    private static final String base = &quot;win&quot;;</b>
<i>377</i>&nbsp;    private static int nameCounter = 0;
<i>378</i>&nbsp;
<i>379</i>&nbsp;    /*
<i>380</i>&nbsp;     * JDK 1.1 serialVersionUID
<i>381</i>&nbsp;     */
<b class="nc"><i>382</i>&nbsp;    private static final long serialVersionUID = 4497834738069338734L;</b>
<b class="nc"><i>383</i>&nbsp;</b>
<i>384</i>&nbsp;    private static final PlatformLogger log = PlatformLogger.getLogger(&quot;java.awt.Window&quot;);
<i>385</i>&nbsp;
<i>386</i>&nbsp;    private static final boolean locationByPlatformProp;
<i>387</i>&nbsp;
<i>388</i>&nbsp;    transient boolean isTrayIconWindow = false;
<i>389</i>&nbsp;
<b class="nc"><i>390</i>&nbsp;    /**</b>
<b class="nc"><i>391</i>&nbsp;     * These fields are initialized in the native peer code</b>
<b class="nc"><i>392</i>&nbsp;     * or via AWTAccessor&#39;s WindowAccessor.</b>
<b class="nc"><i>393</i>&nbsp;     */</b>
<i>394</i>&nbsp;    private transient volatile int securityWarningWidth = 0;
<i>395</i>&nbsp;    private transient volatile int securityWarningHeight = 0;
<i>396</i>&nbsp;
<b class="nc"><i>397</i>&nbsp;    /**</b>
<b class="nc"><i>398</i>&nbsp;     * These fields represent the desired location for the security</b>
<b class="nc"><i>399</i>&nbsp;     * warning if this window is untrusted.</b>
<i>400</i>&nbsp;     * See com.sun.awt.SecurityWarning for more details.
<i>401</i>&nbsp;     */
<b class="nc"><i>402</i>&nbsp;    private transient double securityWarningPointX = 2.0;</b>
<i>403</i>&nbsp;    private transient double securityWarningPointY = 0.0;
<b class="nc"><i>404</i>&nbsp;    private transient float securityWarningAlignmentX = RIGHT_ALIGNMENT;</b>
<b class="nc"><i>405</i>&nbsp;    private transient float securityWarningAlignmentY = TOP_ALIGNMENT;</b>
<i>406</i>&nbsp;
<b class="nc"><i>407</i>&nbsp;    static {</b>
<i>408</i>&nbsp;        /* ensure that the necessary native libraries are loaded */
<i>409</i>&nbsp;        Toolkit.loadLibraries();
<i>410</i>&nbsp;        if (!GraphicsEnvironment.isHeadless()) {
<i>411</i>&nbsp;            initIDs();
<i>412</i>&nbsp;        }
<i>413</i>&nbsp;
<i>414</i>&nbsp;        String s = java.security.AccessController.doPrivileged(
<i>415</i>&nbsp;            new GetPropertyAction(&quot;java.awt.syncLWRequests&quot;));
<i>416</i>&nbsp;        systemSyncLWRequests = (s != null &amp;&amp; s.equals(&quot;true&quot;));
<i>417</i>&nbsp;        s = java.security.AccessController.doPrivileged(
<i>418</i>&nbsp;            new GetPropertyAction(&quot;java.awt.Window.locationByPlatform&quot;));
<i>419</i>&nbsp;        locationByPlatformProp = (s != null &amp;&amp; s.equals(&quot;true&quot;));
<i>420</i>&nbsp;    }
<i>421</i>&nbsp;
<i>422</i>&nbsp;    /**
<i>423</i>&nbsp;     * Initialize JNI field and method IDs for fields that may be
<i>424</i>&nbsp;       accessed from C.
<i>425</i>&nbsp;     */
<i>426</i>&nbsp;    private static native void initIDs();
<i>427</i>&nbsp;
<i>428</i>&nbsp;    /**
<i>429</i>&nbsp;     * Constructs a new, initially invisible window in default size with the
<i>430</i>&nbsp;     * specified {@code GraphicsConfiguration}.
<i>431</i>&nbsp;     * &lt;p&gt;
<i>432</i>&nbsp;     * If there is a security manager, then it is invoked to check
<i>433</i>&nbsp;     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
<i>434</i>&nbsp;     * to determine whether or not the window must be displayed with
<b class="nc"><i>435</i>&nbsp;     * a warning banner.</b>
<b class="nc"><i>436</i>&nbsp;     *</b>
<i>437</i>&nbsp;     * @param gc the {@code GraphicsConfiguration} of the target screen
<i>438</i>&nbsp;     *     device. If {@code gc} is {@code null}, the system default
<b class="nc"><i>439</i>&nbsp;     *     {@code GraphicsConfiguration} is assumed</b>
<i>440</i>&nbsp;     * @exception IllegalArgumentException if {@code gc}
<i>441</i>&nbsp;     *    is not from a screen device
<i>442</i>&nbsp;     * @exception HeadlessException when
<i>443</i>&nbsp;     *     {@code GraphicsEnvironment.isHeadless()} returns {@code true}
<i>444</i>&nbsp;     *
<b class="nc"><i>445</i>&nbsp;     * @see java.awt.GraphicsEnvironment#isHeadless</b>
<b class="nc"><i>446</i>&nbsp;     */</b>
<b class="nc"><i>447</i>&nbsp;    Window(GraphicsConfiguration gc) {</b>
<i>448</i>&nbsp;        init(gc);
<i>449</i>&nbsp;    }
<i>450</i>&nbsp;
<b class="nc"><i>451</i>&nbsp;    transient Object anchor = new Object();</b>
<b class="nc"><i>452</i>&nbsp;    static class WindowDisposerRecord implements sun.java2d.DisposerRecord {</b>
<i>453</i>&nbsp;        WeakReference&lt;Window&gt; owner;
<b class="nc"><i>454</i>&nbsp;        final WeakReference&lt;Window&gt; weakThis;</b>
<i>455</i>&nbsp;        final WeakReference&lt;AppContext&gt; context;
<i>456</i>&nbsp;
<i>457</i>&nbsp;        WindowDisposerRecord(AppContext context, Window victim) {
<b class="nc"><i>458</i>&nbsp;            weakThis = victim.weakThis;</b>
<b class="nc"><i>459</i>&nbsp;            this.context = new WeakReference&lt;AppContext&gt;(context);</b>
<b class="nc"><i>460</i>&nbsp;        }</b>
<b class="nc"><i>461</i>&nbsp;</b>
<i>462</i>&nbsp;        public void updateOwner() {
<i>463</i>&nbsp;            Window victim = weakThis.get();
<b class="nc"><i>464</i>&nbsp;            owner = (victim == null)</b>
<b class="nc"><i>465</i>&nbsp;                    ? null</b>
<b class="nc"><i>466</i>&nbsp;                    : new WeakReference&lt;Window&gt;(victim.getOwner());</b>
<i>467</i>&nbsp;        }
<i>468</i>&nbsp;
<i>469</i>&nbsp;        public void dispose() {
<i>470</i>&nbsp;            if (owner != null) {
<i>471</i>&nbsp;                Window parent = owner.get();
<b class="nc"><i>472</i>&nbsp;                if (parent != null) {</b>
<i>473</i>&nbsp;                    parent.removeOwnedWindow(weakThis);
<b class="nc"><i>474</i>&nbsp;                }</b>
<b class="nc"><i>475</i>&nbsp;            }</b>
<b class="nc"><i>476</i>&nbsp;            AppContext ac = context.get();</b>
<i>477</i>&nbsp;            if (null != ac) {
<b class="nc"><i>478</i>&nbsp;                Window.removeFromWindowList(ac, weakThis);</b>
<i>479</i>&nbsp;            }
<b class="nc"><i>480</i>&nbsp;        }</b>
<i>481</i>&nbsp;    }
<i>482</i>&nbsp;
<i>483</i>&nbsp;    private GraphicsConfiguration initGC(GraphicsConfiguration gc) {
<b class="nc"><i>484</i>&nbsp;        GraphicsEnvironment.checkHeadless();</b>
<i>485</i>&nbsp;
<b class="nc"><i>486</i>&nbsp;        if (gc == null) {</b>
<i>487</i>&nbsp;            gc = GraphicsEnvironment.getLocalGraphicsEnvironment().
<b class="nc"><i>488</i>&nbsp;                getDefaultScreenDevice().getDefaultConfiguration();</b>
<b class="nc"><i>489</i>&nbsp;        }</b>
<i>490</i>&nbsp;        setGraphicsConfiguration(gc);
<b class="nc"><i>491</i>&nbsp;</b>
<b class="nc"><i>492</i>&nbsp;        return gc;</b>
<b class="nc"><i>493</i>&nbsp;    }</b>
<i>494</i>&nbsp;
<b class="nc"><i>495</i>&nbsp;    private void init(GraphicsConfiguration gc) {</b>
<i>496</i>&nbsp;        GraphicsEnvironment.checkHeadless();
<b class="nc"><i>497</i>&nbsp;</b>
<i>498</i>&nbsp;        syncLWRequests = systemSyncLWRequests;
<b class="nc"><i>499</i>&nbsp;</b>
<i>500</i>&nbsp;        weakThis = new WeakReference&lt;Window&gt;(this);
<b class="nc"><i>501</i>&nbsp;        addToWindowList();</b>
<i>502</i>&nbsp;
<i>503</i>&nbsp;        setWarningString();
<i>504</i>&nbsp;        this.cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
<b class="nc"><i>505</i>&nbsp;        this.visible = false;</b>
<b class="nc"><i>506</i>&nbsp;</b>
<b class="nc"><i>507</i>&nbsp;        gc = initGC(gc);</b>
<b class="nc"><i>508</i>&nbsp;</b>
<b class="nc"><i>509</i>&nbsp;        if (gc.getDevice().getType() !=</b>
<b class="nc"><i>510</i>&nbsp;            GraphicsDevice.TYPE_RASTER_SCREEN) {</b>
<i>511</i>&nbsp;            throw new IllegalArgumentException(&quot;not a screen device&quot;);
<b class="nc"><i>512</i>&nbsp;        }</b>
<i>513</i>&nbsp;        setLayout(new BorderLayout());
<i>514</i>&nbsp;
<b class="nc"><i>515</i>&nbsp;        /* offset the initial location with the original of the screen */</b>
<b class="nc"><i>516</i>&nbsp;        /* and any insets                                              */</b>
<b class="nc"><i>517</i>&nbsp;        Rectangle screenBounds = gc.getBounds();</b>
<i>518</i>&nbsp;        Insets screenInsets = getToolkit().getScreenInsets(gc);
<b class="nc"><i>519</i>&nbsp;        int x = getX() + screenBounds.x + screenInsets.left;</b>
<i>520</i>&nbsp;        int y = getY() + screenBounds.y + screenInsets.top;
<i>521</i>&nbsp;        if (x != this.x || y != this.y) {
<i>522</i>&nbsp;            setLocation(x, y);
<i>523</i>&nbsp;            /* reset after setLocation */
<i>524</i>&nbsp;            setLocationByPlatform(locationByPlatformProp);
<i>525</i>&nbsp;        }
<i>526</i>&nbsp;
<i>527</i>&nbsp;        modalExclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;
<i>528</i>&nbsp;        disposerRecord = new WindowDisposerRecord(appContext, this);
<i>529</i>&nbsp;        sun.java2d.Disposer.addRecord(anchor, disposerRecord);
<i>530</i>&nbsp;
<i>531</i>&nbsp;        SunToolkit.checkAndSetPolicy(this);
<i>532</i>&nbsp;    }
<i>533</i>&nbsp;
<i>534</i>&nbsp;    /**
<b class="nc"><i>535</i>&nbsp;     * Constructs a new, initially invisible window in the default size.</b>
<b class="nc"><i>536</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>537</i>&nbsp;     * If there is a security manager set, it is invoked to check</b>
<i>538</i>&nbsp;     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
<i>539</i>&nbsp;     * If that check fails with a {@code SecurityException} then a warning
<i>540</i>&nbsp;     * banner is created.
<i>541</i>&nbsp;     *
<i>542</i>&nbsp;     * @exception HeadlessException when
<i>543</i>&nbsp;     *     {@code GraphicsEnvironment.isHeadless()} returns {@code true}
<i>544</i>&nbsp;     *
<i>545</i>&nbsp;     * @see java.awt.GraphicsEnvironment#isHeadless
<i>546</i>&nbsp;     */
<i>547</i>&nbsp;    Window() throws HeadlessException {
<i>548</i>&nbsp;        GraphicsEnvironment.checkHeadless();
<i>549</i>&nbsp;        init((GraphicsConfiguration)null);
<i>550</i>&nbsp;    }
<i>551</i>&nbsp;
<i>552</i>&nbsp;    /**
<i>553</i>&nbsp;     * Constructs a new, initially invisible window with the specified
<i>554</i>&nbsp;     * {@code Frame} as its owner. The window will not be focusable
<i>555</i>&nbsp;     * unless its owner is showing on the screen.
<i>556</i>&nbsp;     * &lt;p&gt;
<i>557</i>&nbsp;     * If there is a security manager set, it is invoked to check
<i>558</i>&nbsp;     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
<i>559</i>&nbsp;     * If that check fails with a {@code SecurityException} then a warning
<i>560</i>&nbsp;     * banner is created.
<b class="nc"><i>561</i>&nbsp;     *</b>
<b class="nc"><i>562</i>&nbsp;     * @param owner the {@code Frame} to act as owner or {@code null}</b>
<b class="nc"><i>563</i>&nbsp;     *    if this window has no owner</b>
<i>564</i>&nbsp;     * @exception IllegalArgumentException if the {@code owner}&#39;s
<i>565</i>&nbsp;     *    {@code GraphicsConfiguration} is not from a screen device
<i>566</i>&nbsp;     * @exception HeadlessException when
<i>567</i>&nbsp;     *    {@code GraphicsEnvironment.isHeadless} returns {@code true}
<i>568</i>&nbsp;     *
<i>569</i>&nbsp;     * @see java.awt.GraphicsEnvironment#isHeadless
<i>570</i>&nbsp;     * @see #isShowing
<i>571</i>&nbsp;     */
<i>572</i>&nbsp;    public Window(Frame owner) {
<i>573</i>&nbsp;        this(owner == null ? (GraphicsConfiguration)null :
<i>574</i>&nbsp;            owner.getGraphicsConfiguration());
<i>575</i>&nbsp;        ownedInit(owner);
<i>576</i>&nbsp;    }
<i>577</i>&nbsp;
<i>578</i>&nbsp;    /**
<i>579</i>&nbsp;     * Constructs a new, initially invisible window with the specified
<i>580</i>&nbsp;     * {@code Window} as its owner. This window will not be focusable
<i>581</i>&nbsp;     * unless its nearest owning {@code Frame} or {@code Dialog}
<i>582</i>&nbsp;     * is showing on the screen.
<i>583</i>&nbsp;     * &lt;p&gt;
<i>584</i>&nbsp;     * If there is a security manager set, it is invoked to check
<i>585</i>&nbsp;     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
<i>586</i>&nbsp;     * If that check fails with a {@code SecurityException} then a
<i>587</i>&nbsp;     * warning banner is created.
<i>588</i>&nbsp;     *
<i>589</i>&nbsp;     * @param owner the {@code Window} to act as owner or
<i>590</i>&nbsp;     *     {@code null} if this window has no owner
<b class="nc"><i>591</i>&nbsp;     * @exception IllegalArgumentException if the {@code owner}&#39;s</b>
<b class="nc"><i>592</i>&nbsp;     *     {@code GraphicsConfiguration} is not from a screen device</b>
<b class="nc"><i>593</i>&nbsp;     * @exception HeadlessException when</b>
<i>594</i>&nbsp;     *     {@code GraphicsEnvironment.isHeadless()} returns
<i>595</i>&nbsp;     *     {@code true}
<i>596</i>&nbsp;     *
<i>597</i>&nbsp;     * @see       java.awt.GraphicsEnvironment#isHeadless
<i>598</i>&nbsp;     * @see       #isShowing
<i>599</i>&nbsp;     *
<i>600</i>&nbsp;     * @since     1.2
<i>601</i>&nbsp;     */
<i>602</i>&nbsp;    public Window(Window owner) {
<i>603</i>&nbsp;        this(owner == null ? (GraphicsConfiguration)null :
<i>604</i>&nbsp;            owner.getGraphicsConfiguration());
<i>605</i>&nbsp;        ownedInit(owner);
<i>606</i>&nbsp;    }
<i>607</i>&nbsp;
<i>608</i>&nbsp;    /**
<i>609</i>&nbsp;     * Constructs a new, initially invisible window with the specified owner
<i>610</i>&nbsp;     * {@code Window} and a {@code GraphicsConfiguration}
<i>611</i>&nbsp;     * of a screen device. The Window will not be focusable unless
<i>612</i>&nbsp;     * its nearest owning {@code Frame} or {@code Dialog}
<i>613</i>&nbsp;     * is showing on the screen.
<i>614</i>&nbsp;     * &lt;p&gt;
<i>615</i>&nbsp;     * If there is a security manager set, it is invoked to check
<i>616</i>&nbsp;     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}. If that
<i>617</i>&nbsp;     * check fails with a {@code SecurityException} then a warning banner
<i>618</i>&nbsp;     * is created.
<i>619</i>&nbsp;     *
<i>620</i>&nbsp;     * @param owner the window to act as owner or {@code null}
<i>621</i>&nbsp;     *     if this window has no owner
<i>622</i>&nbsp;     * @param gc the {@code GraphicsConfiguration} of the target
<i>623</i>&nbsp;     *     screen device; if {@code gc} is {@code null},
<i>624</i>&nbsp;     *     the system default {@code GraphicsConfiguration} is assumed
<b class="nc"><i>625</i>&nbsp;     * @exception IllegalArgumentException if {@code gc}</b>
<b class="nc"><i>626</i>&nbsp;     *     is not from a screen device</b>
<i>627</i>&nbsp;     * @exception HeadlessException when
<i>628</i>&nbsp;     *     {@code GraphicsEnvironment.isHeadless()} returns
<i>629</i>&nbsp;     *     {@code true}
<b class="nc"><i>630</i>&nbsp;     *</b>
<b class="nc"><i>631</i>&nbsp;     * @see       java.awt.GraphicsEnvironment#isHeadless</b>
<b class="nc"><i>632</i>&nbsp;     * @see       GraphicsConfiguration#getBounds</b>
<b class="nc"><i>633</i>&nbsp;     * @see       #isShowing</b>
<i>634</i>&nbsp;     * @since     1.3
<b class="nc"><i>635</i>&nbsp;     */</b>
<b class="nc"><i>636</i>&nbsp;    public Window(Window owner, GraphicsConfiguration gc) {</b>
<b class="nc"><i>637</i>&nbsp;        this(gc);</b>
<i>638</i>&nbsp;        ownedInit(owner);
<i>639</i>&nbsp;    }
<i>640</i>&nbsp;
<i>641</i>&nbsp;    private void ownedInit(Window owner) {
<b class="nc"><i>642</i>&nbsp;        this.parent = owner;</b>
<i>643</i>&nbsp;        if (owner != null) {
<i>644</i>&nbsp;            owner.addOwnedWindow(weakThis);
<i>645</i>&nbsp;            if (owner.isAlwaysOnTop()) {
<i>646</i>&nbsp;                try {
<i>647</i>&nbsp;                    setAlwaysOnTop(true);
<i>648</i>&nbsp;                } catch (SecurityException ignore) {
<i>649</i>&nbsp;                }
<b class="nc"><i>650</i>&nbsp;            }</b>
<b class="nc"><i>651</i>&nbsp;        }</b>
<b class="nc"><i>652</i>&nbsp;</b>
<i>653</i>&nbsp;        // WindowDisposerRecord requires a proper value of parent field.
<i>654</i>&nbsp;        disposerRecord.updateOwner();
<i>655</i>&nbsp;    }
<i>656</i>&nbsp;
<i>657</i>&nbsp;    /**
<i>658</i>&nbsp;     * Construct a name for this component.  Called by getName() when the
<i>659</i>&nbsp;     * name is null.
<i>660</i>&nbsp;     */
<i>661</i>&nbsp;    String constructComponentName() {
<i>662</i>&nbsp;        synchronized (Window.class) {
<i>663</i>&nbsp;            return base + nameCounter++;
<i>664</i>&nbsp;        }
<i>665</i>&nbsp;    }
<i>666</i>&nbsp;
<i>667</i>&nbsp;    /**
<b class="nc"><i>668</i>&nbsp;     * Returns the sequence of images to be displayed as the icon for this window.</b>
<b class="nc"><i>669</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>670</i>&nbsp;     * This method returns a copy of the internally stored list, so all operations</b>
<i>671</i>&nbsp;     * on the returned object will not affect the window&#39;s behavior.
<b class="nc"><i>672</i>&nbsp;     *</b>
<i>673</i>&nbsp;     * @return    the copy of icon images&#39; list for this window, or
<i>674</i>&nbsp;     *            empty list if this window doesn&#39;t have icon images.
<i>675</i>&nbsp;     * @see       #setIconImages
<i>676</i>&nbsp;     * @see       #setIconImage(Image)
<i>677</i>&nbsp;     * @since     1.6
<i>678</i>&nbsp;     */
<i>679</i>&nbsp;    public java.util.List&lt;Image&gt; getIconImages() {
<i>680</i>&nbsp;        java.util.List&lt;Image&gt; icons = this.icons;
<i>681</i>&nbsp;        if (icons == null || icons.size() == 0) {
<i>682</i>&nbsp;            return new ArrayList&lt;Image&gt;();
<i>683</i>&nbsp;        }
<i>684</i>&nbsp;        return new ArrayList&lt;Image&gt;(icons);
<i>685</i>&nbsp;    }
<i>686</i>&nbsp;
<i>687</i>&nbsp;    /**
<i>688</i>&nbsp;     * Sets the sequence of images to be displayed as the icon
<i>689</i>&nbsp;     * for this window. Subsequent calls to {@code getIconImages} will
<i>690</i>&nbsp;     * always return a copy of the {@code icons} list.
<i>691</i>&nbsp;     * &lt;p&gt;
<i>692</i>&nbsp;     * Depending on the platform capabilities one or several images
<i>693</i>&nbsp;     * of different dimensions will be used as the window&#39;s icon.
<i>694</i>&nbsp;     * &lt;p&gt;
<i>695</i>&nbsp;     * The {@code icons} list can contain {@code MultiResolutionImage} images also.
<i>696</i>&nbsp;     * Suitable image depending on screen resolution is extracted from
<i>697</i>&nbsp;     * base {@code MultiResolutionImage} image and added to the icons list
<i>698</i>&nbsp;     * while base resolution image is removed from list.
<i>699</i>&nbsp;     * The {@code icons} list is scanned for the images of most
<i>700</i>&nbsp;     * appropriate dimensions from the beginning. If the list contains
<i>701</i>&nbsp;     * several images of the same size, the first will be used.
<i>702</i>&nbsp;     * &lt;p&gt;
<i>703</i>&nbsp;     * Ownerless windows with no icon specified use platform-default icon.
<b class="nc"><i>704</i>&nbsp;     * The icon of an owned window may be inherited from the owner</b>
<i>705</i>&nbsp;     * unless explicitly overridden.
<b class="nc"><i>706</i>&nbsp;     * Setting the icon to {@code null} or empty list restores</b>
<b class="nc"><i>707</i>&nbsp;     * the default behavior.</b>
<b class="nc"><i>708</i>&nbsp;     * &lt;p&gt;</b>
<i>709</i>&nbsp;     * Note : Native windowing systems may use different images of differing
<i>710</i>&nbsp;     * dimensions to represent a window, depending on the context (e.g.
<b class="nc"><i>711</i>&nbsp;     * window decoration, window list, taskbar, etc.). They could also use</b>
<i>712</i>&nbsp;     * just a single image for all contexts or no image at all.
<i>713</i>&nbsp;     *
<i>714</i>&nbsp;     * @param     icons the list of icon images to be displayed.
<i>715</i>&nbsp;     * @see       #getIconImages()
<i>716</i>&nbsp;     * @see       #setIconImage(Image)
<i>717</i>&nbsp;     * @since     1.6
<i>718</i>&nbsp;     */
<i>719</i>&nbsp;    public synchronized void setIconImages(java.util.List&lt;? extends Image&gt; icons) {
<i>720</i>&nbsp;        this.icons = (icons == null) ? new ArrayList&lt;Image&gt;() :
<i>721</i>&nbsp;            new ArrayList&lt;Image&gt;(icons);
<i>722</i>&nbsp;        WindowPeer peer = (WindowPeer)this.peer;
<i>723</i>&nbsp;        if (peer != null) {
<i>724</i>&nbsp;            peer.updateIconImages();
<i>725</i>&nbsp;        }
<i>726</i>&nbsp;        // Always send a property change event
<i>727</i>&nbsp;        firePropertyChange(&quot;iconImage&quot;, null, null);
<i>728</i>&nbsp;    }
<i>729</i>&nbsp;
<i>730</i>&nbsp;    /**
<i>731</i>&nbsp;     * Sets the image to be displayed as the icon for this window.
<i>732</i>&nbsp;     * &lt;p&gt;
<i>733</i>&nbsp;     * This method can be used instead of {@link #setIconImages setIconImages()}
<i>734</i>&nbsp;     * to specify a single image as a window&#39;s icon.
<i>735</i>&nbsp;     * &lt;p&gt;
<i>736</i>&nbsp;     * The following statement:
<i>737</i>&nbsp;     * &lt;pre&gt;
<i>738</i>&nbsp;     *     setIconImage(image);
<i>739</i>&nbsp;     * &lt;/pre&gt;
<i>740</i>&nbsp;     * is equivalent to:
<i>741</i>&nbsp;     * &lt;pre&gt;
<b class="nc"><i>742</i>&nbsp;     *     ArrayList&amp;lt;Image&amp;gt; imageList = new ArrayList&amp;lt;Image&amp;gt;();</b>
<b class="nc"><i>743</i>&nbsp;     *     imageList.add(image);</b>
<b class="nc"><i>744</i>&nbsp;     *     setIconImages(imageList);</b>
<i>745</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>746</i>&nbsp;     * &lt;p&gt;</b>
<i>747</i>&nbsp;     * Note : Native windowing systems may use different images of differing
<i>748</i>&nbsp;     * dimensions to represent a window, depending on the context (e.g.
<i>749</i>&nbsp;     * window decoration, window list, taskbar, etc.). They could also use
<i>750</i>&nbsp;     * just a single image for all contexts or no image at all.
<i>751</i>&nbsp;     *
<i>752</i>&nbsp;     * @param     image the icon image to be displayed.
<i>753</i>&nbsp;     * @see       #setIconImages
<i>754</i>&nbsp;     * @see       #getIconImages()
<i>755</i>&nbsp;     * @since     1.6
<i>756</i>&nbsp;     */
<i>757</i>&nbsp;    public void setIconImage(Image image) {
<i>758</i>&nbsp;        ArrayList&lt;Image&gt; imageList = new ArrayList&lt;Image&gt;();
<b class="nc"><i>759</i>&nbsp;        if (image != null) {</b>
<b class="nc"><i>760</i>&nbsp;            imageList.add(image);</b>
<b class="nc"><i>761</i>&nbsp;        }</b>
<b class="nc"><i>762</i>&nbsp;        setIconImages(imageList);</b>
<i>763</i>&nbsp;    }
<b class="nc"><i>764</i>&nbsp;</b>
<b class="nc"><i>765</i>&nbsp;    /**</b>
<i>766</i>&nbsp;     * Makes this Window displayable by creating the connection to its
<b class="nc"><i>767</i>&nbsp;     * native screen resource.</b>
<b class="nc"><i>768</i>&nbsp;     * This method is called internally by the toolkit and should</b>
<b class="nc"><i>769</i>&nbsp;     * not be called directly by programs.</b>
<b class="nc"><i>770</i>&nbsp;     * @see Component#isDisplayable</b>
<b class="nc"><i>771</i>&nbsp;     * @see Container#removeNotify</b>
<i>772</i>&nbsp;     * @since 1.0
<i>773</i>&nbsp;     */
<i>774</i>&nbsp;    public void addNotify() {
<i>775</i>&nbsp;        synchronized (getTreeLock()) {
<i>776</i>&nbsp;            Container parent = this.parent;
<i>777</i>&nbsp;            if (parent != null &amp;&amp; parent.peer == null) {
<b class="nc"><i>778</i>&nbsp;                parent.addNotify();</b>
<b class="nc"><i>779</i>&nbsp;            }</b>
<b class="nc"><i>780</i>&nbsp;            if (peer == null) {</b>
<b class="nc"><i>781</i>&nbsp;                peer = getComponentFactory().createWindow(this);</b>
<b class="nc"><i>782</i>&nbsp;            }</b>
<b class="nc"><i>783</i>&nbsp;            synchronized (allWindows) {</b>
<i>784</i>&nbsp;                allWindows.add(this);
<i>785</i>&nbsp;            }
<i>786</i>&nbsp;            super.addNotify();
<i>787</i>&nbsp;        }
<i>788</i>&nbsp;    }
<i>789</i>&nbsp;
<i>790</i>&nbsp;    /**
<i>791</i>&nbsp;     * {@inheritDoc}
<i>792</i>&nbsp;     */
<i>793</i>&nbsp;    public void removeNotify() {
<i>794</i>&nbsp;        synchronized (getTreeLock()) {
<i>795</i>&nbsp;            synchronized (allWindows) {
<i>796</i>&nbsp;                allWindows.remove(this);
<i>797</i>&nbsp;            }
<i>798</i>&nbsp;            super.removeNotify();
<i>799</i>&nbsp;        }
<i>800</i>&nbsp;    }
<i>801</i>&nbsp;
<b class="nc"><i>802</i>&nbsp;    /**</b>
<b class="nc"><i>803</i>&nbsp;     * Causes this Window to be sized to fit the preferred size</b>
<b class="nc"><i>804</i>&nbsp;     * and layouts of its subcomponents. The resulting width and</b>
<i>805</i>&nbsp;     * height of the window are automatically enlarged if either
<b class="nc"><i>806</i>&nbsp;     * of dimensions is less than the minimum size as specified</b>
<b class="nc"><i>807</i>&nbsp;     * by the previous call to the {@code setMinimumSize} method.</b>
<i>808</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>809</i>&nbsp;     * If the window and/or its owner are not displayable yet,</b>
<b class="nc"><i>810</i>&nbsp;     * both of them are made displayable before calculating</b>
<b class="nc"><i>811</i>&nbsp;     * the preferred size. The Window is validated after its</b>
<i>812</i>&nbsp;     * size is being calculated.
<i>813</i>&nbsp;     *
<b class="nc"><i>814</i>&nbsp;     * @see Component#isDisplayable</b>
<b class="nc"><i>815</i>&nbsp;     * @see #setMinimumSize</b>
<i>816</i>&nbsp;     */
<i>817</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<b class="nc"><i>818</i>&nbsp;    public void pack() {</b>
<i>819</i>&nbsp;        Container parent = this.parent;
<i>820</i>&nbsp;        if (parent != null &amp;&amp; parent.peer == null) {
<i>821</i>&nbsp;            parent.addNotify();
<i>822</i>&nbsp;        }
<i>823</i>&nbsp;        if (peer == null) {
<i>824</i>&nbsp;            addNotify();
<i>825</i>&nbsp;        }
<i>826</i>&nbsp;        Dimension newSize = getPreferredSize();
<i>827</i>&nbsp;        if (peer != null) {
<i>828</i>&nbsp;            setClientSize(newSize.width, newSize.height);
<i>829</i>&nbsp;        }
<i>830</i>&nbsp;
<i>831</i>&nbsp;        if(beforeFirstShow) {
<i>832</i>&nbsp;            isPacked = true;
<i>833</i>&nbsp;        }
<i>834</i>&nbsp;
<i>835</i>&nbsp;        validateUnconditionally();
<i>836</i>&nbsp;    }
<i>837</i>&nbsp;
<i>838</i>&nbsp;    /**
<i>839</i>&nbsp;     * Sets the minimum size of this window to a constant
<i>840</i>&nbsp;     * value.  Subsequent calls to {@code getMinimumSize}
<i>841</i>&nbsp;     * will always return this value. If current window&#39;s
<i>842</i>&nbsp;     * size is less than {@code minimumSize} the size of the
<i>843</i>&nbsp;     * window is automatically enlarged to honor the minimum size.
<i>844</i>&nbsp;     * &lt;p&gt;
<i>845</i>&nbsp;     * If the {@code setSize} or {@code setBounds} methods
<i>846</i>&nbsp;     * are called afterwards with a width or height less than
<i>847</i>&nbsp;     * that was specified by the {@code setMinimumSize} method
<i>848</i>&nbsp;     * the window is automatically enlarged to meet
<i>849</i>&nbsp;     * the {@code minimumSize} value. The {@code minimumSize}
<i>850</i>&nbsp;     * value also affects the behaviour of the {@code pack} method.
<b class="nc"><i>851</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>852</i>&nbsp;     * The default behavior is restored by setting the minimum size</b>
<b class="nc"><i>853</i>&nbsp;     * parameter to the {@code null} value.</b>
<b class="nc"><i>854</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>855</i>&nbsp;     * Resizing operation may be restricted if the user tries</b>
<b class="nc"><i>856</i>&nbsp;     * to resize window below the {@code minimumSize} value.</b>
<b class="nc"><i>857</i>&nbsp;     * This behaviour is platform-dependent.</b>
<b class="nc"><i>858</i>&nbsp;     *</b>
<i>859</i>&nbsp;     * @param minimumSize the new minimum size of this window
<i>860</i>&nbsp;     * @see Component#setMinimumSize
<b class="nc"><i>861</i>&nbsp;     * @see #getMinimumSize</b>
<b class="nc"><i>862</i>&nbsp;     * @see #isMinimumSizeSet</b>
<i>863</i>&nbsp;     * @see #setSize(Dimension)
<b class="nc"><i>864</i>&nbsp;     * @see #pack</b>
<i>865</i>&nbsp;     * @since 1.6
<i>866</i>&nbsp;     */
<i>867</i>&nbsp;    public void setMinimumSize(Dimension minimumSize) {
<i>868</i>&nbsp;        synchronized (getTreeLock()) {
<i>869</i>&nbsp;            super.setMinimumSize(minimumSize);
<i>870</i>&nbsp;            Dimension size = getSize();
<i>871</i>&nbsp;            if (isMinimumSizeSet()) {
<i>872</i>&nbsp;                if (size.width &lt; minimumSize.width || size.height &lt; minimumSize.height) {
<i>873</i>&nbsp;                    int nw = Math.max(width, minimumSize.width);
<i>874</i>&nbsp;                    int nh = Math.max(height, minimumSize.height);
<i>875</i>&nbsp;                    setSize(nw, nh);
<i>876</i>&nbsp;                }
<i>877</i>&nbsp;            }
<i>878</i>&nbsp;            if (peer != null) {
<i>879</i>&nbsp;                ((WindowPeer)peer).updateMinimumSize();
<i>880</i>&nbsp;            }
<i>881</i>&nbsp;        }
<i>882</i>&nbsp;    }
<i>883</i>&nbsp;
<i>884</i>&nbsp;    /**
<i>885</i>&nbsp;     * {@inheritDoc}
<b class="nc"><i>886</i>&nbsp;     * &lt;p&gt;</b>
<i>887</i>&nbsp;     * The {@code d.width} and {@code d.height} values
<i>888</i>&nbsp;     * are automatically enlarged if either is less than
<i>889</i>&nbsp;     * the minimum size as specified by previous call to
<i>890</i>&nbsp;     * {@code setMinimumSize}.
<i>891</i>&nbsp;     * &lt;p&gt;
<i>892</i>&nbsp;     * The method changes the geometry-related data. Therefore,
<i>893</i>&nbsp;     * the native windowing system may ignore such requests, or it may modify
<i>894</i>&nbsp;     * the requested data, so that the {@code Window} object is placed and sized
<i>895</i>&nbsp;     * in a way that corresponds closely to the desktop settings.
<i>896</i>&nbsp;     *
<i>897</i>&nbsp;     * @see #getSize
<i>898</i>&nbsp;     * @see #setBounds
<i>899</i>&nbsp;     * @see #setMinimumSize
<i>900</i>&nbsp;     * @since 1.6
<i>901</i>&nbsp;     */
<i>902</i>&nbsp;    public void setSize(Dimension d) {
<i>903</i>&nbsp;        super.setSize(d);
<i>904</i>&nbsp;    }
<i>905</i>&nbsp;
<i>906</i>&nbsp;    /**
<i>907</i>&nbsp;     * {@inheritDoc}
<b class="nc"><i>908</i>&nbsp;     * &lt;p&gt;</b>
<i>909</i>&nbsp;     * The {@code width} and {@code height} values
<i>910</i>&nbsp;     * are automatically enlarged if either is less than
<i>911</i>&nbsp;     * the minimum size as specified by previous call to
<i>912</i>&nbsp;     * {@code setMinimumSize}.
<i>913</i>&nbsp;     * &lt;p&gt;
<i>914</i>&nbsp;     * The method changes the geometry-related data. Therefore,
<i>915</i>&nbsp;     * the native windowing system may ignore such requests, or it may modify
<i>916</i>&nbsp;     * the requested data, so that the {@code Window} object is placed and sized
<i>917</i>&nbsp;     * in a way that corresponds closely to the desktop settings.
<i>918</i>&nbsp;     *
<i>919</i>&nbsp;     * @see #getSize
<i>920</i>&nbsp;     * @see #setBounds
<b class="nc"><i>921</i>&nbsp;     * @see #setMinimumSize</b>
<i>922</i>&nbsp;     * @since 1.6
<i>923</i>&nbsp;     */
<i>924</i>&nbsp;    public void setSize(int width, int height) {
<i>925</i>&nbsp;        super.setSize(width, height);
<i>926</i>&nbsp;    }
<i>927</i>&nbsp;
<i>928</i>&nbsp;    /**
<i>929</i>&nbsp;     * {@inheritDoc}
<i>930</i>&nbsp;     * &lt;p&gt;
<i>931</i>&nbsp;     * The method changes the geometry-related data. Therefore,
<i>932</i>&nbsp;     * the native windowing system may ignore such requests, or it may modify
<i>933</i>&nbsp;     * the requested data, so that the {@code Window} object is placed and sized
<b class="nc"><i>934</i>&nbsp;     * in a way that corresponds closely to the desktop settings.</b>
<i>935</i>&nbsp;     */
<i>936</i>&nbsp;    @Override
<i>937</i>&nbsp;    public void setLocation(int x, int y) {
<i>938</i>&nbsp;        super.setLocation(x, y);
<i>939</i>&nbsp;    }
<i>940</i>&nbsp;
<i>941</i>&nbsp;    /**
<i>942</i>&nbsp;     * {@inheritDoc}
<b class="nc"><i>943</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>944</i>&nbsp;     * The method changes the geometry-related data. Therefore,</b>
<b class="nc"><i>945</i>&nbsp;     * the native windowing system may ignore such requests, or it may modify</b>
<b class="nc"><i>946</i>&nbsp;     * the requested data, so that the {@code Window} object is placed and sized</b>
<i>947</i>&nbsp;     * in a way that corresponds closely to the desktop settings.
<b class="nc"><i>948</i>&nbsp;     */</b>
<b class="nc"><i>949</i>&nbsp;    @Override</b>
<i>950</i>&nbsp;    public void setLocation(Point p) {
<i>951</i>&nbsp;        super.setLocation(p);
<b class="nc"><i>952</i>&nbsp;    }</b>
<i>953</i>&nbsp;
<i>954</i>&nbsp;    /**
<i>955</i>&nbsp;     * @deprecated As of JDK version 1.1,
<b class="nc"><i>956</i>&nbsp;     * replaced by {@code setBounds(int, int, int, int)}.</b>
<b class="nc"><i>957</i>&nbsp;     */</b>
<b class="nc"><i>958</i>&nbsp;    @Deprecated</b>
<b class="nc"><i>959</i>&nbsp;    public void reshape(int x, int y, int width, int height) {</b>
<i>960</i>&nbsp;        if (isMinimumSizeSet()) {
<i>961</i>&nbsp;            Dimension minSize = getMinimumSize();
<i>962</i>&nbsp;            if (width &lt; minSize.width) {
<b class="nc"><i>963</i>&nbsp;                width = minSize.width;</b>
<i>964</i>&nbsp;            }
<i>965</i>&nbsp;            if (height &lt; minSize.height) {
<b class="nc"><i>966</i>&nbsp;                height = minSize.height;</b>
<i>967</i>&nbsp;            }
<i>968</i>&nbsp;        }
<b class="nc"><i>969</i>&nbsp;        super.reshape(x, y, width, height);</b>
<i>970</i>&nbsp;    }
<i>971</i>&nbsp;
<b class="nc"><i>972</i>&nbsp;    void setClientSize(int w, int h) {</b>
<b class="nc"><i>973</i>&nbsp;        synchronized (getTreeLock()) {</b>
<i>974</i>&nbsp;            setBoundsOp(ComponentPeer.SET_CLIENT_SIZE);
<i>975</i>&nbsp;            setBounds(x, y, w, h);
<i>976</i>&nbsp;        }
<i>977</i>&nbsp;    }
<i>978</i>&nbsp;
<i>979</i>&nbsp;    private static final AtomicBoolean
<i>980</i>&nbsp;        beforeFirstWindowShown = new AtomicBoolean(true);
<i>981</i>&nbsp;
<i>982</i>&nbsp;    final void closeSplashScreen() {
<i>983</i>&nbsp;        if (isTrayIconWindow) {
<i>984</i>&nbsp;            return;
<i>985</i>&nbsp;        }
<i>986</i>&nbsp;        if (beforeFirstWindowShown.getAndSet(false)) {
<i>987</i>&nbsp;            // We don&#39;t use SplashScreen.getSplashScreen() to avoid instantiating
<i>988</i>&nbsp;            // the object if it hasn&#39;t been requested by user code explicitly
<i>989</i>&nbsp;            SunToolkit.closeSplashScreen();
<i>990</i>&nbsp;            SplashScreen.markClosed();
<i>991</i>&nbsp;        }
<i>992</i>&nbsp;    }
<i>993</i>&nbsp;
<i>994</i>&nbsp;    /**
<i>995</i>&nbsp;     * Shows or hides this {@code Window} depending on the value of parameter
<i>996</i>&nbsp;     * {@code b}.
<i>997</i>&nbsp;     * &lt;p&gt;
<i>998</i>&nbsp;     * If the method shows the window then the window is also made
<i>999</i>&nbsp;     * focused under the following conditions:
<i>1000</i>&nbsp;     * &lt;ul&gt;
<i>1001</i>&nbsp;     * &lt;li&gt; The {@code Window} meets the requirements outlined in the
<i>1002</i>&nbsp;     *      {@link #isFocusableWindow} method.
<i>1003</i>&nbsp;     * &lt;li&gt; The {@code Window}&#39;s {@code autoRequestFocus} property is of the {@code true} value.
<i>1004</i>&nbsp;     * &lt;li&gt; Native windowing system allows the {@code Window} to get focused.
<i>1005</i>&nbsp;     * &lt;/ul&gt;
<i>1006</i>&nbsp;     * There is an exception for the second condition (the value of the
<i>1007</i>&nbsp;     * {@code autoRequestFocus} property). The property is not taken into account if the
<i>1008</i>&nbsp;     * window is a modal dialog, which blocks the currently focused window.
<i>1009</i>&nbsp;     * &lt;p&gt;
<i>1010</i>&nbsp;     * Developers must never assume that the window is the focused or active window
<i>1011</i>&nbsp;     * until it receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED event.
<i>1012</i>&nbsp;     * @param b  if {@code true}, makes the {@code Window} visible,
<i>1013</i>&nbsp;     * otherwise hides the {@code Window}.
<b class="nc"><i>1014</i>&nbsp;     * If the {@code Window} and/or its owner</b>
<i>1015</i>&nbsp;     * are not yet displayable, both are made displayable.  The
<i>1016</i>&nbsp;     * {@code Window} will be validated prior to being made visible.
<i>1017</i>&nbsp;     * If the {@code Window} is already visible, this will bring the
<i>1018</i>&nbsp;     * {@code Window} to the front.&lt;p&gt;
<i>1019</i>&nbsp;     * If {@code false}, hides this {@code Window}, its subcomponents, and all
<i>1020</i>&nbsp;     * of its owned children.
<i>1021</i>&nbsp;     * The {@code Window} and its subcomponents can be made visible again
<i>1022</i>&nbsp;     * with a call to {@code #setVisible(true)}.
<i>1023</i>&nbsp;     * @see java.awt.Component#isDisplayable
<i>1024</i>&nbsp;     * @see java.awt.Component#setVisible
<i>1025</i>&nbsp;     * @see java.awt.Window#toFront
<i>1026</i>&nbsp;     * @see java.awt.Window#dispose
<i>1027</i>&nbsp;     * @see java.awt.Window#setAutoRequestFocus
<i>1028</i>&nbsp;     * @see java.awt.Window#isFocusableWindow
<i>1029</i>&nbsp;     */
<b class="nc"><i>1030</i>&nbsp;    public void setVisible(boolean b) {</b>
<b class="nc"><i>1031</i>&nbsp;        super.setVisible(b);</b>
<i>1032</i>&nbsp;    }
<b class="nc"><i>1033</i>&nbsp;</b>
<i>1034</i>&nbsp;    /**
<b class="nc"><i>1035</i>&nbsp;     * Makes the Window visible. If the Window and/or its owner</b>
<b class="nc"><i>1036</i>&nbsp;     * are not yet displayable, both are made displayable.  The</b>
<b class="nc"><i>1037</i>&nbsp;     * Window will be validated prior to being made visible.</b>
<i>1038</i>&nbsp;     * If the Window is already visible, this will bring the Window
<b class="nc"><i>1039</i>&nbsp;     * to the front.</b>
<b class="nc"><i>1040</i>&nbsp;     * @see       Component#isDisplayable</b>
<b class="nc"><i>1041</i>&nbsp;     * @see       #toFront</b>
<b class="nc"><i>1042</i>&nbsp;     * @deprecated As of JDK version 1.5, replaced by</b>
<b class="nc"><i>1043</i>&nbsp;     * {@link #setVisible(boolean)}.</b>
<b class="nc"><i>1044</i>&nbsp;     */</b>
<b class="nc"><i>1045</i>&nbsp;    @Deprecated</b>
<b class="nc"><i>1046</i>&nbsp;    public void show() {</b>
<b class="nc"><i>1047</i>&nbsp;        if (peer == null) {</b>
<b class="nc"><i>1048</i>&nbsp;            addNotify();</b>
<i>1049</i>&nbsp;        }
<i>1050</i>&nbsp;        validateUnconditionally();
<b class="nc"><i>1051</i>&nbsp;</b>
<b class="nc"><i>1052</i>&nbsp;        isInShow = true;</b>
<i>1053</i>&nbsp;        if (visible) {
<i>1054</i>&nbsp;            toFront();
<i>1055</i>&nbsp;        } else {
<b class="nc"><i>1056</i>&nbsp;            beforeFirstShow = false;</b>
<i>1057</i>&nbsp;            closeSplashScreen();
<b class="nc"><i>1058</i>&nbsp;            Dialog.checkShouldBeBlocked(this);</b>
<b class="nc"><i>1059</i>&nbsp;            super.show();</b>
<i>1060</i>&nbsp;            locationByPlatform = false;
<i>1061</i>&nbsp;            for (int i = 0; i &lt; ownedWindowList.size(); i++) {
<b class="nc"><i>1062</i>&nbsp;                Window child = ownedWindowList.elementAt(i).get();</b>
<i>1063</i>&nbsp;                if ((child != null) &amp;&amp; child.showWithParent) {
<i>1064</i>&nbsp;                    child.show();
<b class="nc"><i>1065</i>&nbsp;                    child.showWithParent = false;</b>
<b class="nc"><i>1066</i>&nbsp;                }       // endif</b>
<b class="nc"><i>1067</i>&nbsp;            }   // endfor</b>
<i>1068</i>&nbsp;            if (!isModalBlocked()) {
<i>1069</i>&nbsp;                updateChildrenBlocking();
<i>1070</i>&nbsp;            } else {
<i>1071</i>&nbsp;                // fix for 6532736: after this window is shown, its blocker
<b class="nc"><i>1072</i>&nbsp;                // should be raised to front</b>
<b class="nc"><i>1073</i>&nbsp;                modalBlocker.toFront_NoClientCode();</b>
<i>1074</i>&nbsp;            }
<b class="nc"><i>1075</i>&nbsp;            if (this instanceof Frame || this instanceof Dialog) {</b>
<b class="nc"><i>1076</i>&nbsp;                updateChildFocusableWindowState(this);</b>
<b class="nc"><i>1077</i>&nbsp;            }</b>
<b class="nc"><i>1078</i>&nbsp;        }</b>
<i>1079</i>&nbsp;        isInShow = false;
<i>1080</i>&nbsp;
<i>1081</i>&nbsp;        // If first time shown, generate WindowOpened event
<i>1082</i>&nbsp;        if ((state &amp; OPENED) == 0) {
<i>1083</i>&nbsp;            postWindowEvent(WindowEvent.WINDOW_OPENED);
<b class="nc"><i>1084</i>&nbsp;            state |= OPENED;</b>
<i>1085</i>&nbsp;        }
<b class="nc"><i>1086</i>&nbsp;    }</b>
<b class="nc"><i>1087</i>&nbsp;</b>
<b class="nc"><i>1088</i>&nbsp;    static void updateChildFocusableWindowState(Window w) {</b>
<i>1089</i>&nbsp;        if (w.peer != null &amp;&amp; w.isShowing()) {
<i>1090</i>&nbsp;            ((WindowPeer)w.peer).updateFocusableWindowState();
<i>1091</i>&nbsp;        }
<i>1092</i>&nbsp;        for (int i = 0; i &lt; w.ownedWindowList.size(); i++) {
<i>1093</i>&nbsp;            Window child = w.ownedWindowList.elementAt(i).get();
<i>1094</i>&nbsp;            if (child != null) {
<i>1095</i>&nbsp;                updateChildFocusableWindowState(child);
<i>1096</i>&nbsp;            }
<i>1097</i>&nbsp;        }
<i>1098</i>&nbsp;    }
<i>1099</i>&nbsp;
<i>1100</i>&nbsp;    synchronized void postWindowEvent(int id) {
<i>1101</i>&nbsp;        if (windowListener != null
<i>1102</i>&nbsp;            || (eventMask &amp; AWTEvent.WINDOW_EVENT_MASK) != 0
<b class="nc"><i>1103</i>&nbsp;            ||  Toolkit.enabledOnToolkit(AWTEvent.WINDOW_EVENT_MASK)) {</b>
<b class="nc"><i>1104</i>&nbsp;            WindowEvent e = new WindowEvent(this, id);</b>
<b class="nc"><i>1105</i>&nbsp;            Toolkit.getEventQueue().postEvent(e);</b>
<b class="nc"><i>1106</i>&nbsp;        }</b>
<b class="nc"><i>1107</i>&nbsp;    }</b>
<b class="nc"><i>1108</i>&nbsp;</b>
<i>1109</i>&nbsp;    /**
<i>1110</i>&nbsp;     * Hide this Window, its subcomponents, and all of its owned children.
<b class="nc"><i>1111</i>&nbsp;     * The Window and its subcomponents can be made visible again</b>
<b class="nc"><i>1112</i>&nbsp;     * with a call to {@code show}.</b>
<b class="nc"><i>1113</i>&nbsp;     * @see #show</b>
<i>1114</i>&nbsp;     * @see #dispose
<b class="nc"><i>1115</i>&nbsp;     * @deprecated As of JDK version 1.5, replaced by</b>
<b class="nc"><i>1116</i>&nbsp;     * {@link #setVisible(boolean)}.</b>
<i>1117</i>&nbsp;     */
<i>1118</i>&nbsp;    @Deprecated
<i>1119</i>&nbsp;    public void hide() {
<i>1120</i>&nbsp;        synchronized(ownedWindowList) {
<i>1121</i>&nbsp;            for (int i = 0; i &lt; ownedWindowList.size(); i++) {
<i>1122</i>&nbsp;                Window child = ownedWindowList.elementAt(i).get();
<i>1123</i>&nbsp;                if ((child != null) &amp;&amp; child.visible) {
<i>1124</i>&nbsp;                    child.hide();
<i>1125</i>&nbsp;                    child.showWithParent = true;
<i>1126</i>&nbsp;                }
<i>1127</i>&nbsp;            }
<i>1128</i>&nbsp;        }
<i>1129</i>&nbsp;        if (isModalBlocked()) {
<i>1130</i>&nbsp;            modalBlocker.unblockWindow(this);
<i>1131</i>&nbsp;        }
<i>1132</i>&nbsp;        super.hide();
<i>1133</i>&nbsp;        locationByPlatform = false;
<i>1134</i>&nbsp;    }
<i>1135</i>&nbsp;
<i>1136</i>&nbsp;    final void clearMostRecentFocusOwnerOnHide() {
<i>1137</i>&nbsp;        /* do nothing */
<i>1138</i>&nbsp;    }
<i>1139</i>&nbsp;
<i>1140</i>&nbsp;    /**
<i>1141</i>&nbsp;     * Releases all of the native screen resources used by this
<i>1142</i>&nbsp;     * {@code Window}, its subcomponents, and all of its owned
<i>1143</i>&nbsp;     * children. That is, the resources for these {@code Component}s
<i>1144</i>&nbsp;     * will be destroyed, any memory they consume will be returned to the
<i>1145</i>&nbsp;     * OS, and they will be marked as undisplayable.
<i>1146</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1147</i>&nbsp;     * The {@code Window} and its subcomponents can be made displayable</b>
<i>1148</i>&nbsp;     * again by rebuilding the native resources with a subsequent call to
<i>1149</i>&nbsp;     * {@code pack} or {@code show}. The states of the recreated
<i>1150</i>&nbsp;     * {@code Window} and its subcomponents will be identical to the
<i>1151</i>&nbsp;     * states of these objects at the point where the {@code Window}
<i>1152</i>&nbsp;     * was disposed (not accounting for additional modifications between
<i>1153</i>&nbsp;     * those actions).
<i>1154</i>&nbsp;     * &lt;p&gt;
<i>1155</i>&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When the last displayable window
<i>1156</i>&nbsp;     * within the Java virtual machine (VM) is disposed of, the VM may
<b class="nc"><i>1157</i>&nbsp;     * terminate.  See &lt;a href=&quot;doc-files/AWTThreadIssues.html#Autoshutdown&quot;&gt;</b>
<b class="nc"><i>1158</i>&nbsp;     * AWT Threading Issues&lt;/a&gt; for more information.</b>
<b class="nc"><i>1159</i>&nbsp;     * @see Component#isDisplayable</b>
<i>1160</i>&nbsp;     * @see #pack
<i>1161</i>&nbsp;     * @see #show
<i>1162</i>&nbsp;     */
<i>1163</i>&nbsp;    public void dispose() {
<b class="nc"><i>1164</i>&nbsp;        doDispose();</b>
<i>1165</i>&nbsp;    }
<b class="nc"><i>1166</i>&nbsp;</b>
<i>1167</i>&nbsp;    /*
<i>1168</i>&nbsp;     * Fix for 4872170.
<i>1169</i>&nbsp;     * If dispose() is called on parent then its children have to be disposed as well
<i>1170</i>&nbsp;     * as reported in javadoc. So we need to implement this functionality even if a
<b class="nc"><i>1171</i>&nbsp;     * child overrides dispose() in a wrong way without calling super.dispose().</b>
<b class="nc"><i>1172</i>&nbsp;     */</b>
<b class="nc"><i>1173</i>&nbsp;    void disposeImpl() {</b>
<i>1174</i>&nbsp;        dispose();
<i>1175</i>&nbsp;        if (peer != null) {
<i>1176</i>&nbsp;            doDispose();
<b class="nc"><i>1177</i>&nbsp;        }</b>
<b class="nc"><i>1178</i>&nbsp;    }</b>
<b class="nc"><i>1179</i>&nbsp;</b>
<b class="nc"><i>1180</i>&nbsp;    void doDispose() {</b>
<b class="nc"><i>1181</i>&nbsp;    class DisposeAction implements Runnable {</b>
<b class="nc"><i>1182</i>&nbsp;        public void run() {</b>
<b class="nc"><i>1183</i>&nbsp;            disposing = true;</b>
<b class="nc"><i>1184</i>&nbsp;            try {</b>
<b class="nc"><i>1185</i>&nbsp;                // Check if this window is the fullscreen window for the</b>
<i>1186</i>&nbsp;                // device. Exit the fullscreen mode prior to disposing
<i>1187</i>&nbsp;                // of the window if that&#39;s the case.
<b class="nc"><i>1188</i>&nbsp;                GraphicsDevice gd = getGraphicsConfiguration().getDevice();</b>
<b class="nc"><i>1189</i>&nbsp;                if (gd.getFullScreenWindow() == Window.this) {</b>
<b class="nc"><i>1190</i>&nbsp;                    gd.setFullScreenWindow(null);</b>
<b class="nc"><i>1191</i>&nbsp;                }</b>
<b class="nc"><i>1192</i>&nbsp;</b>
<b class="nc"><i>1193</i>&nbsp;                Object[] ownedWindowArray;</b>
<b class="nc"><i>1194</i>&nbsp;                synchronized(ownedWindowList) {</b>
<i>1195</i>&nbsp;                    ownedWindowArray = new Object[ownedWindowList.size()];
<b class="nc"><i>1196</i>&nbsp;                    ownedWindowList.copyInto(ownedWindowArray);</b>
<b class="nc"><i>1197</i>&nbsp;                }</b>
<i>1198</i>&nbsp;                for (int i = 0; i &lt; ownedWindowArray.length; i++) {
<b class="nc"><i>1199</i>&nbsp;                    Window child = (Window) (((WeakReference)</b>
<b class="nc"><i>1200</i>&nbsp;                                   (ownedWindowArray[i])).get());</b>
<i>1201</i>&nbsp;                    if (child != null) {
<i>1202</i>&nbsp;                        child.disposeImpl();
<b class="nc"><i>1203</i>&nbsp;                    }</b>
<b class="nc"><i>1204</i>&nbsp;                }</b>
<b class="nc"><i>1205</i>&nbsp;                hide();</b>
<b class="nc"><i>1206</i>&nbsp;                beforeFirstShow = true;</b>
<i>1207</i>&nbsp;                removeNotify();
<i>1208</i>&nbsp;                synchronized (inputContextLock) {
<i>1209</i>&nbsp;                    if (inputContext != null) {
<b class="nc"><i>1210</i>&nbsp;                        inputContext.dispose();</b>
<i>1211</i>&nbsp;                        inputContext = null;
<b class="nc"><i>1212</i>&nbsp;                    }</b>
<b class="nc"><i>1213</i>&nbsp;                }</b>
<b class="nc"><i>1214</i>&nbsp;                clearCurrentFocusCycleRootOnHide();</b>
<i>1215</i>&nbsp;            } finally {
<b class="nc"><i>1216</i>&nbsp;                disposing = false;</b>
<b class="nc"><i>1217</i>&nbsp;            }</b>
<b class="nc"><i>1218</i>&nbsp;        }</b>
<b class="nc"><i>1219</i>&nbsp;    }</b>
<i>1220</i>&nbsp;        boolean fireWindowClosedEvent = isDisplayable();
<i>1221</i>&nbsp;        DisposeAction action = new DisposeAction();
<i>1222</i>&nbsp;        if (EventQueue.isDispatchThread()) {
<i>1223</i>&nbsp;            action.run();
<b class="nc"><i>1224</i>&nbsp;        }</b>
<b class="nc"><i>1225</i>&nbsp;        else {</b>
<i>1226</i>&nbsp;            try {
<i>1227</i>&nbsp;                EventQueue.invokeAndWait(this, action);
<i>1228</i>&nbsp;            }
<i>1229</i>&nbsp;            catch (InterruptedException e) {
<i>1230</i>&nbsp;                System.err.println(&quot;Disposal was interrupted:&quot;);
<i>1231</i>&nbsp;                e.printStackTrace();
<i>1232</i>&nbsp;            }
<i>1233</i>&nbsp;            catch (InvocationTargetException e) {
<i>1234</i>&nbsp;                System.err.println(&quot;Exception during disposal:&quot;);
<i>1235</i>&nbsp;                e.printStackTrace();
<i>1236</i>&nbsp;            }
<i>1237</i>&nbsp;        }
<i>1238</i>&nbsp;        // Execute outside the Runnable because postWindowEvent is
<i>1239</i>&nbsp;        // synchronized on (this). We don&#39;t need to synchronize the call
<i>1240</i>&nbsp;        // on the EventQueue anyways.
<i>1241</i>&nbsp;        if (fireWindowClosedEvent) {
<i>1242</i>&nbsp;            postWindowEvent(WindowEvent.WINDOW_CLOSED);
<i>1243</i>&nbsp;        }
<i>1244</i>&nbsp;    }
<i>1245</i>&nbsp;
<i>1246</i>&nbsp;    /*
<i>1247</i>&nbsp;     * Should only be called while holding the tree lock.
<i>1248</i>&nbsp;     * It&#39;s overridden here because parent == owner in Window,
<i>1249</i>&nbsp;     * and we shouldn&#39;t adjust counter on owner
<i>1250</i>&nbsp;     */
<i>1251</i>&nbsp;    void adjustListeningChildrenOnParent(long mask, int num) {
<i>1252</i>&nbsp;    }
<i>1253</i>&nbsp;
<i>1254</i>&nbsp;    // Should only be called while holding tree lock
<i>1255</i>&nbsp;    void adjustDescendantsOnParent(int num) {
<i>1256</i>&nbsp;        // do nothing since parent == owner and we shouldn&#39;t
<i>1257</i>&nbsp;        // adjust counter on owner
<i>1258</i>&nbsp;    }
<i>1259</i>&nbsp;
<i>1260</i>&nbsp;    /**
<i>1261</i>&nbsp;     * If this Window is visible, brings this Window to the front and may make
<i>1262</i>&nbsp;     * it the focused Window.
<i>1263</i>&nbsp;     * &lt;p&gt;
<i>1264</i>&nbsp;     * Places this Window at the top of the stacking order and shows it in
<i>1265</i>&nbsp;     * front of any other Windows in this VM. No action will take place if this
<i>1266</i>&nbsp;     * Window is not visible. Some platforms do not allow Windows which own
<i>1267</i>&nbsp;     * other Windows to appear on top of those owned Windows. Some platforms
<i>1268</i>&nbsp;     * may not permit this VM to place its Windows above windows of native
<i>1269</i>&nbsp;     * applications, or Windows of other VMs. This permission may depend on
<i>1270</i>&nbsp;     * whether a Window in this VM is already focused. Every attempt will be
<i>1271</i>&nbsp;     * made to move this Window as high as possible in the stacking order;
<i>1272</i>&nbsp;     * however, developers should not assume that this method will move this
<i>1273</i>&nbsp;     * Window above all other windows in every situation.
<i>1274</i>&nbsp;     * &lt;p&gt;
<i>1275</i>&nbsp;     * Developers must never assume that this Window is the focused or active
<i>1276</i>&nbsp;     * Window until this Window receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED
<i>1277</i>&nbsp;     * event. On platforms where the top-most window is the focused window, this
<i>1278</i>&nbsp;     * method will &lt;b&gt;probably&lt;/b&gt; focus this Window (if it is not already focused)
<i>1279</i>&nbsp;     * under the following conditions:
<i>1280</i>&nbsp;     * &lt;ul&gt;
<i>1281</i>&nbsp;     * &lt;li&gt; The window meets the requirements outlined in the
<i>1282</i>&nbsp;     *      {@link #isFocusableWindow} method.
<i>1283</i>&nbsp;     * &lt;li&gt; The window&#39;s property {@code autoRequestFocus} is of the
<i>1284</i>&nbsp;     *      {@code true} value.
<i>1285</i>&nbsp;     * &lt;li&gt; Native windowing system allows the window to get focused.
<i>1286</i>&nbsp;     * &lt;/ul&gt;
<b class="nc"><i>1287</i>&nbsp;     * On platforms where the stacking order does not typically affect the focused</b>
<i>1288</i>&nbsp;     * window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused and active
<i>1289</i>&nbsp;     * Windows unchanged.
<i>1290</i>&nbsp;     * &lt;p&gt;
<i>1291</i>&nbsp;     * If this method causes this Window to be focused, and this Window is a
<i>1292</i>&nbsp;     * Frame or a Dialog, it will also become activated. If this Window is
<b class="nc"><i>1293</i>&nbsp;     * focused, but it is not a Frame or a Dialog, then the first Frame or</b>
<b class="nc"><i>1294</i>&nbsp;     * Dialog that is an owner of this Window will be activated.</b>
<b class="nc"><i>1295</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1296</i>&nbsp;     * If this window is blocked by modal dialog, then the blocking dialog</b>
<i>1297</i>&nbsp;     * is brought to the front and remains above the blocked window.
<b class="nc"><i>1298</i>&nbsp;     *</b>
<b class="nc"><i>1299</i>&nbsp;     * @see       #toBack</b>
<i>1300</i>&nbsp;     * @see       #setAutoRequestFocus
<i>1301</i>&nbsp;     * @see       #isFocusableWindow
<i>1302</i>&nbsp;     */
<i>1303</i>&nbsp;    public void toFront() {
<i>1304</i>&nbsp;        toFront_NoClientCode();
<i>1305</i>&nbsp;    }
<i>1306</i>&nbsp;
<i>1307</i>&nbsp;    // This functionality is implemented in a final package-private method
<i>1308</i>&nbsp;    // to insure that it cannot be overridden by client subclasses.
<i>1309</i>&nbsp;    final void toFront_NoClientCode() {
<i>1310</i>&nbsp;        if (visible) {
<i>1311</i>&nbsp;            WindowPeer peer = (WindowPeer)this.peer;
<i>1312</i>&nbsp;            if (peer != null) {
<i>1313</i>&nbsp;                peer.toFront();
<i>1314</i>&nbsp;            }
<i>1315</i>&nbsp;            if (isModalBlocked()) {
<i>1316</i>&nbsp;                modalBlocker.toFront_NoClientCode();
<i>1317</i>&nbsp;            }
<i>1318</i>&nbsp;        }
<i>1319</i>&nbsp;    }
<i>1320</i>&nbsp;
<i>1321</i>&nbsp;    /**
<i>1322</i>&nbsp;     * If this Window is visible, sends this Window to the back and may cause
<i>1323</i>&nbsp;     * it to lose focus or activation if it is the focused or active Window.
<i>1324</i>&nbsp;     * &lt;p&gt;
<i>1325</i>&nbsp;     * Places this Window at the bottom of the stacking order and shows it
<i>1326</i>&nbsp;     * behind any other Windows in this VM. No action will take place is this
<i>1327</i>&nbsp;     * Window is not visible. Some platforms do not allow Windows which are
<i>1328</i>&nbsp;     * owned by other Windows to appear below their owners. Every attempt will
<i>1329</i>&nbsp;     * be made to move this Window as low as possible in the stacking order;
<b class="nc"><i>1330</i>&nbsp;     * however, developers should not assume that this method will move this</b>
<i>1331</i>&nbsp;     * Window below all other windows in every situation.
<i>1332</i>&nbsp;     * &lt;p&gt;
<i>1333</i>&nbsp;     * Because of variations in native windowing systems, no guarantees about
<i>1334</i>&nbsp;     * changes to the focused and active Windows can be made. Developers must
<i>1335</i>&nbsp;     * never assume that this Window is no longer the focused or active Window
<b class="nc"><i>1336</i>&nbsp;     * until this Window receives a WINDOW_LOST_FOCUS or WINDOW_DEACTIVATED</b>
<i>1337</i>&nbsp;     * event. On platforms where the top-most window is the focused window,
<b class="nc"><i>1338</i>&nbsp;     * this method will &lt;b&gt;probably&lt;/b&gt; cause this Window to lose focus. In</b>
<b class="nc"><i>1339</i>&nbsp;     * that case, the next highest, focusable Window in this VM will receive</b>
<b class="nc"><i>1340</i>&nbsp;     * focus. On platforms where the stacking order does not typically affect</b>
<i>1341</i>&nbsp;     * the focused window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused
<b class="nc"><i>1342</i>&nbsp;     * and active Windows unchanged.</b>
<b class="nc"><i>1343</i>&nbsp;     *</b>
<b class="nc"><i>1344</i>&nbsp;     * @see       #toFront</b>
<b class="nc"><i>1345</i>&nbsp;     */</b>
<i>1346</i>&nbsp;    public void toBack() {
<i>1347</i>&nbsp;        toBack_NoClientCode();
<i>1348</i>&nbsp;    }
<i>1349</i>&nbsp;
<i>1350</i>&nbsp;    // This functionality is implemented in a final package-private method
<i>1351</i>&nbsp;    // to insure that it cannot be overridden by client subclasses.
<i>1352</i>&nbsp;    final void toBack_NoClientCode() {
<i>1353</i>&nbsp;        if(isAlwaysOnTop()) {
<i>1354</i>&nbsp;            try {
<i>1355</i>&nbsp;                setAlwaysOnTop(false);
<i>1356</i>&nbsp;            }catch(SecurityException e) {
<i>1357</i>&nbsp;            }
<b class="nc"><i>1358</i>&nbsp;        }</b>
<i>1359</i>&nbsp;        if (visible) {
<i>1360</i>&nbsp;            WindowPeer peer = (WindowPeer)this.peer;
<i>1361</i>&nbsp;            if (peer != null) {
<i>1362</i>&nbsp;                peer.toBack();
<i>1363</i>&nbsp;            }
<i>1364</i>&nbsp;        }
<i>1365</i>&nbsp;    }
<i>1366</i>&nbsp;
<i>1367</i>&nbsp;    /**
<i>1368</i>&nbsp;     * Returns the toolkit of this frame.
<i>1369</i>&nbsp;     * @return    the toolkit of this window.
<i>1370</i>&nbsp;     * @see       Toolkit
<i>1371</i>&nbsp;     * @see       Toolkit#getDefaultToolkit
<i>1372</i>&nbsp;     * @see       Component#getToolkit
<i>1373</i>&nbsp;     */
<i>1374</i>&nbsp;    public Toolkit getToolkit() {
<i>1375</i>&nbsp;        return Toolkit.getDefaultToolkit();
<i>1376</i>&nbsp;    }
<b class="nc"><i>1377</i>&nbsp;</b>
<i>1378</i>&nbsp;    /**
<i>1379</i>&nbsp;     * Gets the warning string that is displayed with this window.
<i>1380</i>&nbsp;     * If this window is insecure, the warning string is displayed
<b class="nc"><i>1381</i>&nbsp;     * somewhere in the visible area of the window. A window is</b>
<b class="nc"><i>1382</i>&nbsp;     * insecure if there is a security manager and the security</b>
<b class="nc"><i>1383</i>&nbsp;     * manager denies</b>
<i>1384</i>&nbsp;     * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
<b class="nc"><i>1385</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1386</i>&nbsp;     * If the window is secure, then {@code getWarningString}</b>
<i>1387</i>&nbsp;     * returns {@code null}. If the window is insecure, this
<i>1388</i>&nbsp;     * method checks for the system property
<i>1389</i>&nbsp;     * {@code awt.appletWarning}
<b class="nc"><i>1390</i>&nbsp;     * and returns the string value of that property.</b>
<i>1391</i>&nbsp;     * @return    the warning string for this window.
<i>1392</i>&nbsp;     */
<b class="nc"><i>1393</i>&nbsp;    public final String getWarningString() {</b>
<i>1394</i>&nbsp;        return warningString;
<i>1395</i>&nbsp;    }
<i>1396</i>&nbsp;
<i>1397</i>&nbsp;    private void setWarningString() {
<i>1398</i>&nbsp;        warningString = null;
<i>1399</i>&nbsp;        SecurityManager sm = System.getSecurityManager();
<i>1400</i>&nbsp;        if (sm != null) {
<i>1401</i>&nbsp;            try {
<i>1402</i>&nbsp;                sm.checkPermission(AWTPermissions.TOPLEVEL_WINDOW_PERMISSION);
<i>1403</i>&nbsp;            } catch (SecurityException se) {
<i>1404</i>&nbsp;                // make sure the privileged action is only
<i>1405</i>&nbsp;                // for getting the property! We don&#39;t want the
<i>1406</i>&nbsp;                // above checkPermission call to always succeed!
<b class="nc"><i>1407</i>&nbsp;                warningString = AccessController.doPrivileged(</b>
<b class="nc"><i>1408</i>&nbsp;                      new GetPropertyAction(&quot;awt.appletWarning&quot;,</b>
<i>1409</i>&nbsp;                                            &quot;Java Applet Window&quot;));
<b class="nc"><i>1410</i>&nbsp;            }</b>
<i>1411</i>&nbsp;        }
<i>1412</i>&nbsp;    }
<i>1413</i>&nbsp;
<i>1414</i>&nbsp;    /**
<i>1415</i>&nbsp;     * Gets the {@code Locale} object that is associated
<i>1416</i>&nbsp;     * with this window, if the locale has been set.
<i>1417</i>&nbsp;     * If no locale has been set, then the default locale
<i>1418</i>&nbsp;     * is returned.
<i>1419</i>&nbsp;     * @return    the locale that is set for this window.
<b class="nc"><i>1420</i>&nbsp;     * @see       java.util.Locale</b>
<b class="nc"><i>1421</i>&nbsp;     * @since     1.1</b>
<b class="nc"><i>1422</i>&nbsp;     */</b>
<i>1423</i>&nbsp;    public Locale getLocale() {
<b class="nc"><i>1424</i>&nbsp;      if (this.locale == null) {</b>
<b class="nc"><i>1425</i>&nbsp;        return Locale.getDefault();</b>
<i>1426</i>&nbsp;      }
<i>1427</i>&nbsp;      return this.locale;
<i>1428</i>&nbsp;    }
<i>1429</i>&nbsp;
<i>1430</i>&nbsp;    /**
<i>1431</i>&nbsp;     * Gets the input context for this window. A window always has an input context,
<i>1432</i>&nbsp;     * which is shared by subcomponents unless they create and set their own.
<i>1433</i>&nbsp;     * @see Component#getInputContext
<i>1434</i>&nbsp;     * @since 1.2
<i>1435</i>&nbsp;     */
<i>1436</i>&nbsp;    public InputContext getInputContext() {
<i>1437</i>&nbsp;        synchronized (inputContextLock) {
<i>1438</i>&nbsp;            if (inputContext == null) {
<i>1439</i>&nbsp;                inputContext = InputContext.getInstance();
<i>1440</i>&nbsp;            }
<i>1441</i>&nbsp;        }
<i>1442</i>&nbsp;        return inputContext;
<b class="nc"><i>1443</i>&nbsp;    }</b>
<b class="nc"><i>1444</i>&nbsp;</b>
<i>1445</i>&nbsp;    /**
<b class="nc"><i>1446</i>&nbsp;     * Set the cursor image to a specified cursor.</b>
<i>1447</i>&nbsp;     * &lt;p&gt;
<i>1448</i>&nbsp;     * The method may have no visual effect if the Java platform
<i>1449</i>&nbsp;     * implementation and/or the native system do not support
<i>1450</i>&nbsp;     * changing the mouse cursor shape.
<i>1451</i>&nbsp;     * @param     cursor One of the constants defined
<i>1452</i>&nbsp;     *            by the {@code Cursor} class. If this parameter is null
<i>1453</i>&nbsp;     *            then the cursor for this window will be set to the type
<b class="nc"><i>1454</i>&nbsp;     *            Cursor.DEFAULT_CURSOR.</b>
<i>1455</i>&nbsp;     * @see       Component#getCursor
<i>1456</i>&nbsp;     * @see       Cursor
<b class="nc"><i>1457</i>&nbsp;     * @since     1.1</b>
<i>1458</i>&nbsp;     */
<i>1459</i>&nbsp;    public void setCursor(Cursor cursor) {
<i>1460</i>&nbsp;        if (cursor == null) {
<i>1461</i>&nbsp;            cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
<i>1462</i>&nbsp;        }
<i>1463</i>&nbsp;        super.setCursor(cursor);
<i>1464</i>&nbsp;    }
<i>1465</i>&nbsp;
<b class="nc"><i>1466</i>&nbsp;    /**</b>
<i>1467</i>&nbsp;     * Returns the owner of this window.
<i>1468</i>&nbsp;     *
<i>1469</i>&nbsp;     * @return the owner of this window
<i>1470</i>&nbsp;     * @since 1.2
<b class="nc"><i>1471</i>&nbsp;     */</b>
<i>1472</i>&nbsp;    public Window getOwner() {
<i>1473</i>&nbsp;        return getOwner_NoClientCode();
<i>1474</i>&nbsp;    }
<i>1475</i>&nbsp;    final Window getOwner_NoClientCode() {
<i>1476</i>&nbsp;        return (Window)parent;
<b class="nc"><i>1477</i>&nbsp;    }</b>
<b class="nc"><i>1478</i>&nbsp;</b>
<b class="nc"><i>1479</i>&nbsp;    /**</b>
<i>1480</i>&nbsp;     * Return an array containing all the windows this
<b class="nc"><i>1481</i>&nbsp;     * window currently owns.</b>
<b class="nc"><i>1482</i>&nbsp;     *</b>
<i>1483</i>&nbsp;     * @return the array of all the owned windows
<b class="nc"><i>1484</i>&nbsp;     * @since 1.2</b>
<b class="nc"><i>1485</i>&nbsp;     */</b>
<i>1486</i>&nbsp;    public Window[] getOwnedWindows() {
<i>1487</i>&nbsp;        return getOwnedWindows_NoClientCode();
<i>1488</i>&nbsp;    }
<b class="nc"><i>1489</i>&nbsp;    final Window[] getOwnedWindows_NoClientCode() {</b>
<b class="nc"><i>1490</i>&nbsp;        Window realCopy[];</b>
<i>1491</i>&nbsp;
<b class="nc"><i>1492</i>&nbsp;        synchronized(ownedWindowList) {</b>
<i>1493</i>&nbsp;            // Recall that ownedWindowList is actually a Vector of
<b class="nc"><i>1494</i>&nbsp;            // WeakReferences and calling get() on one of these references</b>
<i>1495</i>&nbsp;            // may return null. Make two arrays-- one the size of the
<b class="nc"><i>1496</i>&nbsp;            // Vector (fullCopy with size fullSize), and one the size of</b>
<i>1497</i>&nbsp;            // all non-null get()s (realCopy with size realSize).
<i>1498</i>&nbsp;            int fullSize = ownedWindowList.size();
<i>1499</i>&nbsp;            int realSize = 0;
<b class="nc"><i>1500</i>&nbsp;            Window fullCopy[] = new Window[fullSize];</b>
<i>1501</i>&nbsp;
<i>1502</i>&nbsp;            for (int i = 0; i &lt; fullSize; i++) {
<i>1503</i>&nbsp;                fullCopy[realSize] = ownedWindowList.elementAt(i).get();
<b class="nc"><i>1504</i>&nbsp;</b>
<b class="nc"><i>1505</i>&nbsp;                if (fullCopy[realSize] != null) {</b>
<b class="nc"><i>1506</i>&nbsp;                    realSize++;</b>
<b class="nc"><i>1507</i>&nbsp;                }</b>
<b class="nc"><i>1508</i>&nbsp;            }</b>
<i>1509</i>&nbsp;
<i>1510</i>&nbsp;            if (fullSize != realSize) {
<i>1511</i>&nbsp;                realCopy = Arrays.copyOf(fullCopy, realSize);
<i>1512</i>&nbsp;            } else {
<i>1513</i>&nbsp;                realCopy = fullCopy;
<b class="nc"><i>1514</i>&nbsp;            }</b>
<i>1515</i>&nbsp;        }
<i>1516</i>&nbsp;
<i>1517</i>&nbsp;        return realCopy;
<i>1518</i>&nbsp;    }
<i>1519</i>&nbsp;
<i>1520</i>&nbsp;    boolean isModalBlocked() {
<i>1521</i>&nbsp;        return modalBlocker != null;
<i>1522</i>&nbsp;    }
<i>1523</i>&nbsp;
<i>1524</i>&nbsp;    void setModalBlocked(Dialog blocker, boolean blocked, boolean peerCall) {
<b class="nc"><i>1525</i>&nbsp;        this.modalBlocker = blocked ? blocker : null;</b>
<b class="nc"><i>1526</i>&nbsp;        if (peerCall) {</b>
<b class="nc"><i>1527</i>&nbsp;            WindowPeer peer = (WindowPeer)this.peer;</b>
<b class="nc"><i>1528</i>&nbsp;            if (peer != null) {</b>
<b class="nc"><i>1529</i>&nbsp;                peer.setModalBlocked(blocker, blocked);</b>
<i>1530</i>&nbsp;            }
<i>1531</i>&nbsp;        }
<i>1532</i>&nbsp;    }
<b class="nc"><i>1533</i>&nbsp;</b>
<b class="nc"><i>1534</i>&nbsp;    Dialog getModalBlocker() {</b>
<b class="nc"><i>1535</i>&nbsp;        return modalBlocker;</b>
<b class="nc"><i>1536</i>&nbsp;    }</b>
<b class="nc"><i>1537</i>&nbsp;</b>
<b class="nc"><i>1538</i>&nbsp;    /*</b>
<i>1539</i>&nbsp;     * Returns a list of all displayable Windows, i. e. all the
<i>1540</i>&nbsp;     * Windows which peer is not null.
<b class="nc"><i>1541</i>&nbsp;     *</b>
<b class="nc"><i>1542</i>&nbsp;     * @see #addNotify</b>
<i>1543</i>&nbsp;     * @see #removeNotify
<i>1544</i>&nbsp;     */
<i>1545</i>&nbsp;    static IdentityArrayList&lt;Window&gt; getAllWindows() {
<b class="nc"><i>1546</i>&nbsp;        synchronized (allWindows) {</b>
<i>1547</i>&nbsp;            IdentityArrayList&lt;Window&gt; v = new IdentityArrayList&lt;Window&gt;();
<i>1548</i>&nbsp;            v.addAll(allWindows);
<b class="nc"><i>1549</i>&nbsp;            return v;</b>
<b class="nc"><i>1550</i>&nbsp;        }</b>
<b class="nc"><i>1551</i>&nbsp;    }</b>
<b class="nc"><i>1552</i>&nbsp;</b>
<b class="nc"><i>1553</i>&nbsp;    static IdentityArrayList&lt;Window&gt; getAllUnblockedWindows() {</b>
<b class="nc"><i>1554</i>&nbsp;        synchronized (allWindows) {</b>
<b class="nc"><i>1555</i>&nbsp;            IdentityArrayList&lt;Window&gt; unblocked = new IdentityArrayList&lt;Window&gt;();</b>
<b class="nc"><i>1556</i>&nbsp;            for (int i = 0; i &lt; allWindows.size(); i++) {</b>
<b class="nc"><i>1557</i>&nbsp;                Window w = allWindows.get(i);</b>
<b class="nc"><i>1558</i>&nbsp;                if (!w.isModalBlocked()) {</b>
<i>1559</i>&nbsp;                    unblocked.add(w);
<i>1560</i>&nbsp;                }
<b class="nc"><i>1561</i>&nbsp;            }</b>
<b class="nc"><i>1562</i>&nbsp;            return unblocked;</b>
<i>1563</i>&nbsp;        }
<b class="nc"><i>1564</i>&nbsp;    }</b>
<i>1565</i>&nbsp;
<b class="nc"><i>1566</i>&nbsp;    private static Window[] getWindows(AppContext appContext) {</b>
<b class="nc"><i>1567</i>&nbsp;        synchronized (Window.class) {</b>
<i>1568</i>&nbsp;            Window realCopy[];
<b class="nc"><i>1569</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1570</i>&nbsp;            Vector&lt;WeakReference&lt;Window&gt;&gt; windowList =</b>
<i>1571</i>&nbsp;                (Vector&lt;WeakReference&lt;Window&gt;&gt;)appContext.get(Window.class);
<i>1572</i>&nbsp;            if (windowList != null) {
<i>1573</i>&nbsp;                int fullSize = windowList.size();
<i>1574</i>&nbsp;                int realSize = 0;
<i>1575</i>&nbsp;                Window fullCopy[] = new Window[fullSize];
<i>1576</i>&nbsp;                for (int i = 0; i &lt; fullSize; i++) {
<i>1577</i>&nbsp;                    Window w = windowList.get(i).get();
<i>1578</i>&nbsp;                    if (w != null) {
<i>1579</i>&nbsp;                        fullCopy[realSize++] = w;
<i>1580</i>&nbsp;                    }
<i>1581</i>&nbsp;                }
<i>1582</i>&nbsp;                if (fullSize != realSize) {
<i>1583</i>&nbsp;                    realCopy = Arrays.copyOf(fullCopy, realSize);
<i>1584</i>&nbsp;                } else {
<i>1585</i>&nbsp;                    realCopy = fullCopy;
<i>1586</i>&nbsp;                }
<i>1587</i>&nbsp;            } else {
<i>1588</i>&nbsp;                realCopy = new Window[0];
<i>1589</i>&nbsp;            }
<i>1590</i>&nbsp;            return realCopy;
<b class="nc"><i>1591</i>&nbsp;        }</b>
<i>1592</i>&nbsp;    }
<i>1593</i>&nbsp;
<i>1594</i>&nbsp;    /**
<i>1595</i>&nbsp;     * Returns an array of all {@code Window}s, both owned and ownerless,
<i>1596</i>&nbsp;     * created by this application.
<i>1597</i>&nbsp;     * If called from an applet, the array includes only the {@code Window}s
<i>1598</i>&nbsp;     * accessible by that applet.
<i>1599</i>&nbsp;     * &lt;p&gt;
<i>1600</i>&nbsp;     * &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such
<i>1601</i>&nbsp;     * as a print dialog. Applications should not assume the existence of
<i>1602</i>&nbsp;     * these dialogs, nor should an application assume anything about these
<i>1603</i>&nbsp;     * dialogs such as component positions, {@code LayoutManager}s
<i>1604</i>&nbsp;     * or serialization.
<i>1605</i>&nbsp;     *
<i>1606</i>&nbsp;     * @return the array of all the {@code Window}s created by the application
<i>1607</i>&nbsp;     * @see Frame#getFrames
<i>1608</i>&nbsp;     * @see Window#getOwnerlessWindows
<i>1609</i>&nbsp;     *
<i>1610</i>&nbsp;     * @since 1.6
<i>1611</i>&nbsp;     */
<i>1612</i>&nbsp;    public static Window[] getWindows() {
<b class="nc"><i>1613</i>&nbsp;        return getWindows(AppContext.getAppContext());</b>
<i>1614</i>&nbsp;    }
<b class="nc"><i>1615</i>&nbsp;</b>
<b class="nc"><i>1616</i>&nbsp;    /**</b>
<b class="nc"><i>1617</i>&nbsp;     * Returns an array of all {@code Window}s created by this application</b>
<b class="nc"><i>1618</i>&nbsp;     * that have no owner. They include {@code Frame}s and ownerless</b>
<i>1619</i>&nbsp;     * {@code Dialog}s and {@code Window}s.
<i>1620</i>&nbsp;     * If called from an applet, the array includes only the {@code Window}s
<i>1621</i>&nbsp;     * accessible by that applet.
<b class="nc"><i>1622</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1623</i>&nbsp;     * &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such</b>
<b class="nc"><i>1624</i>&nbsp;     * as a print dialog. Applications should not assume the existence of</b>
<b class="nc"><i>1625</i>&nbsp;     * these dialogs, nor should an application assume anything about these</b>
<b class="nc"><i>1626</i>&nbsp;     * dialogs such as component positions, {@code LayoutManager}s</b>
<i>1627</i>&nbsp;     * or serialization.
<i>1628</i>&nbsp;     *
<i>1629</i>&nbsp;     * @return the array of all the ownerless {@code Window}s
<b class="nc"><i>1630</i>&nbsp;     *         created by this application</b>
<i>1631</i>&nbsp;     * @see Frame#getFrames
<i>1632</i>&nbsp;     * @see Window#getWindows()
<i>1633</i>&nbsp;     *
<b class="nc"><i>1634</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>1635</i>&nbsp;     */</b>
<b class="nc"><i>1636</i>&nbsp;    public static Window[] getOwnerlessWindows() {</b>
<b class="nc"><i>1637</i>&nbsp;        Window[] allWindows = Window.getWindows();</b>
<i>1638</i>&nbsp;
<b class="nc"><i>1639</i>&nbsp;        int ownerlessCount = 0;</b>
<b class="nc"><i>1640</i>&nbsp;        for (Window w : allWindows) {</b>
<i>1641</i>&nbsp;            if (w.getOwner() == null) {
<i>1642</i>&nbsp;                ownerlessCount++;
<i>1643</i>&nbsp;            }
<i>1644</i>&nbsp;        }
<i>1645</i>&nbsp;
<i>1646</i>&nbsp;        Window[] ownerless = new Window[ownerlessCount];
<i>1647</i>&nbsp;        int c = 0;
<i>1648</i>&nbsp;        for (Window w : allWindows) {
<i>1649</i>&nbsp;            if (w.getOwner() == null) {
<i>1650</i>&nbsp;                ownerless[c++] = w;
<i>1651</i>&nbsp;            }
<i>1652</i>&nbsp;        }
<i>1653</i>&nbsp;
<i>1654</i>&nbsp;        return ownerless;
<i>1655</i>&nbsp;    }
<i>1656</i>&nbsp;
<i>1657</i>&nbsp;    Window getDocumentRoot() {
<i>1658</i>&nbsp;        synchronized (getTreeLock()) {
<i>1659</i>&nbsp;            Window w = this;
<i>1660</i>&nbsp;            while (w.getOwner() != null) {
<i>1661</i>&nbsp;                w = w.getOwner();
<i>1662</i>&nbsp;            }
<i>1663</i>&nbsp;            return w;
<i>1664</i>&nbsp;        }
<i>1665</i>&nbsp;    }
<i>1666</i>&nbsp;
<b class="nc"><i>1667</i>&nbsp;    /**</b>
<b class="nc"><i>1668</i>&nbsp;     * Specifies the modal exclusion type for this window. If a window is modal</b>
<i>1669</i>&nbsp;     * excluded, it is not blocked by some modal dialogs. See {@link
<b class="nc"><i>1670</i>&nbsp;     * java.awt.Dialog.ModalExclusionType Dialog.ModalExclusionType} for</b>
<b class="nc"><i>1671</i>&nbsp;     * possible modal exclusion types.</b>
<i>1672</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1673</i>&nbsp;     * If the given type is not supported, {@code NO_EXCLUDE} is used.</b>
<i>1674</i>&nbsp;     * &lt;p&gt;
<i>1675</i>&nbsp;     * Note: changing the modal exclusion type for a visible window may have no
<b class="nc"><i>1676</i>&nbsp;     * effect until it is hidden and then shown again.</b>
<b class="nc"><i>1677</i>&nbsp;     *</b>
<b class="nc"><i>1678</i>&nbsp;     * @param exclusionType the modal exclusion type for this window; a {@code null}</b>
<b class="nc"><i>1679</i>&nbsp;     *     value is equivalent to {@link Dialog.ModalExclusionType#NO_EXCLUDE</b>
<i>1680</i>&nbsp;     *     NO_EXCLUDE}
<i>1681</i>&nbsp;     * @throws SecurityException if the calling thread does not have permission
<b class="nc"><i>1682</i>&nbsp;     *     to set the modal exclusion property to the window with the given</b>
<i>1683</i>&nbsp;     *     {@code exclusionType}
<i>1684</i>&nbsp;     * @see java.awt.Dialog.ModalExclusionType
<i>1685</i>&nbsp;     * @see java.awt.Window#getModalExclusionType
<i>1686</i>&nbsp;     * @see java.awt.Toolkit#isModalExclusionTypeSupported
<i>1687</i>&nbsp;     *
<i>1688</i>&nbsp;     * @since 1.6
<i>1689</i>&nbsp;     */
<i>1690</i>&nbsp;    public void setModalExclusionType(Dialog.ModalExclusionType exclusionType) {
<i>1691</i>&nbsp;        if (exclusionType == null) {
<i>1692</i>&nbsp;            exclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;
<i>1693</i>&nbsp;        }
<i>1694</i>&nbsp;        if (!Toolkit.getDefaultToolkit().isModalExclusionTypeSupported(exclusionType)) {
<i>1695</i>&nbsp;            exclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;
<i>1696</i>&nbsp;        }
<i>1697</i>&nbsp;        if (modalExclusionType == exclusionType) {
<i>1698</i>&nbsp;            return;
<i>1699</i>&nbsp;        }
<i>1700</i>&nbsp;        if (exclusionType == Dialog.ModalExclusionType.TOOLKIT_EXCLUDE) {
<i>1701</i>&nbsp;            SecurityManager sm = System.getSecurityManager();
<i>1702</i>&nbsp;            if (sm != null) {
<i>1703</i>&nbsp;                sm.checkPermission(AWTPermissions.TOOLKIT_MODALITY_PERMISSION);
<i>1704</i>&nbsp;            }
<i>1705</i>&nbsp;        }
<i>1706</i>&nbsp;        modalExclusionType = exclusionType;
<b class="nc"><i>1707</i>&nbsp;</b>
<i>1708</i>&nbsp;        // if we want on-fly changes, we need to uncomment the lines below
<i>1709</i>&nbsp;        //   and override the method in Dialog to use modalShow() instead
<i>1710</i>&nbsp;        //   of updateChildrenBlocking()
<b class="nc"><i>1711</i>&nbsp; /*</b>
<b class="nc"><i>1712</i>&nbsp;        if (isModalBlocked()) {</b>
<i>1713</i>&nbsp;            modalBlocker.unblockWindow(this);
<b class="nc"><i>1714</i>&nbsp;        }</b>
<i>1715</i>&nbsp;        Dialog.checkShouldBeBlocked(this);
<b class="nc"><i>1716</i>&nbsp;        updateChildrenBlocking();</b>
<b class="nc"><i>1717</i>&nbsp; */</b>
<i>1718</i>&nbsp;    }
<i>1719</i>&nbsp;
<i>1720</i>&nbsp;    /**
<b class="nc"><i>1721</i>&nbsp;     * Returns the modal exclusion type of this window.</b>
<b class="nc"><i>1722</i>&nbsp;     *</b>
<b class="nc"><i>1723</i>&nbsp;     * @return the modal exclusion type of this window</b>
<b class="nc"><i>1724</i>&nbsp;     *</b>
<i>1725</i>&nbsp;     * @see java.awt.Dialog.ModalExclusionType
<b class="nc"><i>1726</i>&nbsp;     * @see java.awt.Window#setModalExclusionType</b>
<b class="nc"><i>1727</i>&nbsp;     *</b>
<b class="nc"><i>1728</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>1729</i>&nbsp;     */</b>
<b class="nc"><i>1730</i>&nbsp;    public Dialog.ModalExclusionType getModalExclusionType() {</b>
<b class="nc"><i>1731</i>&nbsp;        return modalExclusionType;</b>
<b class="nc"><i>1732</i>&nbsp;    }</b>
<i>1733</i>&nbsp;
<b class="nc"><i>1734</i>&nbsp;    boolean isModalExcluded(Dialog.ModalExclusionType exclusionType) {</b>
<b class="nc"><i>1735</i>&nbsp;        if ((modalExclusionType != null) &amp;&amp;</b>
<b class="nc"><i>1736</i>&nbsp;            modalExclusionType.compareTo(exclusionType) &gt;= 0)</b>
<b class="nc"><i>1737</i>&nbsp;        {</b>
<i>1738</i>&nbsp;            return true;
<i>1739</i>&nbsp;        }
<b class="nc"><i>1740</i>&nbsp;        Window owner = getOwner_NoClientCode();</b>
<b class="nc"><i>1741</i>&nbsp;        return (owner != null) &amp;&amp; owner.isModalExcluded(exclusionType);</b>
<i>1742</i>&nbsp;    }
<i>1743</i>&nbsp;
<i>1744</i>&nbsp;    void updateChildrenBlocking() {
<i>1745</i>&nbsp;        Vector&lt;Window&gt; childHierarchy = new Vector&lt;Window&gt;();
<i>1746</i>&nbsp;        Window[] ownedWindows = getOwnedWindows();
<i>1747</i>&nbsp;        for (int i = 0; i &lt; ownedWindows.length; i++) {
<i>1748</i>&nbsp;            childHierarchy.add(ownedWindows[i]);
<i>1749</i>&nbsp;        }
<i>1750</i>&nbsp;        int k = 0;
<i>1751</i>&nbsp;        while (k &lt; childHierarchy.size()) {
<i>1752</i>&nbsp;            Window w = childHierarchy.get(k);
<i>1753</i>&nbsp;            if (w.isVisible()) {
<i>1754</i>&nbsp;                if (w.isModalBlocked()) {
<i>1755</i>&nbsp;                    Dialog blocker = w.getModalBlocker();
<b class="nc"><i>1756</i>&nbsp;                    blocker.unblockWindow(w);</b>
<i>1757</i>&nbsp;                }
<i>1758</i>&nbsp;                Dialog.checkShouldBeBlocked(w);
<b class="nc"><i>1759</i>&nbsp;                Window[] wOwned = w.getOwnedWindows();</b>
<b class="nc"><i>1760</i>&nbsp;                for (int j = 0; j &lt; wOwned.length; j++) {</b>
<i>1761</i>&nbsp;                    childHierarchy.add(wOwned[j]);
<i>1762</i>&nbsp;                }
<i>1763</i>&nbsp;            }
<i>1764</i>&nbsp;            k++;
<i>1765</i>&nbsp;        }
<i>1766</i>&nbsp;    }
<i>1767</i>&nbsp;
<i>1768</i>&nbsp;    /**
<i>1769</i>&nbsp;     * Adds the specified window listener to receive window events from
<i>1770</i>&nbsp;     * this window.
<i>1771</i>&nbsp;     * If l is null, no exception is thrown and no action is performed.
<i>1772</i>&nbsp;     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
<i>1773</i>&nbsp;     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
<i>1774</i>&nbsp;     *
<i>1775</i>&nbsp;     * @param   l the window listener
<b class="nc"><i>1776</i>&nbsp;     * @see #removeWindowListener</b>
<i>1777</i>&nbsp;     * @see #getWindowListeners
<i>1778</i>&nbsp;     */
<b class="nc"><i>1779</i>&nbsp;    public synchronized void addWindowListener(WindowListener l) {</b>
<b class="nc"><i>1780</i>&nbsp;        if (l == null) {</b>
<i>1781</i>&nbsp;            return;
<i>1782</i>&nbsp;        }
<i>1783</i>&nbsp;        newEventsOnly = true;
<i>1784</i>&nbsp;        windowListener = AWTEventMulticaster.add(windowListener, l);
<i>1785</i>&nbsp;    }
<i>1786</i>&nbsp;
<i>1787</i>&nbsp;    /**
<i>1788</i>&nbsp;     * Adds the specified window state listener to receive window
<i>1789</i>&nbsp;     * events from this window.  If {@code l} is {@code null},
<i>1790</i>&nbsp;     * no exception is thrown and no action is performed.
<i>1791</i>&nbsp;     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
<i>1792</i>&nbsp;     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
<i>1793</i>&nbsp;     *
<i>1794</i>&nbsp;     * @param   l the window state listener
<i>1795</i>&nbsp;     * @see #removeWindowStateListener
<b class="nc"><i>1796</i>&nbsp;     * @see #getWindowStateListeners</b>
<i>1797</i>&nbsp;     * @since 1.4
<i>1798</i>&nbsp;     */
<b class="nc"><i>1799</i>&nbsp;    public synchronized void addWindowStateListener(WindowStateListener l) {</b>
<b class="nc"><i>1800</i>&nbsp;        if (l == null) {</b>
<i>1801</i>&nbsp;            return;
<i>1802</i>&nbsp;        }
<i>1803</i>&nbsp;        windowStateListener = AWTEventMulticaster.add(windowStateListener, l);
<i>1804</i>&nbsp;        newEventsOnly = true;
<i>1805</i>&nbsp;    }
<i>1806</i>&nbsp;
<i>1807</i>&nbsp;    /**
<i>1808</i>&nbsp;     * Adds the specified window focus listener to receive window events
<i>1809</i>&nbsp;     * from this window.
<i>1810</i>&nbsp;     * If l is null, no exception is thrown and no action is performed.
<i>1811</i>&nbsp;     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
<i>1812</i>&nbsp;     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
<i>1813</i>&nbsp;     *
<i>1814</i>&nbsp;     * @param   l the window focus listener
<b class="nc"><i>1815</i>&nbsp;     * @see #removeWindowFocusListener</b>
<i>1816</i>&nbsp;     * @see #getWindowFocusListeners
<i>1817</i>&nbsp;     * @since 1.4
<b class="nc"><i>1818</i>&nbsp;     */</b>
<i>1819</i>&nbsp;    public synchronized void addWindowFocusListener(WindowFocusListener l) {
<i>1820</i>&nbsp;        if (l == null) {
<i>1821</i>&nbsp;            return;
<i>1822</i>&nbsp;        }
<i>1823</i>&nbsp;        windowFocusListener = AWTEventMulticaster.add(windowFocusListener, l);
<i>1824</i>&nbsp;        newEventsOnly = true;
<i>1825</i>&nbsp;    }
<i>1826</i>&nbsp;
<i>1827</i>&nbsp;    /**
<i>1828</i>&nbsp;     * Removes the specified window listener so that it no longer
<i>1829</i>&nbsp;     * receives window events from this window.
<i>1830</i>&nbsp;     * If l is null, no exception is thrown and no action is performed.
<i>1831</i>&nbsp;     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
<i>1832</i>&nbsp;     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
<i>1833</i>&nbsp;     *
<i>1834</i>&nbsp;     * @param   l the window listener
<b class="nc"><i>1835</i>&nbsp;     * @see #addWindowListener</b>
<i>1836</i>&nbsp;     * @see #getWindowListeners
<i>1837</i>&nbsp;     */
<b class="nc"><i>1838</i>&nbsp;    public synchronized void removeWindowListener(WindowListener l) {</b>
<i>1839</i>&nbsp;        if (l == null) {
<i>1840</i>&nbsp;            return;
<i>1841</i>&nbsp;        }
<i>1842</i>&nbsp;        windowListener = AWTEventMulticaster.remove(windowListener, l);
<i>1843</i>&nbsp;    }
<i>1844</i>&nbsp;
<i>1845</i>&nbsp;    /**
<i>1846</i>&nbsp;     * Removes the specified window state listener so that it no
<i>1847</i>&nbsp;     * longer receives window events from this window.  If
<i>1848</i>&nbsp;     * {@code l} is {@code null}, no exception is thrown and
<i>1849</i>&nbsp;     * no action is performed.
<i>1850</i>&nbsp;     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
<i>1851</i>&nbsp;     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
<i>1852</i>&nbsp;     *
<i>1853</i>&nbsp;     * @param   l the window state listener
<b class="nc"><i>1854</i>&nbsp;     * @see #addWindowStateListener</b>
<i>1855</i>&nbsp;     * @see #getWindowStateListeners
<i>1856</i>&nbsp;     * @since 1.4
<b class="nc"><i>1857</i>&nbsp;     */</b>
<i>1858</i>&nbsp;    public synchronized void removeWindowStateListener(WindowStateListener l) {
<i>1859</i>&nbsp;        if (l == null) {
<i>1860</i>&nbsp;            return;
<i>1861</i>&nbsp;        }
<i>1862</i>&nbsp;        windowStateListener = AWTEventMulticaster.remove(windowStateListener, l);
<i>1863</i>&nbsp;    }
<i>1864</i>&nbsp;
<i>1865</i>&nbsp;    /**
<i>1866</i>&nbsp;     * Removes the specified window focus listener so that it no longer
<i>1867</i>&nbsp;     * receives window events from this window.
<i>1868</i>&nbsp;     * If l is null, no exception is thrown and no action is performed.
<i>1869</i>&nbsp;     * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
<i>1870</i>&nbsp;     * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
<i>1871</i>&nbsp;     *
<i>1872</i>&nbsp;     * @param   l the window focus listener
<b class="nc"><i>1873</i>&nbsp;     * @see #addWindowFocusListener</b>
<i>1874</i>&nbsp;     * @see #getWindowFocusListeners
<i>1875</i>&nbsp;     * @since 1.4
<i>1876</i>&nbsp;     */
<i>1877</i>&nbsp;    public synchronized void removeWindowFocusListener(WindowFocusListener l) {
<i>1878</i>&nbsp;        if (l == null) {
<i>1879</i>&nbsp;            return;
<i>1880</i>&nbsp;        }
<i>1881</i>&nbsp;        windowFocusListener = AWTEventMulticaster.remove(windowFocusListener, l);
<i>1882</i>&nbsp;    }
<i>1883</i>&nbsp;
<i>1884</i>&nbsp;    /**
<i>1885</i>&nbsp;     * Returns an array of all the window listeners
<i>1886</i>&nbsp;     * registered on this window.
<i>1887</i>&nbsp;     *
<i>1888</i>&nbsp;     * @return all of this window&#39;s {@code WindowListener}s
<b class="nc"><i>1889</i>&nbsp;     *         or an empty array if no window</b>
<i>1890</i>&nbsp;     *         listeners are currently registered
<i>1891</i>&nbsp;     *
<i>1892</i>&nbsp;     * @see #addWindowListener
<i>1893</i>&nbsp;     * @see #removeWindowListener
<i>1894</i>&nbsp;     * @since 1.4
<i>1895</i>&nbsp;     */
<i>1896</i>&nbsp;    public synchronized WindowListener[] getWindowListeners() {
<i>1897</i>&nbsp;        return getListeners(WindowListener.class);
<i>1898</i>&nbsp;    }
<i>1899</i>&nbsp;
<i>1900</i>&nbsp;    /**
<i>1901</i>&nbsp;     * Returns an array of all the window focus listeners
<i>1902</i>&nbsp;     * registered on this window.
<i>1903</i>&nbsp;     *
<i>1904</i>&nbsp;     * @return all of this window&#39;s {@code WindowFocusListener}s
<b class="nc"><i>1905</i>&nbsp;     *         or an empty array if no window focus</b>
<i>1906</i>&nbsp;     *         listeners are currently registered
<i>1907</i>&nbsp;     *
<i>1908</i>&nbsp;     * @see #addWindowFocusListener
<i>1909</i>&nbsp;     * @see #removeWindowFocusListener
<i>1910</i>&nbsp;     * @since 1.4
<i>1911</i>&nbsp;     */
<i>1912</i>&nbsp;    public synchronized WindowFocusListener[] getWindowFocusListeners() {
<i>1913</i>&nbsp;        return getListeners(WindowFocusListener.class);
<i>1914</i>&nbsp;    }
<i>1915</i>&nbsp;
<i>1916</i>&nbsp;    /**
<i>1917</i>&nbsp;     * Returns an array of all the window state listeners
<i>1918</i>&nbsp;     * registered on this window.
<i>1919</i>&nbsp;     *
<i>1920</i>&nbsp;     * @return all of this window&#39;s {@code WindowStateListener}s
<i>1921</i>&nbsp;     *         or an empty array if no window state
<i>1922</i>&nbsp;     *         listeners are currently registered
<i>1923</i>&nbsp;     *
<i>1924</i>&nbsp;     * @see #addWindowStateListener
<i>1925</i>&nbsp;     * @see #removeWindowStateListener
<i>1926</i>&nbsp;     * @since 1.4
<i>1927</i>&nbsp;     */
<i>1928</i>&nbsp;    public synchronized WindowStateListener[] getWindowStateListeners() {
<i>1929</i>&nbsp;        return getListeners(WindowStateListener.class);
<i>1930</i>&nbsp;    }
<i>1931</i>&nbsp;
<i>1932</i>&nbsp;
<i>1933</i>&nbsp;    /**
<i>1934</i>&nbsp;     * Returns an array of all the objects currently registered
<i>1935</i>&nbsp;     * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
<i>1936</i>&nbsp;     * upon this {@code Window}.
<i>1937</i>&nbsp;     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
<i>1938</i>&nbsp;     * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
<i>1939</i>&nbsp;     *
<i>1940</i>&nbsp;     * &lt;p&gt;
<i>1941</i>&nbsp;     *
<i>1942</i>&nbsp;     * You can specify the {@code listenerType} argument
<i>1943</i>&nbsp;     * with a class literal, such as
<i>1944</i>&nbsp;     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
<b class="nc"><i>1945</i>&nbsp;     * For example, you can query a</b>
<b class="nc"><i>1946</i>&nbsp;     * {@code Window w}</b>
<b class="nc"><i>1947</i>&nbsp;     * for its window listeners with the following code:</b>
<b class="nc"><i>1948</i>&nbsp;     *</b>
<b class="nc"><i>1949</i>&nbsp;     * &lt;pre&gt;WindowListener[] wls = (WindowListener[])(w.getListeners(WindowListener.class));&lt;/pre&gt;</b>
<b class="nc"><i>1950</i>&nbsp;     *</b>
<b class="nc"><i>1951</i>&nbsp;     * If no such listeners exist, this method returns an empty array.</b>
<i>1952</i>&nbsp;     *
<b class="nc"><i>1953</i>&nbsp;     * @param listenerType the type of listeners requested; this parameter</b>
<i>1954</i>&nbsp;     *          should specify an interface that descends from
<b class="nc"><i>1955</i>&nbsp;     *          {@code java.util.EventListener}</b>
<i>1956</i>&nbsp;     * @return an array of all objects registered as
<i>1957</i>&nbsp;     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this window,
<i>1958</i>&nbsp;     *          or an empty array if no such
<i>1959</i>&nbsp;     *          listeners have been added
<b class="nc"><i>1960</i>&nbsp;     * @exception ClassCastException if {@code listenerType}</b>
<i>1961</i>&nbsp;     *          doesn&#39;t specify a class or interface that implements
<i>1962</i>&nbsp;     *          {@code java.util.EventListener}
<i>1963</i>&nbsp;     * @exception NullPointerException if {@code listenerType} is {@code null}
<i>1964</i>&nbsp;     *
<i>1965</i>&nbsp;     * @see #getWindowListeners
<i>1966</i>&nbsp;     * @since 1.3
<i>1967</i>&nbsp;     */
<b class="nc"><i>1968</i>&nbsp;    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {</b>
<i>1969</i>&nbsp;        EventListener l = null;
<b class="nc"><i>1970</i>&nbsp;        if (listenerType == WindowFocusListener.class) {</b>
<i>1971</i>&nbsp;            l = windowFocusListener;
<b class="nc"><i>1972</i>&nbsp;        } else if (listenerType == WindowStateListener.class) {</b>
<i>1973</i>&nbsp;            l = windowStateListener;
<i>1974</i>&nbsp;        } else if (listenerType == WindowListener.class) {
<b class="nc"><i>1975</i>&nbsp;            l = windowListener;</b>
<i>1976</i>&nbsp;        } else {
<b class="nc"><i>1977</i>&nbsp;            return super.getListeners(listenerType);</b>
<i>1978</i>&nbsp;        }
<b class="nc"><i>1979</i>&nbsp;        return AWTEventMulticaster.getListeners(l, listenerType);</b>
<i>1980</i>&nbsp;    }
<b class="nc"><i>1981</i>&nbsp;</b>
<i>1982</i>&nbsp;    // REMIND: remove when filtering is handled at lower level
<b class="nc"><i>1983</i>&nbsp;    boolean eventEnabled(AWTEvent e) {</b>
<i>1984</i>&nbsp;        switch(e.id) {
<b class="nc"><i>1985</i>&nbsp;          case WindowEvent.WINDOW_OPENED:</b>
<i>1986</i>&nbsp;          case WindowEvent.WINDOW_CLOSING:
<i>1987</i>&nbsp;          case WindowEvent.WINDOW_CLOSED:
<i>1988</i>&nbsp;          case WindowEvent.WINDOW_ICONIFIED:
<b class="nc"><i>1989</i>&nbsp;          case WindowEvent.WINDOW_DEICONIFIED:</b>
<i>1990</i>&nbsp;          case WindowEvent.WINDOW_ACTIVATED:
<i>1991</i>&nbsp;          case WindowEvent.WINDOW_DEACTIVATED:
<i>1992</i>&nbsp;            if ((eventMask &amp; AWTEvent.WINDOW_EVENT_MASK) != 0 ||
<i>1993</i>&nbsp;                windowListener != null) {
<i>1994</i>&nbsp;                return true;
<i>1995</i>&nbsp;            }
<i>1996</i>&nbsp;            return false;
<i>1997</i>&nbsp;          case WindowEvent.WINDOW_GAINED_FOCUS:
<i>1998</i>&nbsp;          case WindowEvent.WINDOW_LOST_FOCUS:
<i>1999</i>&nbsp;            if ((eventMask &amp; AWTEvent.WINDOW_FOCUS_EVENT_MASK) != 0 ||
<i>2000</i>&nbsp;                windowFocusListener != null) {
<i>2001</i>&nbsp;                return true;
<i>2002</i>&nbsp;            }
<i>2003</i>&nbsp;            return false;
<b class="nc"><i>2004</i>&nbsp;          case WindowEvent.WINDOW_STATE_CHANGED:</b>
<b class="nc"><i>2005</i>&nbsp;            if ((eventMask &amp; AWTEvent.WINDOW_STATE_EVENT_MASK) != 0 ||</b>
<i>2006</i>&nbsp;                windowStateListener != null) {
<i>2007</i>&nbsp;                return true;
<i>2008</i>&nbsp;            }
<i>2009</i>&nbsp;            return false;
<i>2010</i>&nbsp;          default:
<i>2011</i>&nbsp;            break;
<i>2012</i>&nbsp;        }
<b class="nc"><i>2013</i>&nbsp;        return super.eventEnabled(e);</b>
<b class="nc"><i>2014</i>&nbsp;    }</b>
<i>2015</i>&nbsp;
<i>2016</i>&nbsp;    /**
<b class="nc"><i>2017</i>&nbsp;     * Processes events on this window. If the event is an</b>
<b class="nc"><i>2018</i>&nbsp;     * {@code WindowEvent}, it invokes the</b>
<i>2019</i>&nbsp;     * {@code processWindowEvent} method, else it invokes its
<b class="nc"><i>2020</i>&nbsp;     * superclass&#39;s {@code processEvent}.</b>
<i>2021</i>&nbsp;     * &lt;p&gt;Note that if the event parameter is {@code null}
<i>2022</i>&nbsp;     * the behavior is unspecified and may result in an
<i>2023</i>&nbsp;     * exception.
<i>2024</i>&nbsp;     *
<b class="nc"><i>2025</i>&nbsp;     * @param e the event</b>
<i>2026</i>&nbsp;     */
<i>2027</i>&nbsp;    protected void processEvent(AWTEvent e) {
<i>2028</i>&nbsp;        if (e instanceof WindowEvent) {
<i>2029</i>&nbsp;            switch (e.getID()) {
<i>2030</i>&nbsp;                case WindowEvent.WINDOW_OPENED:
<i>2031</i>&nbsp;                case WindowEvent.WINDOW_CLOSING:
<i>2032</i>&nbsp;                case WindowEvent.WINDOW_CLOSED:
<i>2033</i>&nbsp;                case WindowEvent.WINDOW_ICONIFIED:
<i>2034</i>&nbsp;                case WindowEvent.WINDOW_DEICONIFIED:
<i>2035</i>&nbsp;                case WindowEvent.WINDOW_ACTIVATED:
<i>2036</i>&nbsp;                case WindowEvent.WINDOW_DEACTIVATED:
<i>2037</i>&nbsp;                    processWindowEvent((WindowEvent)e);
<i>2038</i>&nbsp;                    break;
<i>2039</i>&nbsp;                case WindowEvent.WINDOW_GAINED_FOCUS:
<i>2040</i>&nbsp;                case WindowEvent.WINDOW_LOST_FOCUS:
<i>2041</i>&nbsp;                    processWindowFocusEvent((WindowEvent)e);
<i>2042</i>&nbsp;                    break;
<i>2043</i>&nbsp;                case WindowEvent.WINDOW_STATE_CHANGED:
<i>2044</i>&nbsp;                    processWindowStateEvent((WindowEvent)e);
<i>2045</i>&nbsp;                    break;
<i>2046</i>&nbsp;            }
<b class="nc"><i>2047</i>&nbsp;            return;</b>
<b class="nc"><i>2048</i>&nbsp;        }</b>
<b class="nc"><i>2049</i>&nbsp;        super.processEvent(e);</b>
<i>2050</i>&nbsp;    }
<b class="nc"><i>2051</i>&nbsp;</b>
<b class="nc"><i>2052</i>&nbsp;    /**</b>
<i>2053</i>&nbsp;     * Processes window events occurring on this window by
<b class="nc"><i>2054</i>&nbsp;     * dispatching them to any registered WindowListener objects.</b>
<b class="nc"><i>2055</i>&nbsp;     * NOTE: This method will not be called unless window events</b>
<i>2056</i>&nbsp;     * are enabled for this component; this happens when one of the
<b class="nc"><i>2057</i>&nbsp;     * following occurs:</b>
<b class="nc"><i>2058</i>&nbsp;     * &lt;ul&gt;</b>
<i>2059</i>&nbsp;     * &lt;li&gt;A WindowListener object is registered via
<b class="nc"><i>2060</i>&nbsp;     *     {@code addWindowListener}</b>
<b class="nc"><i>2061</i>&nbsp;     * &lt;li&gt;Window events are enabled via {@code enableEvents}</b>
<i>2062</i>&nbsp;     * &lt;/ul&gt;
<b class="nc"><i>2063</i>&nbsp;     * &lt;p&gt;Note that if the event parameter is {@code null}</b>
<b class="nc"><i>2064</i>&nbsp;     * the behavior is unspecified and may result in an</b>
<i>2065</i>&nbsp;     * exception.
<b class="nc"><i>2066</i>&nbsp;     *</b>
<b class="nc"><i>2067</i>&nbsp;     * @param e the window event</b>
<i>2068</i>&nbsp;     * @see Component#enableEvents
<b class="nc"><i>2069</i>&nbsp;     */</b>
<b class="nc"><i>2070</i>&nbsp;    protected void processWindowEvent(WindowEvent e) {</b>
<i>2071</i>&nbsp;        WindowListener listener = windowListener;
<i>2072</i>&nbsp;        if (listener != null) {
<i>2073</i>&nbsp;            switch(e.getID()) {
<i>2074</i>&nbsp;                case WindowEvent.WINDOW_OPENED:
<i>2075</i>&nbsp;                    listener.windowOpened(e);
<i>2076</i>&nbsp;                    break;
<i>2077</i>&nbsp;                case WindowEvent.WINDOW_CLOSING:
<i>2078</i>&nbsp;                    listener.windowClosing(e);
<i>2079</i>&nbsp;                    break;
<i>2080</i>&nbsp;                case WindowEvent.WINDOW_CLOSED:
<i>2081</i>&nbsp;                    listener.windowClosed(e);
<i>2082</i>&nbsp;                    break;
<i>2083</i>&nbsp;                case WindowEvent.WINDOW_ICONIFIED:
<i>2084</i>&nbsp;                    listener.windowIconified(e);
<i>2085</i>&nbsp;                    break;
<i>2086</i>&nbsp;                case WindowEvent.WINDOW_DEICONIFIED:
<i>2087</i>&nbsp;                    listener.windowDeiconified(e);
<i>2088</i>&nbsp;                    break;
<i>2089</i>&nbsp;                case WindowEvent.WINDOW_ACTIVATED:
<i>2090</i>&nbsp;                    listener.windowActivated(e);
<i>2091</i>&nbsp;                    break;
<i>2092</i>&nbsp;                case WindowEvent.WINDOW_DEACTIVATED:
<i>2093</i>&nbsp;                    listener.windowDeactivated(e);
<i>2094</i>&nbsp;                    break;
<i>2095</i>&nbsp;                default:
<i>2096</i>&nbsp;                    break;
<b class="nc"><i>2097</i>&nbsp;            }</b>
<b class="nc"><i>2098</i>&nbsp;        }</b>
<b class="nc"><i>2099</i>&nbsp;    }</b>
<i>2100</i>&nbsp;
<b class="nc"><i>2101</i>&nbsp;    /**</b>
<b class="nc"><i>2102</i>&nbsp;     * Processes window focus event occurring on this window by</b>
<i>2103</i>&nbsp;     * dispatching them to any registered WindowFocusListener objects.
<b class="nc"><i>2104</i>&nbsp;     * NOTE: this method will not be called unless window focus events</b>
<b class="nc"><i>2105</i>&nbsp;     * are enabled for this window. This happens when one of the</b>
<i>2106</i>&nbsp;     * following occurs:
<i>2107</i>&nbsp;     * &lt;ul&gt;
<i>2108</i>&nbsp;     * &lt;li&gt;a WindowFocusListener is registered via
<i>2109</i>&nbsp;     *     {@code addWindowFocusListener}
<i>2110</i>&nbsp;     * &lt;li&gt;Window focus events are enabled via {@code enableEvents}
<i>2111</i>&nbsp;     * &lt;/ul&gt;
<i>2112</i>&nbsp;     * &lt;p&gt;Note that if the event parameter is {@code null}
<i>2113</i>&nbsp;     * the behavior is unspecified and may result in an
<i>2114</i>&nbsp;     * exception.
<i>2115</i>&nbsp;     *
<i>2116</i>&nbsp;     * @param e the window focus event
<i>2117</i>&nbsp;     * @see Component#enableEvents
<i>2118</i>&nbsp;     * @since 1.4
<i>2119</i>&nbsp;     */
<i>2120</i>&nbsp;    protected void processWindowFocusEvent(WindowEvent e) {
<i>2121</i>&nbsp;        WindowFocusListener listener = windowFocusListener;
<i>2122</i>&nbsp;        if (listener != null) {
<i>2123</i>&nbsp;            switch (e.getID()) {
<i>2124</i>&nbsp;                case WindowEvent.WINDOW_GAINED_FOCUS:
<i>2125</i>&nbsp;                    listener.windowGainedFocus(e);
<i>2126</i>&nbsp;                    break;
<i>2127</i>&nbsp;                case WindowEvent.WINDOW_LOST_FOCUS:
<i>2128</i>&nbsp;                    listener.windowLostFocus(e);
<i>2129</i>&nbsp;                    break;
<i>2130</i>&nbsp;                default:
<i>2131</i>&nbsp;                    break;
<i>2132</i>&nbsp;            }
<b class="nc"><i>2133</i>&nbsp;        }</b>
<b class="nc"><i>2134</i>&nbsp;    }</b>
<b class="nc"><i>2135</i>&nbsp;</b>
<i>2136</i>&nbsp;    /**
<b class="nc"><i>2137</i>&nbsp;     * Processes window state event occurring on this window by</b>
<b class="nc"><i>2138</i>&nbsp;     * dispatching them to any registered {@code WindowStateListener}</b>
<i>2139</i>&nbsp;     * objects.
<i>2140</i>&nbsp;     * NOTE: this method will not be called unless window state events
<i>2141</i>&nbsp;     * are enabled for this window.  This happens when one of the
<i>2142</i>&nbsp;     * following occurs:
<i>2143</i>&nbsp;     * &lt;ul&gt;
<i>2144</i>&nbsp;     * &lt;li&gt;a {@code WindowStateListener} is registered via
<i>2145</i>&nbsp;     *    {@code addWindowStateListener}
<i>2146</i>&nbsp;     * &lt;li&gt;window state events are enabled via {@code enableEvents}
<i>2147</i>&nbsp;     * &lt;/ul&gt;
<i>2148</i>&nbsp;     * &lt;p&gt;Note that if the event parameter is {@code null}
<i>2149</i>&nbsp;     * the behavior is unspecified and may result in an
<i>2150</i>&nbsp;     * exception.
<i>2151</i>&nbsp;     *
<i>2152</i>&nbsp;     * @param e the window state event
<b class="nc"><i>2153</i>&nbsp;     * @see java.awt.Component#enableEvents</b>
<b class="nc"><i>2154</i>&nbsp;     * @since 1.4</b>
<b class="nc"><i>2155</i>&nbsp;     */</b>
<b class="nc"><i>2156</i>&nbsp;    protected void processWindowStateEvent(WindowEvent e) {</b>
<i>2157</i>&nbsp;        WindowStateListener listener = windowStateListener;
<i>2158</i>&nbsp;        if (listener != null) {
<i>2159</i>&nbsp;            switch (e.getID()) {
<i>2160</i>&nbsp;                case WindowEvent.WINDOW_STATE_CHANGED:
<i>2161</i>&nbsp;                    listener.windowStateChanged(e);
<i>2162</i>&nbsp;                    break;
<i>2163</i>&nbsp;                default:
<i>2164</i>&nbsp;                    break;
<i>2165</i>&nbsp;            }
<i>2166</i>&nbsp;        }
<i>2167</i>&nbsp;    }
<i>2168</i>&nbsp;
<i>2169</i>&nbsp;    /**
<i>2170</i>&nbsp;     * Implements a debugging hook -- checks to see if
<i>2171</i>&nbsp;     * the user has typed &lt;i&gt;control-shift-F1&lt;/i&gt;.  If so,
<i>2172</i>&nbsp;     * the list of child windows is dumped to {@code System.out}.
<i>2173</i>&nbsp;     * @param e  the keyboard event
<i>2174</i>&nbsp;     */
<i>2175</i>&nbsp;    void preProcessKeyEvent(KeyEvent e) {
<i>2176</i>&nbsp;        // Dump the list of child windows to System.out if debug is enabled.
<i>2177</i>&nbsp;        if (DebugSettings.getInstance().getBoolean(&quot;on&quot;, false)) {
<i>2178</i>&nbsp;            if (e.isActionKey() &amp;&amp; e.getKeyCode() == KeyEvent.VK_F1 &amp;&amp;
<i>2179</i>&nbsp;                    e.isControlDown() &amp;&amp; e.isShiftDown() &amp;&amp;
<i>2180</i>&nbsp;                    e.getID() == KeyEvent.KEY_PRESSED) {
<i>2181</i>&nbsp;                list(System.out, 0);
<i>2182</i>&nbsp;            }
<i>2183</i>&nbsp;        }
<i>2184</i>&nbsp;    }
<i>2185</i>&nbsp;
<i>2186</i>&nbsp;    void postProcessKeyEvent(KeyEvent e) {
<i>2187</i>&nbsp;        // Do nothing
<i>2188</i>&nbsp;    }
<i>2189</i>&nbsp;
<i>2190</i>&nbsp;
<i>2191</i>&nbsp;    /**
<i>2192</i>&nbsp;     * Sets whether this window should always be above other windows.  If
<i>2193</i>&nbsp;     * there are multiple always-on-top windows, their relative order is
<i>2194</i>&nbsp;     * unspecified and platform dependent.
<i>2195</i>&nbsp;     * &lt;p&gt;
<i>2196</i>&nbsp;     * If some other window is already always-on-top then the
<i>2197</i>&nbsp;     * relative order between these windows is unspecified (depends on
<i>2198</i>&nbsp;     * platform).  No window can be brought to be over the always-on-top
<i>2199</i>&nbsp;     * window except maybe another always-on-top window.
<i>2200</i>&nbsp;     * &lt;p&gt;
<i>2201</i>&nbsp;     * All windows owned by an always-on-top window inherit this state and
<i>2202</i>&nbsp;     * automatically become always-on-top.  If a window ceases to be
<i>2203</i>&nbsp;     * always-on-top, the windows that it owns will no longer be
<i>2204</i>&nbsp;     * always-on-top.  When an always-on-top window is sent {@link #toBack
<i>2205</i>&nbsp;     * toBack}, its always-on-top state is set to {@code false}.
<i>2206</i>&nbsp;     *
<i>2207</i>&nbsp;     * &lt;p&gt; When this method is called on a window with a value of
<i>2208</i>&nbsp;     * {@code true}, and the window is visible and the platform
<i>2209</i>&nbsp;     * supports always-on-top for this window, the window is immediately
<i>2210</i>&nbsp;     * brought forward, &quot;sticking&quot; it in the top-most position. If the
<i>2211</i>&nbsp;     * window isn`t currently visible, this method sets the always-on-top
<i>2212</i>&nbsp;     * state to {@code true} but does not bring the window forward.
<i>2213</i>&nbsp;     * When the window is later shown, it will be always-on-top.
<i>2214</i>&nbsp;     *
<i>2215</i>&nbsp;     * &lt;p&gt; When this method is called on a window with a value of
<i>2216</i>&nbsp;     * {@code false} the always-on-top state is set to normal. It may also
<i>2217</i>&nbsp;     * cause an unspecified, platform-dependent change in the z-order of
<i>2218</i>&nbsp;     * top-level windows, but other always-on-top windows will remain in
<i>2219</i>&nbsp;     * top-most position. Calling this method with a value of {@code false}
<i>2220</i>&nbsp;     * on a window that has a normal state has no effect.
<i>2221</i>&nbsp;     *
<i>2222</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: some platforms might not support always-on-top
<i>2223</i>&nbsp;     * windows.  To detect if always-on-top windows are supported by the
<i>2224</i>&nbsp;     * current platform, use {@link Toolkit#isAlwaysOnTopSupported()} and
<b class="nc"><i>2225</i>&nbsp;     * {@link Window#isAlwaysOnTopSupported()}.  If always-on-top mode</b>
<b class="nc"><i>2226</i>&nbsp;     * isn&#39;t supported for this window or this window&#39;s toolkit does not</b>
<b class="nc"><i>2227</i>&nbsp;     * support always-on-top windows, calling this method has no effect.</b>
<i>2228</i>&nbsp;     * &lt;p&gt;
<i>2229</i>&nbsp;     * If a SecurityManager is installed, the calling thread must be
<i>2230</i>&nbsp;     * granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in
<b class="nc"><i>2231</i>&nbsp;     * order to set the value of this property. If this</b>
<b class="nc"><i>2232</i>&nbsp;     * permission is not granted, this method will throw a</b>
<b class="nc"><i>2233</i>&nbsp;     * SecurityException, and the current value of the property will</b>
<b class="nc"><i>2234</i>&nbsp;     * be left unchanged.</b>
<b class="nc"><i>2235</i>&nbsp;     *</b>
<b class="nc"><i>2236</i>&nbsp;     * @param alwaysOnTop true if the window should always be above other</b>
<b class="nc"><i>2237</i>&nbsp;     *        windows</b>
<b class="nc"><i>2238</i>&nbsp;     * @throws SecurityException if the calling thread does not have</b>
<b class="nc"><i>2239</i>&nbsp;     *         permission to set the value of always-on-top property</b>
<b class="nc"><i>2240</i>&nbsp;     *</b>
<i>2241</i>&nbsp;     * @see #isAlwaysOnTop
<b class="nc"><i>2242</i>&nbsp;     * @see #toFront</b>
<i>2243</i>&nbsp;     * @see #toBack
<b class="nc"><i>2244</i>&nbsp;     * @see AWTPermission</b>
<i>2245</i>&nbsp;     * @see #isAlwaysOnTopSupported
<b class="nc"><i>2246</i>&nbsp;     * @see #getToolkit</b>
<i>2247</i>&nbsp;     * @see Toolkit#isAlwaysOnTopSupported
<i>2248</i>&nbsp;     * @since 1.5
<i>2249</i>&nbsp;     */
<i>2250</i>&nbsp;    public final void setAlwaysOnTop(boolean alwaysOnTop) throws SecurityException {
<i>2251</i>&nbsp;        SecurityManager security = System.getSecurityManager();
<b class="nc"><i>2252</i>&nbsp;        if (security != null) {</b>
<b class="nc"><i>2253</i>&nbsp;            security.checkPermission(AWTPermissions.SET_WINDOW_ALWAYS_ON_TOP_PERMISSION);</b>
<b class="nc"><i>2254</i>&nbsp;        }</b>
<b class="nc"><i>2255</i>&nbsp;</b>
<i>2256</i>&nbsp;        boolean oldAlwaysOnTop;
<b class="nc"><i>2257</i>&nbsp;        synchronized(this) {</b>
<b class="nc"><i>2258</i>&nbsp;            oldAlwaysOnTop = this.alwaysOnTop;</b>
<b class="nc"><i>2259</i>&nbsp;            this.alwaysOnTop = alwaysOnTop;</b>
<i>2260</i>&nbsp;        }
<b class="nc"><i>2261</i>&nbsp;        if (oldAlwaysOnTop != alwaysOnTop ) {</b>
<b class="nc"><i>2262</i>&nbsp;            if (isAlwaysOnTopSupported()) {</b>
<b class="nc"><i>2263</i>&nbsp;                WindowPeer peer = (WindowPeer)this.peer;</b>
<i>2264</i>&nbsp;                synchronized(getTreeLock()) {
<i>2265</i>&nbsp;                    if (peer != null) {
<i>2266</i>&nbsp;                        peer.updateAlwaysOnTopState();
<i>2267</i>&nbsp;                    }
<i>2268</i>&nbsp;                }
<i>2269</i>&nbsp;            }
<i>2270</i>&nbsp;            firePropertyChange(&quot;alwaysOnTop&quot;, oldAlwaysOnTop, alwaysOnTop);
<i>2271</i>&nbsp;        }
<i>2272</i>&nbsp;        setOwnedWindowsAlwaysOnTop(alwaysOnTop);
<i>2273</i>&nbsp;    }
<i>2274</i>&nbsp;
<i>2275</i>&nbsp;    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
<i>2276</i>&nbsp;    private void setOwnedWindowsAlwaysOnTop(boolean alwaysOnTop) {
<i>2277</i>&nbsp;        WeakReference&lt;Window&gt;[] ownedWindowArray;
<i>2278</i>&nbsp;        synchronized (ownedWindowList) {
<i>2279</i>&nbsp;            ownedWindowArray = new WeakReference[ownedWindowList.size()];
<i>2280</i>&nbsp;            ownedWindowList.copyInto(ownedWindowArray);
<i>2281</i>&nbsp;        }
<i>2282</i>&nbsp;
<i>2283</i>&nbsp;        for (WeakReference&lt;Window&gt; ref : ownedWindowArray) {
<b class="nc"><i>2284</i>&nbsp;            Window window = ref.get();</b>
<i>2285</i>&nbsp;            if (window != null) {
<i>2286</i>&nbsp;                try {
<i>2287</i>&nbsp;                    window.setAlwaysOnTop(alwaysOnTop);
<i>2288</i>&nbsp;                } catch (SecurityException ignore) {
<i>2289</i>&nbsp;                }
<i>2290</i>&nbsp;            }
<i>2291</i>&nbsp;        }
<i>2292</i>&nbsp;    }
<i>2293</i>&nbsp;
<i>2294</i>&nbsp;    /**
<i>2295</i>&nbsp;     * Returns whether the always-on-top mode is supported for this
<b class="nc"><i>2296</i>&nbsp;     * window. Some platforms may not support always-on-top windows, some</b>
<i>2297</i>&nbsp;     * may support only some kinds of top-level windows; for example,
<i>2298</i>&nbsp;     * a platform may not support always-on-top modal dialogs.
<i>2299</i>&nbsp;     *
<i>2300</i>&nbsp;     * @return {@code true}, if the always-on-top mode is supported for
<i>2301</i>&nbsp;     *         this window and this window&#39;s toolkit supports always-on-top windows,
<i>2302</i>&nbsp;     *         {@code false} otherwise
<i>2303</i>&nbsp;     *
<i>2304</i>&nbsp;     * @see #setAlwaysOnTop(boolean)
<i>2305</i>&nbsp;     * @see #getToolkit
<i>2306</i>&nbsp;     * @see Toolkit#isAlwaysOnTopSupported
<i>2307</i>&nbsp;     * @since 1.6
<i>2308</i>&nbsp;     */
<i>2309</i>&nbsp;    public boolean isAlwaysOnTopSupported() {
<b class="nc"><i>2310</i>&nbsp;        return Toolkit.getDefaultToolkit().isAlwaysOnTopSupported();</b>
<b class="nc"><i>2311</i>&nbsp;    }</b>
<b class="nc"><i>2312</i>&nbsp;</b>
<i>2313</i>&nbsp;
<i>2314</i>&nbsp;    /**
<i>2315</i>&nbsp;     * Returns whether this window is an always-on-top window.
<i>2316</i>&nbsp;     * @return {@code true}, if the window is in always-on-top state,
<i>2317</i>&nbsp;     *         {@code false} otherwise
<i>2318</i>&nbsp;     * @see #setAlwaysOnTop
<i>2319</i>&nbsp;     * @since 1.5
<i>2320</i>&nbsp;     */
<i>2321</i>&nbsp;    public final boolean isAlwaysOnTop() {
<i>2322</i>&nbsp;        return alwaysOnTop;
<i>2323</i>&nbsp;    }
<i>2324</i>&nbsp;
<i>2325</i>&nbsp;
<i>2326</i>&nbsp;    /**
<i>2327</i>&nbsp;     * Returns the child Component of this Window that has focus if this Window
<i>2328</i>&nbsp;     * is focused; returns null otherwise.
<i>2329</i>&nbsp;     *
<i>2330</i>&nbsp;     * @return the child Component with focus, or null if this Window is not
<i>2331</i>&nbsp;     *         focused
<i>2332</i>&nbsp;     * @see #getMostRecentFocusOwner
<i>2333</i>&nbsp;     * @see #isFocused
<b class="nc"><i>2334</i>&nbsp;     */</b>
<b class="nc"><i>2335</i>&nbsp;    public Component getFocusOwner() {</b>
<i>2336</i>&nbsp;        return (isFocused())
<b class="nc"><i>2337</i>&nbsp;            ? KeyboardFocusManager.getCurrentKeyboardFocusManager().</b>
<b class="nc"><i>2338</i>&nbsp;                  getFocusOwner()</b>
<b class="nc"><i>2339</i>&nbsp;            : null;</b>
<b class="nc"><i>2340</i>&nbsp;    }</b>
<i>2341</i>&nbsp;
<b class="nc"><i>2342</i>&nbsp;    /**</b>
<b class="nc"><i>2343</i>&nbsp;     * Returns the child Component of this Window that will receive the focus</b>
<i>2344</i>&nbsp;     * when this Window is focused. If this Window is currently focused, this
<i>2345</i>&nbsp;     * method returns the same Component as {@code getFocusOwner()}. If
<i>2346</i>&nbsp;     * this Window is not focused, then the child Component that most recently
<i>2347</i>&nbsp;     * requested focus will be returned. If no child Component has ever
<i>2348</i>&nbsp;     * requested focus, and this is a focusable Window, then this Window&#39;s
<i>2349</i>&nbsp;     * initial focusable Component is returned. If no child Component has ever
<i>2350</i>&nbsp;     * requested focus, and this is a non-focusable Window, null is returned.
<i>2351</i>&nbsp;     *
<i>2352</i>&nbsp;     * @return the child Component that will receive focus when this Window is
<i>2353</i>&nbsp;     *         focused
<i>2354</i>&nbsp;     * @see #getFocusOwner
<i>2355</i>&nbsp;     * @see #isFocused
<i>2356</i>&nbsp;     * @see #isFocusableWindow
<i>2357</i>&nbsp;     * @since 1.4
<i>2358</i>&nbsp;     */
<i>2359</i>&nbsp;    public Component getMostRecentFocusOwner() {
<i>2360</i>&nbsp;        if (isFocused()) {
<b class="nc"><i>2361</i>&nbsp;            return getFocusOwner();</b>
<b class="nc"><i>2362</i>&nbsp;        } else {</b>
<i>2363</i>&nbsp;            Component mostRecent =
<i>2364</i>&nbsp;                KeyboardFocusManager.getMostRecentFocusOwner(this);
<i>2365</i>&nbsp;            if (mostRecent != null) {
<i>2366</i>&nbsp;                return mostRecent;
<i>2367</i>&nbsp;            } else {
<i>2368</i>&nbsp;                return (isFocusableWindow())
<i>2369</i>&nbsp;                    ? getFocusTraversalPolicy().getInitialComponent(this)
<i>2370</i>&nbsp;                    : null;
<i>2371</i>&nbsp;            }
<i>2372</i>&nbsp;        }
<i>2373</i>&nbsp;    }
<i>2374</i>&nbsp;
<i>2375</i>&nbsp;    /**
<i>2376</i>&nbsp;     * Returns whether this Window is active. Only a Frame or a Dialog may be
<i>2377</i>&nbsp;     * active. The native windowing system may denote the active Window or its
<i>2378</i>&nbsp;     * children with special decorations, such as a highlighted title bar. The
<b class="nc"><i>2379</i>&nbsp;     * active Window is always either the focused Window, or the first Frame or</b>
<b class="nc"><i>2380</i>&nbsp;     * Dialog that is an owner of the focused Window.</b>
<i>2381</i>&nbsp;     *
<i>2382</i>&nbsp;     * @return whether this is the active Window.
<i>2383</i>&nbsp;     * @see #isFocused
<i>2384</i>&nbsp;     * @since 1.4
<i>2385</i>&nbsp;     */
<i>2386</i>&nbsp;    public boolean isActive() {
<i>2387</i>&nbsp;        return (KeyboardFocusManager.getCurrentKeyboardFocusManager().
<i>2388</i>&nbsp;                getActiveWindow() == this);
<i>2389</i>&nbsp;    }
<i>2390</i>&nbsp;
<i>2391</i>&nbsp;    /**
<i>2392</i>&nbsp;     * Returns whether this Window is focused. If there exists a focus owner,
<i>2393</i>&nbsp;     * the focused Window is the Window that is, or contains, that focus owner.
<i>2394</i>&nbsp;     * If there is no focus owner, then no Window is focused.
<i>2395</i>&nbsp;     * &lt;p&gt;
<i>2396</i>&nbsp;     * If the focused Window is a Frame or a Dialog it is also the active
<i>2397</i>&nbsp;     * Window. Otherwise, the active Window is the first Frame or Dialog that
<i>2398</i>&nbsp;     * is an owner of the focused Window.
<i>2399</i>&nbsp;     *
<i>2400</i>&nbsp;     * @return whether this is the focused Window.
<i>2401</i>&nbsp;     * @see #isActive
<i>2402</i>&nbsp;     * @since 1.4
<i>2403</i>&nbsp;     */
<i>2404</i>&nbsp;    public boolean isFocused() {
<i>2405</i>&nbsp;        return (KeyboardFocusManager.getCurrentKeyboardFocusManager().
<i>2406</i>&nbsp;                getGlobalFocusedWindow() == this);
<i>2407</i>&nbsp;    }
<i>2408</i>&nbsp;
<i>2409</i>&nbsp;    /**
<i>2410</i>&nbsp;     * Gets a focus traversal key for this Window. (See {@code
<i>2411</i>&nbsp;     * setFocusTraversalKeys} for a full description of each key.)
<b class="nc"><i>2412</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2413</i>&nbsp;     * If the traversal key has not been explicitly set for this Window,</b>
<i>2414</i>&nbsp;     * then this Window&#39;s parent&#39;s traversal key is returned. If the
<i>2415</i>&nbsp;     * traversal key has not been explicitly set for any of this Window&#39;s
<i>2416</i>&nbsp;     * ancestors, then the current KeyboardFocusManager&#39;s default traversal key
<i>2417</i>&nbsp;     * is returned.
<b class="nc"><i>2418</i>&nbsp;     *</b>
<i>2419</i>&nbsp;     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
<i>2420</i>&nbsp;     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
<i>2421</i>&nbsp;     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
<b class="nc"><i>2422</i>&nbsp;     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS</b>
<b class="nc"><i>2423</i>&nbsp;     * @return the AWTKeyStroke for the specified key</b>
<i>2424</i>&nbsp;     * @see Container#setFocusTraversalKeys
<b class="nc"><i>2425</i>&nbsp;     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS</b>
<b class="nc"><i>2426</i>&nbsp;     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS</b>
<i>2427</i>&nbsp;     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
<i>2428</i>&nbsp;     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS
<i>2429</i>&nbsp;     * @throws IllegalArgumentException if id is not one of
<i>2430</i>&nbsp;     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
<i>2431</i>&nbsp;     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
<i>2432</i>&nbsp;     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
<i>2433</i>&nbsp;     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
<i>2434</i>&nbsp;     * @since 1.4
<i>2435</i>&nbsp;     */
<i>2436</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>2437</i>&nbsp;    public Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys(int id) {
<i>2438</i>&nbsp;        if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {
<i>2439</i>&nbsp;            throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);
<i>2440</i>&nbsp;        }
<i>2441</i>&nbsp;
<i>2442</i>&nbsp;        // Okay to return Set directly because it is an unmodifiable view
<i>2443</i>&nbsp;        @SuppressWarnings(&quot;rawtypes&quot;)
<i>2444</i>&nbsp;        Set keystrokes = (focusTraversalKeys != null)
<i>2445</i>&nbsp;            ? focusTraversalKeys[id]
<i>2446</i>&nbsp;            : null;
<i>2447</i>&nbsp;
<i>2448</i>&nbsp;        if (keystrokes != null) {
<i>2449</i>&nbsp;            return keystrokes;
<i>2450</i>&nbsp;        } else {
<i>2451</i>&nbsp;            return KeyboardFocusManager.getCurrentKeyboardFocusManager().
<i>2452</i>&nbsp;                getDefaultFocusTraversalKeys(id);
<i>2453</i>&nbsp;        }
<b class="nc"><i>2454</i>&nbsp;    }</b>
<i>2455</i>&nbsp;
<i>2456</i>&nbsp;    /**
<i>2457</i>&nbsp;     * Does nothing because Windows must always be roots of a focus traversal
<i>2458</i>&nbsp;     * cycle. The passed-in value is ignored.
<i>2459</i>&nbsp;     *
<i>2460</i>&nbsp;     * @param focusCycleRoot this value is ignored
<i>2461</i>&nbsp;     * @see #isFocusCycleRoot
<i>2462</i>&nbsp;     * @see Container#setFocusTraversalPolicy
<i>2463</i>&nbsp;     * @see Container#getFocusTraversalPolicy
<i>2464</i>&nbsp;     * @since 1.4
<i>2465</i>&nbsp;     */
<b class="nc"><i>2466</i>&nbsp;    public final void setFocusCycleRoot(boolean focusCycleRoot) {</b>
<i>2467</i>&nbsp;    }
<i>2468</i>&nbsp;
<i>2469</i>&nbsp;    /**
<i>2470</i>&nbsp;     * Always returns {@code true} because all Windows must be roots of a
<i>2471</i>&nbsp;     * focus traversal cycle.
<i>2472</i>&nbsp;     *
<i>2473</i>&nbsp;     * @return {@code true}
<i>2474</i>&nbsp;     * @see #setFocusCycleRoot
<i>2475</i>&nbsp;     * @see Container#setFocusTraversalPolicy
<i>2476</i>&nbsp;     * @see Container#getFocusTraversalPolicy
<i>2477</i>&nbsp;     * @since 1.4
<i>2478</i>&nbsp;     */
<i>2479</i>&nbsp;    public final boolean isFocusCycleRoot() {
<i>2480</i>&nbsp;        return true;
<i>2481</i>&nbsp;    }
<i>2482</i>&nbsp;
<i>2483</i>&nbsp;    /**
<i>2484</i>&nbsp;     * Always returns {@code null} because Windows have no ancestors; they
<i>2485</i>&nbsp;     * represent the top of the Component hierarchy.
<i>2486</i>&nbsp;     *
<i>2487</i>&nbsp;     * @return {@code null}
<i>2488</i>&nbsp;     * @see Container#isFocusCycleRoot()
<i>2489</i>&nbsp;     * @since 1.4
<i>2490</i>&nbsp;     */
<i>2491</i>&nbsp;    public final Container getFocusCycleRootAncestor() {
<b class="nc"><i>2492</i>&nbsp;        return null;</b>
<b class="nc"><i>2493</i>&nbsp;    }</b>
<i>2494</i>&nbsp;
<i>2495</i>&nbsp;    /**
<i>2496</i>&nbsp;     * Returns whether this Window can become the focused Window, that is,
<b class="nc"><i>2497</i>&nbsp;     * whether this Window or any of its subcomponents can become the focus</b>
<b class="nc"><i>2498</i>&nbsp;     * owner. For a Frame or Dialog to be focusable, its focusable Window state</b>
<i>2499</i>&nbsp;     * must be set to {@code true}. For a Window which is not a Frame or
<i>2500</i>&nbsp;     * Dialog to be focusable, its focusable Window state must be set to
<i>2501</i>&nbsp;     * {@code true}, its nearest owning Frame or Dialog must be
<i>2502</i>&nbsp;     * showing on the screen, and it must contain at least one Component in
<b class="nc"><i>2503</i>&nbsp;     * its focus traversal cycle. If any of these conditions is not met, then</b>
<b class="nc"><i>2504</i>&nbsp;     * neither this Window nor any of its subcomponents can become the focus</b>
<i>2505</i>&nbsp;     * owner.
<i>2506</i>&nbsp;     *
<i>2507</i>&nbsp;     * @return {@code true} if this Window can be the focused Window;
<i>2508</i>&nbsp;     *         {@code false} otherwise
<b class="nc"><i>2509</i>&nbsp;     * @see #getFocusableWindowState</b>
<b class="nc"><i>2510</i>&nbsp;     * @see #setFocusableWindowState</b>
<i>2511</i>&nbsp;     * @see #isShowing
<b class="nc"><i>2512</i>&nbsp;     * @see Component#isFocusable</b>
<b class="nc"><i>2513</i>&nbsp;     * @since 1.4</b>
<i>2514</i>&nbsp;     */
<i>2515</i>&nbsp;    public final boolean isFocusableWindow() {
<i>2516</i>&nbsp;        // If a Window/Frame/Dialog was made non-focusable, then it is always
<b class="nc"><i>2517</i>&nbsp;        // non-focusable.</b>
<i>2518</i>&nbsp;        if (!getFocusableWindowState()) {
<i>2519</i>&nbsp;            return false;
<i>2520</i>&nbsp;        }
<i>2521</i>&nbsp;
<i>2522</i>&nbsp;        // All other tests apply only to Windows.
<i>2523</i>&nbsp;        if (this instanceof Frame || this instanceof Dialog) {
<i>2524</i>&nbsp;            return true;
<i>2525</i>&nbsp;        }
<i>2526</i>&nbsp;
<i>2527</i>&nbsp;        // A Window must have at least one Component in its root focus
<i>2528</i>&nbsp;        // traversal cycle to be focusable.
<i>2529</i>&nbsp;        if (getFocusTraversalPolicy().getDefaultComponent(this) == null) {
<i>2530</i>&nbsp;            return false;
<i>2531</i>&nbsp;        }
<i>2532</i>&nbsp;
<i>2533</i>&nbsp;        // A Window&#39;s nearest owning Frame or Dialog must be showing on the
<i>2534</i>&nbsp;        // screen.
<i>2535</i>&nbsp;        for (Window owner = getOwner(); owner != null;
<i>2536</i>&nbsp;             owner = owner.getOwner())
<i>2537</i>&nbsp;        {
<i>2538</i>&nbsp;            if (owner instanceof Frame || owner instanceof Dialog) {
<i>2539</i>&nbsp;                return owner.isShowing();
<i>2540</i>&nbsp;            }
<b class="nc"><i>2541</i>&nbsp;        }</b>
<i>2542</i>&nbsp;
<i>2543</i>&nbsp;        return false;
<i>2544</i>&nbsp;    }
<i>2545</i>&nbsp;
<i>2546</i>&nbsp;    /**
<i>2547</i>&nbsp;     * Returns whether this Window can become the focused Window if it meets
<i>2548</i>&nbsp;     * the other requirements outlined in {@code isFocusableWindow}. If
<i>2549</i>&nbsp;     * this method returns {@code false}, then
<i>2550</i>&nbsp;     * {@code isFocusableWindow} will return {@code false} as well.
<i>2551</i>&nbsp;     * If this method returns {@code true}, then
<i>2552</i>&nbsp;     * {@code isFocusableWindow} may return {@code true} or
<i>2553</i>&nbsp;     * {@code false} depending upon the other requirements which must be
<i>2554</i>&nbsp;     * met in order for a Window to be focusable.
<i>2555</i>&nbsp;     * &lt;p&gt;
<i>2556</i>&nbsp;     * By default, all Windows have a focusable Window state of
<i>2557</i>&nbsp;     * {@code true}.
<i>2558</i>&nbsp;     *
<i>2559</i>&nbsp;     * @return whether this Window can be the focused Window
<i>2560</i>&nbsp;     * @see #isFocusableWindow
<i>2561</i>&nbsp;     * @see #setFocusableWindowState
<i>2562</i>&nbsp;     * @see #isShowing
<i>2563</i>&nbsp;     * @see Component#setFocusable
<i>2564</i>&nbsp;     * @since 1.4
<i>2565</i>&nbsp;     */
<i>2566</i>&nbsp;    public boolean getFocusableWindowState() {
<i>2567</i>&nbsp;        return focusableWindowState;
<i>2568</i>&nbsp;    }
<i>2569</i>&nbsp;
<i>2570</i>&nbsp;    /**
<i>2571</i>&nbsp;     * Sets whether this Window can become the focused Window if it meets
<i>2572</i>&nbsp;     * the other requirements outlined in {@code isFocusableWindow}. If
<i>2573</i>&nbsp;     * this Window&#39;s focusable Window state is set to {@code false}, then
<i>2574</i>&nbsp;     * {@code isFocusableWindow} will return {@code false}. If this
<i>2575</i>&nbsp;     * Window&#39;s focusable Window state is set to {@code true}, then
<b class="nc"><i>2576</i>&nbsp;     * {@code isFocusableWindow} may return {@code true} or</b>
<b class="nc"><i>2577</i>&nbsp;     * {@code false} depending upon the other requirements which must be</b>
<b class="nc"><i>2578</i>&nbsp;     * met in order for a Window to be focusable.</b>
<b class="nc"><i>2579</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2580</i>&nbsp;     * Setting a Window&#39;s focusability state to {@code false} is the</b>
<b class="nc"><i>2581</i>&nbsp;     * standard mechanism for an application to identify to the AWT a Window</b>
<b class="nc"><i>2582</i>&nbsp;     * which will be used as a floating palette or toolbar, and thus should be</b>
<i>2583</i>&nbsp;     * a non-focusable Window.
<b class="nc"><i>2584</i>&nbsp;     *</b>
<i>2585</i>&nbsp;     * Setting the focusability state on a visible {@code Window}
<b class="nc"><i>2586</i>&nbsp;     * can have a delayed effect on some platforms &amp;#8212; the actual</b>
<b class="nc"><i>2587</i>&nbsp;     * change may happen only when the {@code Window} becomes</b>
<b class="nc"><i>2588</i>&nbsp;     * hidden and then visible again.  To ensure consistent behavior</b>
<b class="nc"><i>2589</i>&nbsp;     * across platforms, set the {@code Window}&#39;s focusable state</b>
<i>2590</i>&nbsp;     * when the {@code Window} is invisible and then show it.
<b class="nc"><i>2591</i>&nbsp;     *</b>
<b class="nc"><i>2592</i>&nbsp;     * @param focusableWindowState whether this Window can be the focused</b>
<b class="nc"><i>2593</i>&nbsp;     *        Window</b>
<i>2594</i>&nbsp;     * @see #isFocusableWindow
<i>2595</i>&nbsp;     * @see #getFocusableWindowState
<i>2596</i>&nbsp;     * @see #isShowing
<b class="nc"><i>2597</i>&nbsp;     * @see Component#setFocusable</b>
<b class="nc"><i>2598</i>&nbsp;     * @since 1.4</b>
<i>2599</i>&nbsp;     */
<i>2600</i>&nbsp;    public void setFocusableWindowState(boolean focusableWindowState) {
<i>2601</i>&nbsp;        boolean oldFocusableWindowState;
<i>2602</i>&nbsp;        synchronized (this) {
<i>2603</i>&nbsp;            oldFocusableWindowState = this.focusableWindowState;
<i>2604</i>&nbsp;            this.focusableWindowState = focusableWindowState;
<i>2605</i>&nbsp;        }
<i>2606</i>&nbsp;        WindowPeer peer = (WindowPeer)this.peer;
<i>2607</i>&nbsp;        if (peer != null) {
<i>2608</i>&nbsp;            peer.updateFocusableWindowState();
<i>2609</i>&nbsp;        }
<i>2610</i>&nbsp;        firePropertyChange(&quot;focusableWindowState&quot;, oldFocusableWindowState,
<i>2611</i>&nbsp;                           focusableWindowState);
<i>2612</i>&nbsp;        if (oldFocusableWindowState &amp;&amp; !focusableWindowState &amp;&amp; isFocused()) {
<i>2613</i>&nbsp;            for (Window owner = getOwner();
<i>2614</i>&nbsp;                 owner != null;
<i>2615</i>&nbsp;                 owner = owner.getOwner())
<i>2616</i>&nbsp;                {
<i>2617</i>&nbsp;                    Component toFocus =
<i>2618</i>&nbsp;                        KeyboardFocusManager.getMostRecentFocusOwner(owner);
<i>2619</i>&nbsp;                    if (toFocus != null &amp;&amp; toFocus.requestFocus(false, FocusEvent.Cause.ACTIVATION)) {
<i>2620</i>&nbsp;                        return;
<i>2621</i>&nbsp;                    }
<i>2622</i>&nbsp;                }
<i>2623</i>&nbsp;            KeyboardFocusManager.getCurrentKeyboardFocusManager().
<b class="nc"><i>2624</i>&nbsp;                clearGlobalFocusOwnerPriv();</b>
<i>2625</i>&nbsp;        }
<i>2626</i>&nbsp;    }
<i>2627</i>&nbsp;
<i>2628</i>&nbsp;    /**
<i>2629</i>&nbsp;     * Sets whether this window should receive focus on
<i>2630</i>&nbsp;     * subsequently being shown (with a call to {@link #setVisible setVisible(true)}),
<i>2631</i>&nbsp;     * or being moved to the front (with a call to {@link #toFront}).
<i>2632</i>&nbsp;     * &lt;p&gt;
<i>2633</i>&nbsp;     * Note that {@link #setVisible setVisible(true)} may be called indirectly
<i>2634</i>&nbsp;     * (e.g. when showing an owner of the window makes the window to be shown).
<i>2635</i>&nbsp;     * {@link #toFront} may also be called indirectly (e.g. when
<i>2636</i>&nbsp;     * {@link #setVisible setVisible(true)} is called on already visible window).
<i>2637</i>&nbsp;     * In all such cases this property takes effect as well.
<i>2638</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2639</i>&nbsp;     * The value of the property is not inherited by owned windows.</b>
<i>2640</i>&nbsp;     *
<i>2641</i>&nbsp;     * @param autoRequestFocus whether this window should be focused on
<i>2642</i>&nbsp;     *        subsequently being shown or being moved to the front
<i>2643</i>&nbsp;     * @see #isAutoRequestFocus
<i>2644</i>&nbsp;     * @see #isFocusableWindow
<i>2645</i>&nbsp;     * @see #setVisible
<i>2646</i>&nbsp;     * @see #toFront
<i>2647</i>&nbsp;     * @since 1.7
<i>2648</i>&nbsp;     */
<i>2649</i>&nbsp;    public void setAutoRequestFocus(boolean autoRequestFocus) {
<i>2650</i>&nbsp;        this.autoRequestFocus = autoRequestFocus;
<i>2651</i>&nbsp;    }
<i>2652</i>&nbsp;
<i>2653</i>&nbsp;    /**
<i>2654</i>&nbsp;     * Returns whether this window should receive focus on subsequently being shown
<i>2655</i>&nbsp;     * (with a call to {@link #setVisible setVisible(true)}), or being moved to the front
<i>2656</i>&nbsp;     * (with a call to {@link #toFront}).
<i>2657</i>&nbsp;     * &lt;p&gt;
<i>2658</i>&nbsp;     * By default, the window has {@code autoRequestFocus} value of {@code true}.
<i>2659</i>&nbsp;     *
<i>2660</i>&nbsp;     * @return {@code autoRequestFocus} value
<i>2661</i>&nbsp;     * @see #setAutoRequestFocus
<i>2662</i>&nbsp;     * @since 1.7
<i>2663</i>&nbsp;     */
<i>2664</i>&nbsp;    public boolean isAutoRequestFocus() {
<i>2665</i>&nbsp;        return autoRequestFocus;
<i>2666</i>&nbsp;    }
<i>2667</i>&nbsp;
<i>2668</i>&nbsp;    /**
<i>2669</i>&nbsp;     * Adds a PropertyChangeListener to the listener list. The listener is
<i>2670</i>&nbsp;     * registered for all bound properties of this class, including the
<i>2671</i>&nbsp;     * following:
<i>2672</i>&nbsp;     * &lt;ul&gt;
<i>2673</i>&nbsp;     *    &lt;li&gt;this Window&#39;s font (&quot;font&quot;)&lt;/li&gt;
<i>2674</i>&nbsp;     *    &lt;li&gt;this Window&#39;s background color (&quot;background&quot;)&lt;/li&gt;
<i>2675</i>&nbsp;     *    &lt;li&gt;this Window&#39;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
<i>2676</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focusability (&quot;focusable&quot;)&lt;/li&gt;
<i>2677</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focus traversal keys enabled state
<b class="nc"><i>2678</i>&nbsp;     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;</b>
<i>2679</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of FORWARD_TRAVERSAL_KEYS
<i>2680</i>&nbsp;     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
<i>2681</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of BACKWARD_TRAVERSAL_KEYS
<i>2682</i>&nbsp;     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
<i>2683</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of UP_CYCLE_TRAVERSAL_KEYS
<i>2684</i>&nbsp;     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
<i>2685</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
<i>2686</i>&nbsp;     *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
<i>2687</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
<i>2688</i>&nbsp;     *        &lt;/li&gt;
<i>2689</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focusable Window state (&quot;focusableWindowState&quot;)
<i>2690</i>&nbsp;     *        &lt;/li&gt;
<i>2691</i>&nbsp;     *    &lt;li&gt;this Window&#39;s always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
<i>2692</i>&nbsp;     * &lt;/ul&gt;
<i>2693</i>&nbsp;     * Note that if this Window is inheriting a bound property, then no
<i>2694</i>&nbsp;     * event will be fired in response to a change in the inherited property.
<i>2695</i>&nbsp;     * &lt;p&gt;
<i>2696</i>&nbsp;     * If listener is null, no exception is thrown and no action is performed.
<i>2697</i>&nbsp;     *
<i>2698</i>&nbsp;     * @param    listener  the PropertyChangeListener to be added
<i>2699</i>&nbsp;     *
<i>2700</i>&nbsp;     * @see Component#removePropertyChangeListener
<i>2701</i>&nbsp;     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
<i>2702</i>&nbsp;     */
<i>2703</i>&nbsp;    public void addPropertyChangeListener(PropertyChangeListener listener) {
<i>2704</i>&nbsp;        super.addPropertyChangeListener(listener);
<i>2705</i>&nbsp;    }
<i>2706</i>&nbsp;
<i>2707</i>&nbsp;    /**
<i>2708</i>&nbsp;     * Adds a PropertyChangeListener to the listener list for a specific
<i>2709</i>&nbsp;     * property. The specified property may be user-defined, or one of the
<i>2710</i>&nbsp;     * following:
<i>2711</i>&nbsp;     * &lt;ul&gt;
<i>2712</i>&nbsp;     *    &lt;li&gt;this Window&#39;s font (&quot;font&quot;)&lt;/li&gt;
<i>2713</i>&nbsp;     *    &lt;li&gt;this Window&#39;s background color (&quot;background&quot;)&lt;/li&gt;
<i>2714</i>&nbsp;     *    &lt;li&gt;this Window&#39;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
<i>2715</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focusability (&quot;focusable&quot;)&lt;/li&gt;
<i>2716</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focus traversal keys enabled state
<i>2717</i>&nbsp;     *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
<i>2718</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of FORWARD_TRAVERSAL_KEYS
<b class="nc"><i>2719</i>&nbsp;     *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;</b>
<i>2720</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of BACKWARD_TRAVERSAL_KEYS
<i>2721</i>&nbsp;     *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
<i>2722</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of UP_CYCLE_TRAVERSAL_KEYS
<i>2723</i>&nbsp;     *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
<i>2724</i>&nbsp;     *    &lt;li&gt;this Window&#39;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
<i>2725</i>&nbsp;     *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
<i>2726</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
<i>2727</i>&nbsp;     *        &lt;/li&gt;
<i>2728</i>&nbsp;     *    &lt;li&gt;this Window&#39;s focusable Window state (&quot;focusableWindowState&quot;)
<i>2729</i>&nbsp;     *        &lt;/li&gt;
<i>2730</i>&nbsp;     *    &lt;li&gt;this Window&#39;s always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
<i>2731</i>&nbsp;     * &lt;/ul&gt;
<i>2732</i>&nbsp;     * Note that if this Window is inheriting a bound property, then no
<i>2733</i>&nbsp;     * event will be fired in response to a change in the inherited property.
<b class="nc"><i>2734</i>&nbsp;     * &lt;p&gt;</b>
<i>2735</i>&nbsp;     * If listener is null, no exception is thrown and no action is performed.
<i>2736</i>&nbsp;     *
<i>2737</i>&nbsp;     * @param propertyName one of the property names listed above
<i>2738</i>&nbsp;     * @param listener the PropertyChangeListener to be added
<i>2739</i>&nbsp;     *
<i>2740</i>&nbsp;     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
<i>2741</i>&nbsp;     * @see Component#removePropertyChangeListener
<b class="nc"><i>2742</i>&nbsp;     */</b>
<b class="nc"><i>2743</i>&nbsp;    public void addPropertyChangeListener(String propertyName,</b>
<b class="nc"><i>2744</i>&nbsp;                                          PropertyChangeListener listener) {</b>
<i>2745</i>&nbsp;        super.addPropertyChangeListener(propertyName, listener);
<b class="nc"><i>2746</i>&nbsp;    }</b>
<i>2747</i>&nbsp;
<i>2748</i>&nbsp;    /**
<i>2749</i>&nbsp;     * Indicates if this container is a validate root.
<i>2750</i>&nbsp;     * &lt;p&gt;
<i>2751</i>&nbsp;     * {@code Window} objects are the validate roots, and, therefore, they
<i>2752</i>&nbsp;     * override this method to return {@code true}.
<i>2753</i>&nbsp;     *
<i>2754</i>&nbsp;     * @return {@code true}
<b class="nc"><i>2755</i>&nbsp;     * @since 1.7</b>
<b class="nc"><i>2756</i>&nbsp;     * @see java.awt.Container#isValidateRoot</b>
<b class="nc"><i>2757</i>&nbsp;     */</b>
<i>2758</i>&nbsp;    @Override
<b class="nc"><i>2759</i>&nbsp;    public boolean isValidateRoot() {</b>
<i>2760</i>&nbsp;        return true;
<i>2761</i>&nbsp;    }
<i>2762</i>&nbsp;
<i>2763</i>&nbsp;    /**
<i>2764</i>&nbsp;     * Dispatches an event to this window or one of its sub components.
<i>2765</i>&nbsp;     * @param e the event
<i>2766</i>&nbsp;     */
<b class="nc"><i>2767</i>&nbsp;    void dispatchEventImpl(AWTEvent e) {</b>
<i>2768</i>&nbsp;        if (e.getID() == ComponentEvent.COMPONENT_RESIZED) {
<i>2769</i>&nbsp;            invalidate();
<i>2770</i>&nbsp;            validate();
<b class="nc"><i>2771</i>&nbsp;        }</b>
<i>2772</i>&nbsp;        super.dispatchEventImpl(e);
<i>2773</i>&nbsp;    }
<i>2774</i>&nbsp;
<i>2775</i>&nbsp;    /**
<i>2776</i>&nbsp;     * @deprecated As of JDK version 1.1
<i>2777</i>&nbsp;     * replaced by {@code dispatchEvent(AWTEvent)}.
<i>2778</i>&nbsp;     */
<i>2779</i>&nbsp;    @Deprecated
<b class="nc"><i>2780</i>&nbsp;    public boolean postEvent(Event e) {</b>
<i>2781</i>&nbsp;        if (handleEvent(e)) {
<i>2782</i>&nbsp;            e.consume();
<i>2783</i>&nbsp;            return true;
<i>2784</i>&nbsp;        }
<i>2785</i>&nbsp;        return false;
<i>2786</i>&nbsp;    }
<i>2787</i>&nbsp;
<i>2788</i>&nbsp;    /**
<b class="nc"><i>2789</i>&nbsp;     * Checks if this Window is showing on screen.</b>
<i>2790</i>&nbsp;     * @see Component#setVisible
<i>2791</i>&nbsp;    */
<i>2792</i>&nbsp;    public boolean isShowing() {
<i>2793</i>&nbsp;        return visible;
<i>2794</i>&nbsp;    }
<i>2795</i>&nbsp;
<b class="nc"><i>2796</i>&nbsp;    boolean isDisposing() {</b>
<b class="nc"><i>2797</i>&nbsp;        return disposing;</b>
<i>2798</i>&nbsp;    }
<i>2799</i>&nbsp;
<b class="nc"><i>2800</i>&nbsp;    /**</b>
<b class="nc"><i>2801</i>&nbsp;     * @deprecated As of J2SE 1.4, replaced by</b>
<i>2802</i>&nbsp;     * {@link Component#applyComponentOrientation Component.applyComponentOrientation}.
<b class="nc"><i>2803</i>&nbsp;     * @param rb the resource bundle</b>
<i>2804</i>&nbsp;     */
<i>2805</i>&nbsp;    @Deprecated
<i>2806</i>&nbsp;    public void applyResourceBundle(ResourceBundle rb) {
<i>2807</i>&nbsp;        applyComponentOrientation(ComponentOrientation.getOrientation(rb));
<b class="nc"><i>2808</i>&nbsp;    }</b>
<i>2809</i>&nbsp;
<i>2810</i>&nbsp;    /**
<b class="nc"><i>2811</i>&nbsp;     * @deprecated As of J2SE 1.4, replaced by</b>
<i>2812</i>&nbsp;     * {@link Component#applyComponentOrientation Component.applyComponentOrientation}.
<i>2813</i>&nbsp;     * @param rbName the resource name
<i>2814</i>&nbsp;     */
<i>2815</i>&nbsp;    @Deprecated
<b class="nc"><i>2816</i>&nbsp;    public void applyResourceBundle(String rbName) {</b>
<b class="nc"><i>2817</i>&nbsp;        // Use the unnamed module from the TCCL or system class loader.</b>
<b class="nc"><i>2818</i>&nbsp;        ClassLoader cl = Thread.currentThread().getContextClassLoader();</b>
<i>2819</i>&nbsp;        if (cl == null) {
<i>2820</i>&nbsp;            cl = ClassLoader.getSystemClassLoader();
<i>2821</i>&nbsp;        }
<b class="nc"><i>2822</i>&nbsp;        applyResourceBundle(ResourceBundle.getBundle(rbName, cl.getUnnamedModule()));</b>
<i>2823</i>&nbsp;    }
<b class="nc"><i>2824</i>&nbsp;</b>
<b class="nc"><i>2825</i>&nbsp;   /*</b>
<b class="nc"><i>2826</i>&nbsp;    * Support for tracking all windows owned by this window</b>
<b class="nc"><i>2827</i>&nbsp;    */</b>
<i>2828</i>&nbsp;    void addOwnedWindow(WeakReference&lt;Window&gt; weakWindow) {
<b class="nc"><i>2829</i>&nbsp;        if (weakWindow != null) {</b>
<b class="nc"><i>2830</i>&nbsp;            synchronized(ownedWindowList) {</b>
<i>2831</i>&nbsp;                // this if statement should really be an assert, but we don&#39;t
<i>2832</i>&nbsp;                // have asserts...
<i>2833</i>&nbsp;                if (!ownedWindowList.contains(weakWindow)) {
<b class="nc"><i>2834</i>&nbsp;                    ownedWindowList.addElement(weakWindow);</b>
<i>2835</i>&nbsp;                }
<b class="nc"><i>2836</i>&nbsp;            }</b>
<b class="nc"><i>2837</i>&nbsp;        }</b>
<b class="nc"><i>2838</i>&nbsp;    }</b>
<i>2839</i>&nbsp;
<b class="nc"><i>2840</i>&nbsp;    void removeOwnedWindow(WeakReference&lt;Window&gt; weakWindow) {</b>
<i>2841</i>&nbsp;        if (weakWindow != null) {
<i>2842</i>&nbsp;            // synchronized block not required since removeElement is
<i>2843</i>&nbsp;            // already synchronized
<b class="nc"><i>2844</i>&nbsp;            ownedWindowList.removeElement(weakWindow);</b>
<i>2845</i>&nbsp;        }
<i>2846</i>&nbsp;    }
<i>2847</i>&nbsp;
<i>2848</i>&nbsp;    void connectOwnedWindow(Window child) {
<i>2849</i>&nbsp;        child.parent = this;
<i>2850</i>&nbsp;        addOwnedWindow(child.weakThis);
<i>2851</i>&nbsp;        child.disposerRecord.updateOwner();
<b class="nc"><i>2852</i>&nbsp;    }</b>
<i>2853</i>&nbsp;
<i>2854</i>&nbsp;    private void addToWindowList() {
<i>2855</i>&nbsp;        synchronized (Window.class) {
<i>2856</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<i>2857</i>&nbsp;            Vector&lt;WeakReference&lt;Window&gt;&gt; windowList = (Vector&lt;WeakReference&lt;Window&gt;&gt;)appContext.get(Window.class);
<i>2858</i>&nbsp;            if (windowList == null) {
<i>2859</i>&nbsp;                windowList = new Vector&lt;WeakReference&lt;Window&gt;&gt;();
<i>2860</i>&nbsp;                appContext.put(Window.class, windowList);
<i>2861</i>&nbsp;            }
<i>2862</i>&nbsp;            windowList.add(weakThis);
<i>2863</i>&nbsp;        }
<i>2864</i>&nbsp;    }
<i>2865</i>&nbsp;
<i>2866</i>&nbsp;    private static void removeFromWindowList(AppContext context, WeakReference&lt;Window&gt; weakThis) {
<b class="nc"><i>2867</i>&nbsp;        synchronized (Window.class) {</b>
<b class="nc"><i>2868</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)</b>
<i>2869</i>&nbsp;            Vector&lt;WeakReference&lt;Window&gt;&gt; windowList = (Vector&lt;WeakReference&lt;Window&gt;&gt;)context.get(Window.class);
<b class="nc"><i>2870</i>&nbsp;            if (windowList != null) {</b>
<b class="nc"><i>2871</i>&nbsp;                windowList.remove(weakThis);</b>
<b class="nc"><i>2872</i>&nbsp;            }</b>
<i>2873</i>&nbsp;        }
<i>2874</i>&nbsp;    }
<b class="nc"><i>2875</i>&nbsp;</b>
<b class="nc"><i>2876</i>&nbsp;    private void removeFromWindowList() {</b>
<b class="nc"><i>2877</i>&nbsp;        removeFromWindowList(appContext, weakThis);</b>
<b class="nc"><i>2878</i>&nbsp;    }</b>
<i>2879</i>&nbsp;
<i>2880</i>&nbsp;    /**
<i>2881</i>&nbsp;     * Window type.
<i>2882</i>&nbsp;     *
<i>2883</i>&nbsp;     * Synchronization: ObjectLock
<i>2884</i>&nbsp;     */
<i>2885</i>&nbsp;    private Type type = Type.NORMAL;
<i>2886</i>&nbsp;
<i>2887</i>&nbsp;    /**
<b class="nc"><i>2888</i>&nbsp;     * Sets the type of the window.</b>
<b class="nc"><i>2889</i>&nbsp;     *</b>
<b class="nc"><i>2890</i>&nbsp;     * This method can only be called while the window is not displayable.</b>
<i>2891</i>&nbsp;     *
<i>2892</i>&nbsp;     * @param  type the window type
<i>2893</i>&nbsp;     * @throws IllegalComponentStateException if the window
<i>2894</i>&nbsp;     *         is displayable.
<i>2895</i>&nbsp;     * @throws IllegalArgumentException if the type is {@code null}
<i>2896</i>&nbsp;     * @see    Component#isDisplayable
<i>2897</i>&nbsp;     * @see    #getType
<b class="nc"><i>2898</i>&nbsp;     * @since 1.7</b>
<i>2899</i>&nbsp;     */
<i>2900</i>&nbsp;    public void setType(Type type) {
<i>2901</i>&nbsp;        if (type == null) {
<i>2902</i>&nbsp;            throw new IllegalArgumentException(&quot;type should not be null.&quot;);
<i>2903</i>&nbsp;        }
<i>2904</i>&nbsp;        synchronized (getTreeLock()) {
<i>2905</i>&nbsp;            if (isDisplayable()) {
<i>2906</i>&nbsp;                throw new IllegalComponentStateException(
<i>2907</i>&nbsp;                        &quot;The window is displayable.&quot;);
<i>2908</i>&nbsp;            }
<i>2909</i>&nbsp;            synchronized (getObjectLock()) {
<i>2910</i>&nbsp;                this.type = type;
<i>2911</i>&nbsp;            }
<i>2912</i>&nbsp;        }
<i>2913</i>&nbsp;    }
<i>2914</i>&nbsp;
<i>2915</i>&nbsp;    /**
<i>2916</i>&nbsp;     * Returns the type of the window.
<i>2917</i>&nbsp;     *
<i>2918</i>&nbsp;     * @return the type of the window
<i>2919</i>&nbsp;     * @see   #setType
<i>2920</i>&nbsp;     * @since 1.7
<i>2921</i>&nbsp;     */
<i>2922</i>&nbsp;    public Type getType() {
<i>2923</i>&nbsp;        synchronized (getObjectLock()) {
<i>2924</i>&nbsp;            return type;
<i>2925</i>&nbsp;        }
<b class="nc"><i>2926</i>&nbsp;    }</b>
<i>2927</i>&nbsp;
<i>2928</i>&nbsp;    /**
<b class="nc"><i>2929</i>&nbsp;     * The window serialized data version.</b>
<b class="nc"><i>2930</i>&nbsp;     *</b>
<b class="nc"><i>2931</i>&nbsp;     * @serial</b>
<i>2932</i>&nbsp;     */
<b class="nc"><i>2933</i>&nbsp;    private int windowSerializedDataVersion = 2;</b>
<i>2934</i>&nbsp;
<i>2935</i>&nbsp;    /**
<b class="nc"><i>2936</i>&nbsp;     * Writes default serializable fields to stream.  Writes</b>
<i>2937</i>&nbsp;     * a list of serializable {@code WindowListener}s and
<b class="nc"><i>2938</i>&nbsp;     * {@code WindowFocusListener}s as optional data.</b>
<b class="nc"><i>2939</i>&nbsp;     * Writes a list of child windows as optional data.</b>
<b class="nc"><i>2940</i>&nbsp;     * Writes a list of icon images as optional data</b>
<b class="nc"><i>2941</i>&nbsp;     *</b>
<i>2942</i>&nbsp;     * @param s the {@code ObjectOutputStream} to write
<b class="nc"><i>2943</i>&nbsp;     * @serialData {@code null} terminated sequence of</b>
<i>2944</i>&nbsp;     *    0 or more pairs; the pair consists of a {@code String}
<b class="nc"><i>2945</i>&nbsp;     *    and {@code Object}; the {@code String}</b>
<b class="nc"><i>2946</i>&nbsp;     *    indicates the type of object and is one of the following:</b>
<b class="nc"><i>2947</i>&nbsp;     *    {@code windowListenerK} indicating a</b>
<b class="nc"><i>2948</i>&nbsp;     *      {@code WindowListener} object;</b>
<b class="nc"><i>2949</i>&nbsp;     *    {@code windowFocusWindowK} indicating a</b>
<b class="nc"><i>2950</i>&nbsp;     *      {@code WindowFocusListener} object;</b>
<i>2951</i>&nbsp;     *    {@code ownedWindowK} indicating a child
<i>2952</i>&nbsp;     *      {@code Window} object
<b class="nc"><i>2953</i>&nbsp;     *</b>
<b class="nc"><i>2954</i>&nbsp;     * @see AWTEventMulticaster#save(java.io.ObjectOutputStream, java.lang.String, java.util.EventListener)</b>
<i>2955</i>&nbsp;     * @see Component#windowListenerK
<i>2956</i>&nbsp;     * @see Component#windowFocusListenerK
<b class="nc"><i>2957</i>&nbsp;     * @see Component#ownedWindowK</b>
<b class="nc"><i>2958</i>&nbsp;     * @see #readObject(ObjectInputStream)</b>
<b class="nc"><i>2959</i>&nbsp;     */</b>
<b class="nc"><i>2960</i>&nbsp;    private void writeObject(ObjectOutputStream s) throws IOException {</b>
<i>2961</i>&nbsp;        synchronized (this) {
<b class="nc"><i>2962</i>&nbsp;            // Update old focusMgr fields so that our object stream can be read</b>
<i>2963</i>&nbsp;            // by previous releases
<b class="nc"><i>2964</i>&nbsp;            focusMgr = new FocusManager();</b>
<i>2965</i>&nbsp;            focusMgr.focusRoot = this;
<i>2966</i>&nbsp;            focusMgr.focusOwner = getMostRecentFocusOwner();
<i>2967</i>&nbsp;
<i>2968</i>&nbsp;            s.defaultWriteObject();
<i>2969</i>&nbsp;
<i>2970</i>&nbsp;            // Clear fields so that we don&#39;t keep extra references around
<i>2971</i>&nbsp;            focusMgr = null;
<b class="nc"><i>2972</i>&nbsp;</b>
<b class="nc"><i>2973</i>&nbsp;            AWTEventMulticaster.save(s, windowListenerK, windowListener);</b>
<i>2974</i>&nbsp;            AWTEventMulticaster.save(s, windowFocusListenerK, windowFocusListener);
<i>2975</i>&nbsp;            AWTEventMulticaster.save(s, windowStateListenerK, windowStateListener);
<b class="nc"><i>2976</i>&nbsp;        }</b>
<i>2977</i>&nbsp;
<b class="nc"><i>2978</i>&nbsp;        s.writeObject(null);</b>
<i>2979</i>&nbsp;
<b class="nc"><i>2980</i>&nbsp;        synchronized (ownedWindowList) {</b>
<b class="nc"><i>2981</i>&nbsp;            for (int i = 0; i &lt; ownedWindowList.size(); i++) {</b>
<b class="nc"><i>2982</i>&nbsp;                Window child = ownedWindowList.elementAt(i).get();</b>
<i>2983</i>&nbsp;                if (child != null) {
<b class="nc"><i>2984</i>&nbsp;                    s.writeObject(ownedWindowK);</b>
<b class="nc"><i>2985</i>&nbsp;                    s.writeObject(child);</b>
<b class="nc"><i>2986</i>&nbsp;                }</b>
<i>2987</i>&nbsp;            }
<i>2988</i>&nbsp;        }
<i>2989</i>&nbsp;        s.writeObject(null);
<i>2990</i>&nbsp;
<i>2991</i>&nbsp;        //write icon array
<b class="nc"><i>2992</i>&nbsp;        if (icons != null) {</b>
<i>2993</i>&nbsp;            for (Image i : icons) {
<i>2994</i>&nbsp;                if (i instanceof Serializable) {
<i>2995</i>&nbsp;                    s.writeObject(i);
<b class="nc"><i>2996</i>&nbsp;                }</b>
<b class="nc"><i>2997</i>&nbsp;            }</b>
<b class="nc"><i>2998</i>&nbsp;        }</b>
<b class="nc"><i>2999</i>&nbsp;        s.writeObject(null);</b>
<i>3000</i>&nbsp;    }
<i>3001</i>&nbsp;
<i>3002</i>&nbsp;    //
<i>3003</i>&nbsp;    // Part of deserialization procedure to be called before
<i>3004</i>&nbsp;    // user&#39;s code.
<i>3005</i>&nbsp;    //
<b class="nc"><i>3006</i>&nbsp;    private void initDeserializedWindow() {</b>
<i>3007</i>&nbsp;        setWarningString();
<i>3008</i>&nbsp;        inputContextLock = new Object();
<i>3009</i>&nbsp;
<i>3010</i>&nbsp;        // Deserialized Windows are not yet visible.
<i>3011</i>&nbsp;        visible = false;
<b class="nc"><i>3012</i>&nbsp;</b>
<b class="nc"><i>3013</i>&nbsp;        weakThis = new WeakReference&lt;&gt;(this);</b>
<i>3014</i>&nbsp;
<b class="nc"><i>3015</i>&nbsp;        anchor = new Object();</b>
<b class="nc"><i>3016</i>&nbsp;        disposerRecord = new WindowDisposerRecord(appContext, this);</b>
<b class="nc"><i>3017</i>&nbsp;        sun.java2d.Disposer.addRecord(anchor, disposerRecord);</b>
<b class="nc"><i>3018</i>&nbsp;</b>
<b class="nc"><i>3019</i>&nbsp;        addToWindowList();</b>
<b class="nc"><i>3020</i>&nbsp;        initGC(null);</b>
<i>3021</i>&nbsp;        ownedWindowList = new Vector&lt;&gt;();
<b class="nc"><i>3022</i>&nbsp;    }</b>
<b class="nc"><i>3023</i>&nbsp;</b>
<i>3024</i>&nbsp;    private void deserializeResources(ObjectInputStream s)
<i>3025</i>&nbsp;        throws ClassNotFoundException, IOException, HeadlessException {
<b class="nc"><i>3026</i>&nbsp;</b>
<b class="nc"><i>3027</i>&nbsp;            if (windowSerializedDataVersion &lt; 2) {</b>
<i>3028</i>&nbsp;                // Translate old-style focus tracking to new model. For 1.4 and
<b class="nc"><i>3029</i>&nbsp;                // later releases, we&#39;ll rely on the Window&#39;s initial focusable</b>
<b class="nc"><i>3030</i>&nbsp;                // Component.</b>
<i>3031</i>&nbsp;                if (focusMgr != null) {
<i>3032</i>&nbsp;                    if (focusMgr.focusOwner != null) {
<b class="nc"><i>3033</i>&nbsp;                        KeyboardFocusManager.</b>
<b class="nc"><i>3034</i>&nbsp;                            setMostRecentFocusOwner(this, focusMgr.focusOwner);</b>
<i>3035</i>&nbsp;                    }
<i>3036</i>&nbsp;                }
<b class="nc"><i>3037</i>&nbsp;</b>
<i>3038</i>&nbsp;                // This field is non-transient and relies on default serialization.
<b class="nc"><i>3039</i>&nbsp;                // However, the default value is insufficient, so we need to set</b>
<i>3040</i>&nbsp;                // it explicitly for object data streams prior to 1.4.
<b class="nc"><i>3041</i>&nbsp;                focusableWindowState = true;</b>
<b class="nc"><i>3042</i>&nbsp;</b>
<b class="nc"><i>3043</i>&nbsp;</b>
<i>3044</i>&nbsp;            }
<b class="nc"><i>3045</i>&nbsp;</b>
<i>3046</i>&nbsp;        Object keyOrNull;
<i>3047</i>&nbsp;        while(null != (keyOrNull = s.readObject())) {
<b class="nc"><i>3048</i>&nbsp;            String key = ((String)keyOrNull).intern();</b>
<i>3049</i>&nbsp;
<i>3050</i>&nbsp;            if (windowListenerK == key) {
<b class="nc"><i>3051</i>&nbsp;                addWindowListener((WindowListener)(s.readObject()));</b>
<i>3052</i>&nbsp;            } else if (windowFocusListenerK == key) {
<i>3053</i>&nbsp;                addWindowFocusListener((WindowFocusListener)(s.readObject()));
<i>3054</i>&nbsp;            } else if (windowStateListenerK == key) {
<i>3055</i>&nbsp;                addWindowStateListener((WindowStateListener)(s.readObject()));
<i>3056</i>&nbsp;            } else // skip value for unrecognized key
<i>3057</i>&nbsp;                s.readObject();
<i>3058</i>&nbsp;        }
<i>3059</i>&nbsp;
<i>3060</i>&nbsp;        try {
<i>3061</i>&nbsp;            while (null != (keyOrNull = s.readObject())) {
<i>3062</i>&nbsp;                String key = ((String)keyOrNull).intern();
<i>3063</i>&nbsp;
<i>3064</i>&nbsp;                if (ownedWindowK == key)
<i>3065</i>&nbsp;                    connectOwnedWindow((Window) s.readObject());
<i>3066</i>&nbsp;
<i>3067</i>&nbsp;                else // skip value for unrecognized key
<i>3068</i>&nbsp;                    s.readObject();
<i>3069</i>&nbsp;            }
<i>3070</i>&nbsp;
<i>3071</i>&nbsp;            //read icons
<b class="nc"><i>3072</i>&nbsp;            Object obj = s.readObject(); //Throws OptionalDataException</b>
<b class="nc"><i>3073</i>&nbsp;                                         //for pre1.6 objects.</b>
<b class="nc"><i>3074</i>&nbsp;            icons = new ArrayList&lt;Image&gt;(); //Frame.readObject() assumes</b>
<i>3075</i>&nbsp;                                            //pre1.6 version if icons is null.
<b class="nc"><i>3076</i>&nbsp;            while (obj != null) {</b>
<b class="nc"><i>3077</i>&nbsp;                if (obj instanceof Image) {</b>
<b class="nc"><i>3078</i>&nbsp;                    icons.add((Image)obj);</b>
<b class="nc"><i>3079</i>&nbsp;                }</b>
<b class="nc"><i>3080</i>&nbsp;                obj = s.readObject();</b>
<i>3081</i>&nbsp;            }
<b class="nc"><i>3082</i>&nbsp;        }</b>
<b class="nc"><i>3083</i>&nbsp;        catch (OptionalDataException e) {</b>
<b class="nc"><i>3084</i>&nbsp;            // 1.1 serialized form</b>
<b class="nc"><i>3085</i>&nbsp;            // ownedWindowList will be updated by Frame.readObject</b>
<b class="nc"><i>3086</i>&nbsp;        }</b>
<b class="nc"><i>3087</i>&nbsp;</b>
<b class="nc"><i>3088</i>&nbsp;    }</b>
<i>3089</i>&nbsp;
<b class="nc"><i>3090</i>&nbsp;    /**</b>
<b class="nc"><i>3091</i>&nbsp;     * Reads the {@code ObjectInputStream} and an optional</b>
<i>3092</i>&nbsp;     * list of listeners to receive various events fired by
<b class="nc"><i>3093</i>&nbsp;     * the component; also reads a list of</b>
<b class="nc"><i>3094</i>&nbsp;     * (possibly {@code null}) child windows.</b>
<b class="nc"><i>3095</i>&nbsp;     * Unrecognized keys or values will be ignored.</b>
<b class="nc"><i>3096</i>&nbsp;     *</b>
<b class="nc"><i>3097</i>&nbsp;     * @param s the {@code ObjectInputStream} to read</b>
<b class="nc"><i>3098</i>&nbsp;     * @exception HeadlessException if</b>
<i>3099</i>&nbsp;     *   {@code GraphicsEnvironment.isHeadless} returns
<b class="nc"><i>3100</i>&nbsp;     *   {@code true}</b>
<i>3101</i>&nbsp;     * @see java.awt.GraphicsEnvironment#isHeadless
<i>3102</i>&nbsp;     * @see #writeObject
<i>3103</i>&nbsp;     */
<i>3104</i>&nbsp;    private void readObject(ObjectInputStream s)
<i>3105</i>&nbsp;      throws ClassNotFoundException, IOException, HeadlessException
<i>3106</i>&nbsp;    {
<i>3107</i>&nbsp;         GraphicsEnvironment.checkHeadless();
<i>3108</i>&nbsp;         initDeserializedWindow();
<i>3109</i>&nbsp;         ObjectInputStream.GetField f = s.readFields();
<i>3110</i>&nbsp;
<i>3111</i>&nbsp;         syncLWRequests = f.get(&quot;syncLWRequests&quot;, systemSyncLWRequests);
<i>3112</i>&nbsp;         state = f.get(&quot;state&quot;, 0);
<i>3113</i>&nbsp;         focusableWindowState = f.get(&quot;focusableWindowState&quot;, true);
<i>3114</i>&nbsp;         windowSerializedDataVersion = f.get(&quot;windowSerializedDataVersion&quot;, 1);
<i>3115</i>&nbsp;         locationByPlatform = f.get(&quot;locationByPlatform&quot;, locationByPlatformProp);
<i>3116</i>&nbsp;         // Note: 1.4 (or later) doesn&#39;t use focusMgr
<i>3117</i>&nbsp;         focusMgr = (FocusManager)f.get(&quot;focusMgr&quot;, null);
<i>3118</i>&nbsp;         Dialog.ModalExclusionType et = (Dialog.ModalExclusionType)
<b class="nc"><i>3119</i>&nbsp;             f.get(&quot;modalExclusionType&quot;, Dialog.ModalExclusionType.NO_EXCLUDE);</b>
<b class="nc"><i>3120</i>&nbsp;         setModalExclusionType(et); // since 6.0</b>
<i>3121</i>&nbsp;         boolean aot = f.get(&quot;alwaysOnTop&quot;, false);
<b class="nc"><i>3122</i>&nbsp;         if(aot) {</b>
<i>3123</i>&nbsp;             setAlwaysOnTop(aot); // since 1.5; subject to permission check
<i>3124</i>&nbsp;         }
<i>3125</i>&nbsp;         shape = (Shape)f.get(&quot;shape&quot;, null);
<i>3126</i>&nbsp;         opacity = (Float)f.get(&quot;opacity&quot;, 1.0f);
<i>3127</i>&nbsp;
<i>3128</i>&nbsp;         this.securityWarningWidth = 0;
<i>3129</i>&nbsp;         this.securityWarningHeight = 0;
<i>3130</i>&nbsp;         this.securityWarningPointX = 2.0;
<b class="nc"><i>3131</i>&nbsp;         this.securityWarningPointY = 0.0;</b>
<i>3132</i>&nbsp;         this.securityWarningAlignmentX = RIGHT_ALIGNMENT;
<i>3133</i>&nbsp;         this.securityWarningAlignmentY = TOP_ALIGNMENT;
<i>3134</i>&nbsp;
<i>3135</i>&nbsp;         deserializeResources(s);
<i>3136</i>&nbsp;    }
<i>3137</i>&nbsp;
<i>3138</i>&nbsp;    /*
<i>3139</i>&nbsp;     * --- Accessibility Support ---
<i>3140</i>&nbsp;     *
<i>3141</i>&nbsp;     */
<i>3142</i>&nbsp;
<i>3143</i>&nbsp;    /**
<i>3144</i>&nbsp;     * Gets the AccessibleContext associated with this Window.
<i>3145</i>&nbsp;     * For windows, the AccessibleContext takes the form of an
<b class="nc"><i>3146</i>&nbsp;     * AccessibleAWTWindow.</b>
<i>3147</i>&nbsp;     * A new AccessibleAWTWindow instance is created if necessary.
<i>3148</i>&nbsp;     *
<i>3149</i>&nbsp;     * @return an AccessibleAWTWindow that serves as the
<i>3150</i>&nbsp;     *         AccessibleContext of this Window
<i>3151</i>&nbsp;     * @since 1.3
<i>3152</i>&nbsp;     */
<i>3153</i>&nbsp;    public AccessibleContext getAccessibleContext() {
<i>3154</i>&nbsp;        if (accessibleContext == null) {
<i>3155</i>&nbsp;            accessibleContext = new AccessibleAWTWindow();
<i>3156</i>&nbsp;        }
<b class="nc"><i>3157</i>&nbsp;        return accessibleContext;</b>
<b class="nc"><i>3158</i>&nbsp;    }</b>
<b class="nc"><i>3159</i>&nbsp;</b>
<i>3160</i>&nbsp;    /**
<b class="nc"><i>3161</i>&nbsp;     * This class implements accessibility support for the</b>
<i>3162</i>&nbsp;     * {@code Window} class.  It provides an implementation of the
<i>3163</i>&nbsp;     * Java Accessibility API appropriate to window user-interface elements.
<i>3164</i>&nbsp;     * @since 1.3
<i>3165</i>&nbsp;     */
<i>3166</i>&nbsp;    protected class AccessibleAWTWindow extends AccessibleAWTContainer
<i>3167</i>&nbsp;    {
<b class="nc"><i>3168</i>&nbsp;        /*</b>
<i>3169</i>&nbsp;         * JDK 1.3 serialVersionUID
<b class="nc"><i>3170</i>&nbsp;         */</b>
<b class="nc"><i>3171</i>&nbsp;        private static final long serialVersionUID = 4215068635060671780L;</b>
<b class="nc"><i>3172</i>&nbsp;</b>
<i>3173</i>&nbsp;        /**
<b class="nc"><i>3174</i>&nbsp;         * Get the role of this object.</b>
<b class="nc"><i>3175</i>&nbsp;         *</b>
<b class="nc"><i>3176</i>&nbsp;         * @return an instance of AccessibleRole describing the role of the</b>
<b class="nc"><i>3177</i>&nbsp;         * object</b>
<i>3178</i>&nbsp;         * @see javax.accessibility.AccessibleRole
<b class="nc"><i>3179</i>&nbsp;         */</b>
<i>3180</i>&nbsp;        public AccessibleRole getAccessibleRole() {
<i>3181</i>&nbsp;            return AccessibleRole.WINDOW;
<i>3182</i>&nbsp;        }
<i>3183</i>&nbsp;
<i>3184</i>&nbsp;        /**
<i>3185</i>&nbsp;         * Get the state of this object.
<i>3186</i>&nbsp;         *
<i>3187</i>&nbsp;         * @return an instance of AccessibleStateSet containing the current
<i>3188</i>&nbsp;         * state set of the object
<i>3189</i>&nbsp;         * @see javax.accessibility.AccessibleState
<i>3190</i>&nbsp;         */
<i>3191</i>&nbsp;        public AccessibleStateSet getAccessibleStateSet() {
<i>3192</i>&nbsp;            AccessibleStateSet states = super.getAccessibleStateSet();
<i>3193</i>&nbsp;            if (getFocusOwner() != null) {
<i>3194</i>&nbsp;                states.add(AccessibleState.ACTIVE);
<i>3195</i>&nbsp;            }
<i>3196</i>&nbsp;            return states;
<i>3197</i>&nbsp;        }
<i>3198</i>&nbsp;
<i>3199</i>&nbsp;    } // inner class AccessibleAWTWindow
<i>3200</i>&nbsp;
<i>3201</i>&nbsp;    @Override
<i>3202</i>&nbsp;    void setGraphicsConfiguration(GraphicsConfiguration gc) {
<i>3203</i>&nbsp;        if (gc == null) {
<i>3204</i>&nbsp;            gc = GraphicsEnvironment.
<i>3205</i>&nbsp;                    getLocalGraphicsEnvironment().
<i>3206</i>&nbsp;                    getDefaultScreenDevice().
<i>3207</i>&nbsp;                    getDefaultConfiguration();
<i>3208</i>&nbsp;        }
<i>3209</i>&nbsp;        synchronized (getTreeLock()) {
<i>3210</i>&nbsp;            super.setGraphicsConfiguration(gc);
<i>3211</i>&nbsp;            if (log.isLoggable(PlatformLogger.Level.FINER)) {
<i>3212</i>&nbsp;                log.finer(&quot;+ Window.setGraphicsConfiguration(): new GC is \n+ &quot; + getGraphicsConfiguration_NoClientCode() + &quot;\n+ this is &quot; + this);
<i>3213</i>&nbsp;            }
<i>3214</i>&nbsp;        }
<i>3215</i>&nbsp;    }
<i>3216</i>&nbsp;
<i>3217</i>&nbsp;    /**
<i>3218</i>&nbsp;     * Sets the location of the window relative to the specified
<i>3219</i>&nbsp;     * component according to the following scenarios.
<i>3220</i>&nbsp;     * &lt;p&gt;
<i>3221</i>&nbsp;     * The target screen mentioned below is a screen to which
<i>3222</i>&nbsp;     * the window should be placed after the setLocationRelativeTo
<i>3223</i>&nbsp;     * method is called.
<i>3224</i>&nbsp;     * &lt;ul&gt;
<i>3225</i>&nbsp;     * &lt;li&gt;If the component is {@code null}, or the {@code
<i>3226</i>&nbsp;     * GraphicsConfiguration} associated with this component is
<i>3227</i>&nbsp;     * {@code null}, the window is placed in the center of the
<i>3228</i>&nbsp;     * screen. The center point can be obtained with the {@link
<i>3229</i>&nbsp;     * GraphicsEnvironment#getCenterPoint
<i>3230</i>&nbsp;     * GraphicsEnvironment.getCenterPoint} method.
<i>3231</i>&nbsp;     * &lt;li&gt;If the component is not {@code null}, but it is not
<i>3232</i>&nbsp;     * currently showing, the window is placed in the center of
<i>3233</i>&nbsp;     * the target screen defined by the {@code
<i>3234</i>&nbsp;     * GraphicsConfiguration} associated with this component.
<i>3235</i>&nbsp;     * &lt;li&gt;If the component is not {@code null} and is shown on
<i>3236</i>&nbsp;     * the screen, then the window is located in such a way that
<i>3237</i>&nbsp;     * the center of the window coincides with the center of the
<i>3238</i>&nbsp;     * component.
<i>3239</i>&nbsp;     * &lt;/ul&gt;
<b class="nc"><i>3240</i>&nbsp;     * &lt;p&gt;</b>
<i>3241</i>&nbsp;     * If the screens configuration does not allow the window to
<b class="nc"><i>3242</i>&nbsp;     * be moved from one screen to another, then the window is</b>
<b class="nc"><i>3243</i>&nbsp;     * only placed at the location determined according to the</b>
<i>3244</i>&nbsp;     * above conditions and its {@code GraphicsConfiguration} is
<b class="nc"><i>3245</i>&nbsp;     * not changed.</b>
<i>3246</i>&nbsp;     * &lt;p&gt;
<i>3247</i>&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: If the lower edge of the window is out of the screen,
<b class="nc"><i>3248</i>&nbsp;     * then the window is placed to the side of the {@code Component}</b>
<b class="nc"><i>3249</i>&nbsp;     * that is closest to the center of the screen. So if the</b>
<b class="nc"><i>3250</i>&nbsp;     * component is on the right part of the screen, the window</b>
<b class="nc"><i>3251</i>&nbsp;     * is placed to its left, and vice versa.</b>
<b class="nc"><i>3252</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3253</i>&nbsp;     * If after the window location has been calculated, the upper,</b>
<b class="nc"><i>3254</i>&nbsp;     * left, or right edge of the window is out of the screen,</b>
<b class="nc"><i>3255</i>&nbsp;     * then the window is located in such a way that the upper,</b>
<b class="nc"><i>3256</i>&nbsp;     * left, or right edge of the window coincides with the</b>
<b class="nc"><i>3257</i>&nbsp;     * corresponding edge of the screen. If both left and right</b>
<b class="nc"><i>3258</i>&nbsp;     * edges of the window are out of the screen, the window is</b>
<b class="nc"><i>3259</i>&nbsp;     * placed at the left side of the screen. The similar placement</b>
<b class="nc"><i>3260</i>&nbsp;     * will occur if both top and bottom edges are out of the screen.</b>
<i>3261</i>&nbsp;     * In that case, the window is placed at the top side of the screen.
<b class="nc"><i>3262</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3263</i>&nbsp;     * The method changes the geometry-related data. Therefore,</b>
<b class="nc"><i>3264</i>&nbsp;     * the native windowing system may ignore such requests, or it may modify</b>
<b class="nc"><i>3265</i>&nbsp;     * the requested data, so that the {@code Window} object is placed and sized</b>
<b class="nc"><i>3266</i>&nbsp;     * in a way that corresponds closely to the desktop settings.</b>
<b class="nc"><i>3267</i>&nbsp;     *</b>
<i>3268</i>&nbsp;     * @param c  the component in relation to which the window&#39;s location
<i>3269</i>&nbsp;     *           is determined
<b class="nc"><i>3270</i>&nbsp;     * @see java.awt.GraphicsEnvironment#getCenterPoint</b>
<b class="nc"><i>3271</i>&nbsp;     * @since 1.4</b>
<b class="nc"><i>3272</i>&nbsp;     */</b>
<b class="nc"><i>3273</i>&nbsp;    public void setLocationRelativeTo(Component c) {</b>
<i>3274</i>&nbsp;        // target location
<b class="nc"><i>3275</i>&nbsp;        int dx = 0, dy = 0;</b>
<i>3276</i>&nbsp;        // target GC
<i>3277</i>&nbsp;        GraphicsConfiguration gc = getGraphicsConfiguration_NoClientCode();
<i>3278</i>&nbsp;        Rectangle gcBounds = gc.getBounds();
<i>3279</i>&nbsp;
<i>3280</i>&nbsp;        Dimension windowSize = getSize();
<i>3281</i>&nbsp;
<b class="nc"><i>3282</i>&nbsp;        // search a top-level of c</b>
<b class="nc"><i>3283</i>&nbsp;        Window componentWindow = SunToolkit.getContainingWindow(c);</b>
<i>3284</i>&nbsp;        if ((c == null) || (componentWindow == null)) {
<i>3285</i>&nbsp;            GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
<b class="nc"><i>3286</i>&nbsp;            gc = ge.getDefaultScreenDevice().getDefaultConfiguration();</b>
<b class="nc"><i>3287</i>&nbsp;            gcBounds = gc.getBounds();</b>
<i>3288</i>&nbsp;            Point centerPoint = ge.getCenterPoint();
<i>3289</i>&nbsp;            dx = centerPoint.x - windowSize.width / 2;
<b class="nc"><i>3290</i>&nbsp;            dy = centerPoint.y - windowSize.height / 2;</b>
<b class="nc"><i>3291</i>&nbsp;        } else if (!c.isShowing()) {</b>
<i>3292</i>&nbsp;            gc = componentWindow.getGraphicsConfiguration();
<i>3293</i>&nbsp;            gcBounds = gc.getBounds();
<b class="nc"><i>3294</i>&nbsp;            dx = gcBounds.x + (gcBounds.width - windowSize.width) / 2;</b>
<b class="nc"><i>3295</i>&nbsp;            dy = gcBounds.y + (gcBounds.height - windowSize.height) / 2;</b>
<i>3296</i>&nbsp;        } else {
<i>3297</i>&nbsp;            gc = componentWindow.getGraphicsConfiguration();
<b class="nc"><i>3298</i>&nbsp;            gcBounds = gc.getBounds();</b>
<i>3299</i>&nbsp;            Dimension compSize = c.getSize();
<i>3300</i>&nbsp;            Point compLocation = c.getLocationOnScreen();
<i>3301</i>&nbsp;            dx = compLocation.x + ((compSize.width - windowSize.width) / 2);
<i>3302</i>&nbsp;            dy = compLocation.y + ((compSize.height - windowSize.height) / 2);
<i>3303</i>&nbsp;
<i>3304</i>&nbsp;            // Adjust for bottom edge being offscreen
<i>3305</i>&nbsp;            if (dy + windowSize.height &gt; gcBounds.y + gcBounds.height) {
<i>3306</i>&nbsp;                dy = gcBounds.y + gcBounds.height - windowSize.height;
<i>3307</i>&nbsp;                if (compLocation.x - gcBounds.x + compSize.width / 2 &lt; gcBounds.width / 2) {
<i>3308</i>&nbsp;                    dx = compLocation.x + compSize.width;
<i>3309</i>&nbsp;                } else {
<b class="nc"><i>3310</i>&nbsp;                    dx = compLocation.x - windowSize.width;</b>
<i>3311</i>&nbsp;                }
<i>3312</i>&nbsp;            }
<i>3313</i>&nbsp;        }
<i>3314</i>&nbsp;
<i>3315</i>&nbsp;        // Avoid being placed off the edge of the screen:
<i>3316</i>&nbsp;        // bottom
<i>3317</i>&nbsp;        if (dy + windowSize.height &gt; gcBounds.y + gcBounds.height) {
<i>3318</i>&nbsp;            dy = gcBounds.y + gcBounds.height - windowSize.height;
<i>3319</i>&nbsp;        }
<i>3320</i>&nbsp;        // top
<i>3321</i>&nbsp;        if (dy &lt; gcBounds.y) {
<i>3322</i>&nbsp;            dy = gcBounds.y;
<i>3323</i>&nbsp;        }
<i>3324</i>&nbsp;        // right
<i>3325</i>&nbsp;        if (dx + windowSize.width &gt; gcBounds.x + gcBounds.width) {
<i>3326</i>&nbsp;            dx = gcBounds.x + gcBounds.width - windowSize.width;
<i>3327</i>&nbsp;        }
<i>3328</i>&nbsp;        // left
<i>3329</i>&nbsp;        if (dx &lt; gcBounds.x) {
<i>3330</i>&nbsp;            dx = gcBounds.x;
<i>3331</i>&nbsp;        }
<b class="nc"><i>3332</i>&nbsp;</b>
<i>3333</i>&nbsp;        setLocation(dx, dy);
<i>3334</i>&nbsp;    }
<i>3335</i>&nbsp;
<i>3336</i>&nbsp;    /**
<i>3337</i>&nbsp;     * Overridden from Component.  Top-level Windows should not propagate a
<i>3338</i>&nbsp;     * MouseWheelEvent beyond themselves into their owning Windows.
<i>3339</i>&nbsp;     */
<i>3340</i>&nbsp;    void deliverMouseWheelToAncestor(MouseWheelEvent e) {}
<i>3341</i>&nbsp;
<i>3342</i>&nbsp;    /**
<i>3343</i>&nbsp;     * Overridden from Component.  Top-level Windows don&#39;t dispatch to ancestors
<i>3344</i>&nbsp;     */
<i>3345</i>&nbsp;    boolean dispatchMouseWheelToAncestor(MouseWheelEvent e) {return false;}
<i>3346</i>&nbsp;
<i>3347</i>&nbsp;    /**
<i>3348</i>&nbsp;     * Creates a new strategy for multi-buffering on this component.
<i>3349</i>&nbsp;     * Multi-buffering is useful for rendering performance.  This method
<i>3350</i>&nbsp;     * attempts to create the best strategy available with the number of
<i>3351</i>&nbsp;     * buffers supplied.  It will always create a {@code BufferStrategy}
<i>3352</i>&nbsp;     * with that number of buffers.
<i>3353</i>&nbsp;     * A page-flipping strategy is attempted first, then a blitting strategy
<i>3354</i>&nbsp;     * using accelerated buffers.  Finally, an unaccelerated blitting
<i>3355</i>&nbsp;     * strategy is used.
<i>3356</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>3357</i>&nbsp;     * Each time this method is called,</b>
<i>3358</i>&nbsp;     * the existing buffer strategy for this component is discarded.
<i>3359</i>&nbsp;     * @param numBuffers number of buffers to create
<i>3360</i>&nbsp;     * @exception IllegalArgumentException if numBuffers is less than 1.
<i>3361</i>&nbsp;     * @exception IllegalStateException if the component is not displayable
<i>3362</i>&nbsp;     * @see #isDisplayable
<i>3363</i>&nbsp;     * @see #getBufferStrategy
<i>3364</i>&nbsp;     * @since 1.4
<i>3365</i>&nbsp;     */
<i>3366</i>&nbsp;    public void createBufferStrategy(int numBuffers) {
<i>3367</i>&nbsp;        super.createBufferStrategy(numBuffers);
<i>3368</i>&nbsp;    }
<i>3369</i>&nbsp;
<b class="nc"><i>3370</i>&nbsp;    /**</b>
<i>3371</i>&nbsp;     * Creates a new strategy for multi-buffering on this component with the
<i>3372</i>&nbsp;     * required buffer capabilities.  This is useful, for example, if only
<i>3373</i>&nbsp;     * accelerated memory or page flipping is desired (as specified by the
<b class="nc"><i>3374</i>&nbsp;     * buffer capabilities).</b>
<i>3375</i>&nbsp;     * &lt;p&gt;
<i>3376</i>&nbsp;     * Each time this method
<b class="nc"><i>3377</i>&nbsp;     * is called, the existing buffer strategy for this component is discarded.</b>
<i>3378</i>&nbsp;     * @param numBuffers number of buffers to create, including the front buffer
<i>3379</i>&nbsp;     * @param caps the required capabilities for creating the buffer strategy;
<b class="nc"><i>3380</i>&nbsp;     * cannot be {@code null}</b>
<b class="nc"><i>3381</i>&nbsp;     * @exception AWTException if the capabilities supplied could not be</b>
<i>3382</i>&nbsp;     * supported or met; this may happen, for example, if there is not enough
<b class="nc"><i>3383</i>&nbsp;     * accelerated memory currently available, or if page flipping is specified</b>
<i>3384</i>&nbsp;     * but not possible.
<b class="nc"><i>3385</i>&nbsp;     * @exception IllegalArgumentException if numBuffers is less than 1, or if</b>
<i>3386</i>&nbsp;     * caps is {@code null}
<i>3387</i>&nbsp;     * @see #getBufferStrategy
<i>3388</i>&nbsp;     * @since 1.4
<i>3389</i>&nbsp;     */
<i>3390</i>&nbsp;    public void createBufferStrategy(int numBuffers,
<i>3391</i>&nbsp;        BufferCapabilities caps) throws AWTException {
<i>3392</i>&nbsp;        super.createBufferStrategy(numBuffers, caps);
<i>3393</i>&nbsp;    }
<b class="nc"><i>3394</i>&nbsp;</b>
<i>3395</i>&nbsp;    /**
<i>3396</i>&nbsp;     * Returns the {@code BufferStrategy} used by this component.  This
<b class="nc"><i>3397</i>&nbsp;     * method will return null if a {@code BufferStrategy} has not yet</b>
<i>3398</i>&nbsp;     * been created or has been disposed.
<i>3399</i>&nbsp;     *
<i>3400</i>&nbsp;     * @return the buffer strategy used by this component
<i>3401</i>&nbsp;     * @see #createBufferStrategy
<i>3402</i>&nbsp;     * @since 1.4
<i>3403</i>&nbsp;     */
<i>3404</i>&nbsp;    public BufferStrategy getBufferStrategy() {
<i>3405</i>&nbsp;        return super.getBufferStrategy();
<i>3406</i>&nbsp;    }
<i>3407</i>&nbsp;
<i>3408</i>&nbsp;    Component getTemporaryLostComponent() {
<i>3409</i>&nbsp;        return temporaryLostComponent;
<i>3410</i>&nbsp;    }
<i>3411</i>&nbsp;    Component setTemporaryLostComponent(Component component) {
<i>3412</i>&nbsp;        Component previousComp = temporaryLostComponent;
<i>3413</i>&nbsp;        // Check that &quot;component&quot; is an acceptable focus owner and don&#39;t store it otherwise
<i>3414</i>&nbsp;        // - or later we will have problems with opposite while handling  WINDOW_GAINED_FOCUS
<i>3415</i>&nbsp;        if (component == null || component.canBeFocusOwner()) {
<i>3416</i>&nbsp;            temporaryLostComponent = component;
<i>3417</i>&nbsp;        } else {
<i>3418</i>&nbsp;            temporaryLostComponent = null;
<i>3419</i>&nbsp;        }
<i>3420</i>&nbsp;        return previousComp;
<i>3421</i>&nbsp;    }
<i>3422</i>&nbsp;
<i>3423</i>&nbsp;    /**
<i>3424</i>&nbsp;     * Checks whether this window can contain focus owner.
<i>3425</i>&nbsp;     * Verifies that it is focusable and as container it can container focus owner.
<i>3426</i>&nbsp;     * @since 1.5
<i>3427</i>&nbsp;     */
<i>3428</i>&nbsp;    boolean canContainFocusOwner(Component focusOwnerCandidate) {
<i>3429</i>&nbsp;        return super.canContainFocusOwner(focusOwnerCandidate) &amp;&amp; isFocusableWindow();
<i>3430</i>&nbsp;    }
<i>3431</i>&nbsp;
<i>3432</i>&nbsp;    private volatile boolean locationByPlatform = locationByPlatformProp;
<i>3433</i>&nbsp;
<i>3434</i>&nbsp;
<i>3435</i>&nbsp;    /**
<i>3436</i>&nbsp;     * Sets whether this Window should appear at the default location for the
<i>3437</i>&nbsp;     * native windowing system or at the current location (returned by
<i>3438</i>&nbsp;     * {@code getLocation}) the next time the Window is made visible.
<i>3439</i>&nbsp;     * This behavior resembles a native window shown without programmatically
<i>3440</i>&nbsp;     * setting its location.  Most windowing systems cascade windows if their
<i>3441</i>&nbsp;     * locations are not explicitly set. The actual location is determined once the
<i>3442</i>&nbsp;     * window is shown on the screen.
<i>3443</i>&nbsp;     * &lt;p&gt;
<i>3444</i>&nbsp;     * This behavior can also be enabled by setting the System Property
<i>3445</i>&nbsp;     * &quot;java.awt.Window.locationByPlatform&quot; to &quot;true&quot;, though calls to this method
<i>3446</i>&nbsp;     * take precedence.
<i>3447</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>3448</i>&nbsp;     * Calls to {@code setVisible}, {@code setLocation} and</b>
<b class="nc"><i>3449</i>&nbsp;     * {@code setBounds} after calling {@code setLocationByPlatform} clear</b>
<b class="nc"><i>3450</i>&nbsp;     * this property of the Window.</b>
<i>3451</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>3452</i>&nbsp;     * For example, after the following code is executed:</b>
<b class="nc"><i>3453</i>&nbsp;     * &lt;pre&gt;</b>
<i>3454</i>&nbsp;     * setLocationByPlatform(true);
<i>3455</i>&nbsp;     * setVisible(true);
<i>3456</i>&nbsp;     * boolean flag = isLocationByPlatform();
<i>3457</i>&nbsp;     * &lt;/pre&gt;
<i>3458</i>&nbsp;     * The window will be shown at platform&#39;s default location and
<i>3459</i>&nbsp;     * {@code flag} will be {@code false}.
<i>3460</i>&nbsp;     * &lt;p&gt;
<i>3461</i>&nbsp;     * In the following sample:
<i>3462</i>&nbsp;     * &lt;pre&gt;
<i>3463</i>&nbsp;     * setLocationByPlatform(true);
<i>3464</i>&nbsp;     * setLocation(10, 10);
<i>3465</i>&nbsp;     * boolean flag = isLocationByPlatform();
<i>3466</i>&nbsp;     * setVisible(true);
<i>3467</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>3468</i>&nbsp;     * The window will be shown at (10, 10) and {@code flag} will be</b>
<i>3469</i>&nbsp;     * {@code false}.
<i>3470</i>&nbsp;     *
<i>3471</i>&nbsp;     * @param locationByPlatform {@code true} if this Window should appear
<i>3472</i>&nbsp;     *        at the default location, {@code false} if at the current location
<i>3473</i>&nbsp;     * @throws IllegalComponentStateException if the window
<i>3474</i>&nbsp;     *         is showing on screen and locationByPlatform is {@code true}.
<i>3475</i>&nbsp;     * @see #setLocation
<i>3476</i>&nbsp;     * @see #isShowing
<i>3477</i>&nbsp;     * @see #setVisible
<i>3478</i>&nbsp;     * @see #isLocationByPlatform
<i>3479</i>&nbsp;     * @see java.lang.System#getProperty(String)
<i>3480</i>&nbsp;     * @since 1.5
<i>3481</i>&nbsp;     */
<i>3482</i>&nbsp;    public void setLocationByPlatform(boolean locationByPlatform) {
<i>3483</i>&nbsp;        synchronized (getTreeLock()) {
<i>3484</i>&nbsp;            if (locationByPlatform &amp;&amp; isShowing()) {
<i>3485</i>&nbsp;                throw new IllegalComponentStateException(&quot;The window is showing on screen.&quot;);
<i>3486</i>&nbsp;            }
<i>3487</i>&nbsp;            this.locationByPlatform = locationByPlatform;
<i>3488</i>&nbsp;        }
<i>3489</i>&nbsp;    }
<i>3490</i>&nbsp;
<i>3491</i>&nbsp;    /**
<i>3492</i>&nbsp;     * Returns {@code true} if this Window will appear at the default location
<i>3493</i>&nbsp;     * for the native windowing system the next time this Window is made visible.
<i>3494</i>&nbsp;     * This method always returns {@code false} if the Window is showing on the
<b class="nc"><i>3495</i>&nbsp;     * screen.</b>
<b class="nc"><i>3496</i>&nbsp;     *</b>
<b class="nc"><i>3497</i>&nbsp;     * @return whether this Window will appear at the default location</b>
<i>3498</i>&nbsp;     * @see #setLocationByPlatform
<b class="nc"><i>3499</i>&nbsp;     * @see #isShowing</b>
<i>3500</i>&nbsp;     * @since 1.5
<b class="nc"><i>3501</i>&nbsp;     */</b>
<b class="nc"><i>3502</i>&nbsp;    public boolean isLocationByPlatform() {</b>
<i>3503</i>&nbsp;        return locationByPlatform;
<i>3504</i>&nbsp;    }
<i>3505</i>&nbsp;
<i>3506</i>&nbsp;    /**
<i>3507</i>&nbsp;     * {@inheritDoc}
<i>3508</i>&nbsp;     * &lt;p&gt;
<i>3509</i>&nbsp;     * The {@code width} or {@code height} values
<i>3510</i>&nbsp;     * are automatically enlarged if either is less than
<i>3511</i>&nbsp;     * the minimum size as specified by previous call to
<i>3512</i>&nbsp;     * {@code setMinimumSize}.
<i>3513</i>&nbsp;     * &lt;p&gt;
<i>3514</i>&nbsp;     * The method changes the geometry-related data. Therefore,
<i>3515</i>&nbsp;     * the native windowing system may ignore such requests, or it may modify
<i>3516</i>&nbsp;     * the requested data, so that the {@code Window} object is placed and sized
<i>3517</i>&nbsp;     * in a way that corresponds closely to the desktop settings.
<i>3518</i>&nbsp;     *
<i>3519</i>&nbsp;     * @see #getBounds
<i>3520</i>&nbsp;     * @see #setLocation(int, int)
<i>3521</i>&nbsp;     * @see #setLocation(Point)
<i>3522</i>&nbsp;     * @see #setSize(int, int)
<i>3523</i>&nbsp;     * @see #setSize(Dimension)
<i>3524</i>&nbsp;     * @see #setMinimumSize
<i>3525</i>&nbsp;     * @see #setLocationByPlatform
<i>3526</i>&nbsp;     * @see #isLocationByPlatform
<i>3527</i>&nbsp;     * @since 1.6
<i>3528</i>&nbsp;     */
<b class="nc"><i>3529</i>&nbsp;    public void setBounds(int x, int y, int width, int height) {</b>
<i>3530</i>&nbsp;        synchronized (getTreeLock()) {
<i>3531</i>&nbsp;            if (getBoundsOp() == ComponentPeer.SET_LOCATION ||
<i>3532</i>&nbsp;                getBoundsOp() == ComponentPeer.SET_BOUNDS)
<i>3533</i>&nbsp;            {
<i>3534</i>&nbsp;                locationByPlatform = false;
<i>3535</i>&nbsp;            }
<i>3536</i>&nbsp;            super.setBounds(x, y, width, height);
<i>3537</i>&nbsp;        }
<i>3538</i>&nbsp;    }
<i>3539</i>&nbsp;
<b class="nc"><i>3540</i>&nbsp;    /**</b>
<i>3541</i>&nbsp;     * {@inheritDoc}
<i>3542</i>&nbsp;     * &lt;p&gt;
<i>3543</i>&nbsp;     * The {@code r.width} or {@code r.height} values
<i>3544</i>&nbsp;     * will be automatically enlarged if either is less than
<i>3545</i>&nbsp;     * the minimum size as specified by previous call to
<i>3546</i>&nbsp;     * {@code setMinimumSize}.
<i>3547</i>&nbsp;     * &lt;p&gt;
<i>3548</i>&nbsp;     * The method changes the geometry-related data. Therefore,
<i>3549</i>&nbsp;     * the native windowing system may ignore such requests, or it may modify
<i>3550</i>&nbsp;     * the requested data, so that the {@code Window} object is placed and sized
<i>3551</i>&nbsp;     * in a way that corresponds closely to the desktop settings.
<i>3552</i>&nbsp;     *
<i>3553</i>&nbsp;     * @see #getBounds
<i>3554</i>&nbsp;     * @see #setLocation(int, int)
<i>3555</i>&nbsp;     * @see #setLocation(Point)
<i>3556</i>&nbsp;     * @see #setSize(int, int)
<b class="nc"><i>3557</i>&nbsp;     * @see #setSize(Dimension)</b>
<i>3558</i>&nbsp;     * @see #setMinimumSize
<i>3559</i>&nbsp;     * @see #setLocationByPlatform
<i>3560</i>&nbsp;     * @see #isLocationByPlatform
<i>3561</i>&nbsp;     * @since 1.6
<i>3562</i>&nbsp;     */
<i>3563</i>&nbsp;    public void setBounds(Rectangle r) {
<i>3564</i>&nbsp;        setBounds(r.x, r.y, r.width, r.height);
<i>3565</i>&nbsp;    }
<i>3566</i>&nbsp;
<i>3567</i>&nbsp;    /**
<i>3568</i>&nbsp;     * Determines whether this component will be displayed on the screen.
<i>3569</i>&nbsp;     * @return {@code true} if the component and all of its ancestors
<i>3570</i>&nbsp;     *          until a toplevel window are visible, {@code false} otherwise
<i>3571</i>&nbsp;     */
<i>3572</i>&nbsp;    boolean isRecursivelyVisible() {
<i>3573</i>&nbsp;        // 5079694 fix: for a toplevel to be displayed, its parent doesn&#39;t have to be visible.
<i>3574</i>&nbsp;        // We&#39;re overriding isRecursivelyVisible to implement this policy.
<i>3575</i>&nbsp;        return visible;
<i>3576</i>&nbsp;    }
<i>3577</i>&nbsp;
<i>3578</i>&nbsp;
<i>3579</i>&nbsp;    // ******************** SHAPES &amp; TRANSPARENCY CODE ********************
<i>3580</i>&nbsp;
<i>3581</i>&nbsp;    /**
<i>3582</i>&nbsp;     * Returns the opacity of the window.
<i>3583</i>&nbsp;     *
<i>3584</i>&nbsp;     * @return the opacity of the window
<i>3585</i>&nbsp;     *
<i>3586</i>&nbsp;     * @see Window#setOpacity(float)
<i>3587</i>&nbsp;     * @see GraphicsDevice.WindowTranslucency
<i>3588</i>&nbsp;     *
<i>3589</i>&nbsp;     * @since 1.7
<i>3590</i>&nbsp;     */
<i>3591</i>&nbsp;    public float getOpacity() {
<i>3592</i>&nbsp;        return opacity;
<i>3593</i>&nbsp;    }
<i>3594</i>&nbsp;
<i>3595</i>&nbsp;    /**
<i>3596</i>&nbsp;     * Sets the opacity of the window.
<i>3597</i>&nbsp;     * &lt;p&gt;
<i>3598</i>&nbsp;     * The opacity value is in the range [0..1]. Note that setting the opacity
<i>3599</i>&nbsp;     * level of 0 may or may not disable the mouse event handling on this
<i>3600</i>&nbsp;     * window. This is a platform-dependent behavior.
<i>3601</i>&nbsp;     * &lt;p&gt;
<i>3602</i>&nbsp;     * The following conditions must be met in order to set the opacity value
<i>3603</i>&nbsp;     * less than {@code 1.0f}:
<i>3604</i>&nbsp;     * &lt;ul&gt;
<i>3605</i>&nbsp;     * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}
<i>3606</i>&nbsp;     * translucency must be supported by the underlying system
<i>3607</i>&nbsp;     * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
<i>3608</i>&nbsp;     * and {@link Dialog#setUndecorated})
<i>3609</i>&nbsp;     * &lt;li&gt;The window must not be in full-screen mode (see {@link
<b class="nc"><i>3610</i>&nbsp;     * GraphicsDevice#setFullScreenWindow(Window)})</b>
<b class="nc"><i>3611</i>&nbsp;     * &lt;/ul&gt;</b>
<b class="nc"><i>3612</i>&nbsp;     * &lt;p&gt;</b>
<i>3613</i>&nbsp;     * If the requested opacity value is less than {@code 1.0f}, and any of the
<i>3614</i>&nbsp;     * above conditions are not met, the window opacity will not change,
<b class="nc"><i>3615</i>&nbsp;     * and the {@code IllegalComponentStateException} will be thrown.</b>
<b class="nc"><i>3616</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3617</i>&nbsp;     * The translucency levels of individual pixels may also be effected by the</b>
<b class="nc"><i>3618</i>&nbsp;     * alpha component of their color (see {@link Window#setBackground(Color)}) and the</b>
<b class="nc"><i>3619</i>&nbsp;     * current shape of this window (see {@link #setShape(Shape)}).</b>
<i>3620</i>&nbsp;     *
<i>3621</i>&nbsp;     * @param opacity the opacity level to set to the window
<b class="nc"><i>3622</i>&nbsp;     *</b>
<i>3623</i>&nbsp;     * @throws IllegalArgumentException if the opacity is out of the range
<i>3624</i>&nbsp;     *     [0..1]
<b class="nc"><i>3625</i>&nbsp;     * @throws IllegalComponentStateException if the window is decorated and</b>
<i>3626</i>&nbsp;     *     the opacity is less than {@code 1.0f}
<i>3627</i>&nbsp;     * @throws IllegalComponentStateException if the window is in full screen
<i>3628</i>&nbsp;     *     mode, and the opacity is less than {@code 1.0f}
<b class="nc"><i>3629</i>&nbsp;     * @throws UnsupportedOperationException if the {@code</b>
<b class="nc"><i>3630</i>&nbsp;     *     GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}</b>
<b class="nc"><i>3631</i>&nbsp;     *     translucency is not supported and the opacity is less than</b>
<b class="nc"><i>3632</i>&nbsp;     *     {@code 1.0f}</b>
<i>3633</i>&nbsp;     *
<b class="nc"><i>3634</i>&nbsp;     * @see Window#getOpacity</b>
<i>3635</i>&nbsp;     * @see Window#setBackground(Color)
<i>3636</i>&nbsp;     * @see Window#setShape(Shape)
<i>3637</i>&nbsp;     * @see Frame#isUndecorated
<i>3638</i>&nbsp;     * @see Dialog#isUndecorated
<i>3639</i>&nbsp;     * @see GraphicsDevice.WindowTranslucency
<i>3640</i>&nbsp;     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
<i>3641</i>&nbsp;     *
<i>3642</i>&nbsp;     * @since 1.7
<i>3643</i>&nbsp;     */
<i>3644</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>3645</i>&nbsp;    public void setOpacity(float opacity) {
<i>3646</i>&nbsp;        synchronized (getTreeLock()) {
<i>3647</i>&nbsp;            if (opacity &lt; 0.0f || opacity &gt; 1.0f) {
<i>3648</i>&nbsp;                throw new IllegalArgumentException(
<i>3649</i>&nbsp;                    &quot;The value of opacity should be in the range [0.0f .. 1.0f].&quot;);
<i>3650</i>&nbsp;            }
<i>3651</i>&nbsp;            if (opacity &lt; 1.0f) {
<i>3652</i>&nbsp;                GraphicsConfiguration gc = getGraphicsConfiguration();
<b class="nc"><i>3653</i>&nbsp;                GraphicsDevice gd = gc.getDevice();</b>
<b class="nc"><i>3654</i>&nbsp;                if (gc.getDevice().getFullScreenWindow() == this) {</b>
<b class="nc"><i>3655</i>&nbsp;                    throw new IllegalComponentStateException(</b>
<i>3656</i>&nbsp;                        &quot;Setting opacity for full-screen window is not supported.&quot;);
<i>3657</i>&nbsp;                }
<i>3658</i>&nbsp;                if (!gd.isWindowTranslucencySupported(
<i>3659</i>&nbsp;                    GraphicsDevice.WindowTranslucency.TRANSLUCENT))
<i>3660</i>&nbsp;                {
<i>3661</i>&nbsp;                    throw new UnsupportedOperationException(
<i>3662</i>&nbsp;                        &quot;TRANSLUCENT translucency is not supported.&quot;);
<i>3663</i>&nbsp;                }
<i>3664</i>&nbsp;            }
<i>3665</i>&nbsp;            this.opacity = opacity;
<i>3666</i>&nbsp;            WindowPeer peer = (WindowPeer) this.peer;
<i>3667</i>&nbsp;            if (peer != null) {
<i>3668</i>&nbsp;                peer.setOpacity(opacity);
<i>3669</i>&nbsp;            }
<i>3670</i>&nbsp;        }
<i>3671</i>&nbsp;    }
<i>3672</i>&nbsp;
<i>3673</i>&nbsp;    /**
<i>3674</i>&nbsp;     * Returns the shape of the window.
<i>3675</i>&nbsp;     *
<i>3676</i>&nbsp;     * The value returned by this method may not be the same as
<i>3677</i>&nbsp;     * previously set with {@code setShape(shape)}, but it is guaranteed
<i>3678</i>&nbsp;     * to represent the same shape.
<i>3679</i>&nbsp;     *
<i>3680</i>&nbsp;     * @return the shape of the window or {@code null} if no
<i>3681</i>&nbsp;     *     shape is specified for the window
<i>3682</i>&nbsp;     *
<i>3683</i>&nbsp;     * @see Window#setShape(Shape)
<i>3684</i>&nbsp;     * @see GraphicsDevice.WindowTranslucency
<i>3685</i>&nbsp;     *
<i>3686</i>&nbsp;     * @since 1.7
<i>3687</i>&nbsp;     */
<i>3688</i>&nbsp;    public Shape getShape() {
<i>3689</i>&nbsp;        synchronized (getTreeLock()) {
<i>3690</i>&nbsp;            return shape == null ? null : new Path2D.Float(shape);
<i>3691</i>&nbsp;        }
<i>3692</i>&nbsp;    }
<i>3693</i>&nbsp;
<i>3694</i>&nbsp;    /**
<i>3695</i>&nbsp;     * Sets the shape of the window.
<i>3696</i>&nbsp;     * &lt;p&gt;
<i>3697</i>&nbsp;     * Setting a shape cuts off some parts of the window. Only the parts that
<i>3698</i>&nbsp;     * belong to the given {@link Shape} remain visible and clickable. If
<i>3699</i>&nbsp;     * the shape argument is {@code null}, this method restores the default
<i>3700</i>&nbsp;     * shape, making the window rectangular on most platforms.
<i>3701</i>&nbsp;     * &lt;p&gt;
<i>3702</i>&nbsp;     * The following conditions must be met to set a non-null shape:
<i>3703</i>&nbsp;     * &lt;ul&gt;
<i>3704</i>&nbsp;     * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENT
<i>3705</i>&nbsp;     * PERPIXEL_TRANSPARENT} translucency must be supported by the
<i>3706</i>&nbsp;     * underlying system
<i>3707</i>&nbsp;     * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
<b class="nc"><i>3708</i>&nbsp;     * and {@link Dialog#setUndecorated})</b>
<b class="nc"><i>3709</i>&nbsp;     * &lt;li&gt;The window must not be in full-screen mode (see {@link</b>
<b class="nc"><i>3710</i>&nbsp;     * GraphicsDevice#setFullScreenWindow(Window)})</b>
<b class="nc"><i>3711</i>&nbsp;     * &lt;/ul&gt;</b>
<b class="nc"><i>3712</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3713</i>&nbsp;     * If the requested shape is not {@code null}, and any of the above</b>
<i>3714</i>&nbsp;     * conditions are not met, the shape of this window will not change,
<i>3715</i>&nbsp;     * and either the {@code UnsupportedOperationException} or {@code
<b class="nc"><i>3716</i>&nbsp;     * IllegalComponentStateException} will be thrown.</b>
<i>3717</i>&nbsp;     * &lt;p&gt;
<i>3718</i>&nbsp;     * The translucency levels of individual pixels may also be effected by the
<b class="nc"><i>3719</i>&nbsp;     * alpha component of their color (see {@link Window#setBackground(Color)}) and the</b>
<i>3720</i>&nbsp;     * opacity value (see {@link #setOpacity(float)}). See {@link
<i>3721</i>&nbsp;     * GraphicsDevice.WindowTranslucency} for more details.
<i>3722</i>&nbsp;     *
<b class="nc"><i>3723</i>&nbsp;     * @param shape the shape to set to the window</b>
<b class="nc"><i>3724</i>&nbsp;     *</b>
<b class="nc"><i>3725</i>&nbsp;     * @throws IllegalComponentStateException if the shape is not {@code</b>
<b class="nc"><i>3726</i>&nbsp;     *     null} and the window is decorated</b>
<i>3727</i>&nbsp;     * @throws IllegalComponentStateException if the shape is not {@code
<b class="nc"><i>3728</i>&nbsp;     *     null} and the window is in full-screen mode</b>
<i>3729</i>&nbsp;     * @throws UnsupportedOperationException if the shape is not {@code
<i>3730</i>&nbsp;     *     null} and {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENT
<i>3731</i>&nbsp;     *     PERPIXEL_TRANSPARENT} translucency is not supported
<i>3732</i>&nbsp;     *
<i>3733</i>&nbsp;     * @see Window#getShape()
<i>3734</i>&nbsp;     * @see Window#setBackground(Color)
<i>3735</i>&nbsp;     * @see Window#setOpacity(float)
<i>3736</i>&nbsp;     * @see Frame#isUndecorated
<i>3737</i>&nbsp;     * @see Dialog#isUndecorated
<i>3738</i>&nbsp;     * @see GraphicsDevice.WindowTranslucency
<i>3739</i>&nbsp;     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
<i>3740</i>&nbsp;     *
<i>3741</i>&nbsp;     * @since 1.7
<i>3742</i>&nbsp;     */
<i>3743</i>&nbsp;    public void setShape(Shape shape) {
<i>3744</i>&nbsp;        synchronized (getTreeLock()) {
<b class="nc"><i>3745</i>&nbsp;            if (shape != null) {</b>
<i>3746</i>&nbsp;                GraphicsConfiguration gc = getGraphicsConfiguration();
<i>3747</i>&nbsp;                GraphicsDevice gd = gc.getDevice();
<i>3748</i>&nbsp;                if (gc.getDevice().getFullScreenWindow() == this) {
<i>3749</i>&nbsp;                    throw new IllegalComponentStateException(
<i>3750</i>&nbsp;                        &quot;Setting shape for full-screen window is not supported.&quot;);
<i>3751</i>&nbsp;                }
<i>3752</i>&nbsp;                if (!gd.isWindowTranslucencySupported(
<i>3753</i>&nbsp;                        GraphicsDevice.WindowTranslucency.PERPIXEL_TRANSPARENT))
<i>3754</i>&nbsp;                {
<i>3755</i>&nbsp;                    throw new UnsupportedOperationException(
<i>3756</i>&nbsp;                        &quot;PERPIXEL_TRANSPARENT translucency is not supported.&quot;);
<i>3757</i>&nbsp;                }
<i>3758</i>&nbsp;            }
<i>3759</i>&nbsp;            this.shape = (shape == null) ? null : new Path2D.Float(shape);
<i>3760</i>&nbsp;            WindowPeer peer = (WindowPeer) this.peer;
<i>3761</i>&nbsp;            if (peer != null) {
<i>3762</i>&nbsp;                peer.applyShape(shape == null ? null : Region.getInstance(shape, null));
<i>3763</i>&nbsp;            }
<i>3764</i>&nbsp;        }
<i>3765</i>&nbsp;    }
<i>3766</i>&nbsp;
<i>3767</i>&nbsp;    /**
<i>3768</i>&nbsp;     * Gets the background color of this window.
<i>3769</i>&nbsp;     * &lt;p&gt;
<i>3770</i>&nbsp;     * Note that the alpha component of the returned color indicates whether
<i>3771</i>&nbsp;     * the window is in the non-opaque (per-pixel translucent) mode.
<i>3772</i>&nbsp;     *
<i>3773</i>&nbsp;     * @return this component&#39;s background color
<i>3774</i>&nbsp;     *
<i>3775</i>&nbsp;     * @see Window#setBackground(Color)
<i>3776</i>&nbsp;     * @see Window#isOpaque
<i>3777</i>&nbsp;     * @see GraphicsDevice.WindowTranslucency
<i>3778</i>&nbsp;     */
<i>3779</i>&nbsp;    @Override
<i>3780</i>&nbsp;    public Color getBackground() {
<i>3781</i>&nbsp;        return super.getBackground();
<i>3782</i>&nbsp;    }
<i>3783</i>&nbsp;
<i>3784</i>&nbsp;    /**
<i>3785</i>&nbsp;     * Sets the background color of this window.
<i>3786</i>&nbsp;     * &lt;p&gt;
<i>3787</i>&nbsp;     * If the windowing system supports the {@link
<i>3788</i>&nbsp;     * GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}
<i>3789</i>&nbsp;     * translucency, the alpha component of the given background color
<i>3790</i>&nbsp;     * may effect the mode of operation for this window: it indicates whether
<i>3791</i>&nbsp;     * this window must be opaque (alpha equals {@code 1.0f}) or per-pixel translucent
<i>3792</i>&nbsp;     * (alpha is less than {@code 1.0f}). If the given background color is
<i>3793</i>&nbsp;     * {@code null}, the window is considered completely opaque.
<i>3794</i>&nbsp;     * &lt;p&gt;
<i>3795</i>&nbsp;     * All the following conditions must be met to enable the per-pixel
<i>3796</i>&nbsp;     * transparency mode for this window:
<i>3797</i>&nbsp;     * &lt;ul&gt;
<i>3798</i>&nbsp;     * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
<i>3799</i>&nbsp;     * PERPIXEL_TRANSLUCENT} translucency must be supported by the graphics
<i>3800</i>&nbsp;     * device where this window is located
<i>3801</i>&nbsp;     * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
<i>3802</i>&nbsp;     * and {@link Dialog#setUndecorated})
<i>3803</i>&nbsp;     * &lt;li&gt;The window must not be in full-screen mode (see {@link
<i>3804</i>&nbsp;     * GraphicsDevice#setFullScreenWindow(Window)})
<i>3805</i>&nbsp;     * &lt;/ul&gt;
<i>3806</i>&nbsp;     * &lt;p&gt;
<i>3807</i>&nbsp;     * If the alpha component of the requested background color is less than
<i>3808</i>&nbsp;     * {@code 1.0f}, and any of the above conditions are not met, the background
<i>3809</i>&nbsp;     * color of this window will not change, the alpha component of the given
<i>3810</i>&nbsp;     * background color will not affect the mode of operation for this window,
<i>3811</i>&nbsp;     * and either the {@code UnsupportedOperationException} or {@code
<i>3812</i>&nbsp;     * IllegalComponentStateException} will be thrown.
<i>3813</i>&nbsp;     * &lt;p&gt;
<i>3814</i>&nbsp;     * When the window is per-pixel translucent, the drawing sub-system
<i>3815</i>&nbsp;     * respects the alpha value of each individual pixel. If a pixel gets
<i>3816</i>&nbsp;     * painted with the alpha color component equal to zero, it becomes
<i>3817</i>&nbsp;     * visually transparent. If the alpha of the pixel is equal to 1.0f, the
<i>3818</i>&nbsp;     * pixel is fully opaque. Interim values of the alpha color component make
<i>3819</i>&nbsp;     * the pixel semi-transparent. In this mode, the background of the window
<i>3820</i>&nbsp;     * gets painted with the alpha value of the given background color. If the
<i>3821</i>&nbsp;     * alpha value of the argument of this method is equal to {@code 0}, the
<i>3822</i>&nbsp;     * background is not painted at all.
<i>3823</i>&nbsp;     * &lt;p&gt;
<i>3824</i>&nbsp;     * The actual level of translucency of a given pixel also depends on window
<b class="nc"><i>3825</i>&nbsp;     * opacity (see {@link #setOpacity(float)}), as well as the current shape of</b>
<b class="nc"><i>3826</i>&nbsp;     * this window (see {@link #setShape(Shape)}).</b>
<b class="nc"><i>3827</i>&nbsp;     * &lt;p&gt;</b>
<i>3828</i>&nbsp;     * Note that painting a pixel with the alpha value of {@code 0} may or may
<i>3829</i>&nbsp;     * not disable the mouse event handling on this pixel. This is a
<b class="nc"><i>3830</i>&nbsp;     * platform-dependent behavior. To make sure the mouse events do not get</b>
<b class="nc"><i>3831</i>&nbsp;     * dispatched to a particular pixel, the pixel must be excluded from the</b>
<b class="nc"><i>3832</i>&nbsp;     * shape of the window.</b>
<b class="nc"><i>3833</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3834</i>&nbsp;     * Enabling the per-pixel translucency mode may change the graphics</b>
<b class="nc"><i>3835</i>&nbsp;     * configuration of this window due to the native platform requirements.</b>
<b class="nc"><i>3836</i>&nbsp;     *</b>
<i>3837</i>&nbsp;     * @param bgColor the color to become this window&#39;s background color.
<i>3838</i>&nbsp;     *
<b class="nc"><i>3839</i>&nbsp;     * @throws IllegalComponentStateException if the alpha value of the given</b>
<b class="nc"><i>3840</i>&nbsp;     *     background color is less than {@code 1.0f} and the window is decorated</b>
<b class="nc"><i>3841</i>&nbsp;     * @throws IllegalComponentStateException if the alpha value of the given</b>
<b class="nc"><i>3842</i>&nbsp;     *     background color is less than {@code 1.0f} and the window is in</b>
<i>3843</i>&nbsp;     *     full-screen mode
<i>3844</i>&nbsp;     * @throws UnsupportedOperationException if the alpha value of the given
<b class="nc"><i>3845</i>&nbsp;     *     background color is less than {@code 1.0f} and {@link</b>
<i>3846</i>&nbsp;     *     GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
<b class="nc"><i>3847</i>&nbsp;     *     PERPIXEL_TRANSLUCENT} translucency is not supported</b>
<b class="nc"><i>3848</i>&nbsp;     *</b>
<b class="nc"><i>3849</i>&nbsp;     * @see Window#getBackground</b>
<i>3850</i>&nbsp;     * @see Window#isOpaque
<b class="nc"><i>3851</i>&nbsp;     * @see Window#setOpacity(float)</b>
<b class="nc"><i>3852</i>&nbsp;     * @see Window#setShape(Shape)</b>
<b class="nc"><i>3853</i>&nbsp;     * @see Frame#isUndecorated</b>
<i>3854</i>&nbsp;     * @see Dialog#isUndecorated
<i>3855</i>&nbsp;     * @see GraphicsDevice.WindowTranslucency
<i>3856</i>&nbsp;     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
<i>3857</i>&nbsp;     * @see GraphicsConfiguration#isTranslucencyCapable()
<i>3858</i>&nbsp;     */
<i>3859</i>&nbsp;    @Override
<i>3860</i>&nbsp;    public void setBackground(Color bgColor) {
<i>3861</i>&nbsp;        Color oldBg = getBackground();
<i>3862</i>&nbsp;        super.setBackground(bgColor);
<i>3863</i>&nbsp;        if (oldBg != null &amp;&amp; oldBg.equals(bgColor)) {
<i>3864</i>&nbsp;            return;
<i>3865</i>&nbsp;        }
<i>3866</i>&nbsp;        int oldAlpha = oldBg != null ? oldBg.getAlpha() : 255;
<i>3867</i>&nbsp;        int alpha = bgColor != null ? bgColor.getAlpha() : 255;
<i>3868</i>&nbsp;        if ((oldAlpha == 255) &amp;&amp; (alpha &lt; 255)) { // non-opaque window
<i>3869</i>&nbsp;            GraphicsConfiguration gc = getGraphicsConfiguration();
<i>3870</i>&nbsp;            GraphicsDevice gd = gc.getDevice();
<i>3871</i>&nbsp;            if (gc.getDevice().getFullScreenWindow() == this) {
<b class="nc"><i>3872</i>&nbsp;                throw new IllegalComponentStateException(</b>
<b class="nc"><i>3873</i>&nbsp;                    &quot;Making full-screen window non opaque is not supported.&quot;);</b>
<i>3874</i>&nbsp;            }
<i>3875</i>&nbsp;            if (!gc.isTranslucencyCapable()) {
<i>3876</i>&nbsp;                GraphicsConfiguration capableGC = gd.getTranslucencyCapableGC();
<b class="nc"><i>3877</i>&nbsp;                if (capableGC == null) {</b>
<b class="nc"><i>3878</i>&nbsp;                    throw new UnsupportedOperationException(</b>
<b class="nc"><i>3879</i>&nbsp;                        &quot;PERPIXEL_TRANSLUCENT translucency is not supported&quot;);</b>
<b class="nc"><i>3880</i>&nbsp;                }</b>
<i>3881</i>&nbsp;                setGraphicsConfiguration(capableGC);
<b class="nc"><i>3882</i>&nbsp;            }</b>
<i>3883</i>&nbsp;            setLayersOpaque(this, false);
<i>3884</i>&nbsp;        } else if ((oldAlpha &lt; 255) &amp;&amp; (alpha == 255)) {
<i>3885</i>&nbsp;            setLayersOpaque(this, true);
<i>3886</i>&nbsp;        }
<i>3887</i>&nbsp;        WindowPeer peer = (WindowPeer) this.peer;
<i>3888</i>&nbsp;        if (peer != null) {
<i>3889</i>&nbsp;            peer.setOpaque(alpha == 255);
<i>3890</i>&nbsp;        }
<i>3891</i>&nbsp;    }
<b class="nc"><i>3892</i>&nbsp;</b>
<b class="nc"><i>3893</i>&nbsp;    /**</b>
<i>3894</i>&nbsp;     * Indicates if the window is currently opaque.
<b class="nc"><i>3895</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3896</i>&nbsp;     * The method returns {@code false} if the background color of the window</b>
<b class="nc"><i>3897</i>&nbsp;     * is not {@code null} and the alpha component of the color is less than</b>
<b class="nc"><i>3898</i>&nbsp;     * {@code 1.0f}. The method returns {@code true} otherwise.</b>
<i>3899</i>&nbsp;     *
<i>3900</i>&nbsp;     * @return {@code true} if the window is opaque, {@code false} otherwise
<b class="nc"><i>3901</i>&nbsp;     *</b>
<b class="nc"><i>3902</i>&nbsp;     * @see Window#getBackground</b>
<i>3903</i>&nbsp;     * @see Window#setBackground(Color)
<b class="nc"><i>3904</i>&nbsp;     * @since 1.7</b>
<i>3905</i>&nbsp;     */
<i>3906</i>&nbsp;    @Override
<i>3907</i>&nbsp;    public boolean isOpaque() {
<i>3908</i>&nbsp;        Color bg = getBackground();
<i>3909</i>&nbsp;        return bg != null ? bg.getAlpha() == 255 : true;
<b class="nc"><i>3910</i>&nbsp;    }</b>
<b class="nc"><i>3911</i>&nbsp;</b>
<b class="nc"><i>3912</i>&nbsp;    private void updateWindow() {</b>
<b class="nc"><i>3913</i>&nbsp;        synchronized (getTreeLock()) {</b>
<b class="nc"><i>3914</i>&nbsp;            WindowPeer peer = (WindowPeer) this.peer;</b>
<b class="nc"><i>3915</i>&nbsp;            if (peer != null) {</b>
<i>3916</i>&nbsp;                peer.updateWindow();
<b class="nc"><i>3917</i>&nbsp;            }</b>
<b class="nc"><i>3918</i>&nbsp;        }</b>
<b class="nc"><i>3919</i>&nbsp;    }</b>
<b class="nc"><i>3920</i>&nbsp;</b>
<i>3921</i>&nbsp;    /**
<i>3922</i>&nbsp;     * {@inheritDoc}
<i>3923</i>&nbsp;     *
<b class="nc"><i>3924</i>&nbsp;     * @since 1.7</b>
<b class="nc"><i>3925</i>&nbsp;     */</b>
<b class="nc"><i>3926</i>&nbsp;    @Override</b>
<i>3927</i>&nbsp;    public void paint(Graphics g) {
<i>3928</i>&nbsp;        if (!isOpaque()) {
<b class="nc"><i>3929</i>&nbsp;            Graphics gg = g.create();</b>
<b class="nc"><i>3930</i>&nbsp;            try {</b>
<i>3931</i>&nbsp;                if (gg instanceof Graphics2D) {
<i>3932</i>&nbsp;                    gg.setColor(getBackground());
<i>3933</i>&nbsp;                    ((Graphics2D)gg).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));
<i>3934</i>&nbsp;                    gg.fillRect(0, 0, getWidth(), getHeight());
<i>3935</i>&nbsp;                }
<i>3936</i>&nbsp;            } finally {
<i>3937</i>&nbsp;                gg.dispose();
<i>3938</i>&nbsp;            }
<i>3939</i>&nbsp;        }
<i>3940</i>&nbsp;        super.paint(g);
<i>3941</i>&nbsp;    }
<i>3942</i>&nbsp;
<b class="nc"><i>3943</i>&nbsp;    private static void setLayersOpaque(Component component, boolean isOpaque) {</b>
<i>3944</i>&nbsp;        // Shouldn&#39;t use instanceof to avoid loading Swing classes
<i>3945</i>&nbsp;        //    if it&#39;s a pure AWT application.
<i>3946</i>&nbsp;        if (SunToolkit.isInstanceOf(component, &quot;javax.swing.RootPaneContainer&quot;)) {
<i>3947</i>&nbsp;            javax.swing.RootPaneContainer rpc = (javax.swing.RootPaneContainer)component;
<i>3948</i>&nbsp;            javax.swing.JRootPane root = rpc.getRootPane();
<i>3949</i>&nbsp;            javax.swing.JLayeredPane lp = root.getLayeredPane();
<i>3950</i>&nbsp;            Container c = root.getContentPane();
<i>3951</i>&nbsp;            javax.swing.JComponent content =
<i>3952</i>&nbsp;                (c instanceof javax.swing.JComponent) ? (javax.swing.JComponent)c : null;
<i>3953</i>&nbsp;            lp.setOpaque(isOpaque);
<i>3954</i>&nbsp;            root.setOpaque(isOpaque);
<i>3955</i>&nbsp;            if (content != null) {
<i>3956</i>&nbsp;                content.setOpaque(isOpaque);
<i>3957</i>&nbsp;
<i>3958</i>&nbsp;                // Iterate down one level to see whether we have a JApplet
<i>3959</i>&nbsp;                // (which is also a RootPaneContainer) which requires processing
<i>3960</i>&nbsp;                int numChildren = content.getComponentCount();
<i>3961</i>&nbsp;                if (numChildren &gt; 0) {
<i>3962</i>&nbsp;                    Component child = content.getComponent(0);
<i>3963</i>&nbsp;                    // It&#39;s OK to use instanceof here because we&#39;ve
<i>3964</i>&nbsp;                    // already loaded the RootPaneContainer class by now
<i>3965</i>&nbsp;                    if (child instanceof javax.swing.RootPaneContainer) {
<i>3966</i>&nbsp;                        setLayersOpaque(child, isOpaque);
<i>3967</i>&nbsp;                    }
<i>3968</i>&nbsp;                }
<i>3969</i>&nbsp;            }
<b class="nc"><i>3970</i>&nbsp;        }</b>
<i>3971</i>&nbsp;    }
<i>3972</i>&nbsp;
<i>3973</i>&nbsp;
<i>3974</i>&nbsp;    // ************************** MIXING CODE *******************************
<i>3975</i>&nbsp;
<i>3976</i>&nbsp;    // A window has an owner, but it does NOT have a container
<i>3977</i>&nbsp;    @Override
<i>3978</i>&nbsp;    final Container getContainer() {
<b class="nc"><i>3979</i>&nbsp;        return null;</b>
<b class="nc"><i>3980</i>&nbsp;    }</b>
<b class="nc"><i>3981</i>&nbsp;</b>
<i>3982</i>&nbsp;    /**
<i>3983</i>&nbsp;     * Applies the shape to the component
<i>3984</i>&nbsp;     * @param shape Shape to be applied to the component
<i>3985</i>&nbsp;     */
<i>3986</i>&nbsp;    @Override
<i>3987</i>&nbsp;    final void applyCompoundShape(Region shape) {
<i>3988</i>&nbsp;        // The shape calculated by mixing code is not intended to be applied
<i>3989</i>&nbsp;        // to windows or frames
<i>3990</i>&nbsp;    }
<i>3991</i>&nbsp;
<i>3992</i>&nbsp;    @Override
<i>3993</i>&nbsp;    final void applyCurrentShape() {
<i>3994</i>&nbsp;        // The shape calculated by mixing code is not intended to be applied
<i>3995</i>&nbsp;        // to windows or frames
<i>3996</i>&nbsp;    }
<i>3997</i>&nbsp;
<i>3998</i>&nbsp;    @Override
<b class="nc"><i>3999</i>&nbsp;    final void mixOnReshaping() {</b>
<b class="nc"><i>4000</i>&nbsp;        // The shape calculated by mixing code is not intended to be applied</b>
<i>4001</i>&nbsp;        // to windows or frames
<i>4002</i>&nbsp;    }
<b class="nc"><i>4003</i>&nbsp;</b>
<i>4004</i>&nbsp;    @Override
<i>4005</i>&nbsp;    final Point getLocationOnWindow() {
<b class="nc"><i>4006</i>&nbsp;        return new Point(0, 0);</b>
<i>4007</i>&nbsp;    }
<i>4008</i>&nbsp;
<i>4009</i>&nbsp;    // ****************** END OF MIXING CODE ********************************
<i>4010</i>&nbsp;
<b class="nc"><i>4011</i>&nbsp;    /**</b>
<b class="nc"><i>4012</i>&nbsp;     * Limit the given double value with the given range.</b>
<b class="nc"><i>4013</i>&nbsp;     */</b>
<i>4014</i>&nbsp;    private static double limit(double value, double min, double max) {
<b class="nc"><i>4015</i>&nbsp;        value = Math.max(value, min);</b>
<i>4016</i>&nbsp;        value = Math.min(value, max);
<b class="nc"><i>4017</i>&nbsp;        return value;</b>
<i>4018</i>&nbsp;    }
<i>4019</i>&nbsp;
<i>4020</i>&nbsp;    /**
<b class="nc"><i>4021</i>&nbsp;     * Calculate the position of the security warning.</b>
<i>4022</i>&nbsp;     *
<i>4023</i>&nbsp;     * This method gets the window location/size as reported by the native
<i>4024</i>&nbsp;     * system since the locally cached values may represent outdated data.
<i>4025</i>&nbsp;     *
<b class="nc"><i>4026</i>&nbsp;     * The method is used from the native code, or via AWTAccessor.</b>
<i>4027</i>&nbsp;     *
<i>4028</i>&nbsp;     * NOTE: this method is invoked on the toolkit thread, and therefore is not
<i>4029</i>&nbsp;     * supposed to become public/user-overridable.
<b class="nc"><i>4030</i>&nbsp;     */</b>
<i>4031</i>&nbsp;    private Point2D calculateSecurityWarningPosition(double x, double y,
<b class="nc"><i>4032</i>&nbsp;            double w, double h)</b>
<i>4033</i>&nbsp;    {
<i>4034</i>&nbsp;        // The position according to the spec of SecurityWarning.setPosition()
<b class="nc"><i>4035</i>&nbsp;        double wx = x + w * securityWarningAlignmentX + securityWarningPointX;</b>
<i>4036</i>&nbsp;        double wy = y + h * securityWarningAlignmentY + securityWarningPointY;
<i>4037</i>&nbsp;
<b class="nc"><i>4038</i>&nbsp;        // First, make sure the warning is not too far from the window bounds</b>
<i>4039</i>&nbsp;        wx = Window.limit(wx,
<i>4040</i>&nbsp;                x - securityWarningWidth - 2,
<b class="nc"><i>4041</i>&nbsp;                x + w + 2);</b>
<i>4042</i>&nbsp;        wy = Window.limit(wy,
<i>4043</i>&nbsp;                y - securityWarningHeight - 2,
<b class="nc"><i>4044</i>&nbsp;                y + h + 2);</b>
<b class="nc"><i>4045</i>&nbsp;</b>
<b class="nc"><i>4046</i>&nbsp;        // Now make sure the warning window is visible on the screen</b>
<i>4047</i>&nbsp;        GraphicsConfiguration graphicsConfig =
<b class="nc"><i>4048</i>&nbsp;            getGraphicsConfiguration_NoClientCode();</b>
<i>4049</i>&nbsp;        Rectangle screenBounds = graphicsConfig.getBounds();
<i>4050</i>&nbsp;        Insets screenInsets =
<i>4051</i>&nbsp;            Toolkit.getDefaultToolkit().getScreenInsets(graphicsConfig);
<b class="nc"><i>4052</i>&nbsp;</b>
<i>4053</i>&nbsp;        wx = Window.limit(wx,
<i>4054</i>&nbsp;                screenBounds.x + screenInsets.left,
<i>4055</i>&nbsp;                screenBounds.x + screenBounds.width - screenInsets.right
<b class="nc"><i>4056</i>&nbsp;                - securityWarningWidth);</b>
<b class="nc"><i>4057</i>&nbsp;        wy = Window.limit(wy,</b>
<i>4058</i>&nbsp;                screenBounds.y + screenInsets.top,
<i>4059</i>&nbsp;                screenBounds.y + screenBounds.height - screenInsets.bottom
<i>4060</i>&nbsp;                - securityWarningHeight);
<i>4061</i>&nbsp;
<b class="nc"><i>4062</i>&nbsp;        return new Point2D.Double(wx, wy);</b>
<b class="nc"><i>4063</i>&nbsp;    }</b>
<i>4064</i>&nbsp;
<i>4065</i>&nbsp;    static {
<i>4066</i>&nbsp;        AWTAccessor.setWindowAccessor(new AWTAccessor.WindowAccessor() {
<i>4067</i>&nbsp;            public void updateWindow(Window window) {
<i>4068</i>&nbsp;                window.updateWindow();
<b class="nc"><i>4069</i>&nbsp;            }</b>
<b class="nc"><i>4070</i>&nbsp;</b>
<b class="nc"><i>4071</i>&nbsp;            public Dimension getSecurityWarningSize(Window window) {</b>
<b class="nc"><i>4072</i>&nbsp;                return new Dimension(window.securityWarningWidth,</b>
<i>4073</i>&nbsp;                        window.securityWarningHeight);
<b class="nc"><i>4074</i>&nbsp;            }</b>
<b class="nc"><i>4075</i>&nbsp;</b>
<b class="nc"><i>4076</i>&nbsp;            public void setSecurityWarningSize(Window window, int width, int height)</b>
<b class="nc"><i>4077</i>&nbsp;            {</b>
<i>4078</i>&nbsp;                window.securityWarningWidth = width;
<b class="nc"><i>4079</i>&nbsp;                window.securityWarningHeight = height;</b>
<i>4080</i>&nbsp;            }
<i>4081</i>&nbsp;
<i>4082</i>&nbsp;            public void setSecurityWarningPosition(Window window,
<i>4083</i>&nbsp;                    Point2D point, float alignmentX, float alignmentY)
<i>4084</i>&nbsp;            {
<b class="nc"><i>4085</i>&nbsp;                window.securityWarningPointX = point.getX();</b>
<i>4086</i>&nbsp;                window.securityWarningPointY = point.getY();
<i>4087</i>&nbsp;                window.securityWarningAlignmentX = alignmentX;
<i>4088</i>&nbsp;                window.securityWarningAlignmentY = alignmentY;
<b class="nc"><i>4089</i>&nbsp;</b>
<i>4090</i>&nbsp;                synchronized (window.getTreeLock()) {
<i>4091</i>&nbsp;                    WindowPeer peer = (WindowPeer) window.peer;
<i>4092</i>&nbsp;                    if (peer != null) {
<b class="nc"><i>4093</i>&nbsp;                        peer.repositionSecurityWarning();</b>
<i>4094</i>&nbsp;                    }
<i>4095</i>&nbsp;                }
<i>4096</i>&nbsp;            }
<b class="nc"><i>4097</i>&nbsp;</b>
<i>4098</i>&nbsp;            public Point2D calculateSecurityWarningPosition(Window window,
<i>4099</i>&nbsp;                    double x, double y, double w, double h)
<i>4100</i>&nbsp;            {
<b class="nc"><i>4101</i>&nbsp;                return window.calculateSecurityWarningPosition(x, y, w, h);</b>
<i>4102</i>&nbsp;            }
<i>4103</i>&nbsp;
<i>4104</i>&nbsp;            public void setLWRequestStatus(Window changed, boolean status) {
<b class="nc"><i>4105</i>&nbsp;                changed.syncLWRequests = status;</b>
<i>4106</i>&nbsp;            }
<i>4107</i>&nbsp;
<i>4108</i>&nbsp;            public boolean isAutoRequestFocus(Window w) {
<i>4109</i>&nbsp;                return w.autoRequestFocus;
<i>4110</i>&nbsp;            }
<i>4111</i>&nbsp;
<i>4112</i>&nbsp;            public boolean isTrayIconWindow(Window w) {
<i>4113</i>&nbsp;                return w.isTrayIconWindow;
<i>4114</i>&nbsp;            }
<i>4115</i>&nbsp;
<i>4116</i>&nbsp;            public void setTrayIconWindow(Window w, boolean isTrayIconWindow) {
<i>4117</i>&nbsp;                w.isTrayIconWindow = isTrayIconWindow;
<i>4118</i>&nbsp;            }
<i>4119</i>&nbsp;
<i>4120</i>&nbsp;            public Window[] getOwnedWindows(Window w) {
<i>4121</i>&nbsp;                return w.getOwnedWindows_NoClientCode();
<i>4122</i>&nbsp;            }
<i>4123</i>&nbsp;        }); // WindowAccessor
<i>4124</i>&nbsp;    } // static
<i>4125</i>&nbsp;
<i>4126</i>&nbsp;    // a window doesn&#39;t need to be updated in the Z-order.
<i>4127</i>&nbsp;    @Override
<i>4128</i>&nbsp;    void updateZOrder() {}
<i>4129</i>&nbsp;
<i>4130</i>&nbsp;} // class Window
<i>4131</i>&nbsp;
<i>4132</i>&nbsp;
<i>4133</i>&nbsp;/**
<i>4134</i>&nbsp; * This class is no longer used, but is maintained for Serialization
<i>4135</i>&nbsp; * backward-compatibility.
<i>4136</i>&nbsp; */
<i>4137</i>&nbsp;class FocusManager implements java.io.Serializable {
<i>4138</i>&nbsp;    Container focusRoot;
<i>4139</i>&nbsp;    Component focusOwner;
<i>4140</i>&nbsp;
<i>4141</i>&nbsp;    /*
<i>4142</i>&nbsp;     * JDK 1.1 serialVersionUID
<i>4143</i>&nbsp;     */
<i>4144</i>&nbsp;    static final long serialVersionUID = 2491878825643557906L;
<i>4145</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
