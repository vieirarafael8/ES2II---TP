


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: RenderingHints</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.awt</a> ]
</div>

<h1>Coverage Summary for Class: RenderingHints (java.awt)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RenderingHints</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 89)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RenderingHints$Key</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 106)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.awt;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.Map;
<i>29</i>&nbsp;import java.util.Set;
<i>30</i>&nbsp;import java.util.Collection;
<i>31</i>&nbsp;import java.util.Collections;
<i>32</i>&nbsp;import java.util.HashMap;
<i>33</i>&nbsp;import java.util.Iterator;
<i>34</i>&nbsp;import sun.awt.SunHints;
<i>35</i>&nbsp;import java.lang.ref.WeakReference;
<i>36</i>&nbsp;
<i>37</i>&nbsp;/**
<i>38</i>&nbsp; * The {@code RenderingHints} class defines and manages collections of
<i>39</i>&nbsp; * keys and associated values which allow an application to provide input
<i>40</i>&nbsp; * into the choice of algorithms used by other classes which perform
<i>41</i>&nbsp; * rendering and image manipulation services.
<i>42</i>&nbsp; * The {@link java.awt.Graphics2D} class, and classes that implement
<i>43</i>&nbsp; * {@link java.awt.image.BufferedImageOp} and
<i>44</i>&nbsp; * {@link java.awt.image.RasterOp} all provide methods to get and
<i>45</i>&nbsp; * possibly to set individual or groups of {@code RenderingHints}
<i>46</i>&nbsp; * keys and their associated values.
<i>47</i>&nbsp; * When those implementations perform any rendering or image manipulation
<i>48</i>&nbsp; * operations they should examine the values of any {@code RenderingHints}
<i>49</i>&nbsp; * that were requested by the caller and tailor the algorithms used
<i>50</i>&nbsp; * accordingly and to the best of their ability.
<i>51</i>&nbsp; * &lt;p&gt;
<i>52</i>&nbsp; * Note that since these keys and values are &lt;i&gt;hints&lt;/i&gt;, there is
<i>53</i>&nbsp; * no requirement that a given implementation supports all possible
<i>54</i>&nbsp; * choices indicated below or that it can respond to requests to
<i>55</i>&nbsp; * modify its choice of algorithm.
<i>56</i>&nbsp; * The values of the various hint keys may also interact such that
<i>57</i>&nbsp; * while all variants of a given key are supported in one situation,
<i>58</i>&nbsp; * the implementation may be more restricted when the values associated
<i>59</i>&nbsp; * with other keys are modified.
<i>60</i>&nbsp; * For example, some implementations may be able to provide several
<i>61</i>&nbsp; * types of dithering when the antialiasing hint is turned off, but
<i>62</i>&nbsp; * have little control over dithering when antialiasing is on.
<i>63</i>&nbsp; * The full set of supported keys and hints may also vary by destination
<i>64</i>&nbsp; * since runtimes may use different underlying modules to render to
<i>65</i>&nbsp; * the screen, or to {@link java.awt.image.BufferedImage} objects,
<i>66</i>&nbsp; * or while printing.
<i>67</i>&nbsp; * &lt;p&gt;
<i>68</i>&nbsp; * Implementations are free to ignore the hints completely, but should
<i>69</i>&nbsp; * try to use an implementation algorithm that is as close as possible
<i>70</i>&nbsp; * to the request.
<i>71</i>&nbsp; * If an implementation supports a given algorithm when any value is used
<i>72</i>&nbsp; * for an associated hint key, then minimally it must do so when the
<i>73</i>&nbsp; * value for that key is the exact value that specifies the algorithm.
<i>74</i>&nbsp; * &lt;p&gt;
<i>75</i>&nbsp; * The keys used to control the hints are all special values that
<i>76</i>&nbsp; * subclass the associated {@link RenderingHints.Key} class.
<i>77</i>&nbsp; * Many common hints are expressed below as static constants in this
<i>78</i>&nbsp; * class, but the list is not meant to be exhaustive.
<i>79</i>&nbsp; * Other hints may be created by other packages by defining new objects
<i>80</i>&nbsp; * which subclass the {@code Key} class and defining the associated values.
<i>81</i>&nbsp; */
<i>82</i>&nbsp;public class RenderingHints
<i>83</i>&nbsp;    implements Map&lt;Object,Object&gt;, Cloneable
<i>84</i>&nbsp;{
<i>85</i>&nbsp;    /**
<i>86</i>&nbsp;     * Defines the base type of all keys used along with the
<i>87</i>&nbsp;     * {@link RenderingHints} class to control various
<i>88</i>&nbsp;     * algorithm choices in the rendering and imaging pipelines.
<i>89</i>&nbsp;     * Instances of this class are immutable and unique which
<i>90</i>&nbsp;     * means that tests for matches can be made using the
<i>91</i>&nbsp;     * {@code ==} operator instead of the more expensive
<i>92</i>&nbsp;     * {@code equals()} method.
<i>93</i>&nbsp;     */
<i>94</i>&nbsp;    public abstract static class Key {
<b class="nc"><i>95</i>&nbsp;        private static HashMap&lt;Object,Object&gt; identitymap = new HashMap&lt;&gt;(17);</b>
<i>96</i>&nbsp;
<i>97</i>&nbsp;        private String getIdentity() {
<i>98</i>&nbsp;            // Note that the identity string is dependent on 3 variables:
<i>99</i>&nbsp;            //     - the name of the subclass of Key
<i>100</i>&nbsp;            //     - the identityHashCode of the subclass of Key
<i>101</i>&nbsp;            //     - the integer key of the Key
<i>102</i>&nbsp;            // It is theoretically possible for 2 distinct keys to collide
<i>103</i>&nbsp;            // along all 3 of those attributes in the context of multiple
<i>104</i>&nbsp;            // class loaders, but that occurrence will be extremely rare and
<i>105</i>&nbsp;            // we account for that possibility below in the recordIdentity
<i>106</i>&nbsp;            // method by slightly relaxing our uniqueness guarantees if we
<i>107</i>&nbsp;            // end up in that situation.
<b class="nc"><i>108</i>&nbsp;            return getClass().getName()+&quot;@&quot;+</b>
<b class="nc"><i>109</i>&nbsp;                Integer.toHexString(System.identityHashCode(getClass()))+&quot;:&quot;+</b>
<b class="nc"><i>110</i>&nbsp;                Integer.toHexString(privatekey);</b>
<i>111</i>&nbsp;        }
<i>112</i>&nbsp;
<i>113</i>&nbsp;        private static synchronized void recordIdentity(Key k) {
<b class="nc"><i>114</i>&nbsp;            Object identity = k.getIdentity();</b>
<b class="nc"><i>115</i>&nbsp;            Object otherref = identitymap.get(identity);</b>
<b class="nc"><i>116</i>&nbsp;            if (otherref != null) {</b>
<b class="nc"><i>117</i>&nbsp;                Key otherkey = (Key) ((WeakReference) otherref).get();</b>
<b class="nc"><i>118</i>&nbsp;                if (otherkey != null &amp;&amp; otherkey.getClass() == k.getClass()) {</b>
<b class="nc"><i>119</i>&nbsp;                    throw new IllegalArgumentException(identity+</b>
<i>120</i>&nbsp;                                                       &quot; already registered&quot;);
<i>121</i>&nbsp;                }
<i>122</i>&nbsp;                // Note that this system can fail in a mostly harmless
<i>123</i>&nbsp;                // way.  If we end up generating the same identity
<i>124</i>&nbsp;                // String for 2 different classes (a very rare case)
<i>125</i>&nbsp;                // then we correctly avoid throwing the exception above,
<i>126</i>&nbsp;                // but we are about to drop through to a statement that
<i>127</i>&nbsp;                // will replace the entry for the old Key subclass with
<i>128</i>&nbsp;                // an entry for the new Key subclass.  At that time the
<i>129</i>&nbsp;                // old subclass will be vulnerable to someone generating
<i>130</i>&nbsp;                // a duplicate Key instance for it.  We could bail out
<i>131</i>&nbsp;                // of the method here and let the old identity keep its
<i>132</i>&nbsp;                // record in the map, but we are more likely to see a
<i>133</i>&nbsp;                // duplicate key go by for the new class than the old
<i>134</i>&nbsp;                // one since the new one is probably still in the
<i>135</i>&nbsp;                // initialization stage.  In either case, the probability
<i>136</i>&nbsp;                // of loading 2 classes in the same VM with the same name
<i>137</i>&nbsp;                // and identityHashCode should be nearly impossible.
<i>138</i>&nbsp;            }
<i>139</i>&nbsp;            // Note: Use a weak reference to avoid holding on to extra
<i>140</i>&nbsp;            // objects and classes after they should be unloaded.
<b class="nc"><i>141</i>&nbsp;            identitymap.put(identity, new WeakReference&lt;Key&gt;(k));</b>
<i>142</i>&nbsp;        }
<i>143</i>&nbsp;
<i>144</i>&nbsp;        private int privatekey;
<i>145</i>&nbsp;
<i>146</i>&nbsp;        /**
<i>147</i>&nbsp;         * Construct a key using the indicated private key.  Each
<i>148</i>&nbsp;         * subclass of Key maintains its own unique domain of integer
<i>149</i>&nbsp;         * keys.  No two objects with the same integer key and of the
<i>150</i>&nbsp;         * same specific subclass can be constructed.  An exception
<i>151</i>&nbsp;         * will be thrown if an attempt is made to construct another
<i>152</i>&nbsp;         * object of a given class with the same integer key as a
<i>153</i>&nbsp;         * pre-existing instance of that subclass of Key.
<i>154</i>&nbsp;         * @param privatekey the specified key
<i>155</i>&nbsp;         */
<b class="nc"><i>156</i>&nbsp;        protected Key(int privatekey) {</b>
<b class="nc"><i>157</i>&nbsp;            this.privatekey = privatekey;</b>
<b class="nc"><i>158</i>&nbsp;            recordIdentity(this);</b>
<i>159</i>&nbsp;        }
<i>160</i>&nbsp;
<i>161</i>&nbsp;        /**
<i>162</i>&nbsp;         * Returns true if the specified object is a valid value
<i>163</i>&nbsp;         * for this Key.
<i>164</i>&nbsp;         * @param val the {@code Object} to test for validity
<i>165</i>&nbsp;         * @return {@code true} if {@code val} is valid;
<i>166</i>&nbsp;         *         {@code false} otherwise.
<i>167</i>&nbsp;         */
<i>168</i>&nbsp;        public abstract boolean isCompatibleValue(Object val);
<i>169</i>&nbsp;
<i>170</i>&nbsp;        /**
<i>171</i>&nbsp;         * Returns the private integer key that the subclass
<i>172</i>&nbsp;         * instantiated this Key with.
<i>173</i>&nbsp;         * @return the private integer key that the subclass
<i>174</i>&nbsp;         * instantiated this Key with.
<i>175</i>&nbsp;         */
<i>176</i>&nbsp;        protected final int intKey() {
<b class="nc"><i>177</i>&nbsp;            return privatekey;</b>
<i>178</i>&nbsp;        }
<i>179</i>&nbsp;
<i>180</i>&nbsp;        /**
<i>181</i>&nbsp;         * The hash code for all Key objects will be the same as the
<i>182</i>&nbsp;         * system identity code of the object as defined by the
<i>183</i>&nbsp;         * System.identityHashCode() method.
<i>184</i>&nbsp;         */
<i>185</i>&nbsp;        public final int hashCode() {
<b class="nc"><i>186</i>&nbsp;            return super.hashCode();</b>
<i>187</i>&nbsp;        }
<i>188</i>&nbsp;
<i>189</i>&nbsp;        /**
<i>190</i>&nbsp;         * The equals method for all Key objects will return the same
<i>191</i>&nbsp;         * result as the equality operator &#39;==&#39;.
<i>192</i>&nbsp;         */
<i>193</i>&nbsp;        public final boolean equals(Object o) {
<b class="nc"><i>194</i>&nbsp;            return this == o;</b>
<i>195</i>&nbsp;        }
<i>196</i>&nbsp;    }
<i>197</i>&nbsp;
<b class="nc"><i>198</i>&nbsp;    HashMap&lt;Object,Object&gt; hintmap = new HashMap&lt;&gt;(7);</b>
<i>199</i>&nbsp;
<i>200</i>&nbsp;    /**
<i>201</i>&nbsp;     * Antialiasing hint key.
<i>202</i>&nbsp;     * The {@code ANTIALIASING} hint controls whether or not the
<i>203</i>&nbsp;     * geometry rendering methods of a {@link Graphics2D} object
<i>204</i>&nbsp;     * will attempt to reduce aliasing artifacts along the edges
<i>205</i>&nbsp;     * of shapes.
<i>206</i>&nbsp;     * &lt;p&gt;
<i>207</i>&nbsp;     * A typical antialiasing algorithm works by blending the existing
<i>208</i>&nbsp;     * colors of the pixels along the boundary of a shape with the
<i>209</i>&nbsp;     * requested fill paint according to the estimated partial pixel
<i>210</i>&nbsp;     * coverage of the shape.
<i>211</i>&nbsp;     * &lt;p&gt;
<i>212</i>&nbsp;     * The allowable values for this hint are
<i>213</i>&nbsp;     * &lt;ul&gt;
<i>214</i>&nbsp;     * &lt;li&gt;{@link #VALUE_ANTIALIAS_ON}
<i>215</i>&nbsp;     * &lt;li&gt;{@link #VALUE_ANTIALIAS_OFF}
<i>216</i>&nbsp;     * &lt;li&gt;{@link #VALUE_ANTIALIAS_DEFAULT}
<i>217</i>&nbsp;     * &lt;/ul&gt;
<i>218</i>&nbsp;     */
<b class="nc"><i>219</i>&nbsp;    public static final Key KEY_ANTIALIASING =</b>
<i>220</i>&nbsp;        SunHints.KEY_ANTIALIASING;
<i>221</i>&nbsp;
<i>222</i>&nbsp;    /**
<i>223</i>&nbsp;     * Antialiasing hint value -- rendering is done with antialiasing.
<i>224</i>&nbsp;     * @see #KEY_ANTIALIASING
<i>225</i>&nbsp;     */
<b class="nc"><i>226</i>&nbsp;    public static final Object VALUE_ANTIALIAS_ON =</b>
<i>227</i>&nbsp;        SunHints.VALUE_ANTIALIAS_ON;
<i>228</i>&nbsp;
<i>229</i>&nbsp;    /**
<i>230</i>&nbsp;     * Antialiasing hint value -- rendering is done without antialiasing.
<i>231</i>&nbsp;     * @see #KEY_ANTIALIASING
<i>232</i>&nbsp;     */
<b class="nc"><i>233</i>&nbsp;    public static final Object VALUE_ANTIALIAS_OFF =</b>
<i>234</i>&nbsp;        SunHints.VALUE_ANTIALIAS_OFF;
<i>235</i>&nbsp;
<i>236</i>&nbsp;    /**
<i>237</i>&nbsp;     * Antialiasing hint value -- rendering is done with a default
<i>238</i>&nbsp;     * antialiasing mode chosen by the implementation.
<i>239</i>&nbsp;     * @see #KEY_ANTIALIASING
<i>240</i>&nbsp;     */
<b class="nc"><i>241</i>&nbsp;    public static final Object VALUE_ANTIALIAS_DEFAULT =</b>
<i>242</i>&nbsp;         SunHints.VALUE_ANTIALIAS_DEFAULT;
<i>243</i>&nbsp;
<i>244</i>&nbsp;    /**
<i>245</i>&nbsp;     * Rendering hint key.
<i>246</i>&nbsp;     * The {@code RENDERING} hint is a general hint that provides
<i>247</i>&nbsp;     * a high level recommendation as to whether to bias algorithm
<i>248</i>&nbsp;     * choices more for speed or quality when evaluating tradeoffs.
<i>249</i>&nbsp;     * This hint could be consulted for any rendering or image
<i>250</i>&nbsp;     * manipulation operation, but decisions will usually honor
<i>251</i>&nbsp;     * other, more specific hints in preference to this hint.
<i>252</i>&nbsp;     * &lt;p&gt;
<i>253</i>&nbsp;     * The allowable values for this hint are
<i>254</i>&nbsp;     * &lt;ul&gt;
<i>255</i>&nbsp;     * &lt;li&gt;{@link #VALUE_RENDER_SPEED}
<i>256</i>&nbsp;     * &lt;li&gt;{@link #VALUE_RENDER_QUALITY}
<i>257</i>&nbsp;     * &lt;li&gt;{@link #VALUE_RENDER_DEFAULT}
<i>258</i>&nbsp;     * &lt;/ul&gt;
<i>259</i>&nbsp;     */
<b class="nc"><i>260</i>&nbsp;    public static final Key KEY_RENDERING =</b>
<i>261</i>&nbsp;         SunHints.KEY_RENDERING;
<i>262</i>&nbsp;
<i>263</i>&nbsp;    /**
<i>264</i>&nbsp;     * Rendering hint value -- rendering algorithms are chosen
<i>265</i>&nbsp;     * with a preference for output speed.
<i>266</i>&nbsp;     * @see #KEY_RENDERING
<i>267</i>&nbsp;     */
<b class="nc"><i>268</i>&nbsp;    public static final Object VALUE_RENDER_SPEED =</b>
<i>269</i>&nbsp;         SunHints.VALUE_RENDER_SPEED;
<i>270</i>&nbsp;
<i>271</i>&nbsp;    /**
<i>272</i>&nbsp;     * Rendering hint value -- rendering algorithms are chosen
<i>273</i>&nbsp;     * with a preference for output quality.
<i>274</i>&nbsp;     * @see #KEY_RENDERING
<i>275</i>&nbsp;     */
<b class="nc"><i>276</i>&nbsp;    public static final Object VALUE_RENDER_QUALITY =</b>
<i>277</i>&nbsp;         SunHints.VALUE_RENDER_QUALITY;
<i>278</i>&nbsp;
<i>279</i>&nbsp;    /**
<i>280</i>&nbsp;     * Rendering hint value -- rendering algorithms are chosen
<i>281</i>&nbsp;     * by the implementation for a good tradeoff of performance
<i>282</i>&nbsp;     * vs. quality.
<i>283</i>&nbsp;     * @see #KEY_RENDERING
<i>284</i>&nbsp;     */
<b class="nc"><i>285</i>&nbsp;    public static final Object VALUE_RENDER_DEFAULT =</b>
<i>286</i>&nbsp;         SunHints.VALUE_RENDER_DEFAULT;
<i>287</i>&nbsp;
<i>288</i>&nbsp;    /**
<i>289</i>&nbsp;     * Dithering hint key.
<i>290</i>&nbsp;     * The {@code DITHERING} hint controls how closely to approximate
<i>291</i>&nbsp;     * a color when storing into a destination with limited color
<i>292</i>&nbsp;     * resolution.
<i>293</i>&nbsp;     * &lt;p&gt;
<i>294</i>&nbsp;     * Some rendering destinations may support a limited number of
<i>295</i>&nbsp;     * color choices which may not be able to accurately represent
<i>296</i>&nbsp;     * the full spectrum of colors that can result during rendering
<i>297</i>&nbsp;     * operations.
<i>298</i>&nbsp;     * For such a destination the {@code DITHERING} hint controls
<i>299</i>&nbsp;     * whether rendering is done with a flat solid fill of a single
<i>300</i>&nbsp;     * pixel value which is the closest supported color to what was
<i>301</i>&nbsp;     * requested, or whether shapes will be filled with a pattern of
<i>302</i>&nbsp;     * colors which combine to better approximate that color.
<i>303</i>&nbsp;     * &lt;p&gt;
<i>304</i>&nbsp;     * The allowable values for this hint are
<i>305</i>&nbsp;     * &lt;ul&gt;
<i>306</i>&nbsp;     * &lt;li&gt;{@link #VALUE_DITHER_DISABLE}
<i>307</i>&nbsp;     * &lt;li&gt;{@link #VALUE_DITHER_ENABLE}
<i>308</i>&nbsp;     * &lt;li&gt;{@link #VALUE_DITHER_DEFAULT}
<i>309</i>&nbsp;     * &lt;/ul&gt;
<i>310</i>&nbsp;     */
<b class="nc"><i>311</i>&nbsp;    public static final Key KEY_DITHERING =</b>
<i>312</i>&nbsp;         SunHints.KEY_DITHERING;
<i>313</i>&nbsp;
<i>314</i>&nbsp;    /**
<i>315</i>&nbsp;     * Dithering hint value -- do not dither when rendering geometry.
<i>316</i>&nbsp;     * @see #KEY_DITHERING
<i>317</i>&nbsp;     */
<b class="nc"><i>318</i>&nbsp;    public static final Object VALUE_DITHER_DISABLE =</b>
<i>319</i>&nbsp;         SunHints.VALUE_DITHER_DISABLE;
<i>320</i>&nbsp;
<i>321</i>&nbsp;    /**
<i>322</i>&nbsp;     * Dithering hint value -- dither when rendering geometry, if needed.
<i>323</i>&nbsp;     * @see #KEY_DITHERING
<i>324</i>&nbsp;     */
<b class="nc"><i>325</i>&nbsp;    public static final Object VALUE_DITHER_ENABLE =</b>
<i>326</i>&nbsp;         SunHints.VALUE_DITHER_ENABLE;
<i>327</i>&nbsp;
<i>328</i>&nbsp;    /**
<i>329</i>&nbsp;     * Dithering hint value -- use a default for dithering chosen by
<i>330</i>&nbsp;     * the implementation.
<i>331</i>&nbsp;     * @see #KEY_DITHERING
<i>332</i>&nbsp;     */
<b class="nc"><i>333</i>&nbsp;    public static final Object VALUE_DITHER_DEFAULT =</b>
<i>334</i>&nbsp;         SunHints.VALUE_DITHER_DEFAULT;
<i>335</i>&nbsp;
<i>336</i>&nbsp;    /**
<i>337</i>&nbsp;     * Text antialiasing hint key.
<i>338</i>&nbsp;     * The {@code TEXT_ANTIALIASING} hint can control the use of
<i>339</i>&nbsp;     * antialiasing algorithms for text independently of the
<i>340</i>&nbsp;     * choice used for shape rendering.
<i>341</i>&nbsp;     * Often an application may want to use antialiasing for text
<i>342</i>&nbsp;     * only and not for other shapes.
<i>343</i>&nbsp;     * Additionally, the algorithms for reducing the aliasing
<i>344</i>&nbsp;     * artifacts for text are often more sophisticated than those
<i>345</i>&nbsp;     * that have been developed for general rendering so this
<i>346</i>&nbsp;     * hint key provides additional values which can control
<i>347</i>&nbsp;     * the choices of some of those text-specific algorithms.
<i>348</i>&nbsp;     * If left in the {@code DEFAULT} state, this hint will
<i>349</i>&nbsp;     * generally defer to the value of the regular
<i>350</i>&nbsp;     * {@link #KEY_ANTIALIASING} hint key.
<i>351</i>&nbsp;     * &lt;p&gt;
<i>352</i>&nbsp;     * The allowable values for this hint are
<i>353</i>&nbsp;     * &lt;ul&gt;
<i>354</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_ON}
<i>355</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_OFF}
<i>356</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_DEFAULT}
<i>357</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_GASP}
<i>358</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB}
<i>359</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_HBGR}
<i>360</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_VRGB}
<i>361</i>&nbsp;     * &lt;li&gt;{@link #VALUE_TEXT_ANTIALIAS_LCD_VBGR}
<i>362</i>&nbsp;     * &lt;/ul&gt;
<i>363</i>&nbsp;     */
<b class="nc"><i>364</i>&nbsp;    public static final Key KEY_TEXT_ANTIALIASING =</b>
<i>365</i>&nbsp;         SunHints.KEY_TEXT_ANTIALIASING;
<i>366</i>&nbsp;
<i>367</i>&nbsp;    /**
<i>368</i>&nbsp;     * Text antialiasing hint value -- text rendering is done with
<i>369</i>&nbsp;     * some form of antialiasing.
<i>370</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>371</i>&nbsp;     */
<b class="nc"><i>372</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_ON =</b>
<i>373</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_ON;
<i>374</i>&nbsp;
<i>375</i>&nbsp;    /**
<i>376</i>&nbsp;     * Text antialiasing hint value -- text rendering is done without
<i>377</i>&nbsp;     * any form of antialiasing.
<i>378</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>379</i>&nbsp;     */
<b class="nc"><i>380</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_OFF =</b>
<i>381</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_OFF;
<i>382</i>&nbsp;
<i>383</i>&nbsp;    /**
<i>384</i>&nbsp;     * Text antialiasing hint value -- text rendering is done according
<i>385</i>&nbsp;     * to the {@link #KEY_ANTIALIASING} hint or a default chosen by the
<i>386</i>&nbsp;     * implementation.
<i>387</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>388</i>&nbsp;     */
<b class="nc"><i>389</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_DEFAULT =</b>
<i>390</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_DEFAULT;
<i>391</i>&nbsp;
<i>392</i>&nbsp;    /**
<i>393</i>&nbsp;     * Text antialiasing hint value -- text rendering is requested to
<i>394</i>&nbsp;     * use information in the font resource which specifies for each point
<i>395</i>&nbsp;     * size whether to apply {@link #VALUE_TEXT_ANTIALIAS_ON} or
<i>396</i>&nbsp;     * {@link #VALUE_TEXT_ANTIALIAS_OFF}.
<i>397</i>&nbsp;     * &lt;p&gt;
<i>398</i>&nbsp;     * TrueType fonts typically provide this information in the &#39;gasp&#39; table.
<i>399</i>&nbsp;     * In the absence of this information, the behaviour for a particular
<i>400</i>&nbsp;     * font and size is determined by implementation defaults.
<i>401</i>&nbsp;     * &lt;p&gt;
<i>402</i>&nbsp;     * &lt;i&gt;Note:&lt;/i&gt;A font designer will typically carefully hint a font for
<i>403</i>&nbsp;     * the most common user interface point sizes. Consequently the &#39;gasp&#39;
<i>404</i>&nbsp;     * table will likely specify to use only hinting at those sizes and not
<i>405</i>&nbsp;     * &quot;smoothing&quot;. So in many cases the resulting text display is
<i>406</i>&nbsp;     * equivalent to {@code VALUE_TEXT_ANTIALIAS_OFF}.
<i>407</i>&nbsp;     * This may be unexpected but is correct.
<i>408</i>&nbsp;     * &lt;p&gt;
<i>409</i>&nbsp;     * Logical fonts which are composed of multiple physical fonts will for
<i>410</i>&nbsp;     * consistency will use the setting most appropriate for the overall
<i>411</i>&nbsp;     * composite font.
<i>412</i>&nbsp;     *
<i>413</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>414</i>&nbsp;     * @since 1.6
<i>415</i>&nbsp;     */
<b class="nc"><i>416</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_GASP =</b>
<i>417</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_GASP;
<i>418</i>&nbsp;
<i>419</i>&nbsp;    /**
<i>420</i>&nbsp;     * Text antialiasing hint value -- request that text be displayed
<i>421</i>&nbsp;     * optimised for an LCD display with subpixels in order from display
<i>422</i>&nbsp;     * left to right of R,G,B such that the horizontal subpixel resolution
<i>423</i>&nbsp;     * is three times that of the full pixel horizontal resolution (HRGB).
<i>424</i>&nbsp;     * This is the most common configuration.
<i>425</i>&nbsp;     * Selecting this hint for displays with one of the other LCD subpixel
<i>426</i>&nbsp;     * configurations will likely result in unfocused text.
<i>427</i>&nbsp;     * &lt;p&gt;
<i>428</i>&nbsp;     * &lt;i&gt;Notes:&lt;/i&gt;&lt;br&gt;
<i>429</i>&nbsp;     * An implementation when choosing whether to apply any of the
<i>430</i>&nbsp;     * LCD text hint values may take into account factors including requiring
<i>431</i>&nbsp;     * color depth of the destination to be at least 15 bits per pixel
<i>432</i>&nbsp;     * (ie 5 bits per color component),
<i>433</i>&nbsp;     * characteristics of a font such as whether embedded bitmaps may
<i>434</i>&nbsp;     * produce better results, or when displaying to a non-local networked
<i>435</i>&nbsp;     * display device enabling it only if suitable protocols are available,
<i>436</i>&nbsp;     * or ignoring the hint if performing very high resolution rendering
<i>437</i>&nbsp;     * or the target device is not appropriate: eg when printing.
<i>438</i>&nbsp;     * &lt;p&gt;
<i>439</i>&nbsp;     * These hints can equally be applied when rendering to software images,
<i>440</i>&nbsp;     * but these images may not then be suitable for general export, as the
<i>441</i>&nbsp;     * text will have been rendered appropriately for a specific subpixel
<i>442</i>&nbsp;     * organisation. Also lossy images are not a good choice, nor image
<i>443</i>&nbsp;     * formats such as GIF which have limited colors.
<i>444</i>&nbsp;     * So unless the image is destined solely for rendering on a
<i>445</i>&nbsp;     * display device with the same configuration, some other text
<i>446</i>&nbsp;     * anti-aliasing hint such as
<i>447</i>&nbsp;     * {@link #VALUE_TEXT_ANTIALIAS_ON}
<i>448</i>&nbsp;     * may be a better choice.
<i>449</i>&nbsp;     * &lt;p&gt;Selecting a value which does not match the LCD display in use
<i>450</i>&nbsp;     * will likely lead to a degradation in text quality.
<i>451</i>&nbsp;     * On display devices (ie CRTs) which do not have the same characteristics
<i>452</i>&nbsp;     * as LCD displays, the overall effect may appear similar to standard text
<i>453</i>&nbsp;     * anti-aliasing, but the quality may be degraded by color distortion.
<i>454</i>&nbsp;     * Analog connected LCD displays may also show little advantage over
<i>455</i>&nbsp;     * standard text-antialiasing and be similar to CRTs.
<i>456</i>&nbsp;     * &lt;p&gt;
<i>457</i>&nbsp;     * In other words for the best results use an LCD display with a digital
<i>458</i>&nbsp;     * display connector and specify the appropriate sub-pixel configuration.
<i>459</i>&nbsp;     *
<i>460</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>461</i>&nbsp;     * @since 1.6
<i>462</i>&nbsp;     */
<b class="nc"><i>463</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_LCD_HRGB =</b>
<i>464</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;
<i>465</i>&nbsp;
<i>466</i>&nbsp;    /**
<i>467</i>&nbsp;     * Text antialiasing hint value -- request that text be displayed
<i>468</i>&nbsp;     * optimised for an LCD display with subpixels in order from display
<i>469</i>&nbsp;     * left to right of B,G,R such that the horizontal subpixel resolution
<i>470</i>&nbsp;     * is three times that of the full pixel horizontal resolution (HBGR).
<i>471</i>&nbsp;     * This is a much less common configuration than HRGB.
<i>472</i>&nbsp;     * Selecting this hint for displays with one of the other LCD subpixel
<i>473</i>&nbsp;     * configurations will likely result in unfocused text.
<i>474</i>&nbsp;     * See {@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB},
<i>475</i>&nbsp;     * for more information on when this hint is applied.
<i>476</i>&nbsp;     *
<i>477</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>478</i>&nbsp;     * @since 1.6
<i>479</i>&nbsp;     */
<b class="nc"><i>480</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_LCD_HBGR =</b>
<i>481</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_LCD_HBGR;
<i>482</i>&nbsp;
<i>483</i>&nbsp;    /**
<i>484</i>&nbsp;     * Text antialiasing hint value -- request that text be displayed
<i>485</i>&nbsp;     * optimised for an LCD display with subpixel organisation from display
<i>486</i>&nbsp;     * top to bottom of R,G,B such that the vertical subpixel resolution is
<i>487</i>&nbsp;     * three times that of the full pixel vertical resolution (VRGB).
<i>488</i>&nbsp;     * Vertical orientation is very uncommon and probably mainly useful
<i>489</i>&nbsp;     * for a physically rotated display.
<i>490</i>&nbsp;     * Selecting this hint for displays with one of the other LCD subpixel
<i>491</i>&nbsp;     * configurations will likely result in unfocused text.
<i>492</i>&nbsp;     * See {@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB},
<i>493</i>&nbsp;     * for more information on when this hint is applied.
<i>494</i>&nbsp;     *
<i>495</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>496</i>&nbsp;     * @since 1.6
<i>497</i>&nbsp;     */
<b class="nc"><i>498</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_LCD_VRGB =</b>
<i>499</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_LCD_VRGB;
<i>500</i>&nbsp;
<i>501</i>&nbsp;    /**
<i>502</i>&nbsp;     * Text antialiasing hint value -- request that text be displayed
<i>503</i>&nbsp;     * optimised for an LCD display with subpixel organisation from display
<i>504</i>&nbsp;     * top to bottom of B,G,R such that the vertical subpixel resolution is
<i>505</i>&nbsp;     * three times that of the full pixel vertical resolution (VBGR).
<i>506</i>&nbsp;     * Vertical orientation is very uncommon and probably mainly useful
<i>507</i>&nbsp;     * for a physically rotated display.
<i>508</i>&nbsp;     * Selecting this hint for displays with one of the other LCD subpixel
<i>509</i>&nbsp;     * configurations will likely result in unfocused text.
<i>510</i>&nbsp;     * See {@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB},
<i>511</i>&nbsp;     * for more information on when this hint is applied.
<i>512</i>&nbsp;     *
<i>513</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>514</i>&nbsp;     * @since 1.6
<i>515</i>&nbsp;     */
<b class="nc"><i>516</i>&nbsp;    public static final Object VALUE_TEXT_ANTIALIAS_LCD_VBGR =</b>
<i>517</i>&nbsp;         SunHints.VALUE_TEXT_ANTIALIAS_LCD_VBGR;
<i>518</i>&nbsp;
<i>519</i>&nbsp;
<i>520</i>&nbsp;    /**
<i>521</i>&nbsp;     * LCD text contrast rendering hint key.
<i>522</i>&nbsp;     * The value is an {@code Integer} object which is used as a text
<i>523</i>&nbsp;     * contrast adjustment when used in conjunction with an LCD text
<i>524</i>&nbsp;     * anti-aliasing hint such as
<i>525</i>&nbsp;     * {@link #VALUE_TEXT_ANTIALIAS_LCD_HRGB}.
<i>526</i>&nbsp;     * &lt;ul&gt;
<i>527</i>&nbsp;     * &lt;li&gt;Values should be a positive integer in the range 100 to 250.
<i>528</i>&nbsp;     * &lt;li&gt;A lower value (eg 100) corresponds to higher contrast text when
<i>529</i>&nbsp;     * displaying dark text on a light background.
<i>530</i>&nbsp;     * &lt;li&gt;A higher value (eg 200) corresponds to lower contrast text when
<i>531</i>&nbsp;     * displaying dark text on a light background.
<i>532</i>&nbsp;     * &lt;li&gt;A typical useful value is in the narrow range 140-180.
<i>533</i>&nbsp;     * &lt;li&gt;If no value is specified, a system or implementation default value
<i>534</i>&nbsp;     * will be applied.
<i>535</i>&nbsp;     * &lt;/ul&gt;
<i>536</i>&nbsp;     * The default value can be expected to be adequate for most purposes,
<i>537</i>&nbsp;     * so clients should rarely need to specify a value for this hint unless
<i>538</i>&nbsp;     * they have concrete information as to an appropriate value.
<i>539</i>&nbsp;     * A higher value does not mean a higher contrast, in fact the opposite
<i>540</i>&nbsp;     * is true.
<i>541</i>&nbsp;     * The correction is applied in a similar manner to a gamma adjustment
<i>542</i>&nbsp;     * for non-linear perceptual luminance response of display systems, but
<i>543</i>&nbsp;     * does not indicate a full correction for this.
<i>544</i>&nbsp;     *
<i>545</i>&nbsp;     * @see #KEY_TEXT_ANTIALIASING
<i>546</i>&nbsp;     * @since 1.6
<i>547</i>&nbsp;     */
<b class="nc"><i>548</i>&nbsp;    public static final Key KEY_TEXT_LCD_CONTRAST =</b>
<i>549</i>&nbsp;        SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST;
<i>550</i>&nbsp;
<i>551</i>&nbsp;    /**
<i>552</i>&nbsp;     * Font fractional metrics hint key.
<i>553</i>&nbsp;     * The {@code FRACTIONALMETRICS} hint controls whether the positioning
<i>554</i>&nbsp;     * of individual character glyphs takes into account the sub-pixel
<i>555</i>&nbsp;     * accuracy of the scaled character advances of the font or whether
<i>556</i>&nbsp;     * such advance vectors are rounded to an integer number of whole
<i>557</i>&nbsp;     * device pixels.
<i>558</i>&nbsp;     * This hint only recommends how much accuracy should be used to
<i>559</i>&nbsp;     * position the glyphs and does not specify or recommend whether or
<i>560</i>&nbsp;     * not the actual rasterization or pixel bounds of the glyph should
<i>561</i>&nbsp;     * be modified to match.
<i>562</i>&nbsp;     * &lt;p&gt;
<i>563</i>&nbsp;     * Rendering text to a low resolution device like a screen will
<i>564</i>&nbsp;     * necessarily involve a number of rounding operations as the
<i>565</i>&nbsp;     * high quality and very precise definition of the shape and
<i>566</i>&nbsp;     * metrics of the character glyphs must be matched to discrete
<i>567</i>&nbsp;     * device pixels.
<i>568</i>&nbsp;     * Ideally the positioning of glyphs during text layout would be
<i>569</i>&nbsp;     * calculated by scaling the design metrics in the font according
<i>570</i>&nbsp;     * to the point size, but then the scaled advance width will not
<i>571</i>&nbsp;     * necessarily be an integer number of pixels.
<i>572</i>&nbsp;     * If the glyphs are positioned with sub-pixel accuracy according
<i>573</i>&nbsp;     * to these scaled design metrics then the rasterization would
<i>574</i>&nbsp;     * ideally need to be adjusted for each possible sub-pixel origin.
<i>575</i>&nbsp;     * &lt;p&gt;
<i>576</i>&nbsp;     * Unfortunately, scaling each glyph customized to its exact
<i>577</i>&nbsp;     * subpixel origin during text layout would be prohibitively
<i>578</i>&nbsp;     * expensive so a simplified system based on integer device
<i>579</i>&nbsp;     * positions is typically used to lay out the text.
<i>580</i>&nbsp;     * The rasterization of the glyph and the scaled advance width
<i>581</i>&nbsp;     * are both adjusted together to yield text that looks good at
<i>582</i>&nbsp;     * device resolution and has consistent integer pixel distances
<i>583</i>&nbsp;     * between glyphs that help the glyphs look uniformly and
<i>584</i>&nbsp;     * consistently spaced and readable.
<i>585</i>&nbsp;     * &lt;p&gt;
<i>586</i>&nbsp;     * This process of rounding advance widths for rasterized glyphs
<i>587</i>&nbsp;     * to integer distances means that the character density and the
<i>588</i>&nbsp;     * overall length of a string of text will be different from the
<i>589</i>&nbsp;     * theoretical design measurements due to the accumulation of
<i>590</i>&nbsp;     * a series of small differences in the adjusted widths of
<i>591</i>&nbsp;     * each glyph.
<i>592</i>&nbsp;     * The specific differences will be different for each glyph,
<i>593</i>&nbsp;     * some being wider and some being narrower than their theoretical
<i>594</i>&nbsp;     * design measurements.
<i>595</i>&nbsp;     * Thus the overall difference in character density and length
<i>596</i>&nbsp;     * will vary by a number of factors including the font, the
<i>597</i>&nbsp;     * specific device resolution being targeted, and the glyphs
<i>598</i>&nbsp;     * chosen to represent the string being rendered.
<i>599</i>&nbsp;     * As a result, rendering the same string at multiple device
<i>600</i>&nbsp;     * resolutions can yield widely varying metrics for whole strings.
<i>601</i>&nbsp;     * &lt;p&gt;
<i>602</i>&nbsp;     * When {@code FRACTIONALMETRICS} are enabled, the true font design
<i>603</i>&nbsp;     * metrics are scaled by the point size and used for layout with
<i>604</i>&nbsp;     * sub-pixel accuracy.
<i>605</i>&nbsp;     * The average density of glyphs and total length of a long
<i>606</i>&nbsp;     * string of characters will therefore more closely match the
<i>607</i>&nbsp;     * theoretical design of the font, but readability may be affected
<i>608</i>&nbsp;     * since individual pairs of characters may not always appear to
<i>609</i>&nbsp;     * be consistent distances apart depending on how the sub-pixel
<i>610</i>&nbsp;     * accumulation of the glyph origins meshes with the device pixel
<i>611</i>&nbsp;     * grid.
<i>612</i>&nbsp;     * Enabling this hint may be desirable when text layout is being
<i>613</i>&nbsp;     * performed that must be consistent across a wide variety of
<i>614</i>&nbsp;     * output resolutions.
<i>615</i>&nbsp;     * Specifically, this hint may be desirable in situations where
<i>616</i>&nbsp;     * the layout of text is being previewed on a low resolution
<i>617</i>&nbsp;     * device like a screen for output that will eventually be
<i>618</i>&nbsp;     * rendered on a high resolution printer or typesetting device.
<i>619</i>&nbsp;     * &lt;p&gt;
<i>620</i>&nbsp;     * When disabled, the scaled design metrics are rounded or adjusted
<i>621</i>&nbsp;     * to integer distances for layout.
<i>622</i>&nbsp;     * The distances between any specific pair of glyphs will be more
<i>623</i>&nbsp;     * uniform on the device, but the density and total length of long
<i>624</i>&nbsp;     * strings may no longer match the theoretical intentions of the
<i>625</i>&nbsp;     * font designer.
<i>626</i>&nbsp;     * Disabling this hint will typically produce more readable results
<i>627</i>&nbsp;     * on low resolution devices like computer monitors.
<i>628</i>&nbsp;     * &lt;p&gt;
<i>629</i>&nbsp;     * The allowable values for this key are
<i>630</i>&nbsp;     * &lt;ul&gt;
<i>631</i>&nbsp;     * &lt;li&gt;{@link #VALUE_FRACTIONALMETRICS_OFF}
<i>632</i>&nbsp;     * &lt;li&gt;{@link #VALUE_FRACTIONALMETRICS_ON}
<i>633</i>&nbsp;     * &lt;li&gt;{@link #VALUE_FRACTIONALMETRICS_DEFAULT}
<i>634</i>&nbsp;     * &lt;/ul&gt;
<i>635</i>&nbsp;     */
<b class="nc"><i>636</i>&nbsp;    public static final Key KEY_FRACTIONALMETRICS =</b>
<i>637</i>&nbsp;         SunHints.KEY_FRACTIONALMETRICS;
<i>638</i>&nbsp;
<i>639</i>&nbsp;    /**
<i>640</i>&nbsp;     * Font fractional metrics hint value -- character glyphs are
<i>641</i>&nbsp;     * positioned with advance widths rounded to pixel boundaries.
<i>642</i>&nbsp;     * @see #KEY_FRACTIONALMETRICS
<i>643</i>&nbsp;     */
<b class="nc"><i>644</i>&nbsp;    public static final Object VALUE_FRACTIONALMETRICS_OFF =</b>
<i>645</i>&nbsp;         SunHints.VALUE_FRACTIONALMETRICS_OFF;
<i>646</i>&nbsp;
<i>647</i>&nbsp;    /**
<i>648</i>&nbsp;     * Font fractional metrics hint value -- character glyphs are
<i>649</i>&nbsp;     * positioned with sub-pixel accuracy.
<i>650</i>&nbsp;     * @see #KEY_FRACTIONALMETRICS
<i>651</i>&nbsp;     */
<b class="nc"><i>652</i>&nbsp;    public static final Object VALUE_FRACTIONALMETRICS_ON =</b>
<i>653</i>&nbsp;         SunHints.VALUE_FRACTIONALMETRICS_ON;
<i>654</i>&nbsp;
<i>655</i>&nbsp;    /**
<i>656</i>&nbsp;     * Font fractional metrics hint value -- character glyphs are
<i>657</i>&nbsp;     * positioned with accuracy chosen by the implementation.
<i>658</i>&nbsp;     * @see #KEY_FRACTIONALMETRICS
<i>659</i>&nbsp;     */
<b class="nc"><i>660</i>&nbsp;    public static final Object VALUE_FRACTIONALMETRICS_DEFAULT =</b>
<i>661</i>&nbsp;         SunHints.VALUE_FRACTIONALMETRICS_DEFAULT;
<i>662</i>&nbsp;
<i>663</i>&nbsp;    /**
<i>664</i>&nbsp;     * Interpolation hint key.
<i>665</i>&nbsp;     * The {@code INTERPOLATION} hint controls how image pixels are
<i>666</i>&nbsp;     * filtered or resampled during an image rendering operation.
<i>667</i>&nbsp;     * &lt;p&gt;
<i>668</i>&nbsp;     * Implicitly images are defined to provide color samples at
<i>669</i>&nbsp;     * integer coordinate locations.
<i>670</i>&nbsp;     * When images are rendered upright with no scaling onto a
<i>671</i>&nbsp;     * destination, the choice of which image pixels map to which
<i>672</i>&nbsp;     * device pixels is obvious and the samples at the integer
<i>673</i>&nbsp;     * coordinate locations in the image are transferred to the
<i>674</i>&nbsp;     * pixels at the corresponding integer locations on the device
<i>675</i>&nbsp;     * pixel grid one for one.
<i>676</i>&nbsp;     * When images are rendered in a scaled, rotated, or otherwise
<i>677</i>&nbsp;     * transformed coordinate system, then the mapping of device
<i>678</i>&nbsp;     * pixel coordinates back to the image can raise the question
<i>679</i>&nbsp;     * of what color sample to use for the continuous coordinates
<i>680</i>&nbsp;     * that lie between the integer locations of the provided image
<i>681</i>&nbsp;     * samples.
<i>682</i>&nbsp;     * Interpolation algorithms define functions which provide a
<i>683</i>&nbsp;     * color sample for any continuous coordinate in an image based
<i>684</i>&nbsp;     * on the color samples at the surrounding integer coordinates.
<i>685</i>&nbsp;     * &lt;p&gt;
<i>686</i>&nbsp;     * The allowable values for this hint are
<i>687</i>&nbsp;     * &lt;ul&gt;
<i>688</i>&nbsp;     * &lt;li&gt;{@link #VALUE_INTERPOLATION_NEAREST_NEIGHBOR}
<i>689</i>&nbsp;     * &lt;li&gt;{@link #VALUE_INTERPOLATION_BILINEAR}
<i>690</i>&nbsp;     * &lt;li&gt;{@link #VALUE_INTERPOLATION_BICUBIC}
<i>691</i>&nbsp;     * &lt;/ul&gt;
<i>692</i>&nbsp;     */
<b class="nc"><i>693</i>&nbsp;    public static final Key KEY_INTERPOLATION =</b>
<i>694</i>&nbsp;         SunHints.KEY_INTERPOLATION;
<i>695</i>&nbsp;
<i>696</i>&nbsp;    /**
<i>697</i>&nbsp;     * Interpolation hint value -- the color sample of the nearest
<i>698</i>&nbsp;     * neighboring integer coordinate sample in the image is used.
<i>699</i>&nbsp;     * Conceptually the image is viewed as a grid of unit-sized
<i>700</i>&nbsp;     * square regions of color centered around the center of each
<i>701</i>&nbsp;     * image pixel.
<i>702</i>&nbsp;     * &lt;p&gt;
<i>703</i>&nbsp;     * As the image is scaled up, it will look correspondingly blocky.
<i>704</i>&nbsp;     * As the image is scaled down, the colors for source pixels will
<i>705</i>&nbsp;     * be either used unmodified, or skipped entirely in the output
<i>706</i>&nbsp;     * representation.
<i>707</i>&nbsp;     *
<i>708</i>&nbsp;     * @see #KEY_INTERPOLATION
<i>709</i>&nbsp;     */
<b class="nc"><i>710</i>&nbsp;    public static final Object VALUE_INTERPOLATION_NEAREST_NEIGHBOR =</b>
<i>711</i>&nbsp;         SunHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
<i>712</i>&nbsp;
<i>713</i>&nbsp;    /**
<i>714</i>&nbsp;     * Interpolation hint value -- the color samples of the 4 nearest
<i>715</i>&nbsp;     * neighboring integer coordinate samples in the image are
<i>716</i>&nbsp;     * interpolated linearly to produce a color sample.
<i>717</i>&nbsp;     * Conceptually the image is viewed as a set of infinitely small
<i>718</i>&nbsp;     * point color samples which have value only at the centers of
<i>719</i>&nbsp;     * integer coordinate pixels and the space between those pixel
<i>720</i>&nbsp;     * centers is filled with linear ramps of colors that connect
<i>721</i>&nbsp;     * adjacent discrete samples in a straight line.
<i>722</i>&nbsp;     * &lt;p&gt;
<i>723</i>&nbsp;     * As the image is scaled up, there are no blocky edges between
<i>724</i>&nbsp;     * the colors in the image as there are with
<i>725</i>&nbsp;     * {@link #VALUE_INTERPOLATION_NEAREST_NEIGHBOR NEAREST_NEIGHBOR},
<i>726</i>&nbsp;     * but the blending may show some subtle discontinuities along the
<i>727</i>&nbsp;     * horizontal and vertical edges that line up with the samples
<i>728</i>&nbsp;     * caused by a sudden change in the slope of the interpolation
<i>729</i>&nbsp;     * from one side of a sample to the other.
<i>730</i>&nbsp;     * As the image is scaled down, more image pixels have their
<i>731</i>&nbsp;     * color samples represented in the resulting output since each
<i>732</i>&nbsp;     * output pixel receives color information from up to 4 image
<i>733</i>&nbsp;     * pixels.
<i>734</i>&nbsp;     *
<i>735</i>&nbsp;     * @see #KEY_INTERPOLATION
<i>736</i>&nbsp;     */
<b class="nc"><i>737</i>&nbsp;    public static final Object VALUE_INTERPOLATION_BILINEAR =</b>
<i>738</i>&nbsp;         SunHints.VALUE_INTERPOLATION_BILINEAR;
<i>739</i>&nbsp;
<i>740</i>&nbsp;    /**
<i>741</i>&nbsp;     * Interpolation hint value -- the color samples of 9 nearby
<i>742</i>&nbsp;     * integer coordinate samples in the image are interpolated using
<i>743</i>&nbsp;     * a cubic function in both {@code X} and {@code Y} to produce
<i>744</i>&nbsp;     * a color sample.
<i>745</i>&nbsp;     * Conceptually the view of the image is very similar to the view
<i>746</i>&nbsp;     * used in the {@link #VALUE_INTERPOLATION_BILINEAR BILINEAR}
<i>747</i>&nbsp;     * algorithm except that the ramps of colors that connect between
<i>748</i>&nbsp;     * the samples are curved and have better continuity of slope
<i>749</i>&nbsp;     * as they cross over between sample boundaries.
<i>750</i>&nbsp;     * &lt;p&gt;
<i>751</i>&nbsp;     * As the image is scaled up, there are no blocky edges and the
<i>752</i>&nbsp;     * interpolation should appear smoother and with better depictions
<i>753</i>&nbsp;     * of any edges in the original image than with {@code BILINEAR}.
<i>754</i>&nbsp;     * As the image is scaled down, even more of the original color
<i>755</i>&nbsp;     * samples from the original image will have their color information
<i>756</i>&nbsp;     * carried through and represented.
<i>757</i>&nbsp;     *
<i>758</i>&nbsp;     * @see #KEY_INTERPOLATION
<i>759</i>&nbsp;     */
<b class="nc"><i>760</i>&nbsp;    public static final Object VALUE_INTERPOLATION_BICUBIC =</b>
<i>761</i>&nbsp;         SunHints.VALUE_INTERPOLATION_BICUBIC;
<i>762</i>&nbsp;
<i>763</i>&nbsp;    /**
<i>764</i>&nbsp;     * Alpha interpolation hint key.
<i>765</i>&nbsp;     * The {@code ALPHA_INTERPOLATION} hint is a general hint that
<i>766</i>&nbsp;     * provides a high level recommendation as to whether to bias
<i>767</i>&nbsp;     * alpha blending algorithm choices more for speed or quality
<i>768</i>&nbsp;     * when evaluating tradeoffs.
<i>769</i>&nbsp;     * &lt;p&gt;
<i>770</i>&nbsp;     * This hint could control the choice of alpha blending
<i>771</i>&nbsp;     * calculations that sacrifice some precision to use fast
<i>772</i>&nbsp;     * lookup tables or lower precision SIMD instructions.
<i>773</i>&nbsp;     * This hint could also control whether or not the color
<i>774</i>&nbsp;     * and alpha values are converted into a linear color space
<i>775</i>&nbsp;     * during the calculations for a more linear visual effect
<i>776</i>&nbsp;     * at the expense of additional per-pixel calculations.
<i>777</i>&nbsp;     * &lt;p&gt;
<i>778</i>&nbsp;     * The allowable values for this hint are
<i>779</i>&nbsp;     * &lt;ul&gt;
<i>780</i>&nbsp;     * &lt;li&gt;{@link #VALUE_ALPHA_INTERPOLATION_SPEED}
<i>781</i>&nbsp;     * &lt;li&gt;{@link #VALUE_ALPHA_INTERPOLATION_QUALITY}
<i>782</i>&nbsp;     * &lt;li&gt;{@link #VALUE_ALPHA_INTERPOLATION_DEFAULT}
<i>783</i>&nbsp;     * &lt;/ul&gt;
<i>784</i>&nbsp;     */
<b class="nc"><i>785</i>&nbsp;    public static final Key KEY_ALPHA_INTERPOLATION =</b>
<i>786</i>&nbsp;         SunHints.KEY_ALPHA_INTERPOLATION;
<i>787</i>&nbsp;
<i>788</i>&nbsp;    /**
<i>789</i>&nbsp;     * Alpha interpolation hint value -- alpha blending algorithms
<i>790</i>&nbsp;     * are chosen with a preference for calculation speed.
<i>791</i>&nbsp;     * @see #KEY_ALPHA_INTERPOLATION
<i>792</i>&nbsp;     */
<b class="nc"><i>793</i>&nbsp;    public static final Object VALUE_ALPHA_INTERPOLATION_SPEED =</b>
<i>794</i>&nbsp;         SunHints.VALUE_ALPHA_INTERPOLATION_SPEED;
<i>795</i>&nbsp;
<i>796</i>&nbsp;    /**
<i>797</i>&nbsp;     * Alpha interpolation hint value -- alpha blending algorithms
<i>798</i>&nbsp;     * are chosen with a preference for precision and visual quality.
<i>799</i>&nbsp;     * @see #KEY_ALPHA_INTERPOLATION
<i>800</i>&nbsp;     */
<b class="nc"><i>801</i>&nbsp;    public static final Object VALUE_ALPHA_INTERPOLATION_QUALITY =</b>
<i>802</i>&nbsp;         SunHints.VALUE_ALPHA_INTERPOLATION_QUALITY;
<i>803</i>&nbsp;
<i>804</i>&nbsp;    /**
<i>805</i>&nbsp;     * Alpha interpolation hint value -- alpha blending algorithms
<i>806</i>&nbsp;     * are chosen by the implementation for a good tradeoff of
<i>807</i>&nbsp;     * performance vs. quality.
<i>808</i>&nbsp;     * @see #KEY_ALPHA_INTERPOLATION
<i>809</i>&nbsp;     */
<b class="nc"><i>810</i>&nbsp;    public static final Object VALUE_ALPHA_INTERPOLATION_DEFAULT =</b>
<i>811</i>&nbsp;         SunHints.VALUE_ALPHA_INTERPOLATION_DEFAULT;
<i>812</i>&nbsp;
<i>813</i>&nbsp;    /**
<i>814</i>&nbsp;     * Color rendering hint key.
<i>815</i>&nbsp;     * The {@code COLOR_RENDERING} hint controls the accuracy of
<i>816</i>&nbsp;     * approximation and conversion when storing colors into a
<i>817</i>&nbsp;     * destination image or surface.
<i>818</i>&nbsp;     * &lt;p&gt;
<i>819</i>&nbsp;     * When a rendering or image manipulation operation produces
<i>820</i>&nbsp;     * a color value that must be stored into a destination, it
<i>821</i>&nbsp;     * must first convert that color into a form suitable for
<i>822</i>&nbsp;     * storing into the destination image or surface.
<i>823</i>&nbsp;     * Minimally, the color components must be converted to bit
<i>824</i>&nbsp;     * representations and ordered in the correct order or an
<i>825</i>&nbsp;     * index into a color lookup table must be chosen before
<i>826</i>&nbsp;     * the data can be stored into the destination memory.
<i>827</i>&nbsp;     * Without this minimal conversion, the data in the destination
<i>828</i>&nbsp;     * would likely represent random, incorrect or possibly even
<i>829</i>&nbsp;     * unsupported values.
<i>830</i>&nbsp;     * Algorithms to quickly convert the results of rendering
<i>831</i>&nbsp;     * operations into the color format of most common destinations
<i>832</i>&nbsp;     * are well known and fairly optimal to execute.
<i>833</i>&nbsp;     * &lt;p&gt;
<i>834</i>&nbsp;     * Simply performing the most basic color format conversion to
<i>835</i>&nbsp;     * store colors into a destination can potentially ignore a
<i>836</i>&nbsp;     * difference in the calibration of the
<i>837</i>&nbsp;     * {@link java.awt.color.ColorSpace}
<i>838</i>&nbsp;     * of the source and destination or other factors such as the
<i>839</i>&nbsp;     * linearity of the gamma correction.
<i>840</i>&nbsp;     * Unless the source and destination {@code ColorSpace} are
<i>841</i>&nbsp;     * identical, to correctly perform a rendering operation with
<i>842</i>&nbsp;     * the most care taken for the accuracy of the colors being
<i>843</i>&nbsp;     * represented, the source colors should be converted to a
<i>844</i>&nbsp;     * device independent {@code ColorSpace} and the results then
<i>845</i>&nbsp;     * converted back to the destination {@code ColorSpace}.
<i>846</i>&nbsp;     * Furthermore, if calculations such as the blending of multiple
<i>847</i>&nbsp;     * source colors are to be performed during the rendering
<i>848</i>&nbsp;     * operation, greater visual clarity can be achieved if the
<i>849</i>&nbsp;     * intermediate device independent {@code ColorSpace} is
<i>850</i>&nbsp;     * chosen to have a linear relationship between the values
<i>851</i>&nbsp;     * being calculated and the perception of the human eye to
<i>852</i>&nbsp;     * the response curves of the output device.
<i>853</i>&nbsp;     * &lt;p&gt;
<i>854</i>&nbsp;     * The allowable values for this hint are
<i>855</i>&nbsp;     * &lt;ul&gt;
<i>856</i>&nbsp;     * &lt;li&gt;{@link #VALUE_COLOR_RENDER_SPEED}
<i>857</i>&nbsp;     * &lt;li&gt;{@link #VALUE_COLOR_RENDER_QUALITY}
<i>858</i>&nbsp;     * &lt;li&gt;{@link #VALUE_COLOR_RENDER_DEFAULT}
<i>859</i>&nbsp;     * &lt;/ul&gt;
<i>860</i>&nbsp;     */
<b class="nc"><i>861</i>&nbsp;    public static final Key KEY_COLOR_RENDERING =</b>
<i>862</i>&nbsp;         SunHints.KEY_COLOR_RENDERING;
<i>863</i>&nbsp;
<i>864</i>&nbsp;    /**
<i>865</i>&nbsp;     * Color rendering hint value -- perform the fastest color
<i>866</i>&nbsp;     * conversion to the format of the output device.
<i>867</i>&nbsp;     * @see #KEY_COLOR_RENDERING
<i>868</i>&nbsp;     */
<b class="nc"><i>869</i>&nbsp;    public static final Object VALUE_COLOR_RENDER_SPEED =</b>
<i>870</i>&nbsp;         SunHints.VALUE_COLOR_RENDER_SPEED;
<i>871</i>&nbsp;
<i>872</i>&nbsp;    /**
<i>873</i>&nbsp;     * Color rendering hint value -- perform the color conversion
<i>874</i>&nbsp;     * calculations with the highest accuracy and visual quality.
<i>875</i>&nbsp;     * @see #KEY_COLOR_RENDERING
<i>876</i>&nbsp;     */
<b class="nc"><i>877</i>&nbsp;    public static final Object VALUE_COLOR_RENDER_QUALITY =</b>
<i>878</i>&nbsp;         SunHints.VALUE_COLOR_RENDER_QUALITY;
<i>879</i>&nbsp;
<i>880</i>&nbsp;    /**
<i>881</i>&nbsp;     * Color rendering hint value -- perform color conversion
<i>882</i>&nbsp;     * calculations as chosen by the implementation to represent
<i>883</i>&nbsp;     * the best available tradeoff between performance and
<i>884</i>&nbsp;     * accuracy.
<i>885</i>&nbsp;     * @see #KEY_COLOR_RENDERING
<i>886</i>&nbsp;     */
<b class="nc"><i>887</i>&nbsp;    public static final Object VALUE_COLOR_RENDER_DEFAULT =</b>
<i>888</i>&nbsp;         SunHints.VALUE_COLOR_RENDER_DEFAULT;
<i>889</i>&nbsp;
<i>890</i>&nbsp;    /**
<i>891</i>&nbsp;     * Stroke normalization control hint key.
<i>892</i>&nbsp;     * The {@code STROKE_CONTROL} hint controls whether a rendering
<i>893</i>&nbsp;     * implementation should or is allowed to modify the geometry
<i>894</i>&nbsp;     * of rendered shapes for various purposes.
<i>895</i>&nbsp;     * &lt;p&gt;
<i>896</i>&nbsp;     * Some implementations may be able to use an optimized platform
<i>897</i>&nbsp;     * rendering library which may be faster than traditional software
<i>898</i>&nbsp;     * rendering algorithms on a given platform, but which may also
<i>899</i>&nbsp;     * not support floating point coordinates.
<i>900</i>&nbsp;     * Some implementations may also have sophisticated algorithms
<i>901</i>&nbsp;     * which perturb the coordinates of a path so that wide lines
<i>902</i>&nbsp;     * appear more uniform in width and spacing.
<i>903</i>&nbsp;     * &lt;p&gt;
<i>904</i>&nbsp;     * If an implementation performs any type of modification or
<i>905</i>&nbsp;     * &quot;normalization&quot; of a path, it should never move the coordinates
<i>906</i>&nbsp;     * by more than half a pixel in any direction.
<i>907</i>&nbsp;     * &lt;p&gt;
<i>908</i>&nbsp;     * The allowable values for this hint are
<i>909</i>&nbsp;     * &lt;ul&gt;
<i>910</i>&nbsp;     * &lt;li&gt;{@link #VALUE_STROKE_NORMALIZE}
<i>911</i>&nbsp;     * &lt;li&gt;{@link #VALUE_STROKE_PURE}
<i>912</i>&nbsp;     * &lt;li&gt;{@link #VALUE_STROKE_DEFAULT}
<i>913</i>&nbsp;     * &lt;/ul&gt;
<i>914</i>&nbsp;     * @since 1.3
<i>915</i>&nbsp;     */
<b class="nc"><i>916</i>&nbsp;    public static final Key KEY_STROKE_CONTROL =</b>
<i>917</i>&nbsp;        SunHints.KEY_STROKE_CONTROL;
<i>918</i>&nbsp;
<i>919</i>&nbsp;    /**
<i>920</i>&nbsp;     * Stroke normalization control hint value -- geometry may be
<i>921</i>&nbsp;     * modified or left pure depending on the tradeoffs in a given
<i>922</i>&nbsp;     * implementation.
<i>923</i>&nbsp;     * Typically this setting allows an implementation to use a fast
<i>924</i>&nbsp;     * integer coordinate based platform rendering library, but does
<i>925</i>&nbsp;     * not specifically request normalization for uniformity or
<i>926</i>&nbsp;     * aesthetics.
<i>927</i>&nbsp;     *
<i>928</i>&nbsp;     * @see #KEY_STROKE_CONTROL
<i>929</i>&nbsp;     * @since 1.3
<i>930</i>&nbsp;     */
<b class="nc"><i>931</i>&nbsp;    public static final Object VALUE_STROKE_DEFAULT =</b>
<i>932</i>&nbsp;        SunHints.VALUE_STROKE_DEFAULT;
<i>933</i>&nbsp;
<i>934</i>&nbsp;    /**
<i>935</i>&nbsp;     * Stroke normalization control hint value -- geometry should
<i>936</i>&nbsp;     * be normalized to improve uniformity or spacing of lines and
<i>937</i>&nbsp;     * overall aesthetics.
<i>938</i>&nbsp;     * Note that different normalization algorithms may be more
<i>939</i>&nbsp;     * successful than others for given input paths.
<i>940</i>&nbsp;     *
<i>941</i>&nbsp;     * @see #KEY_STROKE_CONTROL
<i>942</i>&nbsp;     * @since 1.3
<i>943</i>&nbsp;     */
<b class="nc"><i>944</i>&nbsp;    public static final Object VALUE_STROKE_NORMALIZE =</b>
<i>945</i>&nbsp;        SunHints.VALUE_STROKE_NORMALIZE;
<i>946</i>&nbsp;
<i>947</i>&nbsp;    /**
<i>948</i>&nbsp;     * Stroke normalization control hint value -- geometry should
<i>949</i>&nbsp;     * be left unmodified and rendered with sub-pixel accuracy.
<i>950</i>&nbsp;     *
<i>951</i>&nbsp;     * @see #KEY_STROKE_CONTROL
<i>952</i>&nbsp;     * @since 1.3
<i>953</i>&nbsp;     */
<b class="nc"><i>954</i>&nbsp;    public static final Object VALUE_STROKE_PURE =</b>
<i>955</i>&nbsp;        SunHints.VALUE_STROKE_PURE;
<i>956</i>&nbsp;
<i>957</i>&nbsp;    /**
<i>958</i>&nbsp;     * Image resolution variant hint key.
<i>959</i>&nbsp;     * The {@code RESOLUTION_VARIANT} hint controls which image resolution
<i>960</i>&nbsp;     * variant should be chosen for image drawing.
<i>961</i>&nbsp;     *
<i>962</i>&nbsp;     * &lt;ul&gt;
<i>963</i>&nbsp;     * &lt;li&gt;{@link #VALUE_RESOLUTION_VARIANT_DEFAULT}
<i>964</i>&nbsp;     * &lt;li&gt;{@link #VALUE_RESOLUTION_VARIANT_BASE}
<i>965</i>&nbsp;     * &lt;li&gt;{@link #VALUE_RESOLUTION_VARIANT_SIZE_FIT}
<i>966</i>&nbsp;     * &lt;li&gt;{@link #VALUE_RESOLUTION_VARIANT_DPI_FIT}
<i>967</i>&nbsp;     * &lt;/ul&gt;
<i>968</i>&nbsp;     * @since 9
<i>969</i>&nbsp;     */
<b class="nc"><i>970</i>&nbsp;    public static final Key KEY_RESOLUTION_VARIANT =</b>
<i>971</i>&nbsp;        SunHints.KEY_RESOLUTION_VARIANT;
<i>972</i>&nbsp;
<i>973</i>&nbsp;    /**
<i>974</i>&nbsp;     * Image resolution variant hint value -- an image resolution variant is
<i>975</i>&nbsp;     * chosen based on a default heuristic which may depend on the policies
<i>976</i>&nbsp;     * of the platform
<i>977</i>&nbsp;     *
<i>978</i>&nbsp;     * @see #KEY_RESOLUTION_VARIANT
<i>979</i>&nbsp;     * @since 9
<i>980</i>&nbsp;     */
<b class="nc"><i>981</i>&nbsp;    public static final Object VALUE_RESOLUTION_VARIANT_DEFAULT =</b>
<i>982</i>&nbsp;        SunHints.VALUE_RESOLUTION_VARIANT_DEFAULT;
<i>983</i>&nbsp;
<i>984</i>&nbsp;    /**
<i>985</i>&nbsp;     * Image resolution variant hint value -- the standard resolution of an image
<i>986</i>&nbsp;     * is always used.
<i>987</i>&nbsp;     *
<i>988</i>&nbsp;     * @see #KEY_RESOLUTION_VARIANT
<i>989</i>&nbsp;     * @since 9
<i>990</i>&nbsp;     */
<b class="nc"><i>991</i>&nbsp;    public static final Object VALUE_RESOLUTION_VARIANT_BASE =</b>
<i>992</i>&nbsp;        SunHints.VALUE_RESOLUTION_VARIANT_BASE;
<i>993</i>&nbsp;
<i>994</i>&nbsp;    /**
<i>995</i>&nbsp;     * Image resolution variant hint value -- an image resolution variant is
<i>996</i>&nbsp;     * chosen based on the DPI of the screen and the transform in the Graphics2D
<i>997</i>&nbsp;     * context.
<i>998</i>&nbsp;     *
<i>999</i>&nbsp;     * @see #KEY_RESOLUTION_VARIANT
<i>1000</i>&nbsp;     * @since 9
<i>1001</i>&nbsp;     */
<b class="nc"><i>1002</i>&nbsp;    public static final Object VALUE_RESOLUTION_VARIANT_SIZE_FIT =</b>
<i>1003</i>&nbsp;        SunHints.VALUE_RESOLUTION_VARIANT_SIZE_FIT;
<i>1004</i>&nbsp;
<i>1005</i>&nbsp;    /**
<i>1006</i>&nbsp;     * Image resolution variant hint value -- an image resolution variant is
<i>1007</i>&nbsp;     * chosen based only on the DPI of the screen.
<i>1008</i>&nbsp;     *
<i>1009</i>&nbsp;     * @see #KEY_RESOLUTION_VARIANT
<i>1010</i>&nbsp;     * @since 9
<i>1011</i>&nbsp;     */
<b class="nc"><i>1012</i>&nbsp;    public static final Object VALUE_RESOLUTION_VARIANT_DPI_FIT =</b>
<i>1013</i>&nbsp;        SunHints.VALUE_RESOLUTION_VARIANT_DPI_FIT;
<i>1014</i>&nbsp;
<i>1015</i>&nbsp;    /**
<i>1016</i>&nbsp;     * Constructs a new object with keys and values initialized
<i>1017</i>&nbsp;     * from the specified Map object which may be null.
<i>1018</i>&nbsp;     * @param init a map of key/value pairs to initialize the hints
<i>1019</i>&nbsp;     *          or null if the object should be empty
<i>1020</i>&nbsp;     */
<b class="nc"><i>1021</i>&nbsp;    public RenderingHints(Map&lt;Key,?&gt; init) {</b>
<b class="nc"><i>1022</i>&nbsp;        if (init != null) {</b>
<b class="nc"><i>1023</i>&nbsp;            hintmap.putAll(init);</b>
<i>1024</i>&nbsp;        }
<i>1025</i>&nbsp;    }
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;    /**
<i>1028</i>&nbsp;     * Constructs a new object with the specified key/value pair.
<i>1029</i>&nbsp;     * @param key the key of the particular hint property
<i>1030</i>&nbsp;     * @param value the value of the hint property specified with
<i>1031</i>&nbsp;     * {@code key}
<i>1032</i>&nbsp;     */
<b class="nc"><i>1033</i>&nbsp;    public RenderingHints(Key key, Object value) {</b>
<b class="nc"><i>1034</i>&nbsp;        hintmap.put(key, value);</b>
<i>1035</i>&nbsp;    }
<i>1036</i>&nbsp;
<i>1037</i>&nbsp;    /**
<i>1038</i>&nbsp;     * Returns the number of key-value mappings in this
<i>1039</i>&nbsp;     * {@code RenderingHints}.
<i>1040</i>&nbsp;     *
<i>1041</i>&nbsp;     * @return the number of key-value mappings in this
<i>1042</i>&nbsp;     * {@code RenderingHints}.
<i>1043</i>&nbsp;     */
<i>1044</i>&nbsp;    public int size() {
<b class="nc"><i>1045</i>&nbsp;        return hintmap.size();</b>
<i>1046</i>&nbsp;    }
<i>1047</i>&nbsp;
<i>1048</i>&nbsp;    /**
<i>1049</i>&nbsp;     * Returns {@code true} if this
<i>1050</i>&nbsp;     * {@code RenderingHints} contains no key-value mappings.
<i>1051</i>&nbsp;     *
<i>1052</i>&nbsp;     * @return {@code true} if this
<i>1053</i>&nbsp;     * {@code RenderingHints} contains no key-value mappings.
<i>1054</i>&nbsp;     */
<i>1055</i>&nbsp;    public boolean isEmpty() {
<b class="nc"><i>1056</i>&nbsp;        return hintmap.isEmpty();</b>
<i>1057</i>&nbsp;    }
<i>1058</i>&nbsp;
<i>1059</i>&nbsp;    /**
<i>1060</i>&nbsp;     * Returns {@code true} if this {@code RenderingHints}
<i>1061</i>&nbsp;     *  contains a mapping for the specified key.
<i>1062</i>&nbsp;     *
<i>1063</i>&nbsp;     * @param key key whose presence in this
<i>1064</i>&nbsp;     * {@code RenderingHints} is to be tested.
<i>1065</i>&nbsp;     * @return {@code true} if this {@code RenderingHints}
<i>1066</i>&nbsp;     *          contains a mapping for the specified key.
<i>1067</i>&nbsp;     * @exception ClassCastException if the key can not
<i>1068</i>&nbsp;     *            be cast to {@code RenderingHints.Key}
<i>1069</i>&nbsp;     */
<i>1070</i>&nbsp;    public boolean containsKey(Object key) {
<b class="nc"><i>1071</i>&nbsp;        return hintmap.containsKey((Key) key);</b>
<i>1072</i>&nbsp;    }
<i>1073</i>&nbsp;
<i>1074</i>&nbsp;    /**
<i>1075</i>&nbsp;     * Returns true if this RenderingHints maps one or more keys to the
<i>1076</i>&nbsp;     * specified value.
<i>1077</i>&nbsp;     * More formally, returns {@code true} if and only
<i>1078</i>&nbsp;     * if this {@code RenderingHints}
<i>1079</i>&nbsp;     * contains at least one mapping to a value {@code v} such that
<i>1080</i>&nbsp;     * &lt;pre&gt;
<i>1081</i>&nbsp;     * (value==null ? v==null : value.equals(v))
<i>1082</i>&nbsp;     * &lt;/pre&gt;.
<i>1083</i>&nbsp;     * This operation will probably require time linear in the
<i>1084</i>&nbsp;     * {@code RenderingHints} size for most implementations
<i>1085</i>&nbsp;     * of {@code RenderingHints}.
<i>1086</i>&nbsp;     *
<i>1087</i>&nbsp;     * @param value value whose presence in this
<i>1088</i>&nbsp;     *          {@code RenderingHints} is to be tested.
<i>1089</i>&nbsp;     * @return {@code true} if this {@code RenderingHints}
<i>1090</i>&nbsp;     *           maps one or more keys to the specified value.
<i>1091</i>&nbsp;     */
<i>1092</i>&nbsp;    public boolean containsValue(Object value) {
<b class="nc"><i>1093</i>&nbsp;        return hintmap.containsValue(value);</b>
<i>1094</i>&nbsp;    }
<i>1095</i>&nbsp;
<i>1096</i>&nbsp;    /**
<i>1097</i>&nbsp;     * Returns the value to which the specified key is mapped.
<i>1098</i>&nbsp;     * @param   key   a rendering hint key
<i>1099</i>&nbsp;     * @return  the value to which the key is mapped in this object or
<i>1100</i>&nbsp;     *          {@code null} if the key is not mapped to any value in
<i>1101</i>&nbsp;     *          this object.
<i>1102</i>&nbsp;     * @exception ClassCastException if the key can not
<i>1103</i>&nbsp;     *            be cast to {@code RenderingHints.Key}
<i>1104</i>&nbsp;     * @see     #put(Object, Object)
<i>1105</i>&nbsp;     */
<i>1106</i>&nbsp;    public Object get(Object key) {
<b class="nc"><i>1107</i>&nbsp;        return hintmap.get((Key) key);</b>
<i>1108</i>&nbsp;    }
<i>1109</i>&nbsp;
<i>1110</i>&nbsp;    /**
<i>1111</i>&nbsp;     * Maps the specified {@code key} to the specified
<i>1112</i>&nbsp;     * {@code value} in this {@code RenderingHints} object.
<i>1113</i>&nbsp;     * Neither the key nor the value can be {@code null}.
<i>1114</i>&nbsp;     * The value can be retrieved by calling the {@code get} method
<i>1115</i>&nbsp;     * with a key that is equal to the original key.
<i>1116</i>&nbsp;     * @param      key     the rendering hint key.
<i>1117</i>&nbsp;     * @param      value   the rendering hint value.
<i>1118</i>&nbsp;     * @return     the previous value of the specified key in this object
<i>1119</i>&nbsp;     *             or {@code null} if it did not have one.
<i>1120</i>&nbsp;     * @exception NullPointerException if the key is
<i>1121</i>&nbsp;     *            {@code null}.
<i>1122</i>&nbsp;     * @exception ClassCastException if the key can not
<i>1123</i>&nbsp;     *            be cast to {@code RenderingHints.Key}
<i>1124</i>&nbsp;     * @exception IllegalArgumentException if the
<i>1125</i>&nbsp;     *            {@link Key#isCompatibleValue(java.lang.Object)
<i>1126</i>&nbsp;     *                   Key.isCompatibleValue()}
<i>1127</i>&nbsp;     *            method of the specified key returns false for the
<i>1128</i>&nbsp;     *            specified value
<i>1129</i>&nbsp;     * @see     #get(Object)
<i>1130</i>&nbsp;     */
<i>1131</i>&nbsp;    public Object put(Object key, Object value) {
<b class="nc"><i>1132</i>&nbsp;        if (!((Key) key).isCompatibleValue(value)) {</b>
<b class="nc"><i>1133</i>&nbsp;            throw new IllegalArgumentException(value+</b>
<i>1134</i>&nbsp;                                               &quot; incompatible with &quot;+
<i>1135</i>&nbsp;                                               key);
<i>1136</i>&nbsp;        }
<b class="nc"><i>1137</i>&nbsp;        return hintmap.put((Key) key, value);</b>
<i>1138</i>&nbsp;    }
<i>1139</i>&nbsp;
<i>1140</i>&nbsp;    /**
<i>1141</i>&nbsp;     * Adds all of the keys and corresponding values from the specified
<i>1142</i>&nbsp;     * {@code RenderingHints} object to this
<i>1143</i>&nbsp;     * {@code RenderingHints} object. Keys that are present in
<i>1144</i>&nbsp;     * this {@code RenderingHints} object, but not in the specified
<i>1145</i>&nbsp;     * {@code RenderingHints} object are not affected.
<i>1146</i>&nbsp;     * @param hints the set of key/value pairs to be added to this
<i>1147</i>&nbsp;     * {@code RenderingHints} object
<i>1148</i>&nbsp;     */
<i>1149</i>&nbsp;    public void add(RenderingHints hints) {
<b class="nc"><i>1150</i>&nbsp;        hintmap.putAll(hints.hintmap);</b>
<i>1151</i>&nbsp;    }
<i>1152</i>&nbsp;
<i>1153</i>&nbsp;    /**
<i>1154</i>&nbsp;     * Clears this {@code RenderingHints} object of all key/value
<i>1155</i>&nbsp;     * pairs.
<i>1156</i>&nbsp;     */
<i>1157</i>&nbsp;    public void clear() {
<b class="nc"><i>1158</i>&nbsp;        hintmap.clear();</b>
<i>1159</i>&nbsp;    }
<i>1160</i>&nbsp;
<i>1161</i>&nbsp;    /**
<i>1162</i>&nbsp;     * Removes the key and its corresponding value from this
<i>1163</i>&nbsp;     * {@code RenderingHints} object. This method does nothing if the
<i>1164</i>&nbsp;     * key is not in this {@code RenderingHints} object.
<i>1165</i>&nbsp;     * @param   key   the rendering hints key that needs to be removed
<i>1166</i>&nbsp;     * @exception ClassCastException if the key can not
<i>1167</i>&nbsp;     *            be cast to {@code RenderingHints.Key}
<i>1168</i>&nbsp;     * @return  the value to which the key had previously been mapped in this
<i>1169</i>&nbsp;     *          {@code RenderingHints} object, or {@code null}
<i>1170</i>&nbsp;     *          if the key did not have a mapping.
<i>1171</i>&nbsp;     */
<i>1172</i>&nbsp;    public Object remove(Object key) {
<b class="nc"><i>1173</i>&nbsp;        return hintmap.remove((Key) key);</b>
<i>1174</i>&nbsp;    }
<i>1175</i>&nbsp;
<i>1176</i>&nbsp;    /**
<i>1177</i>&nbsp;     * Copies all of the mappings from the specified {@code Map}
<i>1178</i>&nbsp;     * to this {@code RenderingHints}.  These mappings replace
<i>1179</i>&nbsp;     * any mappings that this {@code RenderingHints} had for any
<i>1180</i>&nbsp;     * of the keys currently in the specified {@code Map}.
<i>1181</i>&nbsp;     * @param m the specified {@code Map}
<i>1182</i>&nbsp;     * @exception ClassCastException class of a key or value
<i>1183</i>&nbsp;     *          in the specified {@code Map} prevents it from being
<i>1184</i>&nbsp;     *          stored in this {@code RenderingHints}.
<i>1185</i>&nbsp;     * @exception IllegalArgumentException some aspect
<i>1186</i>&nbsp;     *          of a key or value in the specified {@code Map}
<i>1187</i>&nbsp;     *           prevents it from being stored in
<i>1188</i>&nbsp;     *            this {@code RenderingHints}.
<i>1189</i>&nbsp;     */
<i>1190</i>&nbsp;    public void putAll(Map&lt;?,?&gt; m) {
<i>1191</i>&nbsp;        // ## javac bug?
<i>1192</i>&nbsp;        //if (m instanceof RenderingHints) {
<b class="nc"><i>1193</i>&nbsp;        if (RenderingHints.class.isInstance(m)) {</b>
<i>1194</i>&nbsp;            //hintmap.putAll(((RenderingHints) m).hintmap);
<b class="nc"><i>1195</i>&nbsp;            for (Map.Entry&lt;?,?&gt; entry : m.entrySet())</b>
<b class="nc"><i>1196</i>&nbsp;                hintmap.put(entry.getKey(), entry.getValue());</b>
<i>1197</i>&nbsp;        } else {
<i>1198</i>&nbsp;            // Funnel each key/value pair through our protected put method
<b class="nc"><i>1199</i>&nbsp;            for (Map.Entry&lt;?,?&gt; entry : m.entrySet())</b>
<b class="nc"><i>1200</i>&nbsp;                put(entry.getKey(), entry.getValue());</b>
<i>1201</i>&nbsp;        }
<i>1202</i>&nbsp;    }
<i>1203</i>&nbsp;
<i>1204</i>&nbsp;    /**
<i>1205</i>&nbsp;     * Returns a {@code Set} view of the Keys contained in this
<i>1206</i>&nbsp;     * {@code RenderingHints}.  The Set is backed by the
<i>1207</i>&nbsp;     * {@code RenderingHints}, so changes to the
<i>1208</i>&nbsp;     * {@code RenderingHints} are reflected in the {@code Set},
<i>1209</i>&nbsp;     * and vice-versa.  If the {@code RenderingHints} is modified
<i>1210</i>&nbsp;     * while an iteration over the {@code Set} is in progress,
<i>1211</i>&nbsp;     * the results of the iteration are undefined.  The {@code Set}
<i>1212</i>&nbsp;     * supports element removal, which removes the corresponding
<i>1213</i>&nbsp;     * mapping from the {@code RenderingHints}, via the
<i>1214</i>&nbsp;     * {@code Iterator.remove}, {@code Set.remove},
<i>1215</i>&nbsp;     * {@code removeAll retainAll}, and
<i>1216</i>&nbsp;     * {@code clear} operations.  It does not support
<i>1217</i>&nbsp;     * the {@code add} or {@code addAll} operations.
<i>1218</i>&nbsp;     *
<i>1219</i>&nbsp;     * @return a {@code Set} view of the keys contained
<i>1220</i>&nbsp;     * in this {@code RenderingHints}.
<i>1221</i>&nbsp;     */
<i>1222</i>&nbsp;    public Set&lt;Object&gt; keySet() {
<b class="nc"><i>1223</i>&nbsp;        return hintmap.keySet();</b>
<i>1224</i>&nbsp;    }
<i>1225</i>&nbsp;
<i>1226</i>&nbsp;    /**
<i>1227</i>&nbsp;     * Returns a {@code Collection} view of the values
<i>1228</i>&nbsp;     * contained in this {@code RenderingHints}.
<i>1229</i>&nbsp;     * The {@code Collection} is backed by the
<i>1230</i>&nbsp;     * {@code RenderingHints}, so changes to
<i>1231</i>&nbsp;     * the {@code RenderingHints} are reflected in
<i>1232</i>&nbsp;     * the {@code Collection}, and vice-versa.
<i>1233</i>&nbsp;     * If the {@code RenderingHints} is modified while
<i>1234</i>&nbsp;     * an iteration over the {@code Collection} is
<i>1235</i>&nbsp;     * in progress, the results of the iteration are undefined.
<i>1236</i>&nbsp;     * The {@code Collection} supports element removal,
<i>1237</i>&nbsp;     * which removes the corresponding mapping from the
<i>1238</i>&nbsp;     * {@code RenderingHints}, via the
<i>1239</i>&nbsp;     * {@code Iterator.remove},
<i>1240</i>&nbsp;     * {@code Collection.remove}, {@code removeAll},
<i>1241</i>&nbsp;     * {@code retainAll} and {@code clear} operations.
<i>1242</i>&nbsp;     * It does not support the {@code add} or
<i>1243</i>&nbsp;     * {@code addAll} operations.
<i>1244</i>&nbsp;     *
<i>1245</i>&nbsp;     * @return a {@code Collection} view of the values
<i>1246</i>&nbsp;     *          contained in this {@code RenderingHints}.
<i>1247</i>&nbsp;     */
<i>1248</i>&nbsp;    public Collection&lt;Object&gt; values() {
<b class="nc"><i>1249</i>&nbsp;        return hintmap.values();</b>
<i>1250</i>&nbsp;    }
<i>1251</i>&nbsp;
<i>1252</i>&nbsp;    /**
<i>1253</i>&nbsp;     * Returns a {@code Set} view of the mappings contained
<i>1254</i>&nbsp;     * in this {@code RenderingHints}.  Each element in the
<i>1255</i>&nbsp;     * returned {@code Set} is a {@code Map.Entry}.
<i>1256</i>&nbsp;     * The {@code Set} is backed by the {@code RenderingHints},
<i>1257</i>&nbsp;     * so changes to the {@code RenderingHints} are reflected
<i>1258</i>&nbsp;     * in the {@code Set}, and vice-versa.  If the
<i>1259</i>&nbsp;     * {@code RenderingHints} is modified while
<i>1260</i>&nbsp;     * while an iteration over the {@code Set} is in progress,
<i>1261</i>&nbsp;     * the results of the iteration are undefined.
<i>1262</i>&nbsp;     * &lt;p&gt;
<i>1263</i>&nbsp;     * The entrySet returned from a {@code RenderingHints} object
<i>1264</i>&nbsp;     * is not modifiable.
<i>1265</i>&nbsp;     *
<i>1266</i>&nbsp;     * @return a {@code Set} view of the mappings contained in
<i>1267</i>&nbsp;     * this {@code RenderingHints}.
<i>1268</i>&nbsp;     */
<i>1269</i>&nbsp;    public Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet() {
<b class="nc"><i>1270</i>&nbsp;        return Collections.unmodifiableMap(hintmap).entrySet();</b>
<i>1271</i>&nbsp;    }
<i>1272</i>&nbsp;
<i>1273</i>&nbsp;    /**
<i>1274</i>&nbsp;     * Compares the specified {@code Object} with this
<i>1275</i>&nbsp;     * {@code RenderingHints} for equality.
<i>1276</i>&nbsp;     * Returns {@code true} if the specified object is also a
<i>1277</i>&nbsp;     * {@code Map} and the two {@code Map} objects represent
<i>1278</i>&nbsp;     * the same mappings.  More formally, two {@code Map} objects
<i>1279</i>&nbsp;     * {@code t1} and {@code t2} represent the same mappings
<i>1280</i>&nbsp;     * if {@code t1.keySet().equals(t2.keySet())} and for every
<i>1281</i>&nbsp;     * key {@code k} in {@code t1.keySet()},
<i>1282</i>&nbsp;     * &lt;pre&gt;
<i>1283</i>&nbsp;     * (t1.get(k)==null ? t2.get(k)==null : t1.get(k).equals(t2.get(k)))
<i>1284</i>&nbsp;     * &lt;/pre&gt;.
<i>1285</i>&nbsp;     * This ensures that the {@code equals} method works properly across
<i>1286</i>&nbsp;     * different implementations of the {@code Map} interface.
<i>1287</i>&nbsp;     *
<i>1288</i>&nbsp;     * @param o {@code Object} to be compared for equality with
<i>1289</i>&nbsp;     * this {@code RenderingHints}.
<i>1290</i>&nbsp;     * @return {@code true} if the specified {@code Object}
<i>1291</i>&nbsp;     * is equal to this {@code RenderingHints}.
<i>1292</i>&nbsp;     */
<i>1293</i>&nbsp;    public boolean equals(Object o) {
<b class="nc"><i>1294</i>&nbsp;        if (o instanceof RenderingHints) {</b>
<b class="nc"><i>1295</i>&nbsp;            return hintmap.equals(((RenderingHints) o).hintmap);</b>
<b class="nc"><i>1296</i>&nbsp;        } else if (o instanceof Map) {</b>
<b class="nc"><i>1297</i>&nbsp;            return hintmap.equals(o);</b>
<i>1298</i>&nbsp;        }
<b class="nc"><i>1299</i>&nbsp;        return false;</b>
<i>1300</i>&nbsp;    }
<i>1301</i>&nbsp;
<i>1302</i>&nbsp;    /**
<i>1303</i>&nbsp;     * Returns the hash code value for this {@code RenderingHints}.
<i>1304</i>&nbsp;     * The hash code of a {@code RenderingHints} is defined to be
<i>1305</i>&nbsp;     * the sum of the hashCodes of each {@code Entry} in the
<i>1306</i>&nbsp;     * {@code RenderingHints} object&#39;s entrySet view.  This ensures that
<i>1307</i>&nbsp;     * {@code t1.equals(t2)} implies that
<i>1308</i>&nbsp;     * {@code t1.hashCode()==t2.hashCode()} for any two {@code Map}
<i>1309</i>&nbsp;     * objects {@code t1} and {@code t2}, as required by the general
<i>1310</i>&nbsp;     * contract of {@code Object.hashCode}.
<i>1311</i>&nbsp;     *
<i>1312</i>&nbsp;     * @return the hash code value for this {@code RenderingHints}.
<i>1313</i>&nbsp;     * @see java.util.Map.Entry#hashCode()
<i>1314</i>&nbsp;     * @see Object#hashCode()
<i>1315</i>&nbsp;     * @see Object#equals(Object)
<i>1316</i>&nbsp;     * @see #equals(Object)
<i>1317</i>&nbsp;     */
<i>1318</i>&nbsp;    public int hashCode() {
<b class="nc"><i>1319</i>&nbsp;        return hintmap.hashCode();</b>
<i>1320</i>&nbsp;    }
<i>1321</i>&nbsp;
<i>1322</i>&nbsp;    /**
<i>1323</i>&nbsp;     * Creates a clone of this {@code RenderingHints} object
<i>1324</i>&nbsp;     * that has the same contents as this {@code RenderingHints}
<i>1325</i>&nbsp;     * object.
<i>1326</i>&nbsp;     * @return a clone of this instance.
<i>1327</i>&nbsp;     */
<i>1328</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>1329</i>&nbsp;    public Object clone() {
<i>1330</i>&nbsp;        RenderingHints rh;
<i>1331</i>&nbsp;        try {
<b class="nc"><i>1332</i>&nbsp;            rh = (RenderingHints) super.clone();</b>
<b class="nc"><i>1333</i>&nbsp;            if (hintmap != null) {</b>
<b class="nc"><i>1334</i>&nbsp;                rh.hintmap = (HashMap&lt;Object,Object&gt;) hintmap.clone();</b>
<i>1335</i>&nbsp;            }
<b class="nc"><i>1336</i>&nbsp;        } catch (CloneNotSupportedException e) {</b>
<i>1337</i>&nbsp;            // this shouldn&#39;t happen, since we are Cloneable
<b class="nc"><i>1338</i>&nbsp;            throw new InternalError(e);</b>
<b class="nc"><i>1339</i>&nbsp;        }</b>
<i>1340</i>&nbsp;
<b class="nc"><i>1341</i>&nbsp;        return rh;</b>
<i>1342</i>&nbsp;    }
<i>1343</i>&nbsp;
<i>1344</i>&nbsp;    /**
<i>1345</i>&nbsp;     * Returns a rather long string representation of the hashmap
<i>1346</i>&nbsp;     * which contains the mappings of keys to values for this
<i>1347</i>&nbsp;     * {@code RenderingHints} object.
<i>1348</i>&nbsp;     * @return  a string representation of this object.
<i>1349</i>&nbsp;     */
<i>1350</i>&nbsp;    public String toString() {
<b class="nc"><i>1351</i>&nbsp;        if (hintmap == null) {</b>
<b class="nc"><i>1352</i>&nbsp;            return getClass().getName() + &quot;@&quot; +</b>
<b class="nc"><i>1353</i>&nbsp;                Integer.toHexString(hashCode()) +</b>
<i>1354</i>&nbsp;                &quot; (0 hints)&quot;;
<i>1355</i>&nbsp;        }
<i>1356</i>&nbsp;
<b class="nc"><i>1357</i>&nbsp;        return hintmap.toString();</b>
<i>1358</i>&nbsp;    }
<i>1359</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
