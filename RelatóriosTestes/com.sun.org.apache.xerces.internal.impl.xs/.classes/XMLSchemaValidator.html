


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: XMLSchemaValidator</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.org.apache.xerces.internal.impl.xs</a> ]
</div>

<h1>Coverage Summary for Class: XMLSchemaValidator (com.sun.org.apache.xerces.internal.impl.xs)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">XMLSchemaValidator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1049)
  </span>
</td>
</tr>
  <tr>
    <td class="name">XMLSchemaValidator$KeyRefValueStore</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$KeyValueStore</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$LocalIDKey</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$ShortVector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$UniqueValueStore</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$ValueStoreBase</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 191)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$ValueStoreCache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 89)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$XPathMatcherStack</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">XMLSchemaValidator$XSIErrorReporter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 40)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 125)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1449)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2006, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; */
<i>4</i>&nbsp;/*
<i>5</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>6</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>7</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>8</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>9</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>10</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>13</i>&nbsp; *
<i>14</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>15</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>16</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>17</i>&nbsp; * See the License for the specific language governing permissions and
<i>18</i>&nbsp; * limitations under the License.
<i>19</i>&nbsp; */
<i>20</i>&nbsp;
<i>21</i>&nbsp;package com.sun.org.apache.xerces.internal.impl.xs;
<i>22</i>&nbsp;
<i>23</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.Constants;
<i>24</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
<i>25</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
<i>26</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
<i>27</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.DatatypeException;
<i>28</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
<i>29</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.ValidatedInfo;
<i>30</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
<i>31</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.xs.XSSimpleTypeDecl;
<i>32</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.validation.ConfigurableValidationState;
<i>33</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.validation.ValidationManager;
<i>34</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.validation.ValidationState;
<i>35</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.Field;
<i>36</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.FieldActivator;
<i>37</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.IdentityConstraint;
<i>38</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.KeyRef;
<i>39</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.Selector;
<i>40</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.UniqueOrKey;
<i>41</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.ValueStore;
<i>42</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.identity.XPathMatcher;
<i>43</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.models.CMBuilder;
<i>44</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.models.CMNodeFactory;
<i>45</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.models.XSCMValidator;
<i>46</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.util.XS10TypeHelper;
<i>47</i>&nbsp;import com.sun.org.apache.xerces.internal.parsers.XMLParser;
<i>48</i>&nbsp;import com.sun.org.apache.xerces.internal.util.AugmentationsImpl;
<i>49</i>&nbsp;import com.sun.org.apache.xerces.internal.util.IntStack;
<i>50</i>&nbsp;import com.sun.org.apache.xerces.internal.util.SymbolTable;
<i>51</i>&nbsp;import com.sun.org.apache.xerces.internal.util.URI.MalformedURIException;
<i>52</i>&nbsp;import com.sun.org.apache.xerces.internal.util.XMLAttributesImpl;
<i>53</i>&nbsp;import com.sun.org.apache.xerces.internal.util.XMLChar;
<i>54</i>&nbsp;import com.sun.org.apache.xerces.internal.util.XMLSymbols;
<i>55</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.Augmentations;
<i>56</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
<i>57</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.QName;
<i>58</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
<i>59</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
<i>60</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.XMLLocator;
<i>61</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
<i>62</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.XMLString;
<i>63</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.XNIException;
<i>64</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
<i>65</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarPool;
<i>66</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
<i>67</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.parser.XMLComponentManager;
<i>68</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
<i>69</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentFilter;
<i>70</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;
<i>71</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.parser.XMLEntityResolver;
<i>72</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
<i>73</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
<i>74</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
<i>75</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.ShortList;
<i>76</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.StringList;
<i>77</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.XSConstants;
<i>78</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.XSObjectList;
<i>79</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
<i>80</i>&nbsp;import java.io.IOException;
<i>81</i>&nbsp;import java.util.ArrayList;
<i>82</i>&nbsp;import java.util.Collections;
<i>83</i>&nbsp;import java.util.HashMap;
<i>84</i>&nbsp;import java.util.Iterator;
<i>85</i>&nbsp;import java.util.List;
<i>86</i>&nbsp;import java.util.Map;
<i>87</i>&nbsp;import java.util.Stack;
<i>88</i>&nbsp;import java.util.Vector;
<i>89</i>&nbsp;import javax.xml.XMLConstants;
<i>90</i>&nbsp;import jdk.xml.internal.JdkXmlUtils;
<i>91</i>&nbsp;
<i>92</i>&nbsp;/**
<i>93</i>&nbsp; * The XML Schema validator. The validator implements a document
<i>94</i>&nbsp; * filter: receiving document events from the scanner; validating
<i>95</i>&nbsp; * the content and structure; augmenting the InfoSet, if applicable;
<i>96</i>&nbsp; * and notifying the parser of the information resulting from the
<i>97</i>&nbsp; * validation process.
<i>98</i>&nbsp; * &lt;p&gt;
<i>99</i>&nbsp; * This component requires the following features and properties from the
<i>100</i>&nbsp; * component manager that uses it:
<i>101</i>&nbsp; * &lt;ul&gt;
<i>102</i>&nbsp; *  &lt;li&gt;http://xml.org/sax/features/validation&lt;/li&gt;
<i>103</i>&nbsp; *  &lt;li&gt;http://apache.org/xml/properties/internal/symbol-table&lt;/li&gt;
<i>104</i>&nbsp; *  &lt;li&gt;http://apache.org/xml/properties/internal/error-reporter&lt;/li&gt;
<i>105</i>&nbsp; *  &lt;li&gt;http://apache.org/xml/properties/internal/entity-resolver&lt;/li&gt;
<i>106</i>&nbsp; * &lt;/ul&gt;
<i>107</i>&nbsp; *
<i>108</i>&nbsp; * @xerces.internal
<b class="nc"><i>109</i>&nbsp; *</b>
<i>110</i>&nbsp; * @author Sandy Gao IBM
<i>111</i>&nbsp; * @author Elena Litani IBM
<i>112</i>&nbsp; * @author Andy Clark IBM
<i>113</i>&nbsp; * @author Neeraj Bajaj, Sun Microsystems, inc.
<i>114</i>&nbsp; * @LastModified: Nov 2017
<i>115</i>&nbsp; */
<i>116</i>&nbsp;public class XMLSchemaValidator
<i>117</i>&nbsp;    implements XMLComponent, XMLDocumentFilter, FieldActivator, RevalidationHandler, XSElementDeclHelper {
<i>118</i>&nbsp;
<i>119</i>&nbsp;    //
<i>120</i>&nbsp;    // Constants
<i>121</i>&nbsp;    //
<i>122</i>&nbsp;    private static final boolean DEBUG = false;
<i>123</i>&nbsp;
<i>124</i>&nbsp;    // feature identifiers
<i>125</i>&nbsp;
<i>126</i>&nbsp;    /** Feature identifier: validation. */
<i>127</i>&nbsp;    protected static final String VALIDATION =
<i>128</i>&nbsp;        Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
<i>129</i>&nbsp;
<i>130</i>&nbsp;    /** Feature identifier: validation. */
<i>131</i>&nbsp;    protected static final String SCHEMA_VALIDATION =
<i>132</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE;
<i>133</i>&nbsp;
<i>134</i>&nbsp;    /** Feature identifier: schema full checking*/
<i>135</i>&nbsp;    protected static final String SCHEMA_FULL_CHECKING =
<i>136</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_FULL_CHECKING;
<i>137</i>&nbsp;
<i>138</i>&nbsp;    /** Feature identifier: dynamic validation. */
<i>139</i>&nbsp;    protected static final String DYNAMIC_VALIDATION =
<i>140</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.DYNAMIC_VALIDATION_FEATURE;
<i>141</i>&nbsp;
<i>142</i>&nbsp;    /** Feature identifier: expose schema normalized value */
<i>143</i>&nbsp;    protected static final String NORMALIZE_DATA =
<i>144</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_NORMALIZED_VALUE;
<i>145</i>&nbsp;
<i>146</i>&nbsp;    /** Feature identifier: send element default value via characters() */
<i>147</i>&nbsp;    protected static final String SCHEMA_ELEMENT_DEFAULT =
<i>148</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_ELEMENT_DEFAULT;
<i>149</i>&nbsp;
<i>150</i>&nbsp;    /** Feature identifier: augment PSVI */
<i>151</i>&nbsp;    protected static final String SCHEMA_AUGMENT_PSVI =
<i>152</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_AUGMENT_PSVI;
<i>153</i>&nbsp;
<i>154</i>&nbsp;    /** Feature identifier: whether to recognize java encoding names */
<i>155</i>&nbsp;    protected static final String ALLOW_JAVA_ENCODINGS =
<i>156</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.ALLOW_JAVA_ENCODINGS_FEATURE;
<i>157</i>&nbsp;
<i>158</i>&nbsp;    /** Feature identifier: standard uri conformant feature. */
<i>159</i>&nbsp;    protected static final String STANDARD_URI_CONFORMANT_FEATURE =
<i>160</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.STANDARD_URI_CONFORMANT_FEATURE;
<i>161</i>&nbsp;
<i>162</i>&nbsp;    /** Feature: generate synthetic annotations */
<i>163</i>&nbsp;    protected static final String GENERATE_SYNTHETIC_ANNOTATIONS =
<i>164</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.GENERATE_SYNTHETIC_ANNOTATIONS_FEATURE;
<i>165</i>&nbsp;
<i>166</i>&nbsp;    /** Feature identifier: validate annotations. */
<i>167</i>&nbsp;    protected static final String VALIDATE_ANNOTATIONS =
<i>168</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.VALIDATE_ANNOTATIONS_FEATURE;
<i>169</i>&nbsp;
<i>170</i>&nbsp;    /** Feature identifier: honour all schemaLocations */
<i>171</i>&nbsp;    protected static final String HONOUR_ALL_SCHEMALOCATIONS =
<i>172</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.HONOUR_ALL_SCHEMALOCATIONS_FEATURE;
<i>173</i>&nbsp;
<i>174</i>&nbsp;    /** Feature identifier: use grammar pool only */
<i>175</i>&nbsp;    protected static final String USE_GRAMMAR_POOL_ONLY =
<i>176</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.USE_GRAMMAR_POOL_ONLY_FEATURE;
<i>177</i>&nbsp;
<i>178</i>&nbsp;    /** Feature identifier: whether to continue parsing a schema after a fatal error is encountered */
<i>179</i>&nbsp;    protected static final String CONTINUE_AFTER_FATAL_ERROR =
<i>180</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.CONTINUE_AFTER_FATAL_ERROR_FEATURE;
<i>181</i>&nbsp;
<i>182</i>&nbsp;    protected static final String PARSER_SETTINGS =
<i>183</i>&nbsp;            Constants.XERCES_FEATURE_PREFIX + Constants.PARSER_SETTINGS;
<i>184</i>&nbsp;
<i>185</i>&nbsp;    /** Feature identifier: namespace growth */
<i>186</i>&nbsp;    protected static final String NAMESPACE_GROWTH =
<i>187</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACE_GROWTH_FEATURE;
<i>188</i>&nbsp;
<i>189</i>&nbsp;    /** Feature identifier: tolerate duplicates */
<i>190</i>&nbsp;    protected static final String TOLERATE_DUPLICATES =
<i>191</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.TOLERATE_DUPLICATES_FEATURE;
<i>192</i>&nbsp;
<i>193</i>&nbsp;    /** Feature identifier: whether to ignore xsi:type attributes until a global element declaration is encountered */
<i>194</i>&nbsp;    protected static final String IGNORE_XSI_TYPE =
<i>195</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.IGNORE_XSI_TYPE_FEATURE;
<i>196</i>&nbsp;
<i>197</i>&nbsp;    /** Feature identifier: whether to ignore ID/IDREF errors */
<i>198</i>&nbsp;    protected static final String ID_IDREF_CHECKING =
<i>199</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.ID_IDREF_CHECKING_FEATURE;
<i>200</i>&nbsp;
<i>201</i>&nbsp;    /** Feature identifier: whether to ignore unparsed entity errors */
<i>202</i>&nbsp;    protected static final String UNPARSED_ENTITY_CHECKING =
<i>203</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.UNPARSED_ENTITY_CHECKING_FEATURE;
<i>204</i>&nbsp;
<i>205</i>&nbsp;    /** Feature identifier: whether to ignore identity constraint errors */
<i>206</i>&nbsp;    protected static final String IDENTITY_CONSTRAINT_CHECKING =
<i>207</i>&nbsp;        Constants.XERCES_FEATURE_PREFIX + Constants.IDC_CHECKING_FEATURE;
<i>208</i>&nbsp;
<i>209</i>&nbsp;    protected static final String REPORT_WHITESPACE =
<i>210</i>&nbsp;            Constants.SUN_SCHEMA_FEATURE_PREFIX + Constants.SUN_REPORT_IGNORED_ELEMENT_CONTENT_WHITESPACE;
<i>211</i>&nbsp;
<i>212</i>&nbsp;    // property identifiers
<i>213</i>&nbsp;
<i>214</i>&nbsp;    /** Property identifier: symbol table. */
<i>215</i>&nbsp;    public static final String SYMBOL_TABLE =
<i>216</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
<i>217</i>&nbsp;
<i>218</i>&nbsp;    /** Property identifier: error reporter. */
<i>219</i>&nbsp;    public static final String ERROR_REPORTER =
<i>220</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
<i>221</i>&nbsp;
<i>222</i>&nbsp;    /** Property identifier: entity resolver. */
<i>223</i>&nbsp;    public static final String ENTITY_RESOLVER =
<i>224</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
<i>225</i>&nbsp;
<i>226</i>&nbsp;    /** Property identifier: grammar pool. */
<i>227</i>&nbsp;    public static final String XMLGRAMMAR_POOL =
<i>228</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
<i>229</i>&nbsp;
<i>230</i>&nbsp;    protected static final String VALIDATION_MANAGER =
<i>231</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.VALIDATION_MANAGER_PROPERTY;
<i>232</i>&nbsp;
<i>233</i>&nbsp;    protected static final String ENTITY_MANAGER =
<i>234</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_MANAGER_PROPERTY;
<i>235</i>&nbsp;
<i>236</i>&nbsp;    /** Property identifier: schema location. */
<i>237</i>&nbsp;    protected static final String SCHEMA_LOCATION =
<i>238</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_LOCATION;
<i>239</i>&nbsp;
<i>240</i>&nbsp;    /** Property identifier: no namespace schema location. */
<i>241</i>&nbsp;    protected static final String SCHEMA_NONS_LOCATION =
<b class="nc"><i>242</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_NONS_LOCATION;</b>
<i>243</i>&nbsp;
<i>244</i>&nbsp;    /** Property identifier: JAXP schema source. */
<i>245</i>&nbsp;    protected static final String JAXP_SCHEMA_SOURCE =
<i>246</i>&nbsp;        Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE;
<i>247</i>&nbsp;
<i>248</i>&nbsp;    /** Property identifier: JAXP schema language. */
<i>249</i>&nbsp;    protected static final String JAXP_SCHEMA_LANGUAGE =
<i>250</i>&nbsp;        Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE;
<i>251</i>&nbsp;
<i>252</i>&nbsp;    /** Property identifier: root type definition. */
<i>253</i>&nbsp;    protected static final String ROOT_TYPE_DEF =
<i>254</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.ROOT_TYPE_DEFINITION_PROPERTY;
<i>255</i>&nbsp;
<i>256</i>&nbsp;    /** Property identifier: root element declaration. */
<i>257</i>&nbsp;    protected static final String ROOT_ELEMENT_DECL =
<i>258</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.ROOT_ELEMENT_DECLARATION_PROPERTY;
<i>259</i>&nbsp;
<i>260</i>&nbsp;    /** Property identifier: Schema DV Factory */
<b class="nc"><i>261</i>&nbsp;    protected static final String SCHEMA_DV_FACTORY =</b>
<i>262</i>&nbsp;        Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_DV_FACTORY_PROPERTY;
<i>263</i>&nbsp;
<i>264</i>&nbsp;    /** Property identifier: Security property manager. */
<i>265</i>&nbsp;    private static final String XML_SECURITY_PROPERTY_MANAGER =
<i>266</i>&nbsp;            Constants.XML_SECURITY_PROPERTY_MANAGER;
<i>267</i>&nbsp;
<i>268</i>&nbsp;    protected static final String OVERRIDE_PARSER = JdkXmlUtils.OVERRIDE_PARSER;
<i>269</i>&nbsp;
<i>270</i>&nbsp;    protected static final String USE_CATALOG = XMLConstants.USE_CATALOG;
<i>271</i>&nbsp;
<i>272</i>&nbsp;    // recognized features and properties
<i>273</i>&nbsp;
<i>274</i>&nbsp;    /** Recognized features. */
<i>275</i>&nbsp;    private static final String[] RECOGNIZED_FEATURES =
<i>276</i>&nbsp;        {
<i>277</i>&nbsp;            VALIDATION,
<i>278</i>&nbsp;            SCHEMA_VALIDATION,
<i>279</i>&nbsp;            DYNAMIC_VALIDATION,
<i>280</i>&nbsp;            SCHEMA_FULL_CHECKING,
<i>281</i>&nbsp;            ALLOW_JAVA_ENCODINGS,
<i>282</i>&nbsp;            CONTINUE_AFTER_FATAL_ERROR,
<i>283</i>&nbsp;            STANDARD_URI_CONFORMANT_FEATURE,
<b class="nc"><i>284</i>&nbsp;            GENERATE_SYNTHETIC_ANNOTATIONS,</b>
<i>285</i>&nbsp;            VALIDATE_ANNOTATIONS,
<i>286</i>&nbsp;            HONOUR_ALL_SCHEMALOCATIONS,
<i>287</i>&nbsp;            USE_GRAMMAR_POOL_ONLY,
<i>288</i>&nbsp;            IGNORE_XSI_TYPE,
<i>289</i>&nbsp;            ID_IDREF_CHECKING,
<i>290</i>&nbsp;            IDENTITY_CONSTRAINT_CHECKING,
<i>291</i>&nbsp;            UNPARSED_ENTITY_CHECKING,
<i>292</i>&nbsp;            NAMESPACE_GROWTH,
<i>293</i>&nbsp;            TOLERATE_DUPLICATES,
<i>294</i>&nbsp;            OVERRIDE_PARSER,
<i>295</i>&nbsp;            USE_CATALOG,
<i>296</i>&nbsp;        };
<i>297</i>&nbsp;
<i>298</i>&nbsp;    /** Feature defaults. */
<b class="nc"><i>299</i>&nbsp;    private static final Boolean[] FEATURE_DEFAULTS = { null,</b>
<i>300</i>&nbsp;        // NOTE: The following defaults are nulled out on purpose.
<i>301</i>&nbsp;        //       If they are set, then when the XML Schema validator
<i>302</i>&nbsp;        //       is constructed dynamically, these values may override
<i>303</i>&nbsp;        //       those set by the application. This goes against the
<i>304</i>&nbsp;        //       whole purpose of XMLComponent#getFeatureDefault but
<i>305</i>&nbsp;        //       it can&#39;t be helped in this case. -Ac
<i>306</i>&nbsp;        // NOTE: Instead of adding default values here, add them (and
<i>307</i>&nbsp;        //       the corresponding recognized features) to the objects
<i>308</i>&nbsp;        //       that have an XMLSchemaValidator instance as a member,
<i>309</i>&nbsp;        //       such as the parser configurations. -PM
<i>310</i>&nbsp;        null, //Boolean.FALSE,
<i>311</i>&nbsp;        null, //Boolean.FALSE,
<b class="nc"><i>312</i>&nbsp;        null, //Boolean.FALSE,</b>
<i>313</i>&nbsp;        null, //Boolean.FALSE,
<i>314</i>&nbsp;        null, //Boolean.FALSE,
<i>315</i>&nbsp;        null,
<i>316</i>&nbsp;        null,
<i>317</i>&nbsp;        null,
<i>318</i>&nbsp;        null,
<b class="nc"><i>319</i>&nbsp;        null,</b>
<i>320</i>&nbsp;        null,
<i>321</i>&nbsp;        null,
<i>322</i>&nbsp;        null,
<i>323</i>&nbsp;        null,
<i>324</i>&nbsp;        null,
<b class="nc"><i>325</i>&nbsp;        null,</b>
<i>326</i>&nbsp;        JdkXmlUtils.OVERRIDE_PARSER_DEFAULT,
<i>327</i>&nbsp;        JdkXmlUtils.USE_CATALOG_DEFAULT
<i>328</i>&nbsp;    };
<i>329</i>&nbsp;
<i>330</i>&nbsp;    /** Recognized properties. */
<b class="nc"><i>331</i>&nbsp;    private static final String[] RECOGNIZED_PROPERTIES =</b>
<b class="nc"><i>332</i>&nbsp;        {</b>
<b class="nc"><i>333</i>&nbsp;            SYMBOL_TABLE,</b>
<b class="nc"><i>334</i>&nbsp;            ERROR_REPORTER,</b>
<b class="nc"><i>335</i>&nbsp;            ENTITY_RESOLVER,</b>
<b class="nc"><i>336</i>&nbsp;            VALIDATION_MANAGER,</b>
<b class="nc"><i>337</i>&nbsp;            SCHEMA_LOCATION,</b>
<b class="nc"><i>338</i>&nbsp;            SCHEMA_NONS_LOCATION,</b>
<b class="nc"><i>339</i>&nbsp;            JAXP_SCHEMA_SOURCE,</b>
<i>340</i>&nbsp;            JAXP_SCHEMA_LANGUAGE,
<i>341</i>&nbsp;            ROOT_TYPE_DEF,
<b class="nc"><i>342</i>&nbsp;            ROOT_ELEMENT_DECL,</b>
<i>343</i>&nbsp;            SCHEMA_DV_FACTORY,
<i>344</i>&nbsp;            XML_SECURITY_PROPERTY_MANAGER,
<b class="nc"><i>345</i>&nbsp;            JdkXmlUtils.CATALOG_DEFER,</b>
<i>346</i>&nbsp;            JdkXmlUtils.CATALOG_FILES,
<i>347</i>&nbsp;            JdkXmlUtils.CATALOG_PREFER,
<b class="nc"><i>348</i>&nbsp;            JdkXmlUtils.CATALOG_RESOLVE,</b>
<b class="nc"><i>349</i>&nbsp;            JdkXmlUtils.CDATA_CHUNK_SIZE</b>
<i>350</i>&nbsp;        };
<i>351</i>&nbsp;
<b class="nc"><i>352</i>&nbsp;    /** Property defaults. */</b>
<i>353</i>&nbsp;    private static final Object[] PROPERTY_DEFAULTS =
<i>354</i>&nbsp;        { null, null, null, null, null, null, null, null, null, null, null, null,
<i>355</i>&nbsp;            null, null, null, null, JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT };
<i>356</i>&nbsp;
<i>357</i>&nbsp;    // this is the number of valuestores of each kind
<i>358</i>&nbsp;    // we expect an element to have.  It&#39;s almost
<i>359</i>&nbsp;    // never &gt; 1; so leave it at that.
<i>360</i>&nbsp;    protected static final int ID_CONSTRAINT_NUM = 1;
<i>361</i>&nbsp;
<i>362</i>&nbsp;    // xsi:* attribute declarations
<i>363</i>&nbsp;    static final XSAttributeDecl XSI_TYPE =
<i>364</i>&nbsp;            SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_TYPE);
<i>365</i>&nbsp;    static final XSAttributeDecl XSI_NIL =
<i>366</i>&nbsp;            SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_NIL);
<i>367</i>&nbsp;    static final XSAttributeDecl XSI_SCHEMALOCATION =
<i>368</i>&nbsp;            SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_SCHEMALOCATION);
<b class="nc"><i>369</i>&nbsp;    static final XSAttributeDecl XSI_NONAMESPACESCHEMALOCATION =</b>
<i>370</i>&nbsp;            SchemaGrammar.SG_XSI.getGlobalAttributeDecl(SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION);
<i>371</i>&nbsp;
<i>372</i>&nbsp;    //
<i>373</i>&nbsp;    // Data
<i>374</i>&nbsp;    //
<i>375</i>&nbsp;
<b class="nc"><i>376</i>&nbsp;    /** current PSVI element info */</b>
<b class="nc"><i>377</i>&nbsp;    protected ElementPSVImpl fCurrentPSVI = new ElementPSVImpl();</b>
<i>378</i>&nbsp;
<i>379</i>&nbsp;    // since it is the responsibility of each component to an
<i>380</i>&nbsp;    // Augmentations parameter if one is null, to save ourselves from
<i>381</i>&nbsp;    // having to create this object continually, it is created here.
<b class="nc"><i>382</i>&nbsp;    // If it is not present in calls that we&#39;re passing on, we *must*</b>
<b class="nc"><i>383</i>&nbsp;    // clear this before we introduce it into the pipeline.</b>
<b class="nc"><i>384</i>&nbsp;    protected final AugmentationsImpl fAugmentations = new AugmentationsImpl();</b>
<i>385</i>&nbsp;
<i>386</i>&nbsp;    // this is included for the convenience of handleEndElement
<i>387</i>&nbsp;    protected XMLString fDefaultValue;
<i>388</i>&nbsp;
<i>389</i>&nbsp;    // Validation features
<b class="nc"><i>390</i>&nbsp;    protected boolean fDynamicValidation = false;</b>
<i>391</i>&nbsp;    protected boolean fSchemaDynamicValidation = false;
<i>392</i>&nbsp;    protected boolean fDoValidation = false;
<i>393</i>&nbsp;    protected boolean fFullChecking = false;
<b class="nc"><i>394</i>&nbsp;    protected boolean fNormalizeData = true;</b>
<b class="nc"><i>395</i>&nbsp;    protected boolean fSchemaElementDefault = true;</b>
<b class="nc"><i>396</i>&nbsp;    protected boolean fAugPSVI = true;</b>
<b class="nc"><i>397</i>&nbsp;    protected boolean fIdConstraint = false;</b>
<b class="nc"><i>398</i>&nbsp;    protected boolean fUseGrammarPoolOnly = false;</b>
<i>399</i>&nbsp;
<i>400</i>&nbsp;    // Namespace growth feature
<b class="nc"><i>401</i>&nbsp;    protected boolean fNamespaceGrowth = false;</b>
<i>402</i>&nbsp;
<i>403</i>&nbsp;    /** Schema type: None, DTD, Schema */
<i>404</i>&nbsp;    private String fSchemaType = null;
<i>405</i>&nbsp;
<b class="nc"><i>406</i>&nbsp;    // to indicate whether we are in the scope of entity reference or CData</b>
<b class="nc"><i>407</i>&nbsp;    protected boolean fEntityRef = false;</b>
<i>408</i>&nbsp;    protected boolean fInCDATA = false;
<i>409</i>&nbsp;
<b class="nc"><i>410</i>&nbsp;    // Did we see only whitespace in element content?</b>
<i>411</i>&nbsp;    protected boolean fSawOnlyWhitespaceInElementContent = false;
<b class="nc"><i>412</i>&nbsp;</b>
<i>413</i>&nbsp;    // properties
<b class="nc"><i>414</i>&nbsp;</b>
<b class="nc"><i>415</i>&nbsp;    /** Symbol table. */</b>
<i>416</i>&nbsp;    protected SymbolTable fSymbolTable;
<b class="nc"><i>417</i>&nbsp;</b>
<b class="nc"><i>418</i>&nbsp;    /**</b>
<b class="nc"><i>419</i>&nbsp;     * While parsing a document, keep the location of the document.</b>
<i>420</i>&nbsp;     */
<i>421</i>&nbsp;    private XMLLocator fLocator;
<b class="nc"><i>422</i>&nbsp;</b>
<b class="nc"><i>423</i>&nbsp;    /**</b>
<i>424</i>&nbsp;     * A wrapper of the standard error reporter. We&#39;ll store all schema errors
<i>425</i>&nbsp;     * in this wrapper object, so that we can get all errors (error codes) of
<i>426</i>&nbsp;     * a specific element. This is useful for PSVI.
<i>427</i>&nbsp;     */
<i>428</i>&nbsp;    protected final class XSIErrorReporter {
<i>429</i>&nbsp;
<b class="nc"><i>430</i>&nbsp;        // the error reporter property</b>
<b class="nc"><i>431</i>&nbsp;        XMLErrorReporter fErrorReporter;</b>
<i>432</i>&nbsp;
<i>433</i>&nbsp;        // store error codes; starting position of the errors for each element;
<b class="nc"><i>434</i>&nbsp;        // number of element (depth); and whether to record error</b>
<i>435</i>&nbsp;        Vector&lt;String&gt; fErrors = new Vector&lt;&gt;();
<b class="nc"><i>436</i>&nbsp;        int[] fContext = new int[INITIAL_STACK_SIZE];</b>
<i>437</i>&nbsp;        int fContextCount;
<b class="nc"><i>438</i>&nbsp;</b>
<b class="nc"><i>439</i>&nbsp;        // set the external error reporter, clear errors</b>
<i>440</i>&nbsp;        public void reset(XMLErrorReporter errorReporter) {
<b class="nc"><i>441</i>&nbsp;            fErrorReporter = errorReporter;</b>
<b class="nc"><i>442</i>&nbsp;            fErrors.removeAllElements();</b>
<b class="nc"><i>443</i>&nbsp;            fContextCount = 0;</b>
<i>444</i>&nbsp;        }
<i>445</i>&nbsp;
<i>446</i>&nbsp;        // should be called when starting process an element or an attribute.
<b class="nc"><i>447</i>&nbsp;        // store the starting position for the current context</b>
<i>448</i>&nbsp;        public void pushContext() {
<i>449</i>&nbsp;            if (!fAugPSVI) {
<i>450</i>&nbsp;                return;
<i>451</i>&nbsp;            }
<b class="nc"><i>452</i>&nbsp;            // resize array if necessary</b>
<b class="nc"><i>453</i>&nbsp;            if (fContextCount == fContext.length) {</b>
<b class="nc"><i>454</i>&nbsp;                int newSize = fContextCount + INC_STACK_SIZE;</b>
<i>455</i>&nbsp;                int[] newArray = new int[newSize];
<i>456</i>&nbsp;                System.arraycopy(fContext, 0, newArray, 0, fContextCount);
<i>457</i>&nbsp;                fContext = newArray;
<i>458</i>&nbsp;            }
<i>459</i>&nbsp;
<i>460</i>&nbsp;            fContext[fContextCount++] = fErrors.size();
<i>461</i>&nbsp;        }
<i>462</i>&nbsp;
<i>463</i>&nbsp;        // should be called on endElement: get all errors of the current element
<i>464</i>&nbsp;        public String[] popContext() {
<b class="nc"><i>465</i>&nbsp;            if (!fAugPSVI) {</b>
<b class="nc"><i>466</i>&nbsp;                return null;</b>
<b class="nc"><i>467</i>&nbsp;            }</b>
<i>468</i>&nbsp;            // get starting position of the current element
<i>469</i>&nbsp;            int contextPos = fContext[--fContextCount];
<i>470</i>&nbsp;            // number of errors of the current element
<i>471</i>&nbsp;            int size = fErrors.size() - contextPos;
<i>472</i>&nbsp;            // if no errors, return null
<b class="nc"><i>473</i>&nbsp;            if (size == 0)</b>
<i>474</i>&nbsp;                return null;
<i>475</i>&nbsp;            // copy errors from the list to an string array
<i>476</i>&nbsp;            String[] errors = new String[size];
<i>477</i>&nbsp;            for (int i = 0; i &lt; size; i++) {
<i>478</i>&nbsp;                errors[i] = fErrors.get(contextPos + i);
<b class="nc"><i>479</i>&nbsp;            }</b>
<b class="nc"><i>480</i>&nbsp;            // remove errors of the current element</b>
<i>481</i>&nbsp;            fErrors.setSize(contextPos);
<i>482</i>&nbsp;            return errors;
<i>483</i>&nbsp;        }
<b class="nc"><i>484</i>&nbsp;</b>
<b class="nc"><i>485</i>&nbsp;        // should be called when an attribute is done: get all errors of</b>
<i>486</i>&nbsp;        // this attribute, but leave the errors to the containing element
<i>487</i>&nbsp;        // also called after an element was strictly assessed.
<b class="nc"><i>488</i>&nbsp;        public String[] mergeContext() {</b>
<i>489</i>&nbsp;            if (!fAugPSVI) {
<i>490</i>&nbsp;                return null;
<b class="nc"><i>491</i>&nbsp;            }</b>
<b class="nc"><i>492</i>&nbsp;            // get starting position of the current element</b>
<i>493</i>&nbsp;            int contextPos = fContext[--fContextCount];
<i>494</i>&nbsp;            // number of errors of the current element
<i>495</i>&nbsp;            int size = fErrors.size() - contextPos;
<i>496</i>&nbsp;            // if no errors, return null
<i>497</i>&nbsp;            if (size == 0)
<i>498</i>&nbsp;                return null;
<i>499</i>&nbsp;            // copy errors from the list to an string array
<i>500</i>&nbsp;            String[] errors = new String[size];
<i>501</i>&nbsp;            for (int i = 0; i &lt; size; i++) {
<b class="nc"><i>502</i>&nbsp;                errors[i] = fErrors.get(contextPos + i);</b>
<i>503</i>&nbsp;            }
<i>504</i>&nbsp;            // don&#39;t resize the vector: leave the errors for this attribute
<i>505</i>&nbsp;            // to the containing element
<i>506</i>&nbsp;            return errors;
<i>507</i>&nbsp;        }
<i>508</i>&nbsp;
<i>509</i>&nbsp;        public void reportError(String domain, String key, Object[] arguments, short severity)
<i>510</i>&nbsp;            throws XNIException {
<i>511</i>&nbsp;            String message = fErrorReporter.reportError(domain, key, arguments, severity);
<i>512</i>&nbsp;            if (fAugPSVI) {
<i>513</i>&nbsp;                fErrors.add(key);
<b class="nc"><i>514</i>&nbsp;                fErrors.add(message);</b>
<i>515</i>&nbsp;            }
<i>516</i>&nbsp;        } // reportError(String,String,Object[],short)
<i>517</i>&nbsp;
<i>518</i>&nbsp;        public void reportError(
<i>519</i>&nbsp;            XMLLocator location,
<i>520</i>&nbsp;            String domain,
<i>521</i>&nbsp;            String key,
<i>522</i>&nbsp;            Object[] arguments,
<i>523</i>&nbsp;            short severity)
<i>524</i>&nbsp;            throws XNIException {
<i>525</i>&nbsp;            String message = fErrorReporter.reportError(location, domain, key, arguments, severity);
<i>526</i>&nbsp;            if (fAugPSVI) {
<i>527</i>&nbsp;                fErrors.add(key);
<i>528</i>&nbsp;                fErrors.add(message);
<i>529</i>&nbsp;            }
<i>530</i>&nbsp;        } // reportError(XMLLocator,String,String,Object[],short)
<i>531</i>&nbsp;    }
<i>532</i>&nbsp;
<i>533</i>&nbsp;    /** Error reporter. */
<i>534</i>&nbsp;    protected final XSIErrorReporter fXSIErrorReporter = new XSIErrorReporter();
<i>535</i>&nbsp;
<i>536</i>&nbsp;    /** Entity resolver */
<i>537</i>&nbsp;    protected XMLEntityResolver fEntityResolver;
<i>538</i>&nbsp;
<i>539</i>&nbsp;    // updated during reset
<i>540</i>&nbsp;    protected ValidationManager fValidationManager = null;
<b class="nc"><i>541</i>&nbsp;    protected ConfigurableValidationState fValidationState = new ConfigurableValidationState();</b>
<i>542</i>&nbsp;    protected XMLGrammarPool fGrammarPool;
<i>543</i>&nbsp;
<i>544</i>&nbsp;    // schema location property values
<i>545</i>&nbsp;    protected String fExternalSchemas = null;
<i>546</i>&nbsp;    protected String fExternalNoNamespaceSchema = null;
<i>547</i>&nbsp;
<i>548</i>&nbsp;    //JAXP Schema Source property
<i>549</i>&nbsp;    protected Object fJaxpSchemaSource = null;
<i>550</i>&nbsp;
<i>551</i>&nbsp;    /** Schema Grammar Description passed,  to give a chance to application to supply the Grammar */
<i>552</i>&nbsp;    protected final XSDDescription fXSDDescription = new XSDDescription();
<i>553</i>&nbsp;    protected final Map&lt;String, XMLSchemaLoader.LocationArray&gt; fLocationPairs = new HashMap&lt;&gt;();
<i>554</i>&nbsp;
<i>555</i>&nbsp;
<i>556</i>&nbsp;    // handlers
<i>557</i>&nbsp;
<i>558</i>&nbsp;    /** Document handler. */
<i>559</i>&nbsp;    protected XMLDocumentHandler fDocumentHandler;
<i>560</i>&nbsp;
<i>561</i>&nbsp;    protected XMLDocumentSource fDocumentSource;
<i>562</i>&nbsp;
<i>563</i>&nbsp;    boolean reportWhitespace = false;
<i>564</i>&nbsp;
<i>565</i>&nbsp;    //
<i>566</i>&nbsp;    // XMLComponent methods
<i>567</i>&nbsp;    //
<i>568</i>&nbsp;
<i>569</i>&nbsp;    /**
<i>570</i>&nbsp;     * Returns a list of feature identifiers that are recognized by
<i>571</i>&nbsp;     * this component. This method may return null if no features
<b class="nc"><i>572</i>&nbsp;     * are recognized by this component.</b>
<b class="nc"><i>573</i>&nbsp;     */</b>
<b class="nc"><i>574</i>&nbsp;    public String[] getRecognizedFeatures() {</b>
<i>575</i>&nbsp;        return RECOGNIZED_FEATURES.clone();
<i>576</i>&nbsp;    } // getRecognizedFeatures():String[]
<b class="nc"><i>577</i>&nbsp;</b>
<i>578</i>&nbsp;    /**
<i>579</i>&nbsp;     * Sets the state of a feature. This method is called by the component
<i>580</i>&nbsp;     * manager any time after reset when a feature changes state.
<i>581</i>&nbsp;     * &lt;p&gt;
<i>582</i>&nbsp;     * &lt;strong&gt;Note:&lt;/strong&gt; Components should silently ignore features
<i>583</i>&nbsp;     * that do not affect the operation of the component.
<i>584</i>&nbsp;     *
<i>585</i>&nbsp;     * @param featureId The feature identifier.
<i>586</i>&nbsp;     * @param state     The state of the feature.
<i>587</i>&nbsp;     *
<i>588</i>&nbsp;     * @throws SAXNotRecognizedException The component should not throw
<i>589</i>&nbsp;     *                                   this exception.
<b class="nc"><i>590</i>&nbsp;     * @throws SAXNotSupportedException The component should not throw</b>
<b class="nc"><i>591</i>&nbsp;     *                                  this exception.</b>
<b class="nc"><i>592</i>&nbsp;     */</b>
<i>593</i>&nbsp;    public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
<i>594</i>&nbsp;    } // setFeature(String,boolean)
<b class="nc"><i>595</i>&nbsp;</b>
<i>596</i>&nbsp;    /**
<i>597</i>&nbsp;     * Returns a list of property identifiers that are recognized by
<i>598</i>&nbsp;     * this component. This method may return null if no properties
<i>599</i>&nbsp;     * are recognized by this component.
<i>600</i>&nbsp;     */
<i>601</i>&nbsp;    public String[] getRecognizedProperties() {
<i>602</i>&nbsp;        return RECOGNIZED_PROPERTIES.clone();
<i>603</i>&nbsp;    } // getRecognizedProperties():String[]
<b class="nc"><i>604</i>&nbsp;</b>
<i>605</i>&nbsp;    /**
<i>606</i>&nbsp;     * Sets the value of a property. This method is called by the component
<b class="nc"><i>607</i>&nbsp;     * manager any time after reset when a property changes value.</b>
<i>608</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>609</i>&nbsp;     * &lt;strong&gt;Note:&lt;/strong&gt; Components should silently ignore properties</b>
<b class="nc"><i>610</i>&nbsp;     * that do not affect the operation of the component.</b>
<i>611</i>&nbsp;     *
<b class="nc"><i>612</i>&nbsp;     * @param propertyId The property identifier.</b>
<b class="nc"><i>613</i>&nbsp;     * @param value      The value of the property.</b>
<b class="nc"><i>614</i>&nbsp;     *</b>
<i>615</i>&nbsp;     * @throws SAXNotRecognizedException The component should not throw
<i>616</i>&nbsp;     *                                   this exception.
<i>617</i>&nbsp;     * @throws SAXNotSupportedException The component should not throw
<i>618</i>&nbsp;     *                                  this exception.
<i>619</i>&nbsp;     */
<b class="nc"><i>620</i>&nbsp;    public void setProperty(String propertyId, Object value) throws XMLConfigurationException {</b>
<i>621</i>&nbsp;        if (propertyId.equals(ROOT_TYPE_DEF)) {
<i>622</i>&nbsp;            if (value == null) {
<i>623</i>&nbsp;                fRootTypeQName = null;
<i>624</i>&nbsp;                fRootTypeDefinition = null;
<i>625</i>&nbsp;            }
<i>626</i>&nbsp;            else if (value instanceof javax.xml.namespace.QName) {
<i>627</i>&nbsp;                fRootTypeQName = (javax.xml.namespace.QName) value;
<i>628</i>&nbsp;                fRootTypeDefinition = null;
<b class="nc"><i>629</i>&nbsp;            }</b>
<i>630</i>&nbsp;            else {
<i>631</i>&nbsp;                fRootTypeDefinition = (XSTypeDefinition) value;
<i>632</i>&nbsp;                fRootTypeQName = null;
<i>633</i>&nbsp;            }
<b class="nc"><i>634</i>&nbsp;        }</b>
<i>635</i>&nbsp;        else if (propertyId.equals(ROOT_ELEMENT_DECL)) {
<i>636</i>&nbsp;            if (value == null) {
<i>637</i>&nbsp;                fRootElementDeclQName = null;
<i>638</i>&nbsp;                fRootElementDeclaration = null;
<i>639</i>&nbsp;            }
<i>640</i>&nbsp;            else if (value instanceof javax.xml.namespace.QName) {
<i>641</i>&nbsp;                fRootElementDeclQName = (javax.xml.namespace.QName) value;
<i>642</i>&nbsp;                fRootElementDeclaration = null;
<i>643</i>&nbsp;            }
<i>644</i>&nbsp;            else {
<i>645</i>&nbsp;                fRootElementDeclaration = (XSElementDecl) value;
<i>646</i>&nbsp;                fRootElementDeclQName = null;
<i>647</i>&nbsp;            }
<i>648</i>&nbsp;        }
<i>649</i>&nbsp;    } // setProperty(String,Object)
<i>650</i>&nbsp;
<i>651</i>&nbsp;    /**
<i>652</i>&nbsp;     * Returns the default state for a feature, or null if this
<i>653</i>&nbsp;     * component does not want to report a default value for this
<i>654</i>&nbsp;     * feature.
<i>655</i>&nbsp;     *
<i>656</i>&nbsp;     * @param featureId The feature identifier.
<i>657</i>&nbsp;     *
<i>658</i>&nbsp;     * @since Xerces 2.2.0
<i>659</i>&nbsp;     */
<i>660</i>&nbsp;    public Boolean getFeatureDefault(String featureId) {
<i>661</i>&nbsp;        for (int i = 0; i &lt; RECOGNIZED_FEATURES.length; i++) {
<i>662</i>&nbsp;            if (RECOGNIZED_FEATURES[i].equals(featureId)) {
<i>663</i>&nbsp;                return FEATURE_DEFAULTS[i];
<i>664</i>&nbsp;            }
<i>665</i>&nbsp;        }
<b class="nc"><i>666</i>&nbsp;        return null;</b>
<b class="nc"><i>667</i>&nbsp;    } // getFeatureDefault(String):Boolean</b>
<b class="nc"><i>668</i>&nbsp;</b>
<b class="nc"><i>669</i>&nbsp;    /**</b>
<i>670</i>&nbsp;     * Returns the default state for a property, or null if this
<b class="nc"><i>671</i>&nbsp;     * component does not want to report a default value for this</b>
<i>672</i>&nbsp;     * property.
<b class="nc"><i>673</i>&nbsp;     *</b>
<b class="nc"><i>674</i>&nbsp;     * @param propertyId The property identifier.</b>
<i>675</i>&nbsp;     *
<i>676</i>&nbsp;     * @since Xerces 2.2.0
<i>677</i>&nbsp;     */
<i>678</i>&nbsp;    public Object getPropertyDefault(String propertyId) {
<i>679</i>&nbsp;        for (int i = 0; i &lt; RECOGNIZED_PROPERTIES.length; i++) {
<i>680</i>&nbsp;            if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
<i>681</i>&nbsp;                return PROPERTY_DEFAULTS[i];
<i>682</i>&nbsp;            }
<i>683</i>&nbsp;        }
<i>684</i>&nbsp;        return null;
<i>685</i>&nbsp;    } // getPropertyDefault(String):Object
<i>686</i>&nbsp;
<i>687</i>&nbsp;    //
<i>688</i>&nbsp;    // XMLDocumentSource methods
<i>689</i>&nbsp;    //
<i>690</i>&nbsp;
<i>691</i>&nbsp;    /** Sets the document handler to receive information about the document. */
<i>692</i>&nbsp;    public void setDocumentHandler(XMLDocumentHandler documentHandler) {
<i>693</i>&nbsp;        fDocumentHandler = documentHandler;
<i>694</i>&nbsp;
<i>695</i>&nbsp;        // Init reportWhitespace for this handler
<b class="nc"><i>696</i>&nbsp;        if (documentHandler instanceof XMLParser) {</b>
<b class="nc"><i>697</i>&nbsp;            try {</b>
<i>698</i>&nbsp;                reportWhitespace =
<i>699</i>&nbsp;                    ((XMLParser) documentHandler).getFeature(REPORT_WHITESPACE);
<i>700</i>&nbsp;            }
<i>701</i>&nbsp;            catch (Exception e) {
<i>702</i>&nbsp;                reportWhitespace = false;
<i>703</i>&nbsp;            }
<i>704</i>&nbsp;        }
<i>705</i>&nbsp;    } // setDocumentHandler(XMLDocumentHandler)
<i>706</i>&nbsp;
<i>707</i>&nbsp;    /** Returns the document handler */
<i>708</i>&nbsp;    public XMLDocumentHandler getDocumentHandler() {
<i>709</i>&nbsp;        return fDocumentHandler;
<i>710</i>&nbsp;    } // setDocumentHandler(XMLDocumentHandler)
<i>711</i>&nbsp;
<i>712</i>&nbsp;    //
<i>713</i>&nbsp;    // XMLDocumentHandler methods
<i>714</i>&nbsp;    //
<i>715</i>&nbsp;
<i>716</i>&nbsp;    /** Sets the document source */
<i>717</i>&nbsp;    public void setDocumentSource(XMLDocumentSource source) {
<i>718</i>&nbsp;        fDocumentSource = source;
<i>719</i>&nbsp;    } // setDocumentSource
<i>720</i>&nbsp;
<i>721</i>&nbsp;    /** Returns the document source */
<b class="nc"><i>722</i>&nbsp;    public XMLDocumentSource getDocumentSource() {</b>
<b class="nc"><i>723</i>&nbsp;        return fDocumentSource;</b>
<i>724</i>&nbsp;    } // getDocumentSource
<i>725</i>&nbsp;
<i>726</i>&nbsp;    /**
<i>727</i>&nbsp;     * The start of the document.
<i>728</i>&nbsp;     *
<i>729</i>&nbsp;     * @param locator The system identifier of the entity if the entity
<i>730</i>&nbsp;     *                 is external, null otherwise.
<i>731</i>&nbsp;     * @param encoding The auto-detected IANA encoding name of the entity
<i>732</i>&nbsp;     *                 stream. This value will be null in those situations
<i>733</i>&nbsp;     *                 where the entity encoding is not auto-detected (e.g.
<i>734</i>&nbsp;     *                 internal entities or a document entity that is
<i>735</i>&nbsp;     *                 parsed from a java.io.Reader).
<i>736</i>&nbsp;     * @param namespaceContext
<i>737</i>&nbsp;     *                 The namespace context in effect at the
<i>738</i>&nbsp;     *                 start of this document.
<i>739</i>&nbsp;     *                 This object represents the current context.
<b class="nc"><i>740</i>&nbsp;     *                 Implementors of this class are responsible</b>
<i>741</i>&nbsp;     *                 for copying the namespace bindings from the
<b class="nc"><i>742</i>&nbsp;     *                 the current context (and its parent contexts)</b>
<b class="nc"><i>743</i>&nbsp;     *                 if that information is important.</b>
<i>744</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>745</i>&nbsp;     *
<i>746</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>747</i>&nbsp;     */
<i>748</i>&nbsp;    public void startDocument(
<i>749</i>&nbsp;        XMLLocator locator,
<i>750</i>&nbsp;        String encoding,
<i>751</i>&nbsp;        NamespaceContext namespaceContext,
<i>752</i>&nbsp;        Augmentations augs)
<i>753</i>&nbsp;        throws XNIException {
<i>754</i>&nbsp;
<i>755</i>&nbsp;        fValidationState.setNamespaceSupport(namespaceContext);
<i>756</i>&nbsp;        fState4XsiType.setNamespaceSupport(namespaceContext);
<i>757</i>&nbsp;        fState4ApplyDefault.setNamespaceSupport(namespaceContext);
<i>758</i>&nbsp;        fLocator = locator;
<i>759</i>&nbsp;
<b class="nc"><i>760</i>&nbsp;        handleStartDocument(locator, encoding);</b>
<i>761</i>&nbsp;        // call handlers
<i>762</i>&nbsp;        if (fDocumentHandler != null) {
<i>763</i>&nbsp;            fDocumentHandler.startDocument(locator, encoding, namespaceContext, augs);
<i>764</i>&nbsp;        }
<b class="nc"><i>765</i>&nbsp;</b>
<i>766</i>&nbsp;    } // startDocument(XMLLocator,String)
<i>767</i>&nbsp;
<b class="nc"><i>768</i>&nbsp;    /**</b>
<b class="nc"><i>769</i>&nbsp;     * Notifies of the presence of an XMLDecl line in the document. If</b>
<i>770</i>&nbsp;     * present, this method will be called immediately following the
<i>771</i>&nbsp;     * startDocument call.
<b class="nc"><i>772</i>&nbsp;     *</b>
<b class="nc"><i>773</i>&nbsp;     * @param version    The XML version.</b>
<b class="nc"><i>774</i>&nbsp;     * @param encoding   The IANA encoding name of the document, or null if</b>
<i>775</i>&nbsp;     *                   not specified.
<b class="nc"><i>776</i>&nbsp;     * @param standalone The standalone value, or null if not specified.</b>
<b class="nc"><i>777</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations</b>
<b class="nc"><i>778</i>&nbsp;     *</b>
<i>779</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>780</i>&nbsp;     */
<i>781</i>&nbsp;    public void xmlDecl(String version, String encoding, String standalone, Augmentations augs)
<i>782</i>&nbsp;        throws XNIException {
<i>783</i>&nbsp;
<i>784</i>&nbsp;        // call handlers
<i>785</i>&nbsp;        if (fDocumentHandler != null) {
<i>786</i>&nbsp;            fDocumentHandler.xmlDecl(version, encoding, standalone, augs);
<i>787</i>&nbsp;        }
<i>788</i>&nbsp;
<i>789</i>&nbsp;    } // xmlDecl(String,String,String)
<i>790</i>&nbsp;
<i>791</i>&nbsp;    /**
<b class="nc"><i>792</i>&nbsp;     * Notifies of the presence of the DOCTYPE line in the document.</b>
<i>793</i>&nbsp;     *
<b class="nc"><i>794</i>&nbsp;     * @param rootElement The name of the root element.</b>
<b class="nc"><i>795</i>&nbsp;     * @param publicId    The public identifier if an external DTD or null</b>
<b class="nc"><i>796</i>&nbsp;     *                    if the external DTD is specified using SYSTEM.</b>
<b class="nc"><i>797</i>&nbsp;     * @param systemId    The system identifier if an external DTD, null</b>
<i>798</i>&nbsp;     *                    otherwise.
<i>799</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>800</i>&nbsp;     *
<i>801</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>802</i>&nbsp;     */
<b class="nc"><i>803</i>&nbsp;    public void doctypeDecl(</b>
<b class="nc"><i>804</i>&nbsp;        String rootElement,</b>
<i>805</i>&nbsp;        String publicId,
<i>806</i>&nbsp;        String systemId,
<i>807</i>&nbsp;        Augmentations augs)
<i>808</i>&nbsp;        throws XNIException {
<b class="nc"><i>809</i>&nbsp;</b>
<b class="nc"><i>810</i>&nbsp;        // call handlers</b>
<i>811</i>&nbsp;        if (fDocumentHandler != null) {
<b class="nc"><i>812</i>&nbsp;            fDocumentHandler.doctypeDecl(rootElement, publicId, systemId, augs);</b>
<i>813</i>&nbsp;        }
<i>814</i>&nbsp;
<i>815</i>&nbsp;    } // doctypeDecl(String,String,String)
<i>816</i>&nbsp;
<i>817</i>&nbsp;    /**
<i>818</i>&nbsp;     * The start of an element.
<i>819</i>&nbsp;     *
<i>820</i>&nbsp;     * @param element    The name of the element.
<i>821</i>&nbsp;     * @param attributes The element attributes.
<i>822</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>823</i>&nbsp;     *
<i>824</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>825</i>&nbsp;     */
<i>826</i>&nbsp;    public void startElement(QName element, XMLAttributes attributes, Augmentations augs)
<i>827</i>&nbsp;        throws XNIException {
<i>828</i>&nbsp;
<i>829</i>&nbsp;        Augmentations modifiedAugs = handleStartElement(element, attributes, augs);
<i>830</i>&nbsp;        // call handlers
<i>831</i>&nbsp;        if (fDocumentHandler != null) {
<b class="nc"><i>832</i>&nbsp;            fDocumentHandler.startElement(element, attributes, modifiedAugs);</b>
<i>833</i>&nbsp;        }
<b class="nc"><i>834</i>&nbsp;</b>
<b class="nc"><i>835</i>&nbsp;    } // startElement(QName,XMLAttributes, Augmentations)</b>
<i>836</i>&nbsp;
<i>837</i>&nbsp;    /**
<i>838</i>&nbsp;     * An empty element.
<i>839</i>&nbsp;     *
<i>840</i>&nbsp;     * @param element    The name of the element.
<i>841</i>&nbsp;     * @param attributes The element attributes.
<i>842</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>843</i>&nbsp;     *
<i>844</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>845</i>&nbsp;     */
<i>846</i>&nbsp;    public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs)
<i>847</i>&nbsp;        throws XNIException {
<i>848</i>&nbsp;
<i>849</i>&nbsp;        Augmentations modifiedAugs = handleStartElement(element, attributes, augs);
<i>850</i>&nbsp;
<i>851</i>&nbsp;        // in the case where there is a {value constraint}, and the element
<b class="nc"><i>852</i>&nbsp;        // doesn&#39;t have any text content, change emptyElement call to</b>
<b class="nc"><i>853</i>&nbsp;        // start + characters + end</b>
<i>854</i>&nbsp;        fDefaultValue = null;
<b class="nc"><i>855</i>&nbsp;        // fElementDepth == -2 indicates that the schema validator was removed</b>
<b class="nc"><i>856</i>&nbsp;        // from the pipeline. then we don&#39;t need to call handleEndElement.</b>
<b class="nc"><i>857</i>&nbsp;        if (fElementDepth != -2)</b>
<i>858</i>&nbsp;            modifiedAugs = handleEndElement(element, modifiedAugs);
<b class="nc"><i>859</i>&nbsp;</b>
<b class="nc"><i>860</i>&nbsp;        // call handlers</b>
<i>861</i>&nbsp;        if (fDocumentHandler != null) {
<i>862</i>&nbsp;            if (!fSchemaElementDefault || fDefaultValue == null) {
<i>863</i>&nbsp;                fDocumentHandler.emptyElement(element, attributes, modifiedAugs);
<i>864</i>&nbsp;            } else {
<i>865</i>&nbsp;                fDocumentHandler.startElement(element, attributes, modifiedAugs);
<i>866</i>&nbsp;                fDocumentHandler.characters(fDefaultValue, null);
<i>867</i>&nbsp;                fDocumentHandler.endElement(element, modifiedAugs);
<i>868</i>&nbsp;            }
<i>869</i>&nbsp;        }
<i>870</i>&nbsp;    } // emptyElement(QName,XMLAttributes, Augmentations)
<i>871</i>&nbsp;
<i>872</i>&nbsp;    /**
<i>873</i>&nbsp;     * Character content.
<i>874</i>&nbsp;     *
<b class="nc"><i>875</i>&nbsp;     * @param text The content.</b>
<i>876</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<b class="nc"><i>877</i>&nbsp;     *</b>
<b class="nc"><i>878</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.</b>
<i>879</i>&nbsp;     */
<i>880</i>&nbsp;    public void characters(XMLString text, Augmentations augs) throws XNIException {
<i>881</i>&nbsp;        text = handleCharacters(text);
<i>882</i>&nbsp;
<i>883</i>&nbsp;        if (fSawOnlyWhitespaceInElementContent) {
<i>884</i>&nbsp;            fSawOnlyWhitespaceInElementContent = false;
<i>885</i>&nbsp;            if (!reportWhitespace) {
<i>886</i>&nbsp;                ignorableWhitespace(text, augs);
<i>887</i>&nbsp;                return;
<i>888</i>&nbsp;            }
<i>889</i>&nbsp;        }
<i>890</i>&nbsp;
<i>891</i>&nbsp;        // call handlers
<i>892</i>&nbsp;        if (fDocumentHandler != null) {
<b class="nc"><i>893</i>&nbsp;            if (fNormalizeData &amp;&amp; fUnionType) {</b>
<b class="nc"><i>894</i>&nbsp;                // for union types we can&#39;t normalize data</b>
<b class="nc"><i>895</i>&nbsp;                // thus we only need to send augs information if any;</b>
<i>896</i>&nbsp;                // the normalized data for union will be send
<i>897</i>&nbsp;                // after normalization is performed (at the endElement())
<i>898</i>&nbsp;                if (augs != null)
<i>899</i>&nbsp;                    fDocumentHandler.characters(fEmptyXMLStr, augs);
<i>900</i>&nbsp;            } else {
<i>901</i>&nbsp;                fDocumentHandler.characters(text, augs);
<i>902</i>&nbsp;            }
<i>903</i>&nbsp;        }
<i>904</i>&nbsp;
<i>905</i>&nbsp;    } // characters(XMLString)
<i>906</i>&nbsp;
<i>907</i>&nbsp;    /**
<i>908</i>&nbsp;     * Ignorable whitespace. For this method to be called, the document
<b class="nc"><i>909</i>&nbsp;     * source must have some way of determining that the text containing</b>
<i>910</i>&nbsp;     * only whitespace characters should be considered ignorable. For
<i>911</i>&nbsp;     * example, the validator can determine if a length of whitespace
<b class="nc"><i>912</i>&nbsp;     * characters in the document are ignorable based on the element</b>
<b class="nc"><i>913</i>&nbsp;     * content model.</b>
<i>914</i>&nbsp;     *
<b class="nc"><i>915</i>&nbsp;     * @param text The ignorable whitespace.</b>
<i>916</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>917</i>&nbsp;     *
<i>918</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>919</i>&nbsp;     */
<i>920</i>&nbsp;    public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException {
<i>921</i>&nbsp;
<i>922</i>&nbsp;        handleIgnorableWhitespace(text);
<i>923</i>&nbsp;        // call handlers
<i>924</i>&nbsp;        if (fDocumentHandler != null) {
<i>925</i>&nbsp;            fDocumentHandler.ignorableWhitespace(text, augs);
<i>926</i>&nbsp;        }
<i>927</i>&nbsp;
<i>928</i>&nbsp;    } // ignorableWhitespace(XMLString)
<b class="nc"><i>929</i>&nbsp;</b>
<i>930</i>&nbsp;    /**
<i>931</i>&nbsp;     * The end of an element.
<i>932</i>&nbsp;     *
<i>933</i>&nbsp;     * @param element The name of the element.
<i>934</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>935</i>&nbsp;     *
<b class="nc"><i>936</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.</b>
<i>937</i>&nbsp;     */
<b class="nc"><i>938</i>&nbsp;    public void endElement(QName element, Augmentations augs) throws XNIException {</b>
<b class="nc"><i>939</i>&nbsp;</b>
<i>940</i>&nbsp;        // in the case where there is a {value constraint}, and the element
<b class="nc"><i>941</i>&nbsp;        // doesn&#39;t have any text content, add a characters call.</b>
<b class="nc"><i>942</i>&nbsp;        fDefaultValue = null;</b>
<i>943</i>&nbsp;        Augmentations modifiedAugs = handleEndElement(element, augs);
<i>944</i>&nbsp;        // call handlers
<i>945</i>&nbsp;        if (fDocumentHandler != null) {
<i>946</i>&nbsp;            if (!fSchemaElementDefault || fDefaultValue == null) {
<b class="nc"><i>947</i>&nbsp;                fDocumentHandler.endElement(element, modifiedAugs);</b>
<b class="nc"><i>948</i>&nbsp;            } else {</b>
<b class="nc"><i>949</i>&nbsp;                fDocumentHandler.characters(fDefaultValue, null);</b>
<b class="nc"><i>950</i>&nbsp;                fDocumentHandler.endElement(element, modifiedAugs);</b>
<b class="nc"><i>951</i>&nbsp;            }</b>
<i>952</i>&nbsp;        }
<b class="nc"><i>953</i>&nbsp;    } // endElement(QName, Augmentations)</b>
<b class="nc"><i>954</i>&nbsp;</b>
<b class="nc"><i>955</i>&nbsp;    /**</b>
<b class="nc"><i>956</i>&nbsp;    * The start of a CDATA section.</b>
<b class="nc"><i>957</i>&nbsp;    *</b>
<i>958</i>&nbsp;    * @param augs     Additional information that may include infoset augmentations
<i>959</i>&nbsp;    *
<i>960</i>&nbsp;    * @throws XNIException Thrown by handler to signal an error.
<i>961</i>&nbsp;    */
<i>962</i>&nbsp;    public void startCDATA(Augmentations augs) throws XNIException {
<b class="nc"><i>963</i>&nbsp;</b>
<i>964</i>&nbsp;        // REVISIT: what should we do here if schema normalization is on??
<i>965</i>&nbsp;        fInCDATA = true;
<i>966</i>&nbsp;        // call handlers
<i>967</i>&nbsp;        if (fDocumentHandler != null) {
<i>968</i>&nbsp;            fDocumentHandler.startCDATA(augs);
<i>969</i>&nbsp;        }
<i>970</i>&nbsp;
<i>971</i>&nbsp;    } // startCDATA()
<i>972</i>&nbsp;
<i>973</i>&nbsp;    /**
<i>974</i>&nbsp;     * The end of a CDATA section.
<i>975</i>&nbsp;     *
<i>976</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>977</i>&nbsp;     *
<i>978</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>979</i>&nbsp;     */
<i>980</i>&nbsp;    public void endCDATA(Augmentations augs) throws XNIException {
<i>981</i>&nbsp;
<i>982</i>&nbsp;        // call handlers
<i>983</i>&nbsp;        fInCDATA = false;
<i>984</i>&nbsp;        if (fDocumentHandler != null) {
<i>985</i>&nbsp;            fDocumentHandler.endCDATA(augs);
<i>986</i>&nbsp;        }
<i>987</i>&nbsp;
<i>988</i>&nbsp;    } // endCDATA()
<i>989</i>&nbsp;
<i>990</i>&nbsp;    /**
<i>991</i>&nbsp;     * The end of the document.
<i>992</i>&nbsp;     *
<i>993</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>994</i>&nbsp;     *
<i>995</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>996</i>&nbsp;     */
<i>997</i>&nbsp;    public void endDocument(Augmentations augs) throws XNIException {
<i>998</i>&nbsp;
<b class="nc"><i>999</i>&nbsp;        handleEndDocument();</b>
<i>1000</i>&nbsp;
<b class="nc"><i>1001</i>&nbsp;        // call handlers</b>
<b class="nc"><i>1002</i>&nbsp;        if (fDocumentHandler != null) {</b>
<i>1003</i>&nbsp;            fDocumentHandler.endDocument(augs);
<i>1004</i>&nbsp;        }
<i>1005</i>&nbsp;        fLocator = null;
<i>1006</i>&nbsp;
<i>1007</i>&nbsp;    } // endDocument(Augmentations)
<i>1008</i>&nbsp;
<i>1009</i>&nbsp;    //
<i>1010</i>&nbsp;    // DOMRevalidationHandler methods
<i>1011</i>&nbsp;    //
<i>1012</i>&nbsp;
<i>1013</i>&nbsp;
<i>1014</i>&nbsp;
<i>1015</i>&nbsp;
<i>1016</i>&nbsp;
<i>1017</i>&nbsp;    public boolean characterData(String data, Augmentations augs) {
<i>1018</i>&nbsp;
<i>1019</i>&nbsp;        fSawText = fSawText || data.length() &gt; 0;
<i>1020</i>&nbsp;
<i>1021</i>&nbsp;        // REVISIT: this methods basically duplicates implementation of
<i>1022</i>&nbsp;        //          handleCharacters(). We should be able to reuse some code
<i>1023</i>&nbsp;
<i>1024</i>&nbsp;        // if whitespace == -1 skip normalization, because it is a complexType
<i>1025</i>&nbsp;        // or a union type.
<i>1026</i>&nbsp;        if (fNormalizeData &amp;&amp; fWhiteSpace != -1 &amp;&amp; fWhiteSpace != XSSimpleType.WS_PRESERVE) {
<b class="nc"><i>1027</i>&nbsp;            // normalize data</b>
<b class="nc"><i>1028</i>&nbsp;            normalizeWhitespace(data, fWhiteSpace == XSSimpleType.WS_COLLAPSE);</b>
<i>1029</i>&nbsp;            fBuffer.append(fNormalizedStr.ch, fNormalizedStr.offset, fNormalizedStr.length);
<i>1030</i>&nbsp;        } else {
<i>1031</i>&nbsp;            if (fAppendBuffer)
<i>1032</i>&nbsp;                fBuffer.append(data);
<i>1033</i>&nbsp;        }
<i>1034</i>&nbsp;
<i>1035</i>&nbsp;        // When it&#39;s a complex type with element-only content, we need to
<i>1036</i>&nbsp;        // find out whether the content contains any non-whitespace character.
<i>1037</i>&nbsp;        boolean allWhiteSpace = true;
<i>1038</i>&nbsp;        if (fCurrentType != null
<i>1039</i>&nbsp;            &amp;&amp; fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<i>1040</i>&nbsp;            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
<i>1041</i>&nbsp;            if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT) {
<i>1042</i>&nbsp;                // data outside of element content
<i>1043</i>&nbsp;                for (int i = 0; i &lt; data.length(); i++) {
<b class="nc"><i>1044</i>&nbsp;                    if (!XMLChar.isSpace(data.charAt(i))) {</b>
<b class="nc"><i>1045</i>&nbsp;                        allWhiteSpace = false;</b>
<i>1046</i>&nbsp;                        fSawCharacters = true;
<i>1047</i>&nbsp;                        break;
<i>1048</i>&nbsp;                    }
<i>1049</i>&nbsp;                }
<i>1050</i>&nbsp;            }
<i>1051</i>&nbsp;        }
<i>1052</i>&nbsp;
<i>1053</i>&nbsp;        return allWhiteSpace;
<i>1054</i>&nbsp;    }
<i>1055</i>&nbsp;
<i>1056</i>&nbsp;    public void elementDefault(String data) {
<i>1057</i>&nbsp;        // no-op
<i>1058</i>&nbsp;    }
<i>1059</i>&nbsp;
<i>1060</i>&nbsp;    //
<i>1061</i>&nbsp;    // XMLDocumentHandler and XMLDTDHandler methods
<i>1062</i>&nbsp;    //
<i>1063</i>&nbsp;
<i>1064</i>&nbsp;    /**
<i>1065</i>&nbsp;     * This method notifies the start of a general entity.
<i>1066</i>&nbsp;     * &lt;p&gt;
<i>1067</i>&nbsp;     * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
<i>1068</i>&nbsp;     * appearing as part of attribute values.
<i>1069</i>&nbsp;     *
<i>1070</i>&nbsp;     * @param name     The name of the general entity.
<b class="nc"><i>1071</i>&nbsp;     * @param identifier The resource identifier.</b>
<b class="nc"><i>1072</i>&nbsp;     * @param encoding The auto-detected IANA encoding name of the entity</b>
<i>1073</i>&nbsp;     *                 stream. This value will be null in those situations
<i>1074</i>&nbsp;     *                 where the entity encoding is not auto-detected (e.g.
<i>1075</i>&nbsp;     *                 internal entities or a document entity that is
<i>1076</i>&nbsp;     *                 parsed from a java.io.Reader).
<i>1077</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>1078</i>&nbsp;     *
<i>1079</i>&nbsp;     * @exception XNIException Thrown by handler to signal an error.
<i>1080</i>&nbsp;     */
<i>1081</i>&nbsp;    public void startGeneralEntity(
<i>1082</i>&nbsp;        String name,
<i>1083</i>&nbsp;        XMLResourceIdentifier identifier,
<i>1084</i>&nbsp;        String encoding,
<i>1085</i>&nbsp;        Augmentations augs)
<i>1086</i>&nbsp;        throws XNIException {
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;        // REVISIT: what should happen if normalize_data_ is on??
<i>1089</i>&nbsp;        fEntityRef = true;
<i>1090</i>&nbsp;        // call handlers
<i>1091</i>&nbsp;        if (fDocumentHandler != null) {
<b class="nc"><i>1092</i>&nbsp;            fDocumentHandler.startGeneralEntity(name, identifier, encoding, augs);</b>
<b class="nc"><i>1093</i>&nbsp;        }</b>
<b class="nc"><i>1094</i>&nbsp;</b>
<i>1095</i>&nbsp;    } // startEntity(String,String,String,String,String)
<i>1096</i>&nbsp;
<i>1097</i>&nbsp;    /**
<i>1098</i>&nbsp;     * Notifies of the presence of a TextDecl line in an entity. If present,
<i>1099</i>&nbsp;     * this method will be called immediately following the startEntity call.
<i>1100</i>&nbsp;     * &lt;p&gt;
<i>1101</i>&nbsp;     * &lt;strong&gt;Note:&lt;/strong&gt; This method will never be called for the
<i>1102</i>&nbsp;     * document entity; it is only called for external general entities
<i>1103</i>&nbsp;     * referenced in document content.
<i>1104</i>&nbsp;     * &lt;p&gt;
<i>1105</i>&nbsp;     * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
<i>1106</i>&nbsp;     * appearing as part of attribute values.
<i>1107</i>&nbsp;     *
<i>1108</i>&nbsp;     * @param version  The XML version, or null if not specified.
<i>1109</i>&nbsp;     * @param encoding The IANA encoding name of the entity.
<i>1110</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>1111</i>&nbsp;     *
<b class="nc"><i>1112</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.</b>
<i>1113</i>&nbsp;     */
<i>1114</i>&nbsp;    public void textDecl(String version, String encoding, Augmentations augs) throws XNIException {
<b class="nc"><i>1115</i>&nbsp;</b>
<b class="nc"><i>1116</i>&nbsp;        // call handlers</b>
<i>1117</i>&nbsp;        if (fDocumentHandler != null) {
<b class="nc"><i>1118</i>&nbsp;            fDocumentHandler.textDecl(version, encoding, augs);</b>
<b class="nc"><i>1119</i>&nbsp;        }</b>
<b class="nc"><i>1120</i>&nbsp;</b>
<i>1121</i>&nbsp;    } // textDecl(String,String)
<i>1122</i>&nbsp;
<b class="nc"><i>1123</i>&nbsp;    /**</b>
<b class="nc"><i>1124</i>&nbsp;     * A comment.</b>
<i>1125</i>&nbsp;     *
<i>1126</i>&nbsp;     * @param text The text in the comment.
<i>1127</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>1128</i>&nbsp;     *
<b class="nc"><i>1129</i>&nbsp;     * @throws XNIException Thrown by application to signal an error.</b>
<b class="nc"><i>1130</i>&nbsp;     */</b>
<i>1131</i>&nbsp;    public void comment(XMLString text, Augmentations augs) throws XNIException {
<b class="nc"><i>1132</i>&nbsp;</b>
<i>1133</i>&nbsp;        // call handlers
<i>1134</i>&nbsp;        if (fDocumentHandler != null) {
<b class="nc"><i>1135</i>&nbsp;            fDocumentHandler.comment(text, augs);</b>
<i>1136</i>&nbsp;        }
<i>1137</i>&nbsp;
<b class="nc"><i>1138</i>&nbsp;    } // comment(XMLString)</b>
<i>1139</i>&nbsp;
<i>1140</i>&nbsp;    /**
<i>1141</i>&nbsp;     * A processing instruction. Processing instructions consist of a
<i>1142</i>&nbsp;     * target name and, optionally, text data. The data is only meaningful
<i>1143</i>&nbsp;     * to the application.
<i>1144</i>&nbsp;     * &lt;p&gt;
<i>1145</i>&nbsp;     * Typically, a processing instruction&#39;s data will contain a series
<i>1146</i>&nbsp;     * of pseudo-attributes. These pseudo-attributes follow the form of
<i>1147</i>&nbsp;     * element attributes but are &lt;strong&gt;not&lt;/strong&gt; parsed or presented
<i>1148</i>&nbsp;     * to the application as anything other than text. The application is
<i>1149</i>&nbsp;     * responsible for parsing the data.
<i>1150</i>&nbsp;     *
<i>1151</i>&nbsp;     * @param target The target.
<i>1152</i>&nbsp;     * @param data   The data or null if none specified.
<i>1153</i>&nbsp;     * @param augs     Additional information that may include infoset augmentations
<i>1154</i>&nbsp;     *
<i>1155</i>&nbsp;     * @throws XNIException Thrown by handler to signal an error.
<i>1156</i>&nbsp;     */
<i>1157</i>&nbsp;    public void processingInstruction(String target, XMLString data, Augmentations augs)
<i>1158</i>&nbsp;        throws XNIException {
<i>1159</i>&nbsp;
<i>1160</i>&nbsp;        // call handlers
<i>1161</i>&nbsp;        if (fDocumentHandler != null) {
<i>1162</i>&nbsp;            fDocumentHandler.processingInstruction(target, data, augs);
<i>1163</i>&nbsp;        }
<i>1164</i>&nbsp;
<i>1165</i>&nbsp;    } // processingInstruction(String,XMLString)
<i>1166</i>&nbsp;
<b class="nc"><i>1167</i>&nbsp;    /**</b>
<i>1168</i>&nbsp;     * This method notifies the end of a general entity.
<i>1169</i>&nbsp;     * &lt;p&gt;
<i>1170</i>&nbsp;     * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
<i>1171</i>&nbsp;     * appearing as part of attribute values.
<i>1172</i>&nbsp;     *
<b class="nc"><i>1173</i>&nbsp;     * @param name   The name of the entity.</b>
<i>1174</i>&nbsp;     * @param augs   Additional information that may include infoset augmentations
<i>1175</i>&nbsp;     *
<i>1176</i>&nbsp;     * @exception XNIException
<i>1177</i>&nbsp;     *                   Thrown by handler to signal an error.
<i>1178</i>&nbsp;     */
<b class="nc"><i>1179</i>&nbsp;    public void endGeneralEntity(String name, Augmentations augs) throws XNIException {</b>
<i>1180</i>&nbsp;
<i>1181</i>&nbsp;        // call handlers
<i>1182</i>&nbsp;        fEntityRef = false;
<i>1183</i>&nbsp;        if (fDocumentHandler != null) {
<i>1184</i>&nbsp;            fDocumentHandler.endGeneralEntity(name, augs);
<b class="nc"><i>1185</i>&nbsp;        }</b>
<i>1186</i>&nbsp;
<i>1187</i>&nbsp;    } // endEntity(String)
<i>1188</i>&nbsp;
<i>1189</i>&nbsp;    // constants
<i>1190</i>&nbsp;
<b class="nc"><i>1191</i>&nbsp;    static final int INITIAL_STACK_SIZE = 8;</b>
<i>1192</i>&nbsp;    static final int INC_STACK_SIZE = 8;
<i>1193</i>&nbsp;
<i>1194</i>&nbsp;    //
<i>1195</i>&nbsp;    // Data
<i>1196</i>&nbsp;    //
<b class="nc"><i>1197</i>&nbsp;</b>
<i>1198</i>&nbsp;    // Schema Normalization
<i>1199</i>&nbsp;
<i>1200</i>&nbsp;    private static final boolean DEBUG_NORMALIZATION = false;
<i>1201</i>&nbsp;    // temporary empty string buffer.
<i>1202</i>&nbsp;    private final XMLString fEmptyXMLStr = new XMLString(null, 0, -1);
<b class="nc"><i>1203</i>&nbsp;    // temporary character buffer, and empty string buffer.</b>
<i>1204</i>&nbsp;    private static final int BUFFER_SIZE = 20;
<i>1205</i>&nbsp;    private final XMLString fNormalizedStr = new XMLString();
<b class="nc"><i>1206</i>&nbsp;    private boolean fFirstChunk = true;</b>
<i>1207</i>&nbsp;    // got first chunk in characters() (SAX)
<i>1208</i>&nbsp;    private boolean fTrailing = false; // Previous chunk had a trailing space
<b class="nc"><i>1209</i>&nbsp;    private short fWhiteSpace = -1; //whiteSpace: preserve/replace/collapse</b>
<i>1210</i>&nbsp;    private boolean fUnionType = false;
<i>1211</i>&nbsp;
<b class="nc"><i>1212</i>&nbsp;    /** Schema grammar resolver. */</b>
<i>1213</i>&nbsp;    private final XSGrammarBucket fGrammarBucket = new XSGrammarBucket();
<i>1214</i>&nbsp;    private final SubstitutionGroupHandler fSubGroupHandler = new SubstitutionGroupHandler(this);
<b class="nc"><i>1215</i>&nbsp;</b>
<i>1216</i>&nbsp;    /** the DV usd to convert xsi:type to a QName */
<i>1217</i>&nbsp;    // REVISIT: in new simple type design, make things in DVs static,
<b class="nc"><i>1218</i>&nbsp;    //          so that we can QNameDV.getCompiledForm()</b>
<i>1219</i>&nbsp;    private final XSSimpleType fQNameDV =
<i>1220</i>&nbsp;        (XSSimpleType) SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(SchemaSymbols.ATTVAL_QNAME);
<b class="nc"><i>1221</i>&nbsp;</b>
<i>1222</i>&nbsp;    private final CMNodeFactory nodeFactory = new CMNodeFactory();
<i>1223</i>&nbsp;    /** used to build content models */
<b class="nc"><i>1224</i>&nbsp;    // REVISIT: create decl pool, and pass it to each traversers</b>
<i>1225</i>&nbsp;    private final CMBuilder fCMBuilder = new CMBuilder(nodeFactory);
<i>1226</i>&nbsp;
<b class="nc"><i>1227</i>&nbsp;    // Schema grammar loader</b>
<i>1228</i>&nbsp;    private final XMLSchemaLoader fSchemaLoader =
<i>1229</i>&nbsp;        new XMLSchemaLoader(
<b class="nc"><i>1230</i>&nbsp;                fXSIErrorReporter.fErrorReporter,</b>
<i>1231</i>&nbsp;                fGrammarBucket,
<i>1232</i>&nbsp;                fSubGroupHandler,
<b class="nc"><i>1233</i>&nbsp;                fCMBuilder);</b>
<i>1234</i>&nbsp;
<i>1235</i>&nbsp;    // state
<i>1236</i>&nbsp;
<b class="nc"><i>1237</i>&nbsp;    /** String representation of the validation root. */</b>
<i>1238</i>&nbsp;    // REVISIT: what do we store here? QName, XPATH, some ID? use rawname now.
<i>1239</i>&nbsp;    private String fValidationRoot;
<i>1240</i>&nbsp;
<b class="nc"><i>1241</i>&nbsp;    /** Skip validation: anything below this level should be skipped */</b>
<i>1242</i>&nbsp;    private int fSkipValidationDepth;
<i>1243</i>&nbsp;
<i>1244</i>&nbsp;    /** anything above this level has validation_attempted != full */
<i>1245</i>&nbsp;    private int fNFullValidationDepth;
<i>1246</i>&nbsp;
<i>1247</i>&nbsp;    /** anything above this level has validation_attempted != none */
<i>1248</i>&nbsp;    private int fNNoneValidationDepth;
<i>1249</i>&nbsp;
<i>1250</i>&nbsp;    /** Element depth: -2: validator not in pipeline; &gt;= -1 current depth. */
<i>1251</i>&nbsp;    private int fElementDepth;
<i>1252</i>&nbsp;
<i>1253</i>&nbsp;    /** Seen sub elements. */
<i>1254</i>&nbsp;    private boolean fSubElement;
<i>1255</i>&nbsp;
<i>1256</i>&nbsp;    /** Seen sub elements stack. */
<i>1257</i>&nbsp;    private boolean[] fSubElementStack = new boolean[INITIAL_STACK_SIZE];
<i>1258</i>&nbsp;
<b class="nc"><i>1259</i>&nbsp;    /** Current element declaration. */</b>
<i>1260</i>&nbsp;    private XSElementDecl fCurrentElemDecl;
<i>1261</i>&nbsp;
<b class="nc"><i>1262</i>&nbsp;    /** Element decl stack. */</b>
<i>1263</i>&nbsp;    private XSElementDecl[] fElemDeclStack = new XSElementDecl[INITIAL_STACK_SIZE];
<i>1264</i>&nbsp;
<i>1265</i>&nbsp;    /** nil value of the current element */
<i>1266</i>&nbsp;    private boolean fNil;
<i>1267</i>&nbsp;
<i>1268</i>&nbsp;    /** nil value stack */
<b class="nc"><i>1269</i>&nbsp;    private boolean[] fNilStack = new boolean[INITIAL_STACK_SIZE];</b>
<b class="nc"><i>1270</i>&nbsp;</b>
<b class="nc"><i>1271</i>&nbsp;    /** notation value of the current element */</b>
<i>1272</i>&nbsp;    private XSNotationDecl fNotation;
<i>1273</i>&nbsp;
<i>1274</i>&nbsp;    /** notation stack */
<i>1275</i>&nbsp;    private XSNotationDecl[] fNotationStack = new XSNotationDecl[INITIAL_STACK_SIZE];
<i>1276</i>&nbsp;
<i>1277</i>&nbsp;    /** Current type. */
<i>1278</i>&nbsp;    private XSTypeDefinition fCurrentType;
<i>1279</i>&nbsp;
<i>1280</i>&nbsp;    /** type stack. */
<i>1281</i>&nbsp;    private XSTypeDefinition[] fTypeStack = new XSTypeDefinition[INITIAL_STACK_SIZE];
<i>1282</i>&nbsp;
<i>1283</i>&nbsp;    /** Current content model. */
<i>1284</i>&nbsp;    private XSCMValidator fCurrentCM;
<i>1285</i>&nbsp;
<i>1286</i>&nbsp;    /** Content model stack. */
<i>1287</i>&nbsp;    private XSCMValidator[] fCMStack = new XSCMValidator[INITIAL_STACK_SIZE];
<i>1288</i>&nbsp;
<i>1289</i>&nbsp;    /** the current state of the current content model */
<i>1290</i>&nbsp;    private int[] fCurrCMState;
<i>1291</i>&nbsp;
<b class="nc"><i>1292</i>&nbsp;    /** stack to hold content model states */</b>
<i>1293</i>&nbsp;    private int[][] fCMStateStack = new int[INITIAL_STACK_SIZE][];
<b class="nc"><i>1294</i>&nbsp;</b>
<i>1295</i>&nbsp;    /** whether the curret element is strictly assessed */
<i>1296</i>&nbsp;    private boolean fStrictAssess = true;
<b class="nc"><i>1297</i>&nbsp;</b>
<i>1298</i>&nbsp;    /** strict assess stack */
<i>1299</i>&nbsp;    private boolean[] fStrictAssessStack = new boolean[INITIAL_STACK_SIZE];
<b class="nc"><i>1300</i>&nbsp;</b>
<i>1301</i>&nbsp;    /** Temporary string buffers. */
<i>1302</i>&nbsp;    private final StringBuilder fBuffer = new StringBuilder();
<b class="nc"><i>1303</i>&nbsp;</b>
<i>1304</i>&nbsp;    /** Whether need to append characters to fBuffer */
<i>1305</i>&nbsp;    private boolean fAppendBuffer = true;
<b class="nc"><i>1306</i>&nbsp;</b>
<b class="nc"><i>1307</i>&nbsp;    /** Did we see any character data? */</b>
<b class="nc"><i>1308</i>&nbsp;    private boolean fSawText = false;</b>
<b class="nc"><i>1309</i>&nbsp;</b>
<b class="nc"><i>1310</i>&nbsp;    /** stack to record if we saw character data */</b>
<b class="nc"><i>1311</i>&nbsp;    private boolean[] fSawTextStack = new boolean[INITIAL_STACK_SIZE];</b>
<b class="nc"><i>1312</i>&nbsp;</b>
<b class="nc"><i>1313</i>&nbsp;    /** Did we see non-whitespace character data? */</b>
<b class="nc"><i>1314</i>&nbsp;    private boolean fSawCharacters = false;</b>
<i>1315</i>&nbsp;
<i>1316</i>&nbsp;    /** Stack to record if we saw character data outside of element content*/
<b class="nc"><i>1317</i>&nbsp;    private boolean[] fStringContent = new boolean[INITIAL_STACK_SIZE];</b>
<b class="nc"><i>1318</i>&nbsp;</b>
<i>1319</i>&nbsp;    /** temporary qname */
<b class="nc"><i>1320</i>&nbsp;    private final QName fTempQName = new QName();</b>
<i>1321</i>&nbsp;
<b class="nc"><i>1322</i>&nbsp;    /** value of the &quot;root-type-definition&quot; property. */</b>
<i>1323</i>&nbsp;    private javax.xml.namespace.QName fRootTypeQName = null;
<b class="nc"><i>1324</i>&nbsp;    private XSTypeDefinition fRootTypeDefinition = null;</b>
<i>1325</i>&nbsp;
<i>1326</i>&nbsp;    /** value of the &quot;root-element-declaration&quot; property. */
<i>1327</i>&nbsp;    private javax.xml.namespace.QName fRootElementDeclQName = null;
<b class="nc"><i>1328</i>&nbsp;    private XSElementDecl fRootElementDeclaration = null;</b>
<i>1329</i>&nbsp;
<b class="nc"><i>1330</i>&nbsp;    private int fIgnoreXSITypeDepth;</b>
<i>1331</i>&nbsp;
<b class="nc"><i>1332</i>&nbsp;    private boolean fIDCChecking;</b>
<i>1333</i>&nbsp;
<b class="nc"><i>1334</i>&nbsp;    /** temporary validated info */</b>
<i>1335</i>&nbsp;    private ValidatedInfo fValidatedInfo = new ValidatedInfo();
<b class="nc"><i>1336</i>&nbsp;</b>
<i>1337</i>&nbsp;    // used to validate default/fixed values against xsi:type
<i>1338</i>&nbsp;    // only need to check facets, so we set extraChecking to false (in reset)
<i>1339</i>&nbsp;    private ValidationState fState4XsiType = new ValidationState();
<i>1340</i>&nbsp;
<i>1341</i>&nbsp;    // used to apply default/fixed values
<i>1342</i>&nbsp;    // only need to check id/idref/entity, so we set checkFacets to false
<i>1343</i>&nbsp;    private ValidationState fState4ApplyDefault = new ValidationState();
<i>1344</i>&nbsp;
<i>1345</i>&nbsp;    // identity constraint information
<b class="nc"><i>1346</i>&nbsp;</b>
<b class="nc"><i>1347</i>&nbsp;    /**</b>
<b class="nc"><i>1348</i>&nbsp;     * Stack of active XPath matchers for identity constraints. All</b>
<i>1349</i>&nbsp;     * active XPath matchers are notified of startElement
<i>1350</i>&nbsp;     * and endElement callbacks in order to perform their matches.
<b class="nc"><i>1351</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1352</i>&nbsp;     * For each element with identity constraints, the selector of</b>
<i>1353</i>&nbsp;     * each identity constraint is activated. When the selector matches
<b class="nc"><i>1354</i>&nbsp;     * its XPath, then all the fields of the identity constraint are</b>
<b class="nc"><i>1355</i>&nbsp;     * activated.</b>
<i>1356</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1357</i>&nbsp;     * &lt;strong&gt;Note:&lt;/strong&gt; Once the activation scope is left, the</b>
<i>1358</i>&nbsp;     * XPath matchers are automatically removed from the stack of
<i>1359</i>&nbsp;     * active matchers and no longer receive callbacks.
<b class="nc"><i>1360</i>&nbsp;     */</b>
<b class="nc"><i>1361</i>&nbsp;    protected XPathMatcherStack fMatcherStack = new XPathMatcherStack();</b>
<i>1362</i>&nbsp;
<i>1363</i>&nbsp;    /** Cache of value stores for identity constraint fields. */
<b class="nc"><i>1364</i>&nbsp;    protected ValueStoreCache fValueStoreCache = new ValueStoreCache();</b>
<b class="nc"><i>1365</i>&nbsp;</b>
<b class="nc"><i>1366</i>&nbsp;    //</b>
<i>1367</i>&nbsp;    // Constructors
<b class="nc"><i>1368</i>&nbsp;    //</b>
<i>1369</i>&nbsp;
<b class="nc"><i>1370</i>&nbsp;    /** Default constructor. */</b>
<b class="nc"><i>1371</i>&nbsp;    public XMLSchemaValidator() {</b>
<i>1372</i>&nbsp;        fState4XsiType.setExtraChecking(false);
<i>1373</i>&nbsp;        fState4ApplyDefault.setFacetChecking(false);
<b class="nc"><i>1374</i>&nbsp;</b>
<i>1375</i>&nbsp;    } // &lt;init&gt;()
<b class="nc"><i>1376</i>&nbsp;</b>
<i>1377</i>&nbsp;    /*
<b class="nc"><i>1378</i>&nbsp;     * Resets the component. The component can query the component manager</b>
<b class="nc"><i>1379</i>&nbsp;     * about any features and properties that affect the operation of the</b>
<b class="nc"><i>1380</i>&nbsp;     * component.</b>
<i>1381</i>&nbsp;     *
<i>1382</i>&nbsp;     * @param componentManager The component manager.
<i>1383</i>&nbsp;     *
<i>1384</i>&nbsp;     * @throws SAXException Thrown by component on finitialization error.
<b class="nc"><i>1385</i>&nbsp;     *                      For example, if a feature or property is</b>
<b class="nc"><i>1386</i>&nbsp;     *                      required for the operation of the component, the</b>
<b class="nc"><i>1387</i>&nbsp;     *                      component manager may throw a</b>
<b class="nc"><i>1388</i>&nbsp;     *                      SAXNotRecognizedException or a</b>
<b class="nc"><i>1389</i>&nbsp;     *                      SAXNotSupportedException.</b>
<b class="nc"><i>1390</i>&nbsp;     */</b>
<b class="nc"><i>1391</i>&nbsp;    public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {</b>
<i>1392</i>&nbsp;
<i>1393</i>&nbsp;
<i>1394</i>&nbsp;        fIdConstraint = false;
<i>1395</i>&nbsp;        //reset XSDDescription
<i>1396</i>&nbsp;        fLocationPairs.clear();
<b class="nc"><i>1397</i>&nbsp;</b>
<i>1398</i>&nbsp;        // cleanup id table
<i>1399</i>&nbsp;        fValidationState.resetIDTables();
<i>1400</i>&nbsp;
<i>1401</i>&nbsp;        // reset schema loader
<i>1402</i>&nbsp;        fSchemaLoader.reset(componentManager);
<b class="nc"><i>1403</i>&nbsp;</b>
<i>1404</i>&nbsp;        // initialize state
<i>1405</i>&nbsp;        fCurrentElemDecl = null;
<b class="nc"><i>1406</i>&nbsp;        fCurrentCM = null;</b>
<i>1407</i>&nbsp;        fCurrCMState = null;
<b class="nc"><i>1408</i>&nbsp;        fSkipValidationDepth = -1;</b>
<b class="nc"><i>1409</i>&nbsp;        fNFullValidationDepth = -1;</b>
<i>1410</i>&nbsp;        fNNoneValidationDepth = -1;
<i>1411</i>&nbsp;        fElementDepth = -1;
<i>1412</i>&nbsp;        fSubElement = false;
<i>1413</i>&nbsp;        fSchemaDynamicValidation = false;
<i>1414</i>&nbsp;
<i>1415</i>&nbsp;        // datatype normalization
<i>1416</i>&nbsp;        fEntityRef = false;
<i>1417</i>&nbsp;        fInCDATA = false;
<i>1418</i>&nbsp;
<i>1419</i>&nbsp;        fMatcherStack.clear();
<i>1420</i>&nbsp;
<i>1421</i>&nbsp;        // get error reporter
<i>1422</i>&nbsp;        fXSIErrorReporter.reset((XMLErrorReporter) componentManager.getProperty(ERROR_REPORTER));
<i>1423</i>&nbsp;
<i>1424</i>&nbsp;        boolean parser_settings = componentManager.getFeature(PARSER_SETTINGS, true);
<i>1425</i>&nbsp;
<b class="nc"><i>1426</i>&nbsp;        if (!parser_settings) {</b>
<b class="nc"><i>1427</i>&nbsp;            // parser settings have not been changed</b>
<b class="nc"><i>1428</i>&nbsp;            fValidationManager.addValidationState(fValidationState);</b>
<i>1429</i>&nbsp;            // the node limit on the SecurityManager may have changed so need to refresh.
<i>1430</i>&nbsp;            nodeFactory.reset();
<i>1431</i>&nbsp;            // Re-parse external schema location properties.
<i>1432</i>&nbsp;            XMLSchemaLoader.processExternalHints(
<i>1433</i>&nbsp;                fExternalSchemas,
<i>1434</i>&nbsp;                fExternalNoNamespaceSchema,
<i>1435</i>&nbsp;                fLocationPairs,
<i>1436</i>&nbsp;                fXSIErrorReporter.fErrorReporter);
<i>1437</i>&nbsp;            return;
<i>1438</i>&nbsp;        }
<b class="nc"><i>1439</i>&nbsp;</b>
<b class="nc"><i>1440</i>&nbsp;        // pass the component manager to the factory..</b>
<b class="nc"><i>1441</i>&nbsp;        nodeFactory.reset(componentManager);</b>
<b class="nc"><i>1442</i>&nbsp;</b>
<b class="nc"><i>1443</i>&nbsp;        // get symbol table. if it&#39;s a new one, add symbols to it.</b>
<b class="nc"><i>1444</i>&nbsp;        SymbolTable symbolTable = (SymbolTable) componentManager.getProperty(SYMBOL_TABLE);</b>
<b class="nc"><i>1445</i>&nbsp;        if (symbolTable != fSymbolTable) {</b>
<i>1446</i>&nbsp;            fSymbolTable = symbolTable;
<i>1447</i>&nbsp;        }
<i>1448</i>&nbsp;
<i>1449</i>&nbsp;        fNamespaceGrowth = componentManager.getFeature(NAMESPACE_GROWTH, false);
<i>1450</i>&nbsp;        fDynamicValidation = componentManager.getFeature(DYNAMIC_VALIDATION, false);
<i>1451</i>&nbsp;
<i>1452</i>&nbsp;        if (fDynamicValidation) {
<i>1453</i>&nbsp;            fDoValidation = true;
<i>1454</i>&nbsp;        } else {
<b class="nc"><i>1455</i>&nbsp;            fDoValidation = componentManager.getFeature(VALIDATION, false);</b>
<b class="nc"><i>1456</i>&nbsp;        }</b>
<b class="nc"><i>1457</i>&nbsp;</b>
<i>1458</i>&nbsp;        if (fDoValidation) {
<i>1459</i>&nbsp;            fDoValidation |= componentManager.getFeature(XMLSchemaValidator.SCHEMA_VALIDATION, false);
<i>1460</i>&nbsp;        }
<i>1461</i>&nbsp;
<i>1462</i>&nbsp;        fFullChecking = componentManager.getFeature(SCHEMA_FULL_CHECKING, false);
<i>1463</i>&nbsp;        fNormalizeData = componentManager.getFeature(NORMALIZE_DATA, false);
<i>1464</i>&nbsp;        fSchemaElementDefault = componentManager.getFeature(SCHEMA_ELEMENT_DEFAULT, false);
<i>1465</i>&nbsp;
<i>1466</i>&nbsp;        fAugPSVI = componentManager.getFeature(SCHEMA_AUGMENT_PSVI, true);
<i>1467</i>&nbsp;
<i>1468</i>&nbsp;        fSchemaType =
<i>1469</i>&nbsp;            (String) componentManager.getProperty(
<b class="nc"><i>1470</i>&nbsp;                Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE, null);</b>
<i>1471</i>&nbsp;
<i>1472</i>&nbsp;        fUseGrammarPoolOnly = componentManager.getFeature(USE_GRAMMAR_POOL_ONLY, false);
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;        fEntityResolver = (XMLEntityResolver) componentManager.getProperty(ENTITY_MANAGER);
<i>1475</i>&nbsp;
<i>1476</i>&nbsp;        fValidationManager = (ValidationManager) componentManager.getProperty(VALIDATION_MANAGER);
<i>1477</i>&nbsp;        fValidationManager.addValidationState(fValidationState);
<i>1478</i>&nbsp;        fValidationState.setSymbolTable(fSymbolTable);
<i>1479</i>&nbsp;
<b class="nc"><i>1480</i>&nbsp;        try {</b>
<i>1481</i>&nbsp;            final Object rootType = componentManager.getProperty(ROOT_TYPE_DEF);
<i>1482</i>&nbsp;            if (rootType == null) {
<i>1483</i>&nbsp;                fRootTypeQName = null;
<i>1484</i>&nbsp;                fRootTypeDefinition = null;
<b class="nc"><i>1485</i>&nbsp;            }</b>
<b class="nc"><i>1486</i>&nbsp;            else if (rootType instanceof javax.xml.namespace.QName) {</b>
<b class="nc"><i>1487</i>&nbsp;                fRootTypeQName = (javax.xml.namespace.QName) rootType;</b>
<i>1488</i>&nbsp;                fRootTypeDefinition = null;
<b class="nc"><i>1489</i>&nbsp;            }</b>
<b class="nc"><i>1490</i>&nbsp;            else {</b>
<b class="nc"><i>1491</i>&nbsp;                fRootTypeDefinition = (XSTypeDefinition) rootType;</b>
<i>1492</i>&nbsp;                fRootTypeQName = null;
<i>1493</i>&nbsp;            }
<i>1494</i>&nbsp;        }
<i>1495</i>&nbsp;        catch (XMLConfigurationException e) {
<i>1496</i>&nbsp;            fRootTypeQName = null;
<i>1497</i>&nbsp;            fRootTypeDefinition = null;
<i>1498</i>&nbsp;        }
<i>1499</i>&nbsp;
<i>1500</i>&nbsp;        try {
<b class="nc"><i>1501</i>&nbsp;            final Object rootDecl = componentManager.getProperty(ROOT_ELEMENT_DECL);</b>
<b class="nc"><i>1502</i>&nbsp;            if (rootDecl == null) {</b>
<b class="nc"><i>1503</i>&nbsp;                fRootElementDeclQName = null;</b>
<b class="nc"><i>1504</i>&nbsp;                fRootElementDeclaration = null;</b>
<b class="nc"><i>1505</i>&nbsp;            }</b>
<i>1506</i>&nbsp;            else if (rootDecl instanceof javax.xml.namespace.QName) {
<b class="nc"><i>1507</i>&nbsp;                fRootElementDeclQName = (javax.xml.namespace.QName) rootDecl;</b>
<b class="nc"><i>1508</i>&nbsp;                fRootElementDeclaration = null;</b>
<b class="nc"><i>1509</i>&nbsp;            }</b>
<i>1510</i>&nbsp;            else {
<b class="nc"><i>1511</i>&nbsp;                fRootElementDeclaration = (XSElementDecl) rootDecl;</b>
<b class="nc"><i>1512</i>&nbsp;                fRootElementDeclQName = null;</b>
<b class="nc"><i>1513</i>&nbsp;            }</b>
<i>1514</i>&nbsp;        }
<b class="nc"><i>1515</i>&nbsp;        catch (XMLConfigurationException e) {</b>
<b class="nc"><i>1516</i>&nbsp;            fRootElementDeclQName = null;</b>
<b class="nc"><i>1517</i>&nbsp;            fRootElementDeclaration = null;</b>
<i>1518</i>&nbsp;        }
<b class="nc"><i>1519</i>&nbsp;</b>
<b class="nc"><i>1520</i>&nbsp;        boolean ignoreXSIType = componentManager.getFeature(IGNORE_XSI_TYPE, false);</b>
<b class="nc"><i>1521</i>&nbsp;</b>
<i>1522</i>&nbsp;        // An initial value of -1 means that the root element considers itself
<b class="nc"><i>1523</i>&nbsp;        // below the depth where xsi:type stopped being ignored (which means that</b>
<b class="nc"><i>1524</i>&nbsp;        // xsi:type attributes will not be ignored for the entire document)</b>
<b class="nc"><i>1525</i>&nbsp;        fIgnoreXSITypeDepth = ignoreXSIType ? 0 : -1;</b>
<i>1526</i>&nbsp;
<b class="nc"><i>1527</i>&nbsp;        try {</b>
<b class="nc"><i>1528</i>&nbsp;            fIDCChecking = componentManager.getFeature(IDENTITY_CONSTRAINT_CHECKING);</b>
<b class="nc"><i>1529</i>&nbsp;        }</b>
<i>1530</i>&nbsp;        catch (XMLConfigurationException e) {
<b class="nc"><i>1531</i>&nbsp;            fIDCChecking = true;</b>
<b class="nc"><i>1532</i>&nbsp;        }</b>
<b class="nc"><i>1533</i>&nbsp;</b>
<i>1534</i>&nbsp;        try {
<b class="nc"><i>1535</i>&nbsp;            fValidationState.setIdIdrefChecking(componentManager.getFeature(ID_IDREF_CHECKING));</b>
<b class="nc"><i>1536</i>&nbsp;        }</b>
<b class="nc"><i>1537</i>&nbsp;        catch (XMLConfigurationException e) {</b>
<i>1538</i>&nbsp;            fValidationState.setIdIdrefChecking(true);
<b class="nc"><i>1539</i>&nbsp;        }</b>
<b class="nc"><i>1540</i>&nbsp;</b>
<b class="nc"><i>1541</i>&nbsp;        try {</b>
<i>1542</i>&nbsp;            fValidationState.setUnparsedEntityChecking(componentManager.getFeature(UNPARSED_ENTITY_CHECKING));
<i>1543</i>&nbsp;        }
<i>1544</i>&nbsp;        catch (XMLConfigurationException e) {
<i>1545</i>&nbsp;            fValidationState.setUnparsedEntityChecking(true);
<i>1546</i>&nbsp;        }
<i>1547</i>&nbsp;
<b class="nc"><i>1548</i>&nbsp;        // get schema location properties</b>
<b class="nc"><i>1549</i>&nbsp;        try {</b>
<b class="nc"><i>1550</i>&nbsp;            fExternalSchemas = (String) componentManager.getProperty(SCHEMA_LOCATION);</b>
<b class="nc"><i>1551</i>&nbsp;            fExternalNoNamespaceSchema =</b>
<i>1552</i>&nbsp;                (String) componentManager.getProperty(SCHEMA_NONS_LOCATION);
<i>1553</i>&nbsp;        } catch (XMLConfigurationException e) {
<i>1554</i>&nbsp;            fExternalSchemas = null;
<i>1555</i>&nbsp;            fExternalNoNamespaceSchema = null;
<b class="nc"><i>1556</i>&nbsp;        }</b>
<i>1557</i>&nbsp;
<i>1558</i>&nbsp;        // store the external schema locations. they are set when reset is called,
<i>1559</i>&nbsp;        // so any other schemaLocation declaration for the same namespace will be
<i>1560</i>&nbsp;        // effectively ignored. becuase we choose to take first location hint
<i>1561</i>&nbsp;        // available for a particular namespace.
<i>1562</i>&nbsp;        XMLSchemaLoader.processExternalHints(
<b class="nc"><i>1563</i>&nbsp;            fExternalSchemas,</b>
<b class="nc"><i>1564</i>&nbsp;            fExternalNoNamespaceSchema,</b>
<i>1565</i>&nbsp;            fLocationPairs,
<b class="nc"><i>1566</i>&nbsp;            fXSIErrorReporter.fErrorReporter);</b>
<i>1567</i>&nbsp;
<i>1568</i>&nbsp;        fJaxpSchemaSource = componentManager.getProperty(JAXP_SCHEMA_SOURCE, null);
<i>1569</i>&nbsp;
<i>1570</i>&nbsp;        // clear grammars, and put the one for schema namespace there
<b class="nc"><i>1571</i>&nbsp;        fGrammarPool = (XMLGrammarPool) componentManager.getProperty(XMLGRAMMAR_POOL, null);</b>
<i>1572</i>&nbsp;
<b class="nc"><i>1573</i>&nbsp;        fState4XsiType.setSymbolTable(symbolTable);</b>
<b class="nc"><i>1574</i>&nbsp;        fState4ApplyDefault.setSymbolTable(symbolTable);</b>
<i>1575</i>&nbsp;
<b class="nc"><i>1576</i>&nbsp;    } // reset(XMLComponentManager)</b>
<b class="nc"><i>1577</i>&nbsp;</b>
<i>1578</i>&nbsp;    //
<i>1579</i>&nbsp;    // FieldActivator methods
<i>1580</i>&nbsp;    //
<b class="nc"><i>1581</i>&nbsp;</b>
<b class="nc"><i>1582</i>&nbsp;    /**</b>
<b class="nc"><i>1583</i>&nbsp;     * Start the value scope for the specified identity constraint. This</b>
<b class="nc"><i>1584</i>&nbsp;     * method is called when the selector matches in order to initialize</b>
<b class="nc"><i>1585</i>&nbsp;     * the value store.</b>
<i>1586</i>&nbsp;     *
<b class="nc"><i>1587</i>&nbsp;     * @param identityConstraint The identity constraint.</b>
<b class="nc"><i>1588</i>&nbsp;     */</b>
<b class="nc"><i>1589</i>&nbsp;    public void startValueScopeFor(IdentityConstraint identityConstraint, int initialDepth) {</b>
<b class="nc"><i>1590</i>&nbsp;</b>
<i>1591</i>&nbsp;        ValueStoreBase valueStore =
<b class="nc"><i>1592</i>&nbsp;            fValueStoreCache.getValueStoreFor(identityConstraint, initialDepth);</b>
<i>1593</i>&nbsp;        valueStore.startValueScope();
<i>1594</i>&nbsp;
<i>1595</i>&nbsp;    } // startValueScopeFor(IdentityConstraint identityConstraint)
<i>1596</i>&nbsp;
<b class="nc"><i>1597</i>&nbsp;    /**</b>
<i>1598</i>&nbsp;     * Request to activate the specified field. This method returns the
<i>1599</i>&nbsp;     * matcher for the field.
<i>1600</i>&nbsp;     *
<i>1601</i>&nbsp;     * @param field The field to activate.
<i>1602</i>&nbsp;     */
<i>1603</i>&nbsp;    public XPathMatcher activateField(Field field, int initialDepth) {
<i>1604</i>&nbsp;        ValueStore valueStore =
<i>1605</i>&nbsp;            fValueStoreCache.getValueStoreFor(field.getIdentityConstraint(), initialDepth);
<i>1606</i>&nbsp;        XPathMatcher matcher = field.createMatcher(valueStore);
<b class="nc"><i>1607</i>&nbsp;        fMatcherStack.addMatcher(matcher);</b>
<b class="nc"><i>1608</i>&nbsp;        matcher.startDocumentFragment();</b>
<b class="nc"><i>1609</i>&nbsp;        return matcher;</b>
<b class="nc"><i>1610</i>&nbsp;    } // activateField(Field):XPathMatcher</b>
<i>1611</i>&nbsp;
<b class="nc"><i>1612</i>&nbsp;    /**</b>
<i>1613</i>&nbsp;     * Ends the value scope for the specified identity constraint.
<i>1614</i>&nbsp;     *
<b class="nc"><i>1615</i>&nbsp;     * @param identityConstraint The identity constraint.</b>
<b class="nc"><i>1616</i>&nbsp;     */</b>
<i>1617</i>&nbsp;    public void endValueScopeFor(IdentityConstraint identityConstraint, int initialDepth) {
<i>1618</i>&nbsp;
<b class="nc"><i>1619</i>&nbsp;        ValueStoreBase valueStore =</b>
<b class="nc"><i>1620</i>&nbsp;            fValueStoreCache.getValueStoreFor(identityConstraint, initialDepth);</b>
<i>1621</i>&nbsp;        valueStore.endValueScope();
<b class="nc"><i>1622</i>&nbsp;</b>
<b class="nc"><i>1623</i>&nbsp;    } // endValueScopeFor(IdentityConstraint)</b>
<b class="nc"><i>1624</i>&nbsp;</b>
<b class="nc"><i>1625</i>&nbsp;    // a utility method for Identity constraints</b>
<i>1626</i>&nbsp;    private void activateSelectorFor(IdentityConstraint ic) {
<b class="nc"><i>1627</i>&nbsp;        Selector selector = ic.getSelector();</b>
<b class="nc"><i>1628</i>&nbsp;        FieldActivator activator = this;</b>
<i>1629</i>&nbsp;        if (selector == null)
<b class="nc"><i>1630</i>&nbsp;            return;</b>
<i>1631</i>&nbsp;        XPathMatcher matcher = selector.createMatcher(activator, fElementDepth);
<b class="nc"><i>1632</i>&nbsp;        fMatcherStack.addMatcher(matcher);</b>
<i>1633</i>&nbsp;        matcher.startDocumentFragment();
<i>1634</i>&nbsp;    }
<b class="nc"><i>1635</i>&nbsp;</b>
<b class="nc"><i>1636</i>&nbsp;    // Implements XSElementDeclHelper interface</b>
<b class="nc"><i>1637</i>&nbsp;    public XSElementDecl getGlobalElementDecl(QName element) {</b>
<i>1638</i>&nbsp;        final SchemaGrammar sGrammar =
<i>1639</i>&nbsp;            findSchemaGrammar(
<b class="nc"><i>1640</i>&nbsp;                XSDDescription.CONTEXT_ELEMENT,</b>
<b class="nc"><i>1641</i>&nbsp;                element.uri,</b>
<i>1642</i>&nbsp;                null,
<b class="nc"><i>1643</i>&nbsp;                element,</b>
<b class="nc"><i>1644</i>&nbsp;                null);</b>
<b class="nc"><i>1645</i>&nbsp;        if (sGrammar != null) {</b>
<i>1646</i>&nbsp;            return sGrammar.getGlobalElementDecl(element.localpart);
<i>1647</i>&nbsp;        }
<b class="nc"><i>1648</i>&nbsp;        return null;</b>
<i>1649</i>&nbsp;    }
<i>1650</i>&nbsp;
<i>1651</i>&nbsp;    //
<b class="nc"><i>1652</i>&nbsp;    // Protected methods</b>
<b class="nc"><i>1653</i>&nbsp;    //</b>
<b class="nc"><i>1654</i>&nbsp;</b>
<i>1655</i>&nbsp;    /** ensure element stack capacity */
<i>1656</i>&nbsp;    void ensureStackCapacity() {
<b class="nc"><i>1657</i>&nbsp;</b>
<b class="nc"><i>1658</i>&nbsp;        if (fElementDepth == fElemDeclStack.length) {</b>
<b class="nc"><i>1659</i>&nbsp;            int newSize = fElementDepth + INC_STACK_SIZE;</b>
<i>1660</i>&nbsp;            boolean[] newArrayB = new boolean[newSize];
<i>1661</i>&nbsp;            System.arraycopy(fSubElementStack, 0, newArrayB, 0, fElementDepth);
<b class="nc"><i>1662</i>&nbsp;            fSubElementStack = newArrayB;</b>
<b class="nc"><i>1663</i>&nbsp;</b>
<i>1664</i>&nbsp;            XSElementDecl[] newArrayE = new XSElementDecl[newSize];
<i>1665</i>&nbsp;            System.arraycopy(fElemDeclStack, 0, newArrayE, 0, fElementDepth);
<i>1666</i>&nbsp;            fElemDeclStack = newArrayE;
<i>1667</i>&nbsp;
<i>1668</i>&nbsp;            newArrayB = new boolean[newSize];
<b class="nc"><i>1669</i>&nbsp;            System.arraycopy(fNilStack, 0, newArrayB, 0, fElementDepth);</b>
<i>1670</i>&nbsp;            fNilStack = newArrayB;
<b class="nc"><i>1671</i>&nbsp;</b>
<i>1672</i>&nbsp;            XSNotationDecl[] newArrayN = new XSNotationDecl[newSize];
<b class="nc"><i>1673</i>&nbsp;            System.arraycopy(fNotationStack, 0, newArrayN, 0, fElementDepth);</b>
<b class="nc"><i>1674</i>&nbsp;            fNotationStack = newArrayN;</b>
<i>1675</i>&nbsp;
<i>1676</i>&nbsp;            XSTypeDefinition[] newArrayT = new XSTypeDefinition[newSize];
<i>1677</i>&nbsp;            System.arraycopy(fTypeStack, 0, newArrayT, 0, fElementDepth);
<b class="nc"><i>1678</i>&nbsp;            fTypeStack = newArrayT;</b>
<i>1679</i>&nbsp;
<b class="nc"><i>1680</i>&nbsp;            XSCMValidator[] newArrayC = new XSCMValidator[newSize];</b>
<i>1681</i>&nbsp;            System.arraycopy(fCMStack, 0, newArrayC, 0, fElementDepth);
<i>1682</i>&nbsp;            fCMStack = newArrayC;
<b class="nc"><i>1683</i>&nbsp;</b>
<b class="nc"><i>1684</i>&nbsp;            newArrayB = new boolean[newSize];</b>
<i>1685</i>&nbsp;            System.arraycopy(fSawTextStack, 0, newArrayB, 0, fElementDepth);
<b class="nc"><i>1686</i>&nbsp;            fSawTextStack = newArrayB;</b>
<b class="nc"><i>1687</i>&nbsp;</b>
<i>1688</i>&nbsp;            newArrayB = new boolean[newSize];
<b class="nc"><i>1689</i>&nbsp;            System.arraycopy(fStringContent, 0, newArrayB, 0, fElementDepth);</b>
<b class="nc"><i>1690</i>&nbsp;            fStringContent = newArrayB;</b>
<b class="nc"><i>1691</i>&nbsp;</b>
<b class="nc"><i>1692</i>&nbsp;            newArrayB = new boolean[newSize];</b>
<i>1693</i>&nbsp;            System.arraycopy(fStrictAssessStack, 0, newArrayB, 0, fElementDepth);
<b class="nc"><i>1694</i>&nbsp;            fStrictAssessStack = newArrayB;</b>
<b class="nc"><i>1695</i>&nbsp;</b>
<i>1696</i>&nbsp;            int[][] newArrayIA = new int[newSize][];
<i>1697</i>&nbsp;            System.arraycopy(fCMStateStack, 0, newArrayIA, 0, fElementDepth);
<b class="nc"><i>1698</i>&nbsp;            fCMStateStack = newArrayIA;</b>
<b class="nc"><i>1699</i>&nbsp;        }</b>
<i>1700</i>&nbsp;
<i>1701</i>&nbsp;    } // ensureStackCapacity
<b class="nc"><i>1702</i>&nbsp;</b>
<b class="nc"><i>1703</i>&nbsp;    // handle start document</b>
<i>1704</i>&nbsp;    void handleStartDocument(XMLLocator locator, String encoding) {
<b class="nc"><i>1705</i>&nbsp;        if (fIDCChecking) {</b>
<i>1706</i>&nbsp;            fValueStoreCache.startDocument();
<i>1707</i>&nbsp;        }
<i>1708</i>&nbsp;        if (fAugPSVI) {
<i>1709</i>&nbsp;            fCurrentPSVI.fGrammars = null;
<i>1710</i>&nbsp;            fCurrentPSVI.fSchemaInformation = null;
<i>1711</i>&nbsp;        }
<b class="nc"><i>1712</i>&nbsp;    } // handleStartDocument(XMLLocator,String)</b>
<i>1713</i>&nbsp;
<i>1714</i>&nbsp;    void handleEndDocument() {
<i>1715</i>&nbsp;        if (fIDCChecking) {
<i>1716</i>&nbsp;            fValueStoreCache.endDocument();
<i>1717</i>&nbsp;        }
<i>1718</i>&nbsp;    } // handleEndDocument()
<i>1719</i>&nbsp;
<i>1720</i>&nbsp;    // handle character contents
<i>1721</i>&nbsp;    // returns the normalized string if possible, otherwise the original string
<i>1722</i>&nbsp;    XMLString handleCharacters(XMLString text) {
<i>1723</i>&nbsp;
<i>1724</i>&nbsp;        if (fSkipValidationDepth &gt;= 0)
<i>1725</i>&nbsp;            return text;
<i>1726</i>&nbsp;
<i>1727</i>&nbsp;        fSawText = fSawText || text.length &gt; 0;
<b class="nc"><i>1728</i>&nbsp;</b>
<b class="nc"><i>1729</i>&nbsp;        // Note: data in EntityRef and CDATA is normalized as well</b>
<i>1730</i>&nbsp;        // if whitespace == -1 skip normalization, because it is a complexType
<i>1731</i>&nbsp;        // or a union type.
<i>1732</i>&nbsp;        if (fNormalizeData &amp;&amp; fWhiteSpace != -1 &amp;&amp; fWhiteSpace != XSSimpleType.WS_PRESERVE) {
<i>1733</i>&nbsp;            // normalize data
<b class="nc"><i>1734</i>&nbsp;            normalizeWhitespace(text, fWhiteSpace == XSSimpleType.WS_COLLAPSE);</b>
<i>1735</i>&nbsp;            text = fNormalizedStr;
<i>1736</i>&nbsp;        }
<i>1737</i>&nbsp;        if (fAppendBuffer)
<i>1738</i>&nbsp;            fBuffer.append(text.ch, text.offset, text.length);
<i>1739</i>&nbsp;
<i>1740</i>&nbsp;        // When it&#39;s a complex type with element-only content, we need to
<i>1741</i>&nbsp;        // find out whether the content contains any non-whitespace character.
<i>1742</i>&nbsp;        fSawOnlyWhitespaceInElementContent = false;
<i>1743</i>&nbsp;        if (fCurrentType != null
<i>1744</i>&nbsp;            &amp;&amp; fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<i>1745</i>&nbsp;            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
<i>1746</i>&nbsp;            if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT) {
<b class="nc"><i>1747</i>&nbsp;                // data outside of element content</b>
<b class="nc"><i>1748</i>&nbsp;                for (int i = text.offset; i &lt; text.offset + text.length; i++) {</b>
<b class="nc"><i>1749</i>&nbsp;                    if (!XMLChar.isSpace(text.ch[i])) {</b>
<b class="nc"><i>1750</i>&nbsp;                        fSawCharacters = true;</b>
<i>1751</i>&nbsp;                        break;
<i>1752</i>&nbsp;                    }
<i>1753</i>&nbsp;                    fSawOnlyWhitespaceInElementContent = !fSawCharacters;
<b class="nc"><i>1754</i>&nbsp;                }</b>
<i>1755</i>&nbsp;            }
<i>1756</i>&nbsp;        }
<i>1757</i>&nbsp;
<b class="nc"><i>1758</i>&nbsp;        return text;</b>
<b class="nc"><i>1759</i>&nbsp;    } // handleCharacters(XMLString)</b>
<b class="nc"><i>1760</i>&nbsp;</b>
<b class="nc"><i>1761</i>&nbsp;    /**</b>
<b class="nc"><i>1762</i>&nbsp;     * Normalize whitespace in an XMLString according to the rules defined</b>
<i>1763</i>&nbsp;     * in XML Schema specifications.
<i>1764</i>&nbsp;     * @param value    The string to normalize.
<i>1765</i>&nbsp;     * @param collapse replace or collapse
<b class="nc"><i>1766</i>&nbsp;     */</b>
<b class="nc"><i>1767</i>&nbsp;    private void normalizeWhitespace(XMLString value, boolean collapse) {</b>
<i>1768</i>&nbsp;        boolean skipSpace = collapse;
<i>1769</i>&nbsp;        boolean sawNonWS = false;
<i>1770</i>&nbsp;        boolean leading = false;
<i>1771</i>&nbsp;        boolean trailing = false;
<i>1772</i>&nbsp;        char c;
<i>1773</i>&nbsp;        int size = value.offset + value.length;
<i>1774</i>&nbsp;
<i>1775</i>&nbsp;        // ensure the ch array is big enough
<i>1776</i>&nbsp;        if (fNormalizedStr.ch == null || fNormalizedStr.ch.length &lt; value.length + 1) {
<i>1777</i>&nbsp;            fNormalizedStr.ch = new char[value.length + 1];
<i>1778</i>&nbsp;        }
<b class="nc"><i>1779</i>&nbsp;        // don&#39;t include the leading &#39; &#39; for now. might include it later.</b>
<b class="nc"><i>1780</i>&nbsp;        fNormalizedStr.offset = 1;</b>
<b class="nc"><i>1781</i>&nbsp;        fNormalizedStr.length = 1;</b>
<i>1782</i>&nbsp;
<b class="nc"><i>1783</i>&nbsp;        for (int i = value.offset; i &lt; size; i++) {</b>
<b class="nc"><i>1784</i>&nbsp;            c = value.ch[i];</b>
<i>1785</i>&nbsp;            if (XMLChar.isSpace(c)) {
<i>1786</i>&nbsp;                if (!skipSpace) {
<b class="nc"><i>1787</i>&nbsp;                    // take the first whitespace as a space and skip the others</b>
<b class="nc"><i>1788</i>&nbsp;                    fNormalizedStr.ch[fNormalizedStr.length++] = &#39; &#39;;</b>
<b class="nc"><i>1789</i>&nbsp;                    skipSpace = collapse;</b>
<b class="nc"><i>1790</i>&nbsp;                }</b>
<i>1791</i>&nbsp;                if (!sawNonWS) {
<i>1792</i>&nbsp;                    // this is a leading whitespace, record it
<b class="nc"><i>1793</i>&nbsp;                    leading = true;</b>
<b class="nc"><i>1794</i>&nbsp;                }</b>
<i>1795</i>&nbsp;            } else {
<i>1796</i>&nbsp;                fNormalizedStr.ch[fNormalizedStr.length++] = c;
<i>1797</i>&nbsp;                skipSpace = false;
<i>1798</i>&nbsp;                sawNonWS = true;
<i>1799</i>&nbsp;            }
<b class="nc"><i>1800</i>&nbsp;        }</b>
<b class="nc"><i>1801</i>&nbsp;        if (skipSpace) {</b>
<b class="nc"><i>1802</i>&nbsp;            if (fNormalizedStr.length &gt; 1) {</b>
<b class="nc"><i>1803</i>&nbsp;                // if we finished on a space trim it but also record it</b>
<b class="nc"><i>1804</i>&nbsp;                fNormalizedStr.length--;</b>
<b class="nc"><i>1805</i>&nbsp;                trailing = true;</b>
<b class="nc"><i>1806</i>&nbsp;            } else if (leading &amp;&amp; !fFirstChunk) {</b>
<b class="nc"><i>1807</i>&nbsp;                // if all we had was whitespace we skipped record it as</b>
<b class="nc"><i>1808</i>&nbsp;                // trailing whitespace as well</b>
<b class="nc"><i>1809</i>&nbsp;                trailing = true;</b>
<b class="nc"><i>1810</i>&nbsp;            }</b>
<b class="nc"><i>1811</i>&nbsp;        }</b>
<b class="nc"><i>1812</i>&nbsp;</b>
<i>1813</i>&nbsp;        if (fNormalizedStr.length &gt; 1) {
<i>1814</i>&nbsp;            if (!fFirstChunk &amp;&amp; (fWhiteSpace == XSSimpleType.WS_COLLAPSE)) {
<i>1815</i>&nbsp;                if (fTrailing) {
<i>1816</i>&nbsp;                    // previous chunk ended on whitespace
<b class="nc"><i>1817</i>&nbsp;                    // insert whitespace</b>
<b class="nc"><i>1818</i>&nbsp;                    fNormalizedStr.offset = 0;</b>
<b class="nc"><i>1819</i>&nbsp;                    fNormalizedStr.ch[0] = &#39; &#39;;</b>
<b class="nc"><i>1820</i>&nbsp;                } else if (leading) {</b>
<b class="nc"><i>1821</i>&nbsp;                    // previous chunk ended on character,</b>
<b class="nc"><i>1822</i>&nbsp;                    // this chunk starts with whitespace</b>
<b class="nc"><i>1823</i>&nbsp;                    fNormalizedStr.offset = 0;</b>
<i>1824</i>&nbsp;                    fNormalizedStr.ch[0] = &#39; &#39;;
<i>1825</i>&nbsp;                }
<b class="nc"><i>1826</i>&nbsp;            }</b>
<b class="nc"><i>1827</i>&nbsp;        }</b>
<b class="nc"><i>1828</i>&nbsp;</b>
<i>1829</i>&nbsp;        // The length includes the leading &#39; &#39;. Now removing it.
<i>1830</i>&nbsp;        fNormalizedStr.length -= fNormalizedStr.offset;
<i>1831</i>&nbsp;
<b class="nc"><i>1832</i>&nbsp;        fTrailing = trailing;</b>
<b class="nc"><i>1833</i>&nbsp;</b>
<b class="nc"><i>1834</i>&nbsp;        if (trailing || sawNonWS)</b>
<i>1835</i>&nbsp;            fFirstChunk = false;
<b class="nc"><i>1836</i>&nbsp;    }</b>
<i>1837</i>&nbsp;
<i>1838</i>&nbsp;    private void normalizeWhitespace(String value, boolean collapse) {
<i>1839</i>&nbsp;        boolean skipSpace = collapse;
<i>1840</i>&nbsp;        char c;
<b class="nc"><i>1841</i>&nbsp;        int size = value.length();</b>
<b class="nc"><i>1842</i>&nbsp;</b>
<b class="nc"><i>1843</i>&nbsp;        // ensure the ch array is big enough</b>
<b class="nc"><i>1844</i>&nbsp;        if (fNormalizedStr.ch == null || fNormalizedStr.ch.length &lt; size) {</b>
<b class="nc"><i>1845</i>&nbsp;            fNormalizedStr.ch = new char[size];</b>
<i>1846</i>&nbsp;        }
<i>1847</i>&nbsp;        fNormalizedStr.offset = 0;
<i>1848</i>&nbsp;        fNormalizedStr.length = 0;
<i>1849</i>&nbsp;
<i>1850</i>&nbsp;        for (int i = 0; i &lt; size; i++) {
<b class="nc"><i>1851</i>&nbsp;            c = value.charAt(i);</b>
<b class="nc"><i>1852</i>&nbsp;            if (XMLChar.isSpace(c)) {</b>
<b class="nc"><i>1853</i>&nbsp;                if (!skipSpace) {</b>
<i>1854</i>&nbsp;                    // take the first whitespace as a space and skip the others
<i>1855</i>&nbsp;                    fNormalizedStr.ch[fNormalizedStr.length++] = &#39; &#39;;
<i>1856</i>&nbsp;                    skipSpace = collapse;
<b class="nc"><i>1857</i>&nbsp;                }</b>
<i>1858</i>&nbsp;            } else {
<b class="nc"><i>1859</i>&nbsp;                fNormalizedStr.ch[fNormalizedStr.length++] = c;</b>
<i>1860</i>&nbsp;                skipSpace = false;
<i>1861</i>&nbsp;            }
<i>1862</i>&nbsp;        }
<b class="nc"><i>1863</i>&nbsp;        if (skipSpace) {</b>
<i>1864</i>&nbsp;            if (fNormalizedStr.length != 0)
<i>1865</i>&nbsp;                // if we finished on a space trim it but also record it
<b class="nc"><i>1866</i>&nbsp;                fNormalizedStr.length--;</b>
<i>1867</i>&nbsp;        }
<i>1868</i>&nbsp;    }
<i>1869</i>&nbsp;
<b class="nc"><i>1870</i>&nbsp;    // handle ignorable whitespace</b>
<i>1871</i>&nbsp;    void handleIgnorableWhitespace(XMLString text) {
<i>1872</i>&nbsp;
<b class="nc"><i>1873</i>&nbsp;        if (fSkipValidationDepth &gt;= 0)</b>
<i>1874</i>&nbsp;            return;
<i>1875</i>&nbsp;
<i>1876</i>&nbsp;        // REVISIT: the same process needs to be performed as handleCharacters.
<i>1877</i>&nbsp;        // only it&#39;s simpler here: we know all characters are whitespaces.
<i>1878</i>&nbsp;
<i>1879</i>&nbsp;    } // handleIgnorableWhitespace(XMLString)
<b class="nc"><i>1880</i>&nbsp;</b>
<b class="nc"><i>1881</i>&nbsp;    /** Handle element. */</b>
<b class="nc"><i>1882</i>&nbsp;    Augmentations handleStartElement(QName element, XMLAttributes attributes, Augmentations augs) {</b>
<b class="nc"><i>1883</i>&nbsp;</b>
<i>1884</i>&nbsp;        if (DEBUG) {
<b class="nc"><i>1885</i>&nbsp;            System.out.println(&quot;==&gt;handleStartElement: &quot; + element);</b>
<b class="nc"><i>1886</i>&nbsp;        }</b>
<i>1887</i>&nbsp;
<i>1888</i>&nbsp;        // root element
<b class="nc"><i>1889</i>&nbsp;        if (fElementDepth == -1 &amp;&amp; fValidationManager.isGrammarFound()) {</b>
<b class="nc"><i>1890</i>&nbsp;            if (fSchemaType == null) {</b>
<b class="nc"><i>1891</i>&nbsp;                // schemaType is not specified</b>
<b class="nc"><i>1892</i>&nbsp;                // if a DTD grammar is found, we do the same thing as Dynamic:</b>
<i>1893</i>&nbsp;                // if a schema grammar is found, validation is performed;
<i>1894</i>&nbsp;                // otherwise, skip the whole document.
<i>1895</i>&nbsp;                fSchemaDynamicValidation = true;
<i>1896</i>&nbsp;            } else {
<i>1897</i>&nbsp;                // [1] Either schemaType is DTD, and in this case validate/schema is turned off
<i>1898</i>&nbsp;                // [2] Validating against XML Schemas only
<i>1899</i>&nbsp;                //   [a] dynamic validation is false: report error if SchemaGrammar is not found
<b class="nc"><i>1900</i>&nbsp;                //   [b] dynamic validation is true: if grammar is not found ignore.</b>
<i>1901</i>&nbsp;            }
<i>1902</i>&nbsp;
<i>1903</i>&nbsp;        }
<i>1904</i>&nbsp;
<i>1905</i>&nbsp;        // get xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes,
<i>1906</i>&nbsp;        // parse them to get the grammars. But only do this if the grammar can grow.
<i>1907</i>&nbsp;        if (!fUseGrammarPoolOnly) {
<i>1908</i>&nbsp;            String sLocation =
<b class="nc"><i>1909</i>&nbsp;                attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_SCHEMALOCATION);</b>
<i>1910</i>&nbsp;            String nsLocation =
<b class="nc"><i>1911</i>&nbsp;                attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION);</b>
<i>1912</i>&nbsp;            //store the location hints..  we need to do it so that we can defer the loading of grammar until
<i>1913</i>&nbsp;            //there is a reference to a component from that namespace. To provide location hints to the
<i>1914</i>&nbsp;            //application for a namespace
<i>1915</i>&nbsp;            storeLocations(sLocation, nsLocation);
<b class="nc"><i>1916</i>&nbsp;        }</b>
<b class="nc"><i>1917</i>&nbsp;</b>
<b class="nc"><i>1918</i>&nbsp;        // if we are in the content of &quot;skip&quot;, then just skip this element</b>
<i>1919</i>&nbsp;        // REVISIT:  is this the correct behaviour for ID constraints?  -NG
<b class="nc"><i>1920</i>&nbsp;        if (fSkipValidationDepth &gt;= 0) {</b>
<i>1921</i>&nbsp;            fElementDepth++;
<i>1922</i>&nbsp;            if (fAugPSVI)
<i>1923</i>&nbsp;                augs = getEmptyAugs(augs);
<i>1924</i>&nbsp;            return augs;
<b class="nc"><i>1925</i>&nbsp;        }</b>
<i>1926</i>&nbsp;
<i>1927</i>&nbsp;        // if we are not skipping this element, and there is a content model,
<i>1928</i>&nbsp;        // we try to find the corresponding decl object for this element.
<i>1929</i>&nbsp;        // the reason we move this part of code here is to make sure the
<b class="nc"><i>1930</i>&nbsp;        // error reported here (if any) is stored within the parent element&#39;s</b>
<i>1931</i>&nbsp;        // context, instead of that of the current element.
<i>1932</i>&nbsp;        Object decl = null;
<b class="nc"><i>1933</i>&nbsp;        if (fCurrentCM != null) {</b>
<b class="nc"><i>1934</i>&nbsp;            decl = fCurrentCM.oneTransition(element, fCurrCMState, fSubGroupHandler);</b>
<b class="nc"><i>1935</i>&nbsp;            // it could be an element decl or a wildcard decl</b>
<i>1936</i>&nbsp;            if (fCurrCMState[0] == XSCMValidator.FIRST_ERROR) {
<b class="nc"><i>1937</i>&nbsp;                XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;</b>
<b class="nc"><i>1938</i>&nbsp;                //REVISIT: is it the only case we will have particle = null?</b>
<b class="nc"><i>1939</i>&nbsp;                List&lt;Object&gt; next;</b>
<i>1940</i>&nbsp;                if (ctype.fParticle != null
<b class="nc"><i>1941</i>&nbsp;                    &amp;&amp; (next = fCurrentCM.whatCanGoHere(fCurrCMState)).size() &gt; 0) {</b>
<i>1942</i>&nbsp;                    String expected = expectedStr(next);
<i>1943</i>&nbsp;                    final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);
<i>1944</i>&nbsp;                    String elemExpandedQname = (element.uri != null) ? &quot;{&quot;+&#39;&quot;&#39;+element.uri+&#39;&quot;&#39;+&quot;:&quot;+element.localpart+&quot;}&quot; : element.localpart;
<b class="nc"><i>1945</i>&nbsp;                    if (occurenceInfo != null) {</b>
<i>1946</i>&nbsp;                        final int minOccurs = occurenceInfo[0];
<b class="nc"><i>1947</i>&nbsp;                        final int maxOccurs = occurenceInfo[1];</b>
<b class="nc"><i>1948</i>&nbsp;                        final int count = occurenceInfo[2];</b>
<b class="nc"><i>1949</i>&nbsp;                        // Check if this is a violation of minOccurs</b>
<i>1950</i>&nbsp;                        if (count &lt; minOccurs) {
<i>1951</i>&nbsp;                            final int required = minOccurs - count;
<b class="nc"><i>1952</i>&nbsp;                            if (required &gt; 1) {</b>
<b class="nc"><i>1953</i>&nbsp;                                reportSchemaError(&quot;cvc-complex-type.2.4.h&quot;, new Object[] { element.rawname,</b>
<i>1954</i>&nbsp;                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs), Integer.toString(required) });
<i>1955</i>&nbsp;                            }
<b class="nc"><i>1956</i>&nbsp;                            else {</b>
<b class="nc"><i>1957</i>&nbsp;                                reportSchemaError(&quot;cvc-complex-type.2.4.g&quot;, new Object[] { element.rawname,</b>
<i>1958</i>&nbsp;                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs) });
<i>1959</i>&nbsp;                            }
<i>1960</i>&nbsp;                        }
<i>1961</i>&nbsp;                        // Check if this is a violation of maxOccurs
<i>1962</i>&nbsp;                        else if (count &gt;= maxOccurs &amp;&amp; maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {
<b class="nc"><i>1963</i>&nbsp;                            reportSchemaError(&quot;cvc-complex-type.2.4.e&quot;, new Object[] { element.rawname,</b>
<b class="nc"><i>1964</i>&nbsp;                                    expected, Integer.toString(maxOccurs) });</b>
<i>1965</i>&nbsp;                        }
<i>1966</i>&nbsp;                        else {
<b class="nc"><i>1967</i>&nbsp;                            reportSchemaError(&quot;cvc-complex-type.2.4.a&quot;, new Object[] { elemExpandedQname, expected });</b>
<b class="nc"><i>1968</i>&nbsp;                        }</b>
<i>1969</i>&nbsp;                    }
<i>1970</i>&nbsp;                    else {
<i>1971</i>&nbsp;                        reportSchemaError(&quot;cvc-complex-type.2.4.a&quot;, new Object[] { elemExpandedQname, expected });
<b class="nc"><i>1972</i>&nbsp;                    }</b>
<i>1973</i>&nbsp;                }
<b class="nc"><i>1974</i>&nbsp;                else {</b>
<b class="nc"><i>1975</i>&nbsp;                    final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);</b>
<b class="nc"><i>1976</i>&nbsp;                    if (occurenceInfo != null) {</b>
<b class="nc"><i>1977</i>&nbsp;                        final int maxOccurs = occurenceInfo[1];</b>
<i>1978</i>&nbsp;                        final int count = occurenceInfo[2];
<i>1979</i>&nbsp;                        // Check if this is a violation of maxOccurs
<i>1980</i>&nbsp;                        if (count &gt;= maxOccurs &amp;&amp; maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {
<i>1981</i>&nbsp;                            reportSchemaError(&quot;cvc-complex-type.2.4.f&quot;, new Object[] { fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(maxOccurs) });
<b class="nc"><i>1982</i>&nbsp;                        }</b>
<b class="nc"><i>1983</i>&nbsp;                        else {</b>
<b class="nc"><i>1984</i>&nbsp;                            reportSchemaError(&quot;cvc-complex-type.2.4.d&quot;, new Object[] { element.rawname });</b>
<b class="nc"><i>1985</i>&nbsp;                        }</b>
<i>1986</i>&nbsp;                    }
<b class="nc"><i>1987</i>&nbsp;                    else {</b>
<i>1988</i>&nbsp;                        reportSchemaError(&quot;cvc-complex-type.2.4.d&quot;, new Object[] { element.rawname });
<i>1989</i>&nbsp;                    }
<b class="nc"><i>1990</i>&nbsp;                }</b>
<b class="nc"><i>1991</i>&nbsp;            }</b>
<b class="nc"><i>1992</i>&nbsp;        }</b>
<i>1993</i>&nbsp;
<i>1994</i>&nbsp;        // if it&#39;s not the root element, we push the current states in the stacks
<b class="nc"><i>1995</i>&nbsp;        if (fElementDepth != -1) {</b>
<b class="nc"><i>1996</i>&nbsp;            ensureStackCapacity();</b>
<i>1997</i>&nbsp;            fSubElementStack[fElementDepth] = true;
<b class="nc"><i>1998</i>&nbsp;            fSubElement = false;</b>
<i>1999</i>&nbsp;            fElemDeclStack[fElementDepth] = fCurrentElemDecl;
<i>2000</i>&nbsp;            fNilStack[fElementDepth] = fNil;
<i>2001</i>&nbsp;            fNotationStack[fElementDepth] = fNotation;
<b class="nc"><i>2002</i>&nbsp;            fTypeStack[fElementDepth] = fCurrentType;</b>
<i>2003</i>&nbsp;            fStrictAssessStack[fElementDepth] = fStrictAssess;
<b class="nc"><i>2004</i>&nbsp;            fCMStack[fElementDepth] = fCurrentCM;</b>
<i>2005</i>&nbsp;            fCMStateStack[fElementDepth] = fCurrCMState;
<b class="nc"><i>2006</i>&nbsp;            fSawTextStack[fElementDepth] = fSawText;</b>
<b class="nc"><i>2007</i>&nbsp;            fStringContent[fElementDepth] = fSawCharacters;</b>
<b class="nc"><i>2008</i>&nbsp;        }</b>
<i>2009</i>&nbsp;
<i>2010</i>&nbsp;        // increase the element depth after we&#39;ve saved
<b class="nc"><i>2011</i>&nbsp;        // all states for the parent element</b>
<b class="nc"><i>2012</i>&nbsp;        fElementDepth++;</b>
<i>2013</i>&nbsp;        fCurrentElemDecl = null;
<b class="nc"><i>2014</i>&nbsp;        XSWildcardDecl wildcard = null;</b>
<i>2015</i>&nbsp;        fCurrentType = null;
<i>2016</i>&nbsp;        fStrictAssess = true;
<i>2017</i>&nbsp;        fNil = false;
<i>2018</i>&nbsp;        fNotation = null;
<b class="nc"><i>2019</i>&nbsp;</b>
<b class="nc"><i>2020</i>&nbsp;        // and the buffer to hold the value of the element</b>
<b class="nc"><i>2021</i>&nbsp;        fBuffer.setLength(0);</b>
<i>2022</i>&nbsp;        fSawText = false;
<i>2023</i>&nbsp;        fSawCharacters = false;
<i>2024</i>&nbsp;
<b class="nc"><i>2025</i>&nbsp;        // check what kind of declaration the &quot;decl&quot; from</b>
<b class="nc"><i>2026</i>&nbsp;        // oneTransition() maps to</b>
<b class="nc"><i>2027</i>&nbsp;        if (decl != null) {</b>
<i>2028</i>&nbsp;            if (decl instanceof XSElementDecl) {
<i>2029</i>&nbsp;                fCurrentElemDecl = (XSElementDecl) decl;
<b class="nc"><i>2030</i>&nbsp;            } else {</b>
<i>2031</i>&nbsp;                wildcard = (XSWildcardDecl) decl;
<b class="nc"><i>2032</i>&nbsp;            }</b>
<b class="nc"><i>2033</i>&nbsp;        }</b>
<i>2034</i>&nbsp;
<i>2035</i>&nbsp;        // if the wildcard is skip, then return
<i>2036</i>&nbsp;        if (wildcard != null &amp;&amp; wildcard.fProcessContents == XSWildcardDecl.PC_SKIP) {
<b class="nc"><i>2037</i>&nbsp;            fSkipValidationDepth = fElementDepth;</b>
<b class="nc"><i>2038</i>&nbsp;            if (fAugPSVI)</b>
<b class="nc"><i>2039</i>&nbsp;                augs = getEmptyAugs(augs);</b>
<b class="nc"><i>2040</i>&nbsp;            return augs;</b>
<i>2041</i>&nbsp;        }
<i>2042</i>&nbsp;
<b class="nc"><i>2043</i>&nbsp;        if (fElementDepth == 0) {</b>
<b class="nc"><i>2044</i>&nbsp;            // 1.1.1.1 An element declaration was stipulated by the processor</b>
<b class="nc"><i>2045</i>&nbsp;            if (fRootElementDeclaration != null) {</b>
<b class="nc"><i>2046</i>&nbsp;                fCurrentElemDecl = fRootElementDeclaration;</b>
<i>2047</i>&nbsp;                checkElementMatchesRootElementDecl(fCurrentElemDecl, element);
<b class="nc"><i>2048</i>&nbsp;            }</b>
<i>2049</i>&nbsp;            else if (fRootElementDeclQName != null) {
<b class="nc"><i>2050</i>&nbsp;                processRootElementDeclQName(fRootElementDeclQName, element);</b>
<i>2051</i>&nbsp;            }
<i>2052</i>&nbsp;            // 1.2.1.1 A type definition was stipulated by the processor
<b class="nc"><i>2053</i>&nbsp;            else if (fRootTypeDefinition != null) {</b>
<b class="nc"><i>2054</i>&nbsp;                fCurrentType = fRootTypeDefinition;</b>
<i>2055</i>&nbsp;            }
<i>2056</i>&nbsp;            else if (fRootTypeQName != null) {
<i>2057</i>&nbsp;                processRootTypeQName(fRootTypeQName);
<b class="nc"><i>2058</i>&nbsp;            }</b>
<b class="nc"><i>2059</i>&nbsp;        }</b>
<b class="nc"><i>2060</i>&nbsp;</b>
<b class="nc"><i>2061</i>&nbsp;        // if there was no processor stipulated type</b>
<i>2062</i>&nbsp;        if (fCurrentType == null) {
<i>2063</i>&nbsp;            // try again to get the element decl:
<b class="nc"><i>2064</i>&nbsp;            // case 1: find declaration for root element</b>
<b class="nc"><i>2065</i>&nbsp;            // case 2: find declaration for element from another namespace</b>
<i>2066</i>&nbsp;            if (fCurrentElemDecl == null) {
<i>2067</i>&nbsp;                // try to find schema grammar by different means..
<b class="nc"><i>2068</i>&nbsp;                SchemaGrammar sGrammar =</b>
<i>2069</i>&nbsp;                    findSchemaGrammar(
<b class="nc"><i>2070</i>&nbsp;                        XSDDescription.CONTEXT_ELEMENT,</b>
<i>2071</i>&nbsp;                        element.uri,
<b class="nc"><i>2072</i>&nbsp;                        null,</b>
<i>2073</i>&nbsp;                        element,
<b class="nc"><i>2074</i>&nbsp;                        attributes);</b>
<i>2075</i>&nbsp;                if (sGrammar != null) {
<i>2076</i>&nbsp;                    fCurrentElemDecl = sGrammar.getGlobalElementDecl(element.localpart);
<b class="nc"><i>2077</i>&nbsp;                }</b>
<i>2078</i>&nbsp;            }
<i>2079</i>&nbsp;
<i>2080</i>&nbsp;            if (fCurrentElemDecl != null) {
<i>2081</i>&nbsp;                // then get the type
<i>2082</i>&nbsp;                fCurrentType = fCurrentElemDecl.fType;
<i>2083</i>&nbsp;            }
<i>2084</i>&nbsp;        }
<i>2085</i>&nbsp;
<i>2086</i>&nbsp;        // check if we should be ignoring xsi:type on this element
<i>2087</i>&nbsp;        if (fElementDepth == fIgnoreXSITypeDepth &amp;&amp; fCurrentElemDecl == null) {
<i>2088</i>&nbsp;            fIgnoreXSITypeDepth++;
<i>2089</i>&nbsp;        }
<i>2090</i>&nbsp;
<i>2091</i>&nbsp;        // process xsi:type attribute information
<b class="nc"><i>2092</i>&nbsp;        String xsiType = null;</b>
<i>2093</i>&nbsp;        if (fElementDepth &gt;= fIgnoreXSITypeDepth) {
<i>2094</i>&nbsp;            xsiType = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_TYPE);
<b class="nc"><i>2095</i>&nbsp;        }</b>
<i>2096</i>&nbsp;
<b class="nc"><i>2097</i>&nbsp;        // if no decl/type found for the current element</b>
<b class="nc"><i>2098</i>&nbsp;        if (fCurrentType == null &amp;&amp; xsiType == null) {</b>
<b class="nc"><i>2099</i>&nbsp;            // if this is the validation root, report an error, because</b>
<b class="nc"><i>2100</i>&nbsp;            // we can&#39;t find eith decl or type for this element</b>
<b class="nc"><i>2101</i>&nbsp;            // REVISIT: should we report error, or warning?</b>
<b class="nc"><i>2102</i>&nbsp;            if (fElementDepth == 0) {</b>
<b class="nc"><i>2103</i>&nbsp;                // for dynamic validation, skip the whole content,</b>
<b class="nc"><i>2104</i>&nbsp;                // because no grammar was found.</b>
<b class="nc"><i>2105</i>&nbsp;                if (fDynamicValidation || fSchemaDynamicValidation) {</b>
<b class="nc"><i>2106</i>&nbsp;                    // no schema grammar was found, but it&#39;s either dynamic</b>
<b class="nc"><i>2107</i>&nbsp;                    // validation, or another kind of grammar was found (DTD,</b>
<b class="nc"><i>2108</i>&nbsp;                    // for example). The intended behavior here is to skip</b>
<b class="nc"><i>2109</i>&nbsp;                    // the whole document. To improve performance, we try to</b>
<i>2110</i>&nbsp;                    // remove the validator from the pipeline, since it&#39;s not
<i>2111</i>&nbsp;                    // supposed to do anything.
<b class="nc"><i>2112</i>&nbsp;                    if (fDocumentSource != null) {</b>
<i>2113</i>&nbsp;                        fDocumentSource.setDocumentHandler(fDocumentHandler);
<i>2114</i>&nbsp;                        if (fDocumentHandler != null)
<i>2115</i>&nbsp;                            fDocumentHandler.setDocumentSource(fDocumentSource);
<i>2116</i>&nbsp;                        // indicate that the validator was removed.
<i>2117</i>&nbsp;                        fElementDepth = -2;
<i>2118</i>&nbsp;                        return augs;
<i>2119</i>&nbsp;                    }
<b class="nc"><i>2120</i>&nbsp;</b>
<b class="nc"><i>2121</i>&nbsp;                    fSkipValidationDepth = fElementDepth;</b>
<i>2122</i>&nbsp;                    if (fAugPSVI)
<i>2123</i>&nbsp;                        augs = getEmptyAugs(augs);
<i>2124</i>&nbsp;                    return augs;
<i>2125</i>&nbsp;                }
<i>2126</i>&nbsp;                // We don&#39;t call reportSchemaError here, because the spec
<i>2127</i>&nbsp;                // doesn&#39;t think it&#39;s invalid not to be able to find a
<b class="nc"><i>2128</i>&nbsp;                // declaration or type definition for an element. Xerces is</b>
<b class="nc"><i>2129</i>&nbsp;                // reporting it as an error for historical reasons, but in</b>
<b class="nc"><i>2130</i>&nbsp;                // PSVI, we shouldn&#39;t mark this element as invalid because</b>
<i>2131</i>&nbsp;                // of this. - SG
<i>2132</i>&nbsp;                fXSIErrorReporter.fErrorReporter.reportError(
<i>2133</i>&nbsp;                    XSMessageFormatter.SCHEMA_DOMAIN,
<b class="nc"><i>2134</i>&nbsp;                    &quot;cvc-elt.1.a&quot;,</b>
<i>2135</i>&nbsp;                    new Object[] { element.rawname },
<i>2136</i>&nbsp;                    XMLErrorReporter.SEVERITY_ERROR);
<i>2137</i>&nbsp;            }
<i>2138</i>&nbsp;            // if wildcard = strict, report error.
<i>2139</i>&nbsp;            // needs to be called before fXSIErrorReporter.pushContext()
<b class="nc"><i>2140</i>&nbsp;            // so that the error belongs to the parent element.</b>
<b class="nc"><i>2141</i>&nbsp;            else if (wildcard != null &amp;&amp; wildcard.fProcessContents == XSWildcardDecl.PC_STRICT) {</b>
<b class="nc"><i>2142</i>&nbsp;                // report error, because wilcard = strict</b>
<b class="nc"><i>2143</i>&nbsp;                reportSchemaError(&quot;cvc-complex-type.2.4.c&quot;, new Object[] { element.rawname });</b>
<b class="nc"><i>2144</i>&nbsp;            }</b>
<i>2145</i>&nbsp;            // no element decl or type found for this element.
<i>2146</i>&nbsp;            // Allowed by the spec, we can choose to either laxly assess this
<b class="nc"><i>2147</i>&nbsp;            // element, or to skip it. Now we choose lax assessment.</b>
<i>2148</i>&nbsp;            fCurrentType = SchemaGrammar.fAnyType;
<i>2149</i>&nbsp;            fStrictAssess = false;
<b class="nc"><i>2150</i>&nbsp;            fNFullValidationDepth = fElementDepth;</b>
<i>2151</i>&nbsp;            // any type has mixed content, so we don&#39;t need to append buffer
<i>2152</i>&nbsp;            fAppendBuffer = false;
<i>2153</i>&nbsp;
<i>2154</i>&nbsp;            // push error reporter context: record the current position
<i>2155</i>&nbsp;            // This has to happen after we process skip contents,
<i>2156</i>&nbsp;            // otherwise push and pop won&#39;t be correctly paired.
<i>2157</i>&nbsp;            fXSIErrorReporter.pushContext();
<i>2158</i>&nbsp;        } else {
<i>2159</i>&nbsp;            // push error reporter context: record the current position
<i>2160</i>&nbsp;            // This has to happen after we process skip contents,
<i>2161</i>&nbsp;            // otherwise push and pop won&#39;t be correctly paired.
<b class="nc"><i>2162</i>&nbsp;            fXSIErrorReporter.pushContext();</b>
<b class="nc"><i>2163</i>&nbsp;</b>
<i>2164</i>&nbsp;            // get xsi:type
<i>2165</i>&nbsp;            if (xsiType != null) {
<b class="nc"><i>2166</i>&nbsp;                XSTypeDefinition oldType = fCurrentType;</b>
<i>2167</i>&nbsp;                fCurrentType = getAndCheckXsiType(element, xsiType, attributes);
<b class="nc"><i>2168</i>&nbsp;                // If it fails, use the old type. Use anyType if ther is no old type.</b>
<b class="nc"><i>2169</i>&nbsp;                if (fCurrentType == null) {</b>
<b class="nc"><i>2170</i>&nbsp;                    if (oldType == null)</b>
<b class="nc"><i>2171</i>&nbsp;                        fCurrentType = SchemaGrammar.fAnyType;</b>
<i>2172</i>&nbsp;                    else
<b class="nc"><i>2173</i>&nbsp;                        fCurrentType = oldType;</b>
<b class="nc"><i>2174</i>&nbsp;                }</b>
<b class="nc"><i>2175</i>&nbsp;            }</b>
<i>2176</i>&nbsp;
<i>2177</i>&nbsp;            fNNoneValidationDepth = fElementDepth;
<i>2178</i>&nbsp;            // if the element has a fixed value constraint, we need to append
<i>2179</i>&nbsp;            if (fCurrentElemDecl != null
<i>2180</i>&nbsp;                &amp;&amp; fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED) {
<b class="nc"><i>2181</i>&nbsp;                fAppendBuffer = true;</b>
<b class="nc"><i>2182</i>&nbsp;            }</b>
<b class="nc"><i>2183</i>&nbsp;            // if the type is simple, we need to append</b>
<b class="nc"><i>2184</i>&nbsp;            else if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {</b>
<i>2185</i>&nbsp;                fAppendBuffer = true;
<b class="nc"><i>2186</i>&nbsp;            } else {</b>
<b class="nc"><i>2187</i>&nbsp;                // if the type is simple content complex type, we need to append</b>
<b class="nc"><i>2188</i>&nbsp;                XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;</b>
<b class="nc"><i>2189</i>&nbsp;                fAppendBuffer = (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE);</b>
<b class="nc"><i>2190</i>&nbsp;            }</b>
<b class="nc"><i>2191</i>&nbsp;        }</b>
<i>2192</i>&nbsp;
<i>2193</i>&nbsp;        // Element Locally Valid (Element)
<i>2194</i>&nbsp;        // 2 Its {abstract} must be false.
<b class="nc"><i>2195</i>&nbsp;        if (fCurrentElemDecl != null &amp;&amp; fCurrentElemDecl.getAbstract())</b>
<i>2196</i>&nbsp;            reportSchemaError(&quot;cvc-elt.2&quot;, new Object[] { element.rawname });
<b class="nc"><i>2197</i>&nbsp;</b>
<i>2198</i>&nbsp;        // make the current element validation root
<b class="nc"><i>2199</i>&nbsp;        if (fElementDepth == 0) {</b>
<i>2200</i>&nbsp;            fValidationRoot = element.rawname;
<b class="nc"><i>2201</i>&nbsp;        }</b>
<b class="nc"><i>2202</i>&nbsp;</b>
<b class="nc"><i>2203</i>&nbsp;        // update normalization flags</b>
<b class="nc"><i>2204</i>&nbsp;        if (fNormalizeData) {</b>
<i>2205</i>&nbsp;            // reset values
<i>2206</i>&nbsp;            fFirstChunk = true;
<b class="nc"><i>2207</i>&nbsp;            fTrailing = false;</b>
<b class="nc"><i>2208</i>&nbsp;            fUnionType = false;</b>
<i>2209</i>&nbsp;            fWhiteSpace = -1;
<i>2210</i>&nbsp;        }
<i>2211</i>&nbsp;
<i>2212</i>&nbsp;        // Element Locally Valid (Type)
<i>2213</i>&nbsp;        // 2 Its {abstract} must be false.
<i>2214</i>&nbsp;        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<b class="nc"><i>2215</i>&nbsp;            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;</b>
<i>2216</i>&nbsp;            if (ctype.getAbstract()) {
<b class="nc"><i>2217</i>&nbsp;                reportSchemaError(&quot;cvc-type.2&quot;, new Object[] { element.rawname });</b>
<i>2218</i>&nbsp;            }
<b class="nc"><i>2219</i>&nbsp;            if (fNormalizeData) {</b>
<b class="nc"><i>2220</i>&nbsp;                // find out if the content type is simple and if variety is union</b>
<i>2221</i>&nbsp;                // to be able to do character normalization
<b class="nc"><i>2222</i>&nbsp;                if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {</b>
<i>2223</i>&nbsp;                    if (ctype.fXSSimpleType.getVariety() == XSSimpleType.VARIETY_UNION) {
<b class="nc"><i>2224</i>&nbsp;                        fUnionType = true;</b>
<b class="nc"><i>2225</i>&nbsp;                    } else {</b>
<b class="nc"><i>2226</i>&nbsp;                        try {</b>
<i>2227</i>&nbsp;                            fWhiteSpace = ctype.fXSSimpleType.getWhitespace();
<i>2228</i>&nbsp;                        } catch (DatatypeException e) {
<b class="nc"><i>2229</i>&nbsp;                            // do nothing</b>
<i>2230</i>&nbsp;                        }
<i>2231</i>&nbsp;                    }
<b class="nc"><i>2232</i>&nbsp;                }</b>
<b class="nc"><i>2233</i>&nbsp;            }</b>
<b class="nc"><i>2234</i>&nbsp;        }</b>
<b class="nc"><i>2235</i>&nbsp;        // normalization: simple type</b>
<b class="nc"><i>2236</i>&nbsp;        else if (fNormalizeData) {</b>
<b class="nc"><i>2237</i>&nbsp;            // if !union type</b>
<b class="nc"><i>2238</i>&nbsp;            XSSimpleType dv = (XSSimpleType) fCurrentType;</b>
<b class="nc"><i>2239</i>&nbsp;            if (dv.getVariety() == XSSimpleType.VARIETY_UNION) {</b>
<b class="nc"><i>2240</i>&nbsp;                fUnionType = true;</b>
<b class="nc"><i>2241</i>&nbsp;            } else {</b>
<i>2242</i>&nbsp;                try {
<i>2243</i>&nbsp;                    fWhiteSpace = dv.getWhitespace();
<i>2244</i>&nbsp;                } catch (DatatypeException e) {
<i>2245</i>&nbsp;                    // do nothing
<i>2246</i>&nbsp;                }
<i>2247</i>&nbsp;            }
<b class="nc"><i>2248</i>&nbsp;        }</b>
<i>2249</i>&nbsp;
<i>2250</i>&nbsp;        // then try to get the content model
<b class="nc"><i>2251</i>&nbsp;        fCurrentCM = null;</b>
<i>2252</i>&nbsp;        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<b class="nc"><i>2253</i>&nbsp;            fCurrentCM = ((XSComplexTypeDecl) fCurrentType).getContentModel(fCMBuilder);</b>
<i>2254</i>&nbsp;        }
<i>2255</i>&nbsp;
<b class="nc"><i>2256</i>&nbsp;        // and get the initial content model state</b>
<i>2257</i>&nbsp;        fCurrCMState = null;
<i>2258</i>&nbsp;        if (fCurrentCM != null)
<i>2259</i>&nbsp;            fCurrCMState = fCurrentCM.startContentModel();
<i>2260</i>&nbsp;
<i>2261</i>&nbsp;        // get information about xsi:nil
<i>2262</i>&nbsp;        String xsiNil = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NIL);
<i>2263</i>&nbsp;        // only deal with xsi:nil when there is an element declaration
<b class="nc"><i>2264</i>&nbsp;        if (xsiNil != null &amp;&amp; fCurrentElemDecl != null)</b>
<b class="nc"><i>2265</i>&nbsp;            fNil = getXsiNil(element, xsiNil);</b>
<i>2266</i>&nbsp;
<i>2267</i>&nbsp;        // now validate everything related with the attributes
<b class="nc"><i>2268</i>&nbsp;        // first, get the attribute group</b>
<b class="nc"><i>2269</i>&nbsp;        XSAttributeGroupDecl attrGrp = null;</b>
<b class="nc"><i>2270</i>&nbsp;        if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {</b>
<b class="nc"><i>2271</i>&nbsp;            XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;</b>
<i>2272</i>&nbsp;            attrGrp = ctype.getAttrGrp();
<i>2273</i>&nbsp;        }
<i>2274</i>&nbsp;
<i>2275</i>&nbsp;        if (fIDCChecking) {
<b class="nc"><i>2276</i>&nbsp;            // activate identity constraints</b>
<b class="nc"><i>2277</i>&nbsp;            fValueStoreCache.startElement();</b>
<i>2278</i>&nbsp;            fMatcherStack.pushContext();
<i>2279</i>&nbsp;            //if (fCurrentElemDecl != null &amp;&amp; fCurrentElemDecl.fIDCPos &gt; 0 &amp;&amp; !fIgnoreIDC) {
<i>2280</i>&nbsp;            if (fCurrentElemDecl != null &amp;&amp; fCurrentElemDecl.fIDCPos &gt; 0) {
<i>2281</i>&nbsp;                fIdConstraint = true;
<b class="nc"><i>2282</i>&nbsp;                // initialize when identity constrains are defined for the elem</b>
<b class="nc"><i>2283</i>&nbsp;                fValueStoreCache.initValueStoresFor(fCurrentElemDecl, this);</b>
<i>2284</i>&nbsp;            }
<i>2285</i>&nbsp;        }
<i>2286</i>&nbsp;        processAttributes(element, attributes, attrGrp);
<b class="nc"><i>2287</i>&nbsp;</b>
<b class="nc"><i>2288</i>&nbsp;        // add default attributes</b>
<i>2289</i>&nbsp;        if (attrGrp != null) {
<i>2290</i>&nbsp;            addDefaultAttributes(element, attributes, attrGrp);
<b class="nc"><i>2291</i>&nbsp;        }</b>
<b class="nc"><i>2292</i>&nbsp;</b>
<b class="nc"><i>2293</i>&nbsp;        // call all active identity constraints</b>
<b class="nc"><i>2294</i>&nbsp;        int count = fMatcherStack.getMatcherCount();</b>
<b class="nc"><i>2295</i>&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="nc"><i>2296</i>&nbsp;            XPathMatcher matcher = fMatcherStack.getMatcherAt(i);</b>
<b class="nc"><i>2297</i>&nbsp;            matcher.startElement( element, attributes);</b>
<b class="nc"><i>2298</i>&nbsp;        }</b>
<i>2299</i>&nbsp;
<b class="nc"><i>2300</i>&nbsp;        if (fAugPSVI) {</b>
<i>2301</i>&nbsp;            augs = getEmptyAugs(augs);
<i>2302</i>&nbsp;
<i>2303</i>&nbsp;            // PSVI: add validation context
<i>2304</i>&nbsp;            fCurrentPSVI.fValidationContext = fValidationRoot;
<b class="nc"><i>2305</i>&nbsp;            // PSVI: add element declaration</b>
<i>2306</i>&nbsp;            fCurrentPSVI.fDeclaration = fCurrentElemDecl;
<i>2307</i>&nbsp;            // PSVI: add element type
<b class="nc"><i>2308</i>&nbsp;            fCurrentPSVI.fTypeDecl = fCurrentType;</b>
<i>2309</i>&nbsp;            // PSVI: add notation attribute
<b class="nc"><i>2310</i>&nbsp;            fCurrentPSVI.fNotation = fNotation;</b>
<i>2311</i>&nbsp;            // PSVI: add nil
<b class="nc"><i>2312</i>&nbsp;            fCurrentPSVI.fNil = fNil;</b>
<i>2313</i>&nbsp;        }
<b class="nc"><i>2314</i>&nbsp;</b>
<i>2315</i>&nbsp;        return augs;
<i>2316</i>&nbsp;
<i>2317</i>&nbsp;    } // handleStartElement(QName,XMLAttributes,boolean)
<b class="nc"><i>2318</i>&nbsp;</b>
<i>2319</i>&nbsp;    /**
<i>2320</i>&nbsp;     *  Handle end element. If there is not text content, and there is a
<b class="nc"><i>2321</i>&nbsp;     *  {value constraint} on the corresponding element decl, then</b>
<i>2322</i>&nbsp;     * set the fDefaultValue XMLString representing the default value.
<b class="nc"><i>2323</i>&nbsp;     */</b>
<b class="nc"><i>2324</i>&nbsp;    Augmentations handleEndElement(QName element, Augmentations augs) {</b>
<i>2325</i>&nbsp;
<i>2326</i>&nbsp;        if (DEBUG) {
<i>2327</i>&nbsp;            System.out.println(&quot;==&gt;handleEndElement:&quot; + element);
<b class="nc"><i>2328</i>&nbsp;        }</b>
<i>2329</i>&nbsp;        // if we are skipping, return
<i>2330</i>&nbsp;        if (fSkipValidationDepth &gt;= 0) {
<i>2331</i>&nbsp;            // but if this is the top element that we are skipping,
<i>2332</i>&nbsp;            // restore the states.
<b class="nc"><i>2333</i>&nbsp;            if (fSkipValidationDepth == fElementDepth &amp;&amp; fSkipValidationDepth &gt; 0) {</b>
<b class="nc"><i>2334</i>&nbsp;                // set the partial validation depth to the depth of parent</b>
<b class="nc"><i>2335</i>&nbsp;                fNFullValidationDepth = fSkipValidationDepth - 1;</b>
<i>2336</i>&nbsp;                fSkipValidationDepth = -1;
<b class="nc"><i>2337</i>&nbsp;                fElementDepth--;</b>
<b class="nc"><i>2338</i>&nbsp;                fSubElement = fSubElementStack[fElementDepth];</b>
<i>2339</i>&nbsp;                fCurrentElemDecl = fElemDeclStack[fElementDepth];
<b class="nc"><i>2340</i>&nbsp;                fNil = fNilStack[fElementDepth];</b>
<i>2341</i>&nbsp;                fNotation = fNotationStack[fElementDepth];
<i>2342</i>&nbsp;                fCurrentType = fTypeStack[fElementDepth];
<i>2343</i>&nbsp;                fCurrentCM = fCMStack[fElementDepth];
<b class="nc"><i>2344</i>&nbsp;                fStrictAssess = fStrictAssessStack[fElementDepth];</b>
<b class="nc"><i>2345</i>&nbsp;                fCurrCMState = fCMStateStack[fElementDepth];</b>
<i>2346</i>&nbsp;                fSawText = fSawTextStack[fElementDepth];
<b class="nc"><i>2347</i>&nbsp;                fSawCharacters = fStringContent[fElementDepth];</b>
<i>2348</i>&nbsp;            }
<i>2349</i>&nbsp;            else {
<i>2350</i>&nbsp;                fElementDepth--;
<i>2351</i>&nbsp;            }
<i>2352</i>&nbsp;
<i>2353</i>&nbsp;            // PSVI: validation attempted:
<b class="nc"><i>2354</i>&nbsp;            // use default values in psvi item for</b>
<b class="nc"><i>2355</i>&nbsp;            // validation attempted, validity, and error codes</b>
<b class="nc"><i>2356</i>&nbsp;</b>
<b class="nc"><i>2357</i>&nbsp;            // check extra schema constraints on root element</b>
<b class="nc"><i>2358</i>&nbsp;            if (fElementDepth == -1 &amp;&amp; fFullChecking &amp;&amp; !fUseGrammarPoolOnly) {</b>
<i>2359</i>&nbsp;                XSConstraints.fullSchemaChecking(
<b class="nc"><i>2360</i>&nbsp;                    fGrammarBucket,</b>
<i>2361</i>&nbsp;                    fSubGroupHandler,
<i>2362</i>&nbsp;                    fCMBuilder,
<i>2363</i>&nbsp;                    fXSIErrorReporter.fErrorReporter);
<i>2364</i>&nbsp;            }
<i>2365</i>&nbsp;
<i>2366</i>&nbsp;            if (fAugPSVI)
<i>2367</i>&nbsp;                augs = getEmptyAugs(augs);
<i>2368</i>&nbsp;            return augs;
<i>2369</i>&nbsp;        }
<i>2370</i>&nbsp;
<i>2371</i>&nbsp;        // now validate the content of the element
<i>2372</i>&nbsp;        processElementContent(element);
<i>2373</i>&nbsp;
<b class="nc"><i>2374</i>&nbsp;        if (fIDCChecking) {</b>
<i>2375</i>&nbsp;            // Element Locally Valid (Element)
<b class="nc"><i>2376</i>&nbsp;            // 6 The element information item must be valid with respect to each of the {identity-constraint definitions} as per Identity-constraint Satisfied (3.11.4).</b>
<i>2377</i>&nbsp;
<b class="nc"><i>2378</i>&nbsp;            // call matchers and de-activate context</b>
<b class="nc"><i>2379</i>&nbsp;            int oldCount = fMatcherStack.getMatcherCount();</b>
<i>2380</i>&nbsp;            for (int i = oldCount - 1; i &gt;= 0; i--) {
<b class="nc"><i>2381</i>&nbsp;                XPathMatcher matcher = fMatcherStack.getMatcherAt(i);</b>
<b class="nc"><i>2382</i>&nbsp;                if (fCurrentElemDecl == null) {</b>
<b class="nc"><i>2383</i>&nbsp;                    matcher.endElement(element, fCurrentType, false, fValidatedInfo.actualValue, fValidatedInfo.actualValueType, fValidatedInfo.itemValueTypes);</b>
<i>2384</i>&nbsp;                }
<i>2385</i>&nbsp;                else {
<b class="nc"><i>2386</i>&nbsp;                    matcher.endElement(</b>
<i>2387</i>&nbsp;                            element,
<i>2388</i>&nbsp;                            fCurrentType,
<b class="nc"><i>2389</i>&nbsp;                            fCurrentElemDecl.getNillable(),</b>
<i>2390</i>&nbsp;                            fDefaultValue == null
<i>2391</i>&nbsp;                                ? fValidatedInfo.actualValue
<i>2392</i>&nbsp;                                : fCurrentElemDecl.fDefault.actualValue,
<i>2393</i>&nbsp;                            fDefaultValue == null
<b class="nc"><i>2394</i>&nbsp;                                ? fValidatedInfo.actualValueType</b>
<i>2395</i>&nbsp;                                : fCurrentElemDecl.fDefault.actualValueType,
<i>2396</i>&nbsp;                            fDefaultValue == null
<i>2397</i>&nbsp;                                ? fValidatedInfo.itemValueTypes
<i>2398</i>&nbsp;                                : fCurrentElemDecl.fDefault.itemValueTypes);
<b class="nc"><i>2399</i>&nbsp;                }</b>
<b class="nc"><i>2400</i>&nbsp;            }</b>
<b class="nc"><i>2401</i>&nbsp;</b>
<b class="nc"><i>2402</i>&nbsp;            if (fMatcherStack.size() &gt; 0) {</b>
<b class="nc"><i>2403</i>&nbsp;                fMatcherStack.popContext();</b>
<b class="nc"><i>2404</i>&nbsp;            }</b>
<b class="nc"><i>2405</i>&nbsp;</b>
<b class="nc"><i>2406</i>&nbsp;            int newCount = fMatcherStack.getMatcherCount();</b>
<b class="nc"><i>2407</i>&nbsp;            // handle everything *but* keyref&#39;s.</b>
<i>2408</i>&nbsp;            for (int i = oldCount - 1; i &gt;= newCount; i--) {
<i>2409</i>&nbsp;                XPathMatcher matcher = fMatcherStack.getMatcherAt(i);
<b class="nc"><i>2410</i>&nbsp;                if (matcher instanceof Selector.Matcher) {</b>
<b class="nc"><i>2411</i>&nbsp;                    Selector.Matcher selMatcher = (Selector.Matcher) matcher;</b>
<b class="nc"><i>2412</i>&nbsp;                    IdentityConstraint id;</b>
<b class="nc"><i>2413</i>&nbsp;                    if ((id = selMatcher.getIdentityConstraint()) != null</b>
<b class="nc"><i>2414</i>&nbsp;                            &amp;&amp; id.getCategory() != IdentityConstraint.IC_KEYREF) {</b>
<b class="nc"><i>2415</i>&nbsp;                        fValueStoreCache.transplant(id, selMatcher.getInitialDepth());</b>
<b class="nc"><i>2416</i>&nbsp;                    }</b>
<i>2417</i>&nbsp;                }
<i>2418</i>&nbsp;            }
<i>2419</i>&nbsp;
<b class="nc"><i>2420</i>&nbsp;            // now handle keyref&#39;s/...</b>
<b class="nc"><i>2421</i>&nbsp;            for (int i = oldCount - 1; i &gt;= newCount; i--) {</b>
<b class="nc"><i>2422</i>&nbsp;                XPathMatcher matcher = fMatcherStack.getMatcherAt(i);</b>
<i>2423</i>&nbsp;                if (matcher instanceof Selector.Matcher) {
<b class="nc"><i>2424</i>&nbsp;                    Selector.Matcher selMatcher = (Selector.Matcher) matcher;</b>
<i>2425</i>&nbsp;                    IdentityConstraint id;
<i>2426</i>&nbsp;                    if ((id = selMatcher.getIdentityConstraint()) != null
<i>2427</i>&nbsp;                            &amp;&amp; id.getCategory() == IdentityConstraint.IC_KEYREF) {
<i>2428</i>&nbsp;                        ValueStoreBase values =
<b class="nc"><i>2429</i>&nbsp;                            fValueStoreCache.getValueStoreFor(id, selMatcher.getInitialDepth());</b>
<b class="nc"><i>2430</i>&nbsp;                        // nothing to do if nothing matched, or if not all</b>
<i>2431</i>&nbsp;                        // fields are present.
<i>2432</i>&nbsp;                        if (values != null &amp;&amp; values.fValuesCount == values.fFieldCount)
<i>2433</i>&nbsp;                            values.endDocumentFragment();
<b class="nc"><i>2434</i>&nbsp;                    }</b>
<i>2435</i>&nbsp;                }
<i>2436</i>&nbsp;            }
<i>2437</i>&nbsp;            fValueStoreCache.endElement();
<b class="nc"><i>2438</i>&nbsp;        }</b>
<b class="nc"><i>2439</i>&nbsp;</b>
<i>2440</i>&nbsp;        // Check if we should modify the xsi:type ignore depth
<i>2441</i>&nbsp;        // This check is independent of whether this is the validation root,
<b class="nc"><i>2442</i>&nbsp;        // and should be done before the element depth is decremented.</b>
<b class="nc"><i>2443</i>&nbsp;        if (fElementDepth &lt; fIgnoreXSITypeDepth) {</b>
<i>2444</i>&nbsp;            fIgnoreXSITypeDepth--;
<b class="nc"><i>2445</i>&nbsp;        }</b>
<b class="nc"><i>2446</i>&nbsp;</b>
<i>2447</i>&nbsp;        SchemaGrammar[] grammars = null;
<b class="nc"><i>2448</i>&nbsp;        // have we reached the end tag of the validation root?</b>
<b class="nc"><i>2449</i>&nbsp;        if (fElementDepth == 0) {</b>
<b class="nc"><i>2450</i>&nbsp;            // 7 If the element information item is the validation root, it must be valid per Validation Root Valid (ID/IDREF) (3.3.4).</b>
<i>2451</i>&nbsp;            Iterator&lt;String&gt; invIdRefs = fValidationState.checkIDRefID();
<i>2452</i>&nbsp;            fValidationState.resetIDTables();
<i>2453</i>&nbsp;            if (invIdRefs != null) {
<i>2454</i>&nbsp;                while (invIdRefs.hasNext()) {
<b class="nc"><i>2455</i>&nbsp;                    reportSchemaError(&quot;cvc-id.1&quot;, new Object[] { invIdRefs.next() });</b>
<i>2456</i>&nbsp;                }
<i>2457</i>&nbsp;            }
<i>2458</i>&nbsp;            // check extra schema constraints
<b class="nc"><i>2459</i>&nbsp;            if (fFullChecking &amp;&amp; !fUseGrammarPoolOnly) {</b>
<i>2460</i>&nbsp;                XSConstraints.fullSchemaChecking(
<i>2461</i>&nbsp;                    fGrammarBucket,
<i>2462</i>&nbsp;                    fSubGroupHandler,
<b class="nc"><i>2463</i>&nbsp;                    fCMBuilder,</b>
<b class="nc"><i>2464</i>&nbsp;                    fXSIErrorReporter.fErrorReporter);</b>
<b class="nc"><i>2465</i>&nbsp;            }</b>
<b class="nc"><i>2466</i>&nbsp;</b>
<i>2467</i>&nbsp;            grammars = fGrammarBucket.getGrammars();
<i>2468</i>&nbsp;            // return the final set of grammars validator ended up with
<b class="nc"><i>2469</i>&nbsp;            if (fGrammarPool != null) {</b>
<i>2470</i>&nbsp;                // Set grammars as immutable
<i>2471</i>&nbsp;                for (int k=0; k &lt; grammars.length; k++) {
<i>2472</i>&nbsp;                    grammars[k].setImmutable(true);
<i>2473</i>&nbsp;                }
<b class="nc"><i>2474</i>&nbsp;                fGrammarPool.cacheGrammars(XMLGrammarDescription.XML_SCHEMA, grammars);</b>
<b class="nc"><i>2475</i>&nbsp;            }</b>
<b class="nc"><i>2476</i>&nbsp;            augs = endElementPSVI(true, grammars, augs);</b>
<i>2477</i>&nbsp;        } else {
<b class="nc"><i>2478</i>&nbsp;            augs = endElementPSVI(false, grammars, augs);</b>
<i>2479</i>&nbsp;
<b class="nc"><i>2480</i>&nbsp;            // decrease element depth and restore states</b>
<b class="nc"><i>2481</i>&nbsp;            fElementDepth--;</b>
<b class="nc"><i>2482</i>&nbsp;</b>
<i>2483</i>&nbsp;            // get the states for the parent element.
<i>2484</i>&nbsp;            fSubElement = fSubElementStack[fElementDepth];
<b class="nc"><i>2485</i>&nbsp;            fCurrentElemDecl = fElemDeclStack[fElementDepth];</b>
<b class="nc"><i>2486</i>&nbsp;            fNil = fNilStack[fElementDepth];</b>
<i>2487</i>&nbsp;            fNotation = fNotationStack[fElementDepth];
<i>2488</i>&nbsp;            fCurrentType = fTypeStack[fElementDepth];
<b class="nc"><i>2489</i>&nbsp;            fCurrentCM = fCMStack[fElementDepth];</b>
<b class="nc"><i>2490</i>&nbsp;            fStrictAssess = fStrictAssessStack[fElementDepth];</b>
<b class="nc"><i>2491</i>&nbsp;            fCurrCMState = fCMStateStack[fElementDepth];</b>
<i>2492</i>&nbsp;            fSawText = fSawTextStack[fElementDepth];
<i>2493</i>&nbsp;            fSawCharacters = fStringContent[fElementDepth];
<b class="nc"><i>2494</i>&nbsp;</b>
<b class="nc"><i>2495</i>&nbsp;            // We should have a stack for whitespace value, and pop it up here.</b>
<i>2496</i>&nbsp;            // But when fWhiteSpace != -1, and we see a sub-element, it must be
<i>2497</i>&nbsp;            // an error (at least for Schema 1.0). So for valid documents, the
<i>2498</i>&nbsp;            // only value we are going to push/pop in the stack is -1.
<i>2499</i>&nbsp;            // Here we just mimic the effect of popping -1. -SG
<i>2500</i>&nbsp;            fWhiteSpace = -1;
<i>2501</i>&nbsp;            // Same for append buffer. Simple types and elements with fixed
<i>2502</i>&nbsp;            // value constraint don&#39;t allow sub-elements. -SG
<i>2503</i>&nbsp;            fAppendBuffer = false;
<i>2504</i>&nbsp;            // same here.
<i>2505</i>&nbsp;            fUnionType = false;
<i>2506</i>&nbsp;        }
<i>2507</i>&nbsp;
<b class="nc"><i>2508</i>&nbsp;        return augs;</b>
<i>2509</i>&nbsp;    } // handleEndElement(QName,boolean)*/
<b class="nc"><i>2510</i>&nbsp;</b>
<b class="nc"><i>2511</i>&nbsp;    final Augmentations endElementPSVI(</b>
<b class="nc"><i>2512</i>&nbsp;        boolean root,</b>
<b class="nc"><i>2513</i>&nbsp;        SchemaGrammar[] grammars,</b>
<i>2514</i>&nbsp;        Augmentations augs) {
<i>2515</i>&nbsp;
<i>2516</i>&nbsp;        if (fAugPSVI) {
<i>2517</i>&nbsp;            augs = getEmptyAugs(augs);
<i>2518</i>&nbsp;
<b class="nc"><i>2519</i>&nbsp;            // the 5 properties sent on startElement calls</b>
<b class="nc"><i>2520</i>&nbsp;            fCurrentPSVI.fDeclaration = this.fCurrentElemDecl;</b>
<i>2521</i>&nbsp;            fCurrentPSVI.fTypeDecl = this.fCurrentType;
<i>2522</i>&nbsp;            fCurrentPSVI.fNotation = this.fNotation;
<b class="nc"><i>2523</i>&nbsp;            fCurrentPSVI.fValidationContext = this.fValidationRoot;</b>
<i>2524</i>&nbsp;            fCurrentPSVI.fNil = this.fNil;
<b class="nc"><i>2525</i>&nbsp;            // PSVI: validation attempted</b>
<b class="nc"><i>2526</i>&nbsp;            // nothing below or at the same level has none or partial</b>
<i>2527</i>&nbsp;            // (which means this level is strictly assessed, and all chidren
<i>2528</i>&nbsp;            // are full), so this one has full
<b class="nc"><i>2529</i>&nbsp;            if (fElementDepth &gt; fNFullValidationDepth) {</b>
<i>2530</i>&nbsp;                fCurrentPSVI.fValidationAttempted = ElementPSVI.VALIDATION_FULL;
<b class="nc"><i>2531</i>&nbsp;            }</b>
<b class="nc"><i>2532</i>&nbsp;            // nothing below or at the same level has full or partial</b>
<i>2533</i>&nbsp;            // (which means this level is not strictly assessed, and all chidren
<i>2534</i>&nbsp;            // are none), so this one has none
<i>2535</i>&nbsp;            else if (fElementDepth &gt; fNNoneValidationDepth) {
<i>2536</i>&nbsp;                fCurrentPSVI.fValidationAttempted = ElementPSVI.VALIDATION_NONE;
<i>2537</i>&nbsp;            }
<i>2538</i>&nbsp;            // otherwise partial, and anything above this level will be partial
<b class="nc"><i>2539</i>&nbsp;            else {</b>
<b class="nc"><i>2540</i>&nbsp;                fCurrentPSVI.fValidationAttempted = ElementPSVI.VALIDATION_PARTIAL;</b>
<i>2541</i>&nbsp;            }
<i>2542</i>&nbsp;
<b class="nc"><i>2543</i>&nbsp;            // this guarantees that depth settings do not cross-over between sibling nodes</b>
<b class="nc"><i>2544</i>&nbsp;            if (fNFullValidationDepth == fElementDepth) {</b>
<b class="nc"><i>2545</i>&nbsp;                fNFullValidationDepth = fElementDepth - 1;</b>
<i>2546</i>&nbsp;            }
<i>2547</i>&nbsp;            if (fNNoneValidationDepth == fElementDepth) {
<i>2548</i>&nbsp;                fNNoneValidationDepth = fElementDepth - 1;
<i>2549</i>&nbsp;            }
<b class="nc"><i>2550</i>&nbsp;</b>
<i>2551</i>&nbsp;            if (fDefaultValue != null)
<b class="nc"><i>2552</i>&nbsp;                fCurrentPSVI.fSpecified = true;</b>
<b class="nc"><i>2553</i>&nbsp;            fCurrentPSVI.fValue.copyFrom(fValidatedInfo);</b>
<b class="nc"><i>2554</i>&nbsp;</b>
<b class="nc"><i>2555</i>&nbsp;            if (fStrictAssess) {</b>
<b class="nc"><i>2556</i>&nbsp;                // get all errors for the current element, its attribute,</b>
<i>2557</i>&nbsp;                // and subelements (if they were strictly assessed).
<b class="nc"><i>2558</i>&nbsp;                // any error would make this element invalid.</b>
<i>2559</i>&nbsp;                // and we merge these errors to the parent element.
<i>2560</i>&nbsp;                String[] errors = fXSIErrorReporter.mergeContext();
<b class="nc"><i>2561</i>&nbsp;</b>
<i>2562</i>&nbsp;                // PSVI: error codes
<i>2563</i>&nbsp;                fCurrentPSVI.fErrors = errors;
<i>2564</i>&nbsp;                // PSVI: validity
<i>2565</i>&nbsp;                fCurrentPSVI.fValidity =
<i>2566</i>&nbsp;                    (errors == null) ? ElementPSVI.VALIDITY_VALID : ElementPSVI.VALIDITY_INVALID;
<i>2567</i>&nbsp;            } else {
<b class="nc"><i>2568</i>&nbsp;                // PSVI: validity</b>
<b class="nc"><i>2569</i>&nbsp;                fCurrentPSVI.fValidity = ElementPSVI.VALIDITY_NOTKNOWN;</b>
<i>2570</i>&nbsp;                // Discard the current context: ignore any error happened within
<i>2571</i>&nbsp;                // the sub-elements/attributes of this element, because those
<i>2572</i>&nbsp;                // errors won&#39;t affect the validity of the parent elements.
<i>2573</i>&nbsp;                fXSIErrorReporter.popContext();
<i>2574</i>&nbsp;            }
<i>2575</i>&nbsp;
<i>2576</i>&nbsp;            if (root) {
<i>2577</i>&nbsp;                // store [schema information] in the PSVI
<b class="nc"><i>2578</i>&nbsp;                fCurrentPSVI.fGrammars = grammars;</b>
<b class="nc"><i>2579</i>&nbsp;                fCurrentPSVI.fSchemaInformation = null;</b>
<b class="nc"><i>2580</i>&nbsp;            }</b>
<b class="nc"><i>2581</i>&nbsp;        }</b>
<b class="nc"><i>2582</i>&nbsp;</b>
<b class="nc"><i>2583</i>&nbsp;        return augs;</b>
<i>2584</i>&nbsp;
<i>2585</i>&nbsp;    }
<i>2586</i>&nbsp;
<i>2587</i>&nbsp;    Augmentations getEmptyAugs(Augmentations augs) {
<i>2588</i>&nbsp;        if (augs == null) {
<b class="nc"><i>2589</i>&nbsp;            augs = fAugmentations;</b>
<i>2590</i>&nbsp;            augs.removeAllItems();
<i>2591</i>&nbsp;        }
<b class="nc"><i>2592</i>&nbsp;        augs.putItem(Constants.ELEMENT_PSVI, fCurrentPSVI);</b>
<i>2593</i>&nbsp;        fCurrentPSVI.reset();
<i>2594</i>&nbsp;
<i>2595</i>&nbsp;        return augs;
<i>2596</i>&nbsp;    }
<i>2597</i>&nbsp;
<i>2598</i>&nbsp;    void storeLocations(String sLocation, String nsLocation) {
<i>2599</i>&nbsp;        if (sLocation != null) {
<i>2600</i>&nbsp;            if (!XMLSchemaLoader.tokenizeSchemaLocationStr(sLocation,
<i>2601</i>&nbsp;                    fLocationPairs, fLocator == null ? null : fLocator.getExpandedSystemId())) {
<b class="nc"><i>2602</i>&nbsp;                // error!</b>
<i>2603</i>&nbsp;                fXSIErrorReporter.reportError(
<i>2604</i>&nbsp;                    XSMessageFormatter.SCHEMA_DOMAIN,
<b class="nc"><i>2605</i>&nbsp;                    &quot;SchemaLocation&quot;,</b>
<i>2606</i>&nbsp;                    new Object[] { sLocation },
<b class="nc"><i>2607</i>&nbsp;                    XMLErrorReporter.SEVERITY_WARNING);</b>
<b class="nc"><i>2608</i>&nbsp;            }</b>
<i>2609</i>&nbsp;        }
<b class="nc"><i>2610</i>&nbsp;        if (nsLocation != null) {</b>
<b class="nc"><i>2611</i>&nbsp;            XMLSchemaLoader.LocationArray la = fLocationPairs.get(XMLSymbols.EMPTY_STRING);</b>
<i>2612</i>&nbsp;            if (la == null) {
<b class="nc"><i>2613</i>&nbsp;                la = new XMLSchemaLoader.LocationArray();</b>
<b class="nc"><i>2614</i>&nbsp;                fLocationPairs.put(XMLSymbols.EMPTY_STRING, la);</b>
<b class="nc"><i>2615</i>&nbsp;            }</b>
<b class="nc"><i>2616</i>&nbsp;            if (fLocator != null) {</b>
<b class="nc"><i>2617</i>&nbsp;                try {</b>
<b class="nc"><i>2618</i>&nbsp;                    nsLocation = XMLEntityManager.expandSystemId(nsLocation, fLocator.getExpandedSystemId(), false);</b>
<b class="nc"><i>2619</i>&nbsp;                } catch (MalformedURIException e) {</b>
<i>2620</i>&nbsp;                }
<i>2621</i>&nbsp;            }
<i>2622</i>&nbsp;            la.addLocation(nsLocation);
<i>2623</i>&nbsp;        }
<i>2624</i>&nbsp;
<b class="nc"><i>2625</i>&nbsp;    } //storeLocations</b>
<i>2626</i>&nbsp;
<b class="nc"><i>2627</i>&nbsp;    //this is the function where logic of retrieving grammar is written , parser first tries to get the grammar from</b>
<i>2628</i>&nbsp;    //the local pool, if not in local pool, it gives chance to application to be able to retrieve the grammar, then it
<i>2629</i>&nbsp;    //tries to parse the grammar using location hints from the give namespace.
<i>2630</i>&nbsp;    SchemaGrammar findSchemaGrammar(
<i>2631</i>&nbsp;        short contextType,
<i>2632</i>&nbsp;        String namespace,
<b class="nc"><i>2633</i>&nbsp;        QName enclosingElement,</b>
<b class="nc"><i>2634</i>&nbsp;        QName triggeringComponent,</b>
<b class="nc"><i>2635</i>&nbsp;        XMLAttributes attributes) {</b>
<b class="nc"><i>2636</i>&nbsp;        SchemaGrammar grammar = null;</b>
<b class="nc"><i>2637</i>&nbsp;        //get the grammar from local pool...</b>
<i>2638</i>&nbsp;        grammar = fGrammarBucket.getGrammar(namespace);
<b class="nc"><i>2639</i>&nbsp;</b>
<b class="nc"><i>2640</i>&nbsp;        if (grammar == null) {</b>
<i>2641</i>&nbsp;            fXSDDescription.setNamespace(namespace);
<i>2642</i>&nbsp;            // give a chance to application to be able to retreive the grammar.
<b class="nc"><i>2643</i>&nbsp;            if (fGrammarPool != null) {</b>
<i>2644</i>&nbsp;                grammar = (SchemaGrammar) fGrammarPool.retrieveGrammar(fXSDDescription);
<i>2645</i>&nbsp;                if (grammar != null) {
<i>2646</i>&nbsp;                    // put this grammar into the bucket, along with grammars
<i>2647</i>&nbsp;                    // imported by it (directly or indirectly)
<i>2648</i>&nbsp;                    if (!fGrammarBucket.putGrammar(grammar, true, fNamespaceGrowth)) {
<i>2649</i>&nbsp;                        // REVISIT: a conflict between new grammar(s) and grammars
<i>2650</i>&nbsp;                        // in the bucket. What to do? A warning? An exception?
<i>2651</i>&nbsp;                        fXSIErrorReporter.fErrorReporter.reportError(
<b class="nc"><i>2652</i>&nbsp;                            XSMessageFormatter.SCHEMA_DOMAIN,</b>
<b class="nc"><i>2653</i>&nbsp;                            &quot;GrammarConflict&quot;,</b>
<b class="nc"><i>2654</i>&nbsp;                            null,</b>
<b class="nc"><i>2655</i>&nbsp;                            XMLErrorReporter.SEVERITY_WARNING);</b>
<b class="nc"><i>2656</i>&nbsp;                        grammar = null;</b>
<i>2657</i>&nbsp;                    }
<b class="nc"><i>2658</i>&nbsp;                }</b>
<b class="nc"><i>2659</i>&nbsp;            }</b>
<b class="nc"><i>2660</i>&nbsp;        }</b>
<i>2661</i>&nbsp;
<b class="nc"><i>2662</i>&nbsp;        if (!fUseGrammarPoolOnly &amp;&amp; (grammar == null ||</b>
<b class="nc"><i>2663</i>&nbsp;            (fNamespaceGrowth &amp;&amp; !hasSchemaComponent(grammar, contextType, triggeringComponent)))) {</b>
<b class="nc"><i>2664</i>&nbsp;            fXSDDescription.reset();</b>
<b class="nc"><i>2665</i>&nbsp;            fXSDDescription.fContextType = contextType;</b>
<b class="nc"><i>2666</i>&nbsp;            fXSDDescription.setNamespace(namespace);</b>
<b class="nc"><i>2667</i>&nbsp;            fXSDDescription.fEnclosedElementName = enclosingElement;</b>
<b class="nc"><i>2668</i>&nbsp;            fXSDDescription.fTriggeringComponent = triggeringComponent;</b>
<i>2669</i>&nbsp;            fXSDDescription.fAttributes = attributes;
<i>2670</i>&nbsp;            if (fLocator != null) {
<i>2671</i>&nbsp;                fXSDDescription.setBaseSystemId(fLocator.getExpandedSystemId());
<i>2672</i>&nbsp;            }
<b class="nc"><i>2673</i>&nbsp;</b>
<b class="nc"><i>2674</i>&nbsp;            Map&lt;String, XMLSchemaLoader.LocationArray&gt; locationPairs = fLocationPairs;</b>
<b class="nc"><i>2675</i>&nbsp;            XMLSchemaLoader.LocationArray locationArray =</b>
<i>2676</i>&nbsp;                locationPairs.get(namespace == null ? XMLSymbols.EMPTY_STRING : namespace);
<i>2677</i>&nbsp;            if (locationArray != null) {
<i>2678</i>&nbsp;                String[] temp = locationArray.getLocationArray();
<b class="nc"><i>2679</i>&nbsp;                if (temp.length != 0) {</b>
<b class="nc"><i>2680</i>&nbsp;                    setLocationHints(fXSDDescription, temp, grammar);</b>
<i>2681</i>&nbsp;                }
<i>2682</i>&nbsp;            }
<b class="nc"><i>2683</i>&nbsp;</b>
<i>2684</i>&nbsp;            if (grammar == null || fXSDDescription.fLocationHints != null) {
<i>2685</i>&nbsp;                boolean toParseSchema = true;
<i>2686</i>&nbsp;                if (grammar != null) {
<b class="nc"><i>2687</i>&nbsp;                     // use location hints instead</b>
<b class="nc"><i>2688</i>&nbsp;                    locationPairs = Collections.emptyMap();</b>
<b class="nc"><i>2689</i>&nbsp;                }</b>
<b class="nc"><i>2690</i>&nbsp;</b>
<i>2691</i>&nbsp;                // try to parse the grammar using location hints from that namespace..
<b class="nc"><i>2692</i>&nbsp;                try {</b>
<b class="nc"><i>2693</i>&nbsp;                    XMLInputSource xis =</b>
<i>2694</i>&nbsp;                        XMLSchemaLoader.resolveDocument(
<i>2695</i>&nbsp;                            fXSDDescription,
<i>2696</i>&nbsp;                            locationPairs,
<i>2697</i>&nbsp;                            fEntityResolver);
<i>2698</i>&nbsp;                    if (grammar != null &amp;&amp; fNamespaceGrowth) {
<i>2699</i>&nbsp;                        try {
<i>2700</i>&nbsp;                            // if we are dealing with a different schema location, then include the new schema
<i>2701</i>&nbsp;                            // into the existing grammar
<b class="nc"><i>2702</i>&nbsp;                            if (grammar.getDocumentLocations().contains(XMLEntityManager.expandSystemId(xis.getSystemId(), xis.getBaseSystemId(), false))) {</b>
<i>2703</i>&nbsp;                                toParseSchema = false;
<i>2704</i>&nbsp;                            }
<b class="nc"><i>2705</i>&nbsp;                        }</b>
<i>2706</i>&nbsp;                        catch (MalformedURIException e) {
<b class="nc"><i>2707</i>&nbsp;                        }</b>
<i>2708</i>&nbsp;                    }
<i>2709</i>&nbsp;                    if (toParseSchema) {
<b class="nc"><i>2710</i>&nbsp;                        grammar = fSchemaLoader.loadSchema(fXSDDescription, xis, fLocationPairs);</b>
<i>2711</i>&nbsp;                    }
<i>2712</i>&nbsp;                }
<i>2713</i>&nbsp;                catch (IOException ex) {
<b class="nc"><i>2714</i>&nbsp;                    final String [] locationHints = fXSDDescription.getLocationHints();</b>
<b class="nc"><i>2715</i>&nbsp;                    fXSIErrorReporter.fErrorReporter.reportError(</b>
<b class="nc"><i>2716</i>&nbsp;                        XSMessageFormatter.SCHEMA_DOMAIN,</b>
<i>2717</i>&nbsp;                        &quot;schema_reference.4&quot;,
<i>2718</i>&nbsp;                        new Object[] { locationHints != null ? locationHints[0] : XMLSymbols.EMPTY_STRING },
<i>2719</i>&nbsp;                        XMLErrorReporter.SEVERITY_WARNING, ex);
<b class="nc"><i>2720</i>&nbsp;                }</b>
<b class="nc"><i>2721</i>&nbsp;            }</b>
<i>2722</i>&nbsp;        }
<i>2723</i>&nbsp;
<b class="nc"><i>2724</i>&nbsp;        return grammar;</b>
<b class="nc"><i>2725</i>&nbsp;</b>
<i>2726</i>&nbsp;    } //findSchemaGrammar
<i>2727</i>&nbsp;
<i>2728</i>&nbsp;    private boolean hasSchemaComponent(SchemaGrammar grammar, short contextType, QName triggeringComponent) {
<i>2729</i>&nbsp;        if (grammar != null &amp;&amp; triggeringComponent != null) {
<i>2730</i>&nbsp;            String localName = triggeringComponent.localpart;
<i>2731</i>&nbsp;            if (localName != null &amp;&amp; localName.length() &gt; 0) {
<b class="nc"><i>2732</i>&nbsp;                switch (contextType) {</b>
<b class="nc"><i>2733</i>&nbsp;                    case XSDDescription.CONTEXT_ELEMENT:</b>
<i>2734</i>&nbsp;                        return grammar.getElementDeclaration(localName) != null;
<i>2735</i>&nbsp;                    case XSDDescription.CONTEXT_ATTRIBUTE:
<i>2736</i>&nbsp;                        return grammar.getAttributeDeclaration(localName) != null;
<b class="nc"><i>2737</i>&nbsp;                    case XSDDescription.CONTEXT_XSITYPE:</b>
<i>2738</i>&nbsp;                        return grammar.getTypeDefinition(localName) != null;
<b class="nc"><i>2739</i>&nbsp;                }</b>
<b class="nc"><i>2740</i>&nbsp;            }</b>
<i>2741</i>&nbsp;        }
<i>2742</i>&nbsp;        return false;
<i>2743</i>&nbsp;    }
<i>2744</i>&nbsp;
<i>2745</i>&nbsp;    private void setLocationHints(XSDDescription desc, String[] locations, SchemaGrammar grammar) {
<i>2746</i>&nbsp;        int length = locations.length;
<i>2747</i>&nbsp;        if (grammar == null) {
<i>2748</i>&nbsp;            fXSDDescription.fLocationHints = new String[length];
<i>2749</i>&nbsp;            System.arraycopy(locations, 0, fXSDDescription.fLocationHints, 0, length);
<b class="nc"><i>2750</i>&nbsp;        }</b>
<b class="nc"><i>2751</i>&nbsp;        else {</b>
<b class="nc"><i>2752</i>&nbsp;            setLocationHints(desc, locations, grammar.getDocumentLocations());</b>
<b class="nc"><i>2753</i>&nbsp;        }</b>
<i>2754</i>&nbsp;    }
<i>2755</i>&nbsp;
<i>2756</i>&nbsp;    private void setLocationHints(XSDDescription desc, String[] locations, StringList docLocations) {
<b class="nc"><i>2757</i>&nbsp;        int length = locations.length;</b>
<i>2758</i>&nbsp;        String[] hints = new String[length];
<i>2759</i>&nbsp;        int counter = 0;
<i>2760</i>&nbsp;
<i>2761</i>&nbsp;        for (int i=0; i&lt;length; i++) {
<b class="nc"><i>2762</i>&nbsp;            if (!docLocations.contains(locations[i])) {</b>
<i>2763</i>&nbsp;                hints[counter++] = locations[i];
<i>2764</i>&nbsp;            }
<i>2765</i>&nbsp;        }
<b class="nc"><i>2766</i>&nbsp;</b>
<b class="nc"><i>2767</i>&nbsp;        if (counter &gt; 0) {</b>
<i>2768</i>&nbsp;            if (counter == length) {
<i>2769</i>&nbsp;                fXSDDescription.fLocationHints = hints;
<i>2770</i>&nbsp;            }
<i>2771</i>&nbsp;            else {
<i>2772</i>&nbsp;                fXSDDescription.fLocationHints = new String[counter];
<i>2773</i>&nbsp;                System.arraycopy(hints, 0, fXSDDescription.fLocationHints, 0, counter);
<i>2774</i>&nbsp;            }
<i>2775</i>&nbsp;        }
<i>2776</i>&nbsp;    }
<i>2777</i>&nbsp;
<i>2778</i>&nbsp;    XSTypeDefinition getAndCheckXsiType(QName element, String xsiType, XMLAttributes attributes) {
<i>2779</i>&nbsp;        // This method also deals with clause 1.2.1.2 of the constraint
<i>2780</i>&nbsp;        // Validation Rule: Schema-Validity Assessment (Element)
<i>2781</i>&nbsp;
<b class="nc"><i>2782</i>&nbsp;        // Element Locally Valid (Element)</b>
<b class="nc"><i>2783</i>&nbsp;        // 4 If there is an attribute information item among the element information item&#39;s [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is type, then all of the following must be true:</b>
<i>2784</i>&nbsp;        // 4.1 The normalized value of that attribute information item must be valid with respect to the built-in QName simple type, as defined by String Valid (3.14.4);
<i>2785</i>&nbsp;        QName typeName = null;
<i>2786</i>&nbsp;        try {
<i>2787</i>&nbsp;            typeName = (QName) fQNameDV.validate(xsiType, fValidationState, null);
<i>2788</i>&nbsp;        } catch (InvalidDatatypeValueException e) {
<i>2789</i>&nbsp;            reportSchemaError(e.getKey(), e.getArgs());
<i>2790</i>&nbsp;            reportSchemaError(
<b class="nc"><i>2791</i>&nbsp;                &quot;cvc-elt.4.1&quot;,</b>
<i>2792</i>&nbsp;                new Object[] {
<b class="nc"><i>2793</i>&nbsp;                    element.rawname,</b>
<i>2794</i>&nbsp;                    SchemaSymbols.URI_XSI + &quot;,&quot; + SchemaSymbols.XSI_TYPE,
<b class="nc"><i>2795</i>&nbsp;                    xsiType });</b>
<i>2796</i>&nbsp;            return null;
<b class="nc"><i>2797</i>&nbsp;        }</b>
<b class="nc"><i>2798</i>&nbsp;</b>
<b class="nc"><i>2799</i>&nbsp;        // 4.2 The local name and namespace name (as defined in QName Interpretation (3.15.3)), of the actual value of that attribute information item must resolve to a type definition, as defined in QName resolution (Instance) (3.15.4)</b>
<b class="nc"><i>2800</i>&nbsp;        XSTypeDefinition type = null;</b>
<b class="nc"><i>2801</i>&nbsp;        // if the namespace is schema namespace, first try built-in types</b>
<i>2802</i>&nbsp;        if (typeName.uri == SchemaSymbols.URI_SCHEMAFORSCHEMA) {
<b class="nc"><i>2803</i>&nbsp;            type = SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(typeName.localpart);</b>
<b class="nc"><i>2804</i>&nbsp;        }</b>
<b class="nc"><i>2805</i>&nbsp;        // if it&#39;s not schema built-in types, then try to get a grammar</b>
<i>2806</i>&nbsp;        if (type == null) {
<i>2807</i>&nbsp;            //try to find schema grammar by different means....
<i>2808</i>&nbsp;            SchemaGrammar grammar =
<b class="nc"><i>2809</i>&nbsp;                findSchemaGrammar(</b>
<b class="nc"><i>2810</i>&nbsp;                    XSDDescription.CONTEXT_XSITYPE,</b>
<b class="nc"><i>2811</i>&nbsp;                    typeName.uri,</b>
<b class="nc"><i>2812</i>&nbsp;                    element,</b>
<i>2813</i>&nbsp;                    typeName,
<i>2814</i>&nbsp;                    attributes);
<i>2815</i>&nbsp;
<i>2816</i>&nbsp;            if (grammar != null)
<i>2817</i>&nbsp;                type = grammar.getGlobalTypeDecl(typeName.localpart);
<i>2818</i>&nbsp;        }
<i>2819</i>&nbsp;        // still couldn&#39;t find the type, report an error
<b class="nc"><i>2820</i>&nbsp;        if (type == null) {</b>
<b class="nc"><i>2821</i>&nbsp;            reportSchemaError(&quot;cvc-elt.4.2&quot;, new Object[] { element.rawname, xsiType });</b>
<i>2822</i>&nbsp;            return null;
<i>2823</i>&nbsp;        }
<b class="nc"><i>2824</i>&nbsp;</b>
<b class="nc"><i>2825</i>&nbsp;        // if there is no current type, set this one as current.</b>
<b class="nc"><i>2826</i>&nbsp;        // and we don&#39;t need to do extra checking</b>
<i>2827</i>&nbsp;        if (fCurrentType != null) {
<b class="nc"><i>2828</i>&nbsp;            short block = XSConstants.DERIVATION_NONE;</b>
<b class="nc"><i>2829</i>&nbsp;            // 4.3 The local type definition must be validly derived from the {type definition} given the union of the {disallowed substitutions} and the {type definition}&#39;s {prohibited substitutions}, as defined in Type Derivation OK (Complex) (3.4.6) (if it is a complex type definition), or given {disallowed substitutions} as defined in Type Derivation OK (Simple) (3.14.6) (if it is a simple type definition).</b>
<i>2830</i>&nbsp;            // Note: It&#39;s possible to have fCurrentType be non-null and fCurrentElemDecl
<i>2831</i>&nbsp;            // be null, if the current type is set using the property &quot;root-type-definition&quot;.
<i>2832</i>&nbsp;            // In that case, we don&#39;t disallow any substitutions. -PM
<b class="nc"><i>2833</i>&nbsp;            if (fCurrentElemDecl != null) {</b>
<b class="nc"><i>2834</i>&nbsp;                block = fCurrentElemDecl.fBlock;</b>
<b class="nc"><i>2835</i>&nbsp;            }</b>
<i>2836</i>&nbsp;            if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<i>2837</i>&nbsp;                block |= ((XSComplexTypeDecl) fCurrentType).fBlock;
<i>2838</i>&nbsp;            }
<i>2839</i>&nbsp;            if (!XSConstraints.checkTypeDerivationOk(type, fCurrentType, block)) {
<i>2840</i>&nbsp;                reportSchemaError(
<b class="nc"><i>2841</i>&nbsp;                        &quot;cvc-elt.4.3&quot;,</b>
<i>2842</i>&nbsp;                        new Object[] { element.rawname, xsiType, XS10TypeHelper.getSchemaTypeName(fCurrentType)});
<i>2843</i>&nbsp;            }
<i>2844</i>&nbsp;        }
<i>2845</i>&nbsp;
<b class="nc"><i>2846</i>&nbsp;        return type;</b>
<i>2847</i>&nbsp;    } //getAndCheckXsiType
<i>2848</i>&nbsp;
<b class="nc"><i>2849</i>&nbsp;    boolean getXsiNil(QName element, String xsiNil) {</b>
<b class="nc"><i>2850</i>&nbsp;        // Element Locally Valid (Element)</b>
<i>2851</i>&nbsp;        // 3 The appropriate case among the following must be true:
<i>2852</i>&nbsp;        // 3.1 If {nillable} is false, then there must be no attribute information item among the element information item&#39;s [attributes] whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is nil.
<i>2853</i>&nbsp;        if (fCurrentElemDecl != null &amp;&amp; !fCurrentElemDecl.getNillable()) {
<i>2854</i>&nbsp;            reportSchemaError(
<i>2855</i>&nbsp;                &quot;cvc-elt.3.1&quot;,
<b class="nc"><i>2856</i>&nbsp;                new Object[] {</b>
<i>2857</i>&nbsp;                    element.rawname,
<i>2858</i>&nbsp;                    SchemaSymbols.URI_XSI + &quot;,&quot; + SchemaSymbols.XSI_NIL });
<b class="nc"><i>2859</i>&nbsp;        }</b>
<b class="nc"><i>2860</i>&nbsp;        // 3.2 If {nillable} is true and there is such an attribute information item and its actual value is true , then all of the following must be true:</b>
<i>2861</i>&nbsp;        // 3.2.2 There must be no fixed {value constraint}.
<i>2862</i>&nbsp;        else {
<b class="nc"><i>2863</i>&nbsp;            String value = XMLChar.trim(xsiNil);</b>
<i>2864</i>&nbsp;            if (value.equals(SchemaSymbols.ATTVAL_TRUE)
<b class="nc"><i>2865</i>&nbsp;                || value.equals(SchemaSymbols.ATTVAL_TRUE_1)) {</b>
<i>2866</i>&nbsp;                if (fCurrentElemDecl != null
<b class="nc"><i>2867</i>&nbsp;                    &amp;&amp; fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED) {</b>
<i>2868</i>&nbsp;                    reportSchemaError(
<i>2869</i>&nbsp;                        &quot;cvc-elt.3.2.2&quot;,
<b class="nc"><i>2870</i>&nbsp;                        new Object[] {</b>
<i>2871</i>&nbsp;                            element.rawname,
<i>2872</i>&nbsp;                            SchemaSymbols.URI_XSI + &quot;,&quot; + SchemaSymbols.XSI_NIL });
<i>2873</i>&nbsp;                }
<i>2874</i>&nbsp;                return true;
<b class="nc"><i>2875</i>&nbsp;            }</b>
<b class="nc"><i>2876</i>&nbsp;        }</b>
<b class="nc"><i>2877</i>&nbsp;        return false;</b>
<b class="nc"><i>2878</i>&nbsp;    }</b>
<i>2879</i>&nbsp;
<i>2880</i>&nbsp;    void processAttributes(QName element, XMLAttributes attributes, XSAttributeGroupDecl attrGrp) {
<i>2881</i>&nbsp;
<i>2882</i>&nbsp;        if (DEBUG) {
<b class="nc"><i>2883</i>&nbsp;            System.out.println(&quot;==&gt;processAttributes: &quot; + attributes.getLength());</b>
<i>2884</i>&nbsp;        }
<b class="nc"><i>2885</i>&nbsp;</b>
<i>2886</i>&nbsp;        // whether we have seen a Wildcard ID.
<b class="nc"><i>2887</i>&nbsp;        String wildcardIDName = null;</b>
<i>2888</i>&nbsp;
<b class="nc"><i>2889</i>&nbsp;        // for each present attribute</b>
<i>2890</i>&nbsp;        int attCount = attributes.getLength();
<i>2891</i>&nbsp;
<i>2892</i>&nbsp;        Augmentations augs = null;
<i>2893</i>&nbsp;        AttributePSVImpl attrPSVI = null;
<i>2894</i>&nbsp;
<i>2895</i>&nbsp;        boolean isSimple =
<i>2896</i>&nbsp;            fCurrentType == null || fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE;
<i>2897</i>&nbsp;
<i>2898</i>&nbsp;        XSObjectList attrUses = null;
<i>2899</i>&nbsp;        int useCount = 0;
<i>2900</i>&nbsp;        XSWildcardDecl attrWildcard = null;
<i>2901</i>&nbsp;        if (!isSimple) {
<i>2902</i>&nbsp;            attrUses = attrGrp.getAttributeUses();
<i>2903</i>&nbsp;            useCount = attrUses.getLength();
<i>2904</i>&nbsp;            attrWildcard = attrGrp.fAttributeWC;
<i>2905</i>&nbsp;        }
<i>2906</i>&nbsp;
<b class="nc"><i>2907</i>&nbsp;        // Element Locally Valid (Complex Type)</b>
<b class="nc"><i>2908</i>&nbsp;        // 3 For each attribute information item in the element information item&#39;s [attributes] excepting those whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation, the appropriate case among the following must be true:</b>
<i>2909</i>&nbsp;        // get the corresponding attribute decl
<i>2910</i>&nbsp;        for (int index = 0; index &lt; attCount; index++) {
<i>2911</i>&nbsp;
<i>2912</i>&nbsp;            attributes.getName(index, fTempQName);
<i>2913</i>&nbsp;
<i>2914</i>&nbsp;            if (DEBUG) {
<i>2915</i>&nbsp;                System.out.println(&quot;==&gt;process attribute: &quot; + fTempQName);
<b class="nc"><i>2916</i>&nbsp;            }</b>
<i>2917</i>&nbsp;
<b class="nc"><i>2918</i>&nbsp;            if (fAugPSVI || fIdConstraint) {</b>
<b class="nc"><i>2919</i>&nbsp;                augs = attributes.getAugmentations(index);</b>
<i>2920</i>&nbsp;                attrPSVI = (AttributePSVImpl) augs.getItem(Constants.ATTRIBUTE_PSVI);
<b class="nc"><i>2921</i>&nbsp;                if (attrPSVI != null) {</b>
<b class="nc"><i>2922</i>&nbsp;                    attrPSVI.reset();</b>
<b class="nc"><i>2923</i>&nbsp;                } else {</b>
<b class="nc"><i>2924</i>&nbsp;                    attrPSVI = new AttributePSVImpl();</b>
<b class="nc"><i>2925</i>&nbsp;                    augs.putItem(Constants.ATTRIBUTE_PSVI, attrPSVI);</b>
<i>2926</i>&nbsp;                }
<i>2927</i>&nbsp;                // PSVI attribute: validation context
<b class="nc"><i>2928</i>&nbsp;                attrPSVI.fValidationContext = fValidationRoot;</b>
<i>2929</i>&nbsp;            }
<i>2930</i>&nbsp;
<i>2931</i>&nbsp;            // Element Locally Valid (Type)
<i>2932</i>&nbsp;            // 3.1.1 The element information item&#39;s [attributes] must be empty, excepting those
<i>2933</i>&nbsp;            // whose [namespace name] is identical to http://www.w3.org/2001/XMLSchema-instance and
<b class="nc"><i>2934</i>&nbsp;            // whose [local name] is one of type, nil, schemaLocation or noNamespaceSchemaLocation.</b>
<b class="nc"><i>2935</i>&nbsp;</b>
<b class="nc"><i>2936</i>&nbsp;            // for the 4 xsi attributes, get appropriate decl, and validate</b>
<i>2937</i>&nbsp;            if (fTempQName.uri == SchemaSymbols.URI_XSI) {
<i>2938</i>&nbsp;                XSAttributeDecl attrDecl = null;
<i>2939</i>&nbsp;                if (fTempQName.localpart == SchemaSymbols.XSI_TYPE) {
<i>2940</i>&nbsp;                    attrDecl = XSI_TYPE;
<b class="nc"><i>2941</i>&nbsp;                }</b>
<b class="nc"><i>2942</i>&nbsp;                else if (fTempQName.localpart == SchemaSymbols.XSI_NIL) {</b>
<i>2943</i>&nbsp;                    attrDecl = XSI_NIL;
<b class="nc"><i>2944</i>&nbsp;                }</b>
<b class="nc"><i>2945</i>&nbsp;                else if (fTempQName.localpart == SchemaSymbols.XSI_SCHEMALOCATION) {</b>
<b class="nc"><i>2946</i>&nbsp;                    attrDecl = XSI_SCHEMALOCATION;</b>
<b class="nc"><i>2947</i>&nbsp;                }</b>
<b class="nc"><i>2948</i>&nbsp;                else if (fTempQName.localpart == SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION) {</b>
<i>2949</i>&nbsp;                    attrDecl = XSI_NONAMESPACESCHEMALOCATION;
<i>2950</i>&nbsp;                }
<b class="nc"><i>2951</i>&nbsp;                if (attrDecl != null) {</b>
<b class="nc"><i>2952</i>&nbsp;                    processOneAttribute(element, attributes, index, attrDecl, null, attrPSVI);</b>
<b class="nc"><i>2953</i>&nbsp;                    continue;</b>
<i>2954</i>&nbsp;                }
<i>2955</i>&nbsp;            }
<b class="nc"><i>2956</i>&nbsp;</b>
<i>2957</i>&nbsp;            // for namespace attributes, no_validation/unknow_validity
<i>2958</i>&nbsp;            if (fTempQName.rawname == XMLSymbols.PREFIX_XMLNS
<b class="nc"><i>2959</i>&nbsp;                || fTempQName.rawname.startsWith(&quot;xmlns:&quot;)) {</b>
<b class="nc"><i>2960</i>&nbsp;                continue;</b>
<b class="nc"><i>2961</i>&nbsp;            }</b>
<i>2962</i>&nbsp;
<b class="nc"><i>2963</i>&nbsp;            // simple type doesn&#39;t allow any other attributes</b>
<b class="nc"><i>2964</i>&nbsp;            if (isSimple) {</b>
<b class="nc"><i>2965</i>&nbsp;                reportSchemaError(</b>
<b class="nc"><i>2966</i>&nbsp;                    &quot;cvc-type.3.1.1&quot;,</b>
<b class="nc"><i>2967</i>&nbsp;                    new Object[] { element.rawname, fTempQName.rawname });</b>
<b class="nc"><i>2968</i>&nbsp;                continue;</b>
<b class="nc"><i>2969</i>&nbsp;            }</b>
<b class="nc"><i>2970</i>&nbsp;</b>
<b class="nc"><i>2971</i>&nbsp;            // it&#39;s not xmlns, and not xsi, then we need to find a decl for it</b>
<b class="nc"><i>2972</i>&nbsp;            XSAttributeUseImpl currUse = null, oneUse;</b>
<b class="nc"><i>2973</i>&nbsp;            for (int i = 0; i &lt; useCount; i++) {</b>
<i>2974</i>&nbsp;                oneUse = (XSAttributeUseImpl) attrUses.item(i);
<i>2975</i>&nbsp;                if (oneUse.fAttrDecl.fName == fTempQName.localpart
<i>2976</i>&nbsp;                    &amp;&amp; oneUse.fAttrDecl.fTargetNamespace == fTempQName.uri) {
<i>2977</i>&nbsp;                    currUse = oneUse;
<i>2978</i>&nbsp;                    break;
<i>2979</i>&nbsp;                }
<i>2980</i>&nbsp;            }
<i>2981</i>&nbsp;
<i>2982</i>&nbsp;            // 3.2 otherwise all of the following must be true:
<i>2983</i>&nbsp;            // 3.2.1 There must be an {attribute wildcard}.
<i>2984</i>&nbsp;            // 3.2.2 The attribute information item must be valid with respect to it as defined in Item Valid (Wildcard) (3.10.4).
<i>2985</i>&nbsp;
<i>2986</i>&nbsp;            // if failed, get it from wildcard
<b class="nc"><i>2987</i>&nbsp;            if (currUse == null) {</b>
<i>2988</i>&nbsp;                //if (attrWildcard == null)
<i>2989</i>&nbsp;                //    reportSchemaError(&quot;cvc-complex-type.3.2.1&quot;, new Object[]{element.rawname, fTempQName.rawname});
<i>2990</i>&nbsp;                if (attrWildcard == null || !attrWildcard.allowNamespace(fTempQName.uri)) {
<i>2991</i>&nbsp;                    // so this attribute is not allowed
<i>2992</i>&nbsp;                    reportSchemaError(
<b class="nc"><i>2993</i>&nbsp;                        &quot;cvc-complex-type.3.2.2&quot;,</b>
<b class="nc"><i>2994</i>&nbsp;                        new Object[] { element.rawname, fTempQName.rawname });</b>
<b class="nc"><i>2995</i>&nbsp;</b>
<b class="nc"><i>2996</i>&nbsp;                    // We have seen an attribute that was not declared</b>
<i>2997</i>&nbsp;                    fNFullValidationDepth = fElementDepth;
<b class="nc"><i>2998</i>&nbsp;</b>
<b class="nc"><i>2999</i>&nbsp;                    continue;</b>
<b class="nc"><i>3000</i>&nbsp;                }</b>
<b class="nc"><i>3001</i>&nbsp;            }</b>
<i>3002</i>&nbsp;
<i>3003</i>&nbsp;            XSAttributeDecl currDecl = null;
<i>3004</i>&nbsp;            if (currUse != null) {
<b class="nc"><i>3005</i>&nbsp;                currDecl = currUse.fAttrDecl;</b>
<i>3006</i>&nbsp;            } else {
<i>3007</i>&nbsp;                // which means it matches a wildcard
<i>3008</i>&nbsp;                // skip it if processContents is skip
<b class="nc"><i>3009</i>&nbsp;                if (attrWildcard.fProcessContents == XSWildcardDecl.PC_SKIP)</b>
<b class="nc"><i>3010</i>&nbsp;                    continue;</b>
<b class="nc"><i>3011</i>&nbsp;</b>
<i>3012</i>&nbsp;                //try to find grammar by different means...
<i>3013</i>&nbsp;                SchemaGrammar grammar =
<i>3014</i>&nbsp;                    findSchemaGrammar(
<i>3015</i>&nbsp;                        XSDDescription.CONTEXT_ATTRIBUTE,
<i>3016</i>&nbsp;                        fTempQName.uri,
<i>3017</i>&nbsp;                        element,
<i>3018</i>&nbsp;                        fTempQName,
<b class="nc"><i>3019</i>&nbsp;                        attributes);</b>
<i>3020</i>&nbsp;
<i>3021</i>&nbsp;                if (grammar != null) {
<i>3022</i>&nbsp;                    currDecl = grammar.getGlobalAttributeDecl(fTempQName.localpart);
<b class="nc"><i>3023</i>&nbsp;                }</b>
<b class="nc"><i>3024</i>&nbsp;</b>
<i>3025</i>&nbsp;                // if can&#39;t find
<i>3026</i>&nbsp;                if (currDecl == null) {
<i>3027</i>&nbsp;                    // if strict, report error
<i>3028</i>&nbsp;                    if (attrWildcard.fProcessContents == XSWildcardDecl.PC_STRICT) {
<b class="nc"><i>3029</i>&nbsp;                        reportSchemaError(</b>
<i>3030</i>&nbsp;                            &quot;cvc-complex-type.3.2.2&quot;,
<b class="nc"><i>3031</i>&nbsp;                            new Object[] { element.rawname, fTempQName.rawname });</b>
<b class="nc"><i>3032</i>&nbsp;                    }</b>
<i>3033</i>&nbsp;
<b class="nc"><i>3034</i>&nbsp;                    // then continue to the next attribute</b>
<i>3035</i>&nbsp;                    continue;
<i>3036</i>&nbsp;                } else {
<i>3037</i>&nbsp;                    // 5 Let [Definition:]  the wild IDs be the set of all attribute information item to which clause 3.2 applied and whose validation resulted in a context-determined declaration of mustFind or no context-determined declaration at all, and whose [local name] and [namespace name] resolve (as defined by QName resolution (Instance) (3.15.4)) to an attribute declaration whose {type definition} is or is derived from ID. Then all of the following must be true:
<b class="nc"><i>3038</i>&nbsp;                    // 5.1 There must be no more than one item in wild IDs.</b>
<i>3039</i>&nbsp;                    if (currDecl.fType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE
<i>3040</i>&nbsp;                        &amp;&amp; (currDecl.fType).isIDType()) {
<i>3041</i>&nbsp;                        if (wildcardIDName != null) {
<b class="nc"><i>3042</i>&nbsp;                            reportSchemaError(</b>
<b class="nc"><i>3043</i>&nbsp;                                &quot;cvc-complex-type.5.1&quot;,</b>
<i>3044</i>&nbsp;                                new Object[] { element.rawname, currDecl.fName, wildcardIDName });
<i>3045</i>&nbsp;                        } else
<i>3046</i>&nbsp;                            wildcardIDName = currDecl.fName;
<i>3047</i>&nbsp;                    }
<b class="nc"><i>3048</i>&nbsp;                }</b>
<i>3049</i>&nbsp;            }
<i>3050</i>&nbsp;
<i>3051</i>&nbsp;            processOneAttribute(element, attributes, index, currDecl, currUse, attrPSVI);
<i>3052</i>&nbsp;        } // end of for (all attributes)
<i>3053</i>&nbsp;
<i>3054</i>&nbsp;        // 5.2 If wild IDs is non-empty, there must not be any attribute uses among the {attribute uses} whose {attribute declaration}&#39;s {type definition} is or is derived from ID.
<b class="nc"><i>3055</i>&nbsp;        if (!isSimple &amp;&amp; attrGrp.fIDAttrName != null &amp;&amp; wildcardIDName != null) {</b>
<i>3056</i>&nbsp;            reportSchemaError(
<b class="nc"><i>3057</i>&nbsp;                &quot;cvc-complex-type.5.2&quot;,</b>
<b class="nc"><i>3058</i>&nbsp;                new Object[] { element.rawname, wildcardIDName, attrGrp.fIDAttrName });</b>
<i>3059</i>&nbsp;        }
<b class="nc"><i>3060</i>&nbsp;</b>
<i>3061</i>&nbsp;    } //processAttributes
<b class="nc"><i>3062</i>&nbsp;</b>
<b class="nc"><i>3063</i>&nbsp;    void processOneAttribute(</b>
<i>3064</i>&nbsp;        QName element,
<b class="nc"><i>3065</i>&nbsp;        XMLAttributes attributes,</b>
<b class="nc"><i>3066</i>&nbsp;        int index,</b>
<i>3067</i>&nbsp;        XSAttributeDecl currDecl,
<b class="nc"><i>3068</i>&nbsp;        XSAttributeUseImpl currUse,</b>
<i>3069</i>&nbsp;        AttributePSVImpl attrPSVI) {
<b class="nc"><i>3070</i>&nbsp;</b>
<b class="nc"><i>3071</i>&nbsp;        String attrValue = attributes.getValue(index);</b>
<i>3072</i>&nbsp;        fXSIErrorReporter.pushContext();
<i>3073</i>&nbsp;
<i>3074</i>&nbsp;        // Attribute Locally Valid
<i>3075</i>&nbsp;        // For an attribute information item to be locally valid with respect to an attribute declaration all of the following must be true:
<i>3076</i>&nbsp;        // 1 The declaration must not be absent (see Missing Sub-components (5.3) for how this can fail to be the case).
<i>3077</i>&nbsp;        // 2 Its {type definition} must not be absent.
<i>3078</i>&nbsp;        // 3 The item&#39;s normalized value must be locally valid with respect to that {type definition} as per String Valid (3.14.4).
<b class="nc"><i>3079</i>&nbsp;        // get simple type</b>
<b class="nc"><i>3080</i>&nbsp;        XSSimpleType attDV = currDecl.fType;</b>
<b class="nc"><i>3081</i>&nbsp;</b>
<b class="nc"><i>3082</i>&nbsp;        Object actualValue = null;</b>
<i>3083</i>&nbsp;        try {
<i>3084</i>&nbsp;            actualValue = attDV.validate(attrValue, fValidationState, fValidatedInfo);
<i>3085</i>&nbsp;            // store the normalized value
<i>3086</i>&nbsp;            if (fNormalizeData) {
<b class="nc"><i>3087</i>&nbsp;                attributes.setValue(index, fValidatedInfo.normalizedValue);</b>
<i>3088</i>&nbsp;            }
<i>3089</i>&nbsp;            // PSVI: element notation
<b class="nc"><i>3090</i>&nbsp;            if (attDV.getVariety() == XSSimpleType.VARIETY_ATOMIC</b>
<b class="nc"><i>3091</i>&nbsp;                &amp;&amp; attDV.getPrimitiveKind() == XSSimpleType.PRIMITIVE_NOTATION) {</b>
<b class="nc"><i>3092</i>&nbsp;                QName qName = (QName) actualValue;</b>
<i>3093</i>&nbsp;                SchemaGrammar grammar = fGrammarBucket.getGrammar(qName.uri);
<i>3094</i>&nbsp;
<b class="nc"><i>3095</i>&nbsp;                //REVISIT: is it possible for the notation to be in different namespace than the attribute</b>
<i>3096</i>&nbsp;                //with which it is associated, CHECK !!  &lt;fof n1:att1 = &quot;n2:notation1&quot; ..&gt;
<i>3097</i>&nbsp;                // should we give chance to the application to be able to  retrieve a grammar - nb
<i>3098</i>&nbsp;                //REVISIT: what would be the triggering component here.. if it is attribute value that
<i>3099</i>&nbsp;                // triggered the loading of grammar ?? -nb
<b class="nc"><i>3100</i>&nbsp;</b>
<i>3101</i>&nbsp;                if (grammar != null) {
<i>3102</i>&nbsp;                    fNotation = grammar.getGlobalNotationDecl(qName.localpart);
<i>3103</i>&nbsp;                }
<i>3104</i>&nbsp;            }
<i>3105</i>&nbsp;        }
<b class="nc"><i>3106</i>&nbsp;        catch (InvalidDatatypeValueException idve) {</b>
<i>3107</i>&nbsp;            reportSchemaError(idve.getKey(), idve.getArgs());
<i>3108</i>&nbsp;            reportSchemaError(
<b class="nc"><i>3109</i>&nbsp;                &quot;cvc-attribute.3&quot;,</b>
<b class="nc"><i>3110</i>&nbsp;                new Object[] { element.rawname, fTempQName.rawname, attrValue,</b>
<b class="nc"><i>3111</i>&nbsp;                        (attDV instanceof XSSimpleTypeDecl) ?</b>
<i>3112</i>&nbsp;                                ((XSSimpleTypeDecl) attDV).getTypeName() : attDV.getName()});
<b class="nc"><i>3113</i>&nbsp;        }</b>
<b class="nc"><i>3114</i>&nbsp;</b>
<b class="nc"><i>3115</i>&nbsp;        // get the value constraint from use or decl</b>
<i>3116</i>&nbsp;        // 4 The item&#39;s actual value must match the value of the {value constraint}, if it is present and fixed.                 // now check the value against the simpleType
<b class="nc"><i>3117</i>&nbsp;        if (actualValue != null &amp;&amp; currDecl.getConstraintType() == XSConstants.VC_FIXED) {</b>
<b class="nc"><i>3118</i>&nbsp;            if (!ValidatedInfo.isComparable(fValidatedInfo, currDecl.fDefault) || !actualValue.equals(currDecl.fDefault.actualValue)) {</b>
<b class="nc"><i>3119</i>&nbsp;                reportSchemaError(</b>
<b class="nc"><i>3120</i>&nbsp;                    &quot;cvc-attribute.4&quot;,</b>
<i>3121</i>&nbsp;                    new Object[] {
<i>3122</i>&nbsp;                        element.rawname,
<i>3123</i>&nbsp;                        fTempQName.rawname,
<i>3124</i>&nbsp;                        attrValue,
<b class="nc"><i>3125</i>&nbsp;                        currDecl.fDefault.stringValue()});</b>
<b class="nc"><i>3126</i>&nbsp;            }</b>
<i>3127</i>&nbsp;        }
<b class="nc"><i>3128</i>&nbsp;</b>
<i>3129</i>&nbsp;        // 3.1 If there is among the {attribute uses} an attribute use with an {attribute declaration} whose {name} matches the attribute information item&#39;s [local name] and whose {target namespace} is identical to the attribute information item&#39;s [namespace name] (where an absent {target namespace} is taken to be identical to a [namespace name] with no value), then the attribute information must be valid with respect to that attribute use as per Attribute Locally Valid (Use) (3.5.4). In this case the {attribute declaration} of that attribute use is the context-determined declaration for the attribute information item with respect to Schema-Validity Assessment (Attribute) (3.2.4) and Assessment Outcome (Attribute) (3.2.5).
<i>3130</i>&nbsp;        if (actualValue != null
<i>3131</i>&nbsp;            &amp;&amp; currUse != null
<b class="nc"><i>3132</i>&nbsp;            &amp;&amp; currUse.fConstraintType == XSConstants.VC_FIXED) {</b>
<i>3133</i>&nbsp;            if (!ValidatedInfo.isComparable(fValidatedInfo, currUse.fDefault) || !actualValue.equals(currUse.fDefault.actualValue)) {
<b class="nc"><i>3134</i>&nbsp;                reportSchemaError(</b>
<b class="nc"><i>3135</i>&nbsp;                    &quot;cvc-complex-type.3.1&quot;,</b>
<i>3136</i>&nbsp;                    new Object[] {
<b class="nc"><i>3137</i>&nbsp;                        element.rawname,</b>
<b class="nc"><i>3138</i>&nbsp;                        fTempQName.rawname,</b>
<i>3139</i>&nbsp;                        attrValue,
<b class="nc"><i>3140</i>&nbsp;                        currUse.fDefault.stringValue()});</b>
<b class="nc"><i>3141</i>&nbsp;            }</b>
<i>3142</i>&nbsp;        }
<b class="nc"><i>3143</i>&nbsp;        if (fIdConstraint) {</b>
<b class="nc"><i>3144</i>&nbsp;            attrPSVI.fValue.copyFrom(fValidatedInfo);</b>
<b class="nc"><i>3145</i>&nbsp;        }</b>
<b class="nc"><i>3146</i>&nbsp;</b>
<i>3147</i>&nbsp;        if (fAugPSVI) {
<i>3148</i>&nbsp;            // PSVI: attribute declaration
<b class="nc"><i>3149</i>&nbsp;            attrPSVI.fDeclaration = currDecl;</b>
<b class="nc"><i>3150</i>&nbsp;            // PSVI: attribute type</b>
<i>3151</i>&nbsp;            attrPSVI.fTypeDecl = attDV;
<i>3152</i>&nbsp;
<b class="nc"><i>3153</i>&nbsp;            // PSVI: attribute normalized value</b>
<i>3154</i>&nbsp;            // NOTE: we always store the normalized value, even if it&#39;s invlid,
<i>3155</i>&nbsp;            // because it might still be useful to the user. But when the it&#39;s
<b class="nc"><i>3156</i>&nbsp;            // not valid, the normalized value is not trustable.</b>
<i>3157</i>&nbsp;            attrPSVI.fValue.copyFrom(fValidatedInfo);
<i>3158</i>&nbsp;
<i>3159</i>&nbsp;            // PSVI: validation attempted:
<b class="nc"><i>3160</i>&nbsp;            attrPSVI.fValidationAttempted = AttributePSVI.VALIDATION_FULL;</b>
<b class="nc"><i>3161</i>&nbsp;</b>
<i>3162</i>&nbsp;            // We have seen an attribute that was declared.
<i>3163</i>&nbsp;            if (!fUseGrammarPoolOnly &amp;&amp;
<i>3164</i>&nbsp;                    !(fElementDepth &lt; fIgnoreXSITypeDepth &amp;&amp; fCurrentElemDecl == null)) {
<i>3165</i>&nbsp;                //only when USE_GRAMMAR_POOL_ONLY and IGNORE_XSI_TYPE are not set
<i>3166</i>&nbsp;                fNNoneValidationDepth = fElementDepth;
<b class="nc"><i>3167</i>&nbsp;            }</b>
<i>3168</i>&nbsp;
<b class="nc"><i>3169</i>&nbsp;            String[] errors = fXSIErrorReporter.mergeContext();</b>
<i>3170</i>&nbsp;            // PSVI: error codes
<b class="nc"><i>3171</i>&nbsp;            attrPSVI.fErrors = errors;</b>
<i>3172</i>&nbsp;            // PSVI: validity
<i>3173</i>&nbsp;            attrPSVI.fValidity =
<b class="nc"><i>3174</i>&nbsp;                (errors == null) ? AttributePSVI.VALIDITY_VALID : AttributePSVI.VALIDITY_INVALID;</b>
<b class="nc"><i>3175</i>&nbsp;        }</b>
<b class="nc"><i>3176</i>&nbsp;    }</b>
<b class="nc"><i>3177</i>&nbsp;</b>
<i>3178</i>&nbsp;    void addDefaultAttributes(
<b class="nc"><i>3179</i>&nbsp;        QName element,</b>
<b class="nc"><i>3180</i>&nbsp;        XMLAttributes attributes,</b>
<i>3181</i>&nbsp;        XSAttributeGroupDecl attrGrp) {
<b class="nc"><i>3182</i>&nbsp;        // Check after all specified attrs are scanned</b>
<b class="nc"><i>3183</i>&nbsp;        // (1) report error for REQUIRED attrs that are missing (V_TAGc)</b>
<b class="nc"><i>3184</i>&nbsp;        // REVISIT: should we check prohibited attributes?</b>
<b class="nc"><i>3185</i>&nbsp;        // (2) report error for PROHIBITED attrs that are present (V_TAGc)</b>
<b class="nc"><i>3186</i>&nbsp;        // (3) add default attrs (FIXED and NOT_FIXED)</b>
<i>3187</i>&nbsp;        //
<i>3188</i>&nbsp;        if (DEBUG) {
<b class="nc"><i>3189</i>&nbsp;            System.out.println(&quot;==&gt;addDefaultAttributes: &quot; + element);</b>
<i>3190</i>&nbsp;        }
<b class="nc"><i>3191</i>&nbsp;        XSObjectList attrUses = attrGrp.getAttributeUses();</b>
<b class="nc"><i>3192</i>&nbsp;        int useCount = attrUses.getLength();</b>
<b class="nc"><i>3193</i>&nbsp;        XSAttributeUseImpl currUse;</b>
<i>3194</i>&nbsp;        XSAttributeDecl currDecl;
<i>3195</i>&nbsp;        short constType;
<i>3196</i>&nbsp;        ValidatedInfo defaultValue;
<b class="nc"><i>3197</i>&nbsp;        boolean isSpecified;</b>
<i>3198</i>&nbsp;        QName attName;
<i>3199</i>&nbsp;        // for each attribute use
<i>3200</i>&nbsp;        for (int i = 0; i &lt; useCount; i++) {
<i>3201</i>&nbsp;
<i>3202</i>&nbsp;            currUse = (XSAttributeUseImpl) attrUses.item(i);
<i>3203</i>&nbsp;            currDecl = currUse.fAttrDecl;
<b class="nc"><i>3204</i>&nbsp;            // get value constraint</b>
<b class="nc"><i>3205</i>&nbsp;            constType = currUse.fConstraintType;</b>
<b class="nc"><i>3206</i>&nbsp;            defaultValue = currUse.fDefault;</b>
<i>3207</i>&nbsp;            if (constType == XSConstants.VC_NONE) {
<i>3208</i>&nbsp;                constType = currDecl.getConstraintType();
<b class="nc"><i>3209</i>&nbsp;                defaultValue = currDecl.fDefault;</b>
<i>3210</i>&nbsp;            }
<i>3211</i>&nbsp;            // whether this attribute is specified
<i>3212</i>&nbsp;            isSpecified = attributes.getValue(currDecl.fTargetNamespace, currDecl.fName) != null;
<i>3213</i>&nbsp;
<b class="nc"><i>3214</i>&nbsp;            // Element Locally Valid (Complex Type)</b>
<b class="nc"><i>3215</i>&nbsp;            // 4 The {attribute declaration} of each attribute use in the {attribute uses} whose</b>
<b class="nc"><i>3216</i>&nbsp;            // {required} is true matches one of the attribute information items in the element</b>
<b class="nc"><i>3217</i>&nbsp;            // information item&#39;s [attributes] as per clause 3.1 above.</b>
<b class="nc"><i>3218</i>&nbsp;            if (currUse.fUse == SchemaSymbols.USE_REQUIRED) {</b>
<b class="nc"><i>3219</i>&nbsp;                if (!isSpecified)</b>
<i>3220</i>&nbsp;                    reportSchemaError(
<i>3221</i>&nbsp;                        &quot;cvc-complex-type.4&quot;,
<i>3222</i>&nbsp;                        new Object[] { element.rawname, currDecl.fName });
<i>3223</i>&nbsp;            }
<i>3224</i>&nbsp;            // if the attribute is not specified, then apply the value constraint
<b class="nc"><i>3225</i>&nbsp;            if (!isSpecified &amp;&amp; constType != XSConstants.VC_NONE) {</b>
<i>3226</i>&nbsp;                attName =
<i>3227</i>&nbsp;                    new QName(null, currDecl.fName, currDecl.fName, currDecl.fTargetNamespace);
<i>3228</i>&nbsp;                String normalized = (defaultValue != null) ? defaultValue.stringValue() : &quot;&quot;;
<b class="nc"><i>3229</i>&nbsp;                int attrIndex;</b>
<b class="nc"><i>3230</i>&nbsp;                if (attributes instanceof XMLAttributesImpl) {</b>
<i>3231</i>&nbsp;                    XMLAttributesImpl attrs = (XMLAttributesImpl) attributes;
<i>3232</i>&nbsp;                    attrIndex = attrs.getLength();
<i>3233</i>&nbsp;                    attrs.addAttributeNS(attName, &quot;CDATA&quot;, normalized);
<i>3234</i>&nbsp;                }
<i>3235</i>&nbsp;                else {
<i>3236</i>&nbsp;                    attrIndex = attributes.addAttribute(attName, &quot;CDATA&quot;, normalized);
<i>3237</i>&nbsp;                }
<i>3238</i>&nbsp;
<b class="nc"><i>3239</i>&nbsp;                if (fAugPSVI) {</b>
<b class="nc"><i>3240</i>&nbsp;</b>
<b class="nc"><i>3241</i>&nbsp;                    // PSVI: attribute is &quot;schema&quot; specified</b>
<b class="nc"><i>3242</i>&nbsp;                    Augmentations augs = attributes.getAugmentations(attrIndex);</b>
<i>3243</i>&nbsp;                    AttributePSVImpl attrPSVI = new AttributePSVImpl();
<i>3244</i>&nbsp;                    augs.putItem(Constants.ATTRIBUTE_PSVI, attrPSVI);
<b class="nc"><i>3245</i>&nbsp;</b>
<b class="nc"><i>3246</i>&nbsp;                    attrPSVI.fDeclaration = currDecl;</b>
<b class="nc"><i>3247</i>&nbsp;                    attrPSVI.fTypeDecl = currDecl.fType;</b>
<b class="nc"><i>3248</i>&nbsp;                    attrPSVI.fValue.copyFrom(defaultValue);</b>
<b class="nc"><i>3249</i>&nbsp;                    attrPSVI.fValidationContext = fValidationRoot;</b>
<b class="nc"><i>3250</i>&nbsp;                    attrPSVI.fValidity = AttributePSVI.VALIDITY_VALID;</b>
<b class="nc"><i>3251</i>&nbsp;                    attrPSVI.fValidationAttempted = AttributePSVI.VALIDATION_FULL;</b>
<i>3252</i>&nbsp;                    attrPSVI.fSpecified = true;
<b class="nc"><i>3253</i>&nbsp;                }</b>
<b class="nc"><i>3254</i>&nbsp;            }</b>
<b class="nc"><i>3255</i>&nbsp;</b>
<b class="nc"><i>3256</i>&nbsp;        } // for</b>
<b class="nc"><i>3257</i>&nbsp;    } // addDefaultAttributes</b>
<i>3258</i>&nbsp;
<b class="nc"><i>3259</i>&nbsp;    /**</b>
<i>3260</i>&nbsp;     *  If there is not text content, and there is a
<b class="nc"><i>3261</i>&nbsp;     *  {value constraint} on the corresponding element decl, then return</b>
<i>3262</i>&nbsp;     *  an XMLString representing the default value.
<i>3263</i>&nbsp;     */
<i>3264</i>&nbsp;    void processElementContent(QName element) {
<b class="nc"><i>3265</i>&nbsp;        // 1 If the item is ?valid? with respect to an element declaration as per Element Locally Valid (Element) (?3.3.4) and the {value constraint} is present, but clause 3.2 of Element Locally Valid (Element) (?3.3.4) above is not satisfied and the item has no element or character information item [children], then schema. Furthermore, the post-schema-validation infoset has the canonical lexical representation of the {value constraint} value as the item&#39;s [schema normalized value] property.</b>
<i>3266</i>&nbsp;        if (fCurrentElemDecl != null
<i>3267</i>&nbsp;            &amp;&amp; fCurrentElemDecl.fDefault != null
<i>3268</i>&nbsp;            &amp;&amp; !fSawText
<i>3269</i>&nbsp;            &amp;&amp; !fSubElement
<b class="nc"><i>3270</i>&nbsp;            &amp;&amp; !fNil) {</b>
<b class="nc"><i>3271</i>&nbsp;</b>
<i>3272</i>&nbsp;            String strv = fCurrentElemDecl.fDefault.stringValue();
<i>3273</i>&nbsp;            int bufLen = strv.length();
<b class="nc"><i>3274</i>&nbsp;            if (fNormalizedStr.ch == null || fNormalizedStr.ch.length &lt; bufLen) {</b>
<b class="nc"><i>3275</i>&nbsp;                fNormalizedStr.ch = new char[bufLen];</b>
<i>3276</i>&nbsp;            }
<i>3277</i>&nbsp;            strv.getChars(0, bufLen, fNormalizedStr.ch, 0);
<b class="nc"><i>3278</i>&nbsp;            fNormalizedStr.offset = 0;</b>
<b class="nc"><i>3279</i>&nbsp;            fNormalizedStr.length = bufLen;</b>
<i>3280</i>&nbsp;            fDefaultValue = fNormalizedStr;
<i>3281</i>&nbsp;        }
<b class="nc"><i>3282</i>&nbsp;        // fixed values are handled later, after xsi:type determined.</b>
<i>3283</i>&nbsp;
<i>3284</i>&nbsp;        fValidatedInfo.normalizedValue = null;
<i>3285</i>&nbsp;
<b class="nc"><i>3286</i>&nbsp;        // Element Locally Valid (Element)</b>
<b class="nc"><i>3287</i>&nbsp;        // 3.2.1 The element information item must have no character or element information item [children].</b>
<b class="nc"><i>3288</i>&nbsp;        if (fNil) {</b>
<b class="nc"><i>3289</i>&nbsp;            if (fSubElement || fSawText) {</b>
<b class="nc"><i>3290</i>&nbsp;                reportSchemaError(</b>
<b class="nc"><i>3291</i>&nbsp;                    &quot;cvc-elt.3.2.1&quot;,</b>
<i>3292</i>&nbsp;                    new Object[] {
<b class="nc"><i>3293</i>&nbsp;                        element.rawname,</b>
<b class="nc"><i>3294</i>&nbsp;                        SchemaSymbols.URI_XSI + &quot;,&quot; + SchemaSymbols.XSI_NIL });</b>
<i>3295</i>&nbsp;            }
<i>3296</i>&nbsp;        }
<i>3297</i>&nbsp;
<i>3298</i>&nbsp;        this.fValidatedInfo.reset();
<i>3299</i>&nbsp;
<i>3300</i>&nbsp;        // 5 The appropriate case among the following must be true:
<i>3301</i>&nbsp;        // 5.1 If the declaration has a {value constraint}, the item has neither element nor character [children] and clause 3.2 has not applied, then all of the following must be true:
<i>3302</i>&nbsp;        if (fCurrentElemDecl != null
<i>3303</i>&nbsp;            &amp;&amp; fCurrentElemDecl.getConstraintType() != XSConstants.VC_NONE
<i>3304</i>&nbsp;            &amp;&amp; !fSubElement
<i>3305</i>&nbsp;            &amp;&amp; !fSawText
<i>3306</i>&nbsp;            &amp;&amp; !fNil) {
<i>3307</i>&nbsp;            // 5.1.1 If the actual type definition is a local type definition then the canonical lexical representation of the {value constraint} value must be a valid default for the actual type definition as defined in Element Default Valid (Immediate) (3.3.6).
<i>3308</i>&nbsp;            if (fCurrentType != fCurrentElemDecl.fType) {
<i>3309</i>&nbsp;                //REVISIT:we should pass ValidatedInfo here.
<i>3310</i>&nbsp;                if (XSConstraints
<i>3311</i>&nbsp;                    .ElementDefaultValidImmediate(
<i>3312</i>&nbsp;                        fCurrentType,
<b class="nc"><i>3313</i>&nbsp;                        fCurrentElemDecl.fDefault.stringValue(),</b>
<i>3314</i>&nbsp;                        fState4XsiType,
<i>3315</i>&nbsp;                        null)
<i>3316</i>&nbsp;                    == null)
<i>3317</i>&nbsp;                    reportSchemaError(
<i>3318</i>&nbsp;                        &quot;cvc-elt.5.1.1&quot;,
<b class="nc"><i>3319</i>&nbsp;                        new Object[] {</b>
<i>3320</i>&nbsp;                            element.rawname,
<i>3321</i>&nbsp;                            fCurrentType.getName(),
<i>3322</i>&nbsp;                            fCurrentElemDecl.fDefault.stringValue()});
<i>3323</i>&nbsp;            }
<i>3324</i>&nbsp;            // 5.1.2 The element information item with the canonical lexical representation of the {value constraint} value used as its normalized value must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4).
<b class="nc"><i>3325</i>&nbsp;            // REVISIT: don&#39;t use toString, but validateActualValue instead</b>
<i>3326</i>&nbsp;            //          use the fState4ApplyDefault
<i>3327</i>&nbsp;            elementLocallyValidType(element, fCurrentElemDecl.fDefault.stringValue());
<i>3328</i>&nbsp;        } else {
<i>3329</i>&nbsp;            // The following method call also deal with clause 1.2.2 of the constraint
<i>3330</i>&nbsp;            // Validation Rule: Schema-Validity Assessment (Element)
<i>3331</i>&nbsp;
<i>3332</i>&nbsp;            // 5.2 If the declaration has no {value constraint} or the item has either element or character [children] or clause 3.2 has applied, then all of the following must be true:
<i>3333</i>&nbsp;            // 5.2.1 The element information item must be valid with respect to the actual type definition as defined by Element Locally Valid (Type) (3.3.4).
<b class="nc"><i>3334</i>&nbsp;            Object actualValue = elementLocallyValidType(element, fBuffer);</b>
<b class="nc"><i>3335</i>&nbsp;            // 5.2.2 If there is a fixed {value constraint} and clause 3.2 has not applied, all of the following must be true:</b>
<i>3336</i>&nbsp;            if (fCurrentElemDecl != null
<b class="nc"><i>3337</i>&nbsp;                &amp;&amp; fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED</b>
<b class="nc"><i>3338</i>&nbsp;                &amp;&amp; !fNil) {</b>
<i>3339</i>&nbsp;                String content = fBuffer.toString();
<i>3340</i>&nbsp;                // 5.2.2.1 The element information item must have no element information item [children].
<i>3341</i>&nbsp;                if (fSubElement)
<i>3342</i>&nbsp;                    reportSchemaError(&quot;cvc-elt.5.2.2.1&quot;, new Object[] { element.rawname });
<b class="nc"><i>3343</i>&nbsp;                // 5.2.2.2 The appropriate case among the following must be true:</b>
<i>3344</i>&nbsp;                if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<i>3345</i>&nbsp;                    XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;
<i>3346</i>&nbsp;                    // 5.2.2.2.1 If the {content type} of the actual type definition is mixed, then the initial value of the item must match the canonical lexical representation of the {value constraint} value.
<i>3347</i>&nbsp;                    if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_MIXED) {
<b class="nc"><i>3348</i>&nbsp;                        // REVISIT: how to get the initial value, does whiteSpace count?</b>
<i>3349</i>&nbsp;                        if (!fCurrentElemDecl.fDefault.normalizedValue.equals(content))
<i>3350</i>&nbsp;                            reportSchemaError(
<i>3351</i>&nbsp;                                &quot;cvc-elt.5.2.2.2.1&quot;,
<i>3352</i>&nbsp;                                new Object[] {
<b class="nc"><i>3353</i>&nbsp;                                    element.rawname,</b>
<b class="nc"><i>3354</i>&nbsp;                                    content,</b>
<i>3355</i>&nbsp;                                    fCurrentElemDecl.fDefault.normalizedValue });
<i>3356</i>&nbsp;                    }
<i>3357</i>&nbsp;                    // 5.2.2.2.2 If the {content type} of the actual type definition is a simple type definition, then the actual value of the item must match the canonical lexical representation of the {value constraint} value.
<i>3358</i>&nbsp;                    else if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {
<b class="nc"><i>3359</i>&nbsp;                        if (actualValue != null &amp;&amp; (!ValidatedInfo.isComparable(fValidatedInfo, fCurrentElemDecl.fDefault)</b>
<i>3360</i>&nbsp;                                || !actualValue.equals(fCurrentElemDecl.fDefault.actualValue))) {
<i>3361</i>&nbsp;                            reportSchemaError(
<i>3362</i>&nbsp;                                &quot;cvc-elt.5.2.2.2.2&quot;,
<i>3363</i>&nbsp;                                new Object[] {
<b class="nc"><i>3364</i>&nbsp;                                    element.rawname,</b>
<i>3365</i>&nbsp;                                    content,
<i>3366</i>&nbsp;                                    fCurrentElemDecl.fDefault.stringValue()});
<i>3367</i>&nbsp;                        }
<i>3368</i>&nbsp;                    }
<b class="nc"><i>3369</i>&nbsp;                } else if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {</b>
<i>3370</i>&nbsp;                    if (actualValue != null &amp;&amp; (!ValidatedInfo.isComparable(fValidatedInfo, fCurrentElemDecl.fDefault)
<i>3371</i>&nbsp;                            || !actualValue.equals(fCurrentElemDecl.fDefault.actualValue))) {
<i>3372</i>&nbsp;                        // REVISIT: the spec didn&#39;t mention this case: fixed
<i>3373</i>&nbsp;                        //          value with simple type
<i>3374</i>&nbsp;                        reportSchemaError(
<i>3375</i>&nbsp;                            &quot;cvc-elt.5.2.2.2.2&quot;,
<i>3376</i>&nbsp;                            new Object[] {
<i>3377</i>&nbsp;                                element.rawname,
<b class="nc"><i>3378</i>&nbsp;                                content,</b>
<b class="nc"><i>3379</i>&nbsp;                                fCurrentElemDecl.fDefault.stringValue()});</b>
<b class="nc"><i>3380</i>&nbsp;                    }</b>
<b class="nc"><i>3381</i>&nbsp;                }</b>
<i>3382</i>&nbsp;            }
<i>3383</i>&nbsp;        }
<i>3384</i>&nbsp;
<i>3385</i>&nbsp;        if (fDefaultValue == null &amp;&amp; fNormalizeData &amp;&amp; fDocumentHandler != null &amp;&amp; fUnionType) {
<i>3386</i>&nbsp;            // for union types we need to send data because we delayed sending
<i>3387</i>&nbsp;            // this data when we received it in the characters() call.
<i>3388</i>&nbsp;            String content = fValidatedInfo.normalizedValue;
<i>3389</i>&nbsp;            if (content == null)
<i>3390</i>&nbsp;                content = fBuffer.toString();
<i>3391</i>&nbsp;
<i>3392</i>&nbsp;            int bufLen = content.length();
<i>3393</i>&nbsp;            if (fNormalizedStr.ch == null || fNormalizedStr.ch.length &lt; bufLen) {
<i>3394</i>&nbsp;                fNormalizedStr.ch = new char[bufLen];
<i>3395</i>&nbsp;            }
<i>3396</i>&nbsp;            content.getChars(0, bufLen, fNormalizedStr.ch, 0);
<i>3397</i>&nbsp;            fNormalizedStr.offset = 0;
<i>3398</i>&nbsp;            fNormalizedStr.length = bufLen;
<i>3399</i>&nbsp;            fDocumentHandler.characters(fNormalizedStr, null);
<i>3400</i>&nbsp;        }
<i>3401</i>&nbsp;    } // processElementContent
<i>3402</i>&nbsp;
<b class="nc"><i>3403</i>&nbsp;    Object elementLocallyValidType(QName element, Object textContent) {</b>
<b class="nc"><i>3404</i>&nbsp;        if (fCurrentType == null)</b>
<i>3405</i>&nbsp;            return null;
<b class="nc"><i>3406</i>&nbsp;</b>
<b class="nc"><i>3407</i>&nbsp;        Object retValue = null;</b>
<b class="nc"><i>3408</i>&nbsp;        // Element Locally Valid (Type)</b>
<i>3409</i>&nbsp;        // 3 The appropriate case among the following must be true:
<i>3410</i>&nbsp;        // 3.1 If the type definition is a simple type definition, then all of the following must be true:
<i>3411</i>&nbsp;        if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {
<i>3412</i>&nbsp;            // 3.1.2 The element information item must have no element information item [children].
<i>3413</i>&nbsp;            if (fSubElement)
<b class="nc"><i>3414</i>&nbsp;                reportSchemaError(&quot;cvc-type.3.1.2&quot;, new Object[] { element.rawname });</b>
<b class="nc"><i>3415</i>&nbsp;            // 3.1.3 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the normalized value must be valid with respect to the type definition as defined by String Valid (3.14.4).</b>
<b class="nc"><i>3416</i>&nbsp;            if (!fNil) {</b>
<i>3417</i>&nbsp;                XSSimpleType dv = (XSSimpleType) fCurrentType;
<b class="nc"><i>3418</i>&nbsp;                try {</b>
<b class="nc"><i>3419</i>&nbsp;                    if (!fNormalizeData || fUnionType) {</b>
<b class="nc"><i>3420</i>&nbsp;                        fValidationState.setNormalizationRequired(true);</b>
<i>3421</i>&nbsp;                    }
<b class="nc"><i>3422</i>&nbsp;                    retValue = dv.validate(textContent, fValidationState, fValidatedInfo);</b>
<b class="nc"><i>3423</i>&nbsp;                } catch (InvalidDatatypeValueException e) {</b>
<b class="nc"><i>3424</i>&nbsp;                    reportSchemaError(e.getKey(), e.getArgs());</b>
<i>3425</i>&nbsp;                    reportSchemaError(
<i>3426</i>&nbsp;                        &quot;cvc-type.3.1.3&quot;,
<b class="nc"><i>3427</i>&nbsp;                        new Object[] { element.rawname, textContent });</b>
<i>3428</i>&nbsp;                }
<i>3429</i>&nbsp;            }
<i>3430</i>&nbsp;        } else {
<i>3431</i>&nbsp;            // 3.2 If the type definition is a complex type definition, then the element information item must be valid with respect to the type definition as per Element Locally Valid (Complex Type) (3.4.4);
<i>3432</i>&nbsp;            retValue = elementLocallyValidComplexType(element, textContent);
<i>3433</i>&nbsp;        }
<b class="nc"><i>3434</i>&nbsp;</b>
<b class="nc"><i>3435</i>&nbsp;        return retValue;</b>
<b class="nc"><i>3436</i>&nbsp;    } // elementLocallyValidType</b>
<b class="nc"><i>3437</i>&nbsp;</b>
<b class="nc"><i>3438</i>&nbsp;    Object elementLocallyValidComplexType(QName element, Object textContent) {</b>
<b class="nc"><i>3439</i>&nbsp;        Object actualValue = null;</b>
<b class="nc"><i>3440</i>&nbsp;        XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;</b>
<b class="nc"><i>3441</i>&nbsp;</b>
<b class="nc"><i>3442</i>&nbsp;        // Element Locally Valid (Complex Type)</b>
<i>3443</i>&nbsp;        // For an element information item to be locally valid with respect to a complex type definition all of the following must be true:
<i>3444</i>&nbsp;        // 1 {abstract} is false.
<i>3445</i>&nbsp;        // 2 If clause 3.2 of Element Locally Valid (Element) (3.3.4) did not apply, then the appropriate case among the following must be true:
<i>3446</i>&nbsp;        if (!fNil) {
<i>3447</i>&nbsp;            // 2.1 If the {content type} is empty, then the element information item has no character or element information item [children].
<i>3448</i>&nbsp;            if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_EMPTY
<i>3449</i>&nbsp;                &amp;&amp; (fSubElement || fSawText)) {
<i>3450</i>&nbsp;                reportSchemaError(&quot;cvc-complex-type.2.1&quot;, new Object[] { element.rawname });
<i>3451</i>&nbsp;            }
<i>3452</i>&nbsp;            // 2.2 If the {content type} is a simple type definition, then the element information item has no element information item [children], and the normalized value of the element information item is valid with respect to that simple type definition as defined by String Valid (3.14.4).
<b class="nc"><i>3453</i>&nbsp;            else if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {</b>
<b class="nc"><i>3454</i>&nbsp;                if (fSubElement)</b>
<b class="nc"><i>3455</i>&nbsp;                    reportSchemaError(&quot;cvc-complex-type.2.2&quot;, new Object[] { element.rawname });</b>
<b class="nc"><i>3456</i>&nbsp;                XSSimpleType dv = ctype.fXSSimpleType;</b>
<b class="nc"><i>3457</i>&nbsp;                try {</b>
<b class="nc"><i>3458</i>&nbsp;                    if (!fNormalizeData || fUnionType) {</b>
<b class="nc"><i>3459</i>&nbsp;                        fValidationState.setNormalizationRequired(true);</b>
<b class="nc"><i>3460</i>&nbsp;                    }</b>
<b class="nc"><i>3461</i>&nbsp;                    actualValue = dv.validate(textContent, fValidationState, fValidatedInfo);</b>
<b class="nc"><i>3462</i>&nbsp;                } catch (InvalidDatatypeValueException e) {</b>
<i>3463</i>&nbsp;                    reportSchemaError(e.getKey(), e.getArgs());
<b class="nc"><i>3464</i>&nbsp;                    reportSchemaError(&quot;cvc-complex-type.2.2&quot;, new Object[] { element.rawname });</b>
<b class="nc"><i>3465</i>&nbsp;                }</b>
<i>3466</i>&nbsp;                // REVISIT: eventually, this method should return the same actualValue as elementLocallyValidType...
<i>3467</i>&nbsp;                // obviously it&#39;ll return null when the content is complex.
<i>3468</i>&nbsp;            }
<i>3469</i>&nbsp;            // 2.3 If the {content type} is element-only, then the element information item has no character information item [children] other than those whose [character code] is defined as a white space in [XML 1.0 (Second Edition)].
<i>3470</i>&nbsp;            else if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT) {
<b class="nc"><i>3471</i>&nbsp;                if (fSawCharacters) {</b>
<b class="nc"><i>3472</i>&nbsp;                    reportSchemaError(&quot;cvc-complex-type.2.3&quot;, new Object[] { element.rawname });</b>
<i>3473</i>&nbsp;                }
<i>3474</i>&nbsp;            }
<i>3475</i>&nbsp;            // 2.4 If the {content type} is element-only or mixed, then the sequence of the element information item&#39;s element information item [children], if any, taken in order, is valid with respect to the {content type}&#39;s particle, as defined in Element Sequence Locally Valid (Particle) (3.9.4).
<i>3476</i>&nbsp;            if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_ELEMENT
<i>3477</i>&nbsp;                || ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_MIXED) {
<b class="nc"><i>3478</i>&nbsp;                // if the current state is a valid state, check whether</b>
<b class="nc"><i>3479</i>&nbsp;                // it&#39;s one of the final states.</b>
<b class="nc"><i>3480</i>&nbsp;                if (DEBUG) {</b>
<b class="nc"><i>3481</i>&nbsp;                    System.out.println(fCurrCMState);</b>
<b class="nc"><i>3482</i>&nbsp;                }</b>
<i>3483</i>&nbsp;                if (fCurrCMState[0] &gt;= 0 &amp;&amp; !fCurrentCM.endContentModel(fCurrCMState)) {
<i>3484</i>&nbsp;                    String expected = expectedStr(fCurrentCM.whatCanGoHere(fCurrCMState));
<i>3485</i>&nbsp;                    final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);
<i>3486</i>&nbsp;                    if (occurenceInfo != null) {
<i>3487</i>&nbsp;                        final int minOccurs = occurenceInfo[0];
<i>3488</i>&nbsp;                        final int count = occurenceInfo[2];
<b class="nc"><i>3489</i>&nbsp;                        // Check if this is a violation of minOccurs</b>
<b class="nc"><i>3490</i>&nbsp;                        if (count &lt; minOccurs) {</b>
<b class="nc"><i>3491</i>&nbsp;                            final int required = minOccurs - count;</b>
<b class="nc"><i>3492</i>&nbsp;                            if (required &gt; 1) {</b>
<b class="nc"><i>3493</i>&nbsp;                                reportSchemaError(&quot;cvc-complex-type.2.4.j&quot;, new Object[] { element.rawname,</b>
<b class="nc"><i>3494</i>&nbsp;                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs), Integer.toString(required) });</b>
<i>3495</i>&nbsp;                            }
<i>3496</i>&nbsp;                            else {
<i>3497</i>&nbsp;                                reportSchemaError(&quot;cvc-complex-type.2.4.i&quot;, new Object[] { element.rawname,
<i>3498</i>&nbsp;                                        fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs) });
<i>3499</i>&nbsp;                            }
<i>3500</i>&nbsp;                        }
<i>3501</i>&nbsp;                        else {
<i>3502</i>&nbsp;                            reportSchemaError(&quot;cvc-complex-type.2.4.b&quot;, new Object[] { element.rawname, expected });
<i>3503</i>&nbsp;                        }
<i>3504</i>&nbsp;                    }
<b class="nc"><i>3505</i>&nbsp;                    else {</b>
<b class="nc"><i>3506</i>&nbsp;                        reportSchemaError(&quot;cvc-complex-type.2.4.b&quot;, new Object[] { element.rawname, expected });</b>
<b class="nc"><i>3507</i>&nbsp;                    }</b>
<b class="nc"><i>3508</i>&nbsp;                } else {</b>
<b class="nc"><i>3509</i>&nbsp;                    // Constant space algorithm for a{n,m} for n &gt; 1 and m &lt;= unbounded</b>
<b class="nc"><i>3510</i>&nbsp;                    // After the DFA has completed, check minOccurs and maxOccurs</b>
<b class="nc"><i>3511</i>&nbsp;                    // for all elements and wildcards in this content model where</b>
<i>3512</i>&nbsp;                    // a{n,m} is subsumed to a* or a+
<i>3513</i>&nbsp;                    List&lt;String&gt; errors = fCurrentCM.checkMinMaxBounds();
<i>3514</i>&nbsp;                    if (errors != null) {
<i>3515</i>&nbsp;                        for (int i = 0; i &lt; errors.size(); i += 2) {
<i>3516</i>&nbsp;                            reportSchemaError(errors.get(i),
<i>3517</i>&nbsp;                                new Object[] { element.rawname, errors.get(i + 1) });
<i>3518</i>&nbsp;                        }
<i>3519</i>&nbsp;                    }
<i>3520</i>&nbsp;                }
<i>3521</i>&nbsp;            }
<i>3522</i>&nbsp;        }
<i>3523</i>&nbsp;        return actualValue;
<i>3524</i>&nbsp;    } // elementLocallyValidComplexType
<i>3525</i>&nbsp;
<i>3526</i>&nbsp;    void processRootTypeQName(final javax.xml.namespace.QName rootTypeQName) {
<i>3527</i>&nbsp;        String rootTypeNamespace = rootTypeQName.getNamespaceURI();
<i>3528</i>&nbsp;        // Add namespace to symbol table, to make sure it&#39;s interned.
<i>3529</i>&nbsp;        // This namespace may be later compared with other values using ==.
<i>3530</i>&nbsp;        rootTypeNamespace = fSymbolTable.addSymbol(rootTypeNamespace);
<i>3531</i>&nbsp;        if (rootTypeNamespace != null &amp;&amp; rootTypeNamespace.equals(XMLConstants.NULL_NS_URI)) {
<i>3532</i>&nbsp;            rootTypeNamespace = null;
<i>3533</i>&nbsp;        }
<i>3534</i>&nbsp;        if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(rootTypeNamespace)) {
<i>3535</i>&nbsp;            fCurrentType = SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(rootTypeQName.getLocalPart());
<i>3536</i>&nbsp;        }
<i>3537</i>&nbsp;        else {
<i>3538</i>&nbsp;            final SchemaGrammar grammarForRootType = findSchemaGrammar(
<i>3539</i>&nbsp;                    XSDDescription.CONTEXT_ELEMENT, rootTypeNamespace, null, null, null);
<i>3540</i>&nbsp;            if (grammarForRootType != null) {
<i>3541</i>&nbsp;                fCurrentType = grammarForRootType.getGlobalTypeDecl(rootTypeQName.getLocalPart());
<i>3542</i>&nbsp;            }
<b class="nc"><i>3543</i>&nbsp;        }</b>
<i>3544</i>&nbsp;        if (fCurrentType == null) {
<i>3545</i>&nbsp;            String typeName = (rootTypeQName.getPrefix().equals(XMLConstants.DEFAULT_NS_PREFIX)) ?
<i>3546</i>&nbsp;                    rootTypeQName.getLocalPart() :
<i>3547</i>&nbsp;                        rootTypeQName.getPrefix()+&quot;:&quot;+rootTypeQName.getLocalPart();
<i>3548</i>&nbsp;                    reportSchemaError(&quot;cvc-type.1&quot;, new Object[] {typeName});
<i>3549</i>&nbsp;        }
<i>3550</i>&nbsp;    } // processRootTypeQName
<i>3551</i>&nbsp;
<i>3552</i>&nbsp;    void processRootElementDeclQName(final javax.xml.namespace.QName rootElementDeclQName, final QName element) {
<i>3553</i>&nbsp;        String rootElementDeclNamespace = rootElementDeclQName.getNamespaceURI();
<i>3554</i>&nbsp;        // Add namespace to symbol table, to make sure it&#39;s interned.
<i>3555</i>&nbsp;        // This namespace may be later compared with other values using ==.
<b class="nc"><i>3556</i>&nbsp;        rootElementDeclNamespace = fSymbolTable.addSymbol(rootElementDeclNamespace);</b>
<b class="nc"><i>3557</i>&nbsp;        if (rootElementDeclNamespace != null &amp;&amp; rootElementDeclNamespace.equals(XMLConstants.NULL_NS_URI)) {</b>
<b class="nc"><i>3558</i>&nbsp;            rootElementDeclNamespace = null;</b>
<i>3559</i>&nbsp;        }
<i>3560</i>&nbsp;        final SchemaGrammar grammarForRootElement = findSchemaGrammar(
<i>3561</i>&nbsp;                XSDDescription.CONTEXT_ELEMENT, rootElementDeclNamespace, null, null, null);
<b class="nc"><i>3562</i>&nbsp;        if (grammarForRootElement != null) {</b>
<b class="nc"><i>3563</i>&nbsp;            fCurrentElemDecl = grammarForRootElement.getGlobalElementDecl(rootElementDeclQName.getLocalPart());</b>
<b class="nc"><i>3564</i>&nbsp;        }</b>
<b class="nc"><i>3565</i>&nbsp;        if (fCurrentElemDecl == null) {</b>
<b class="nc"><i>3566</i>&nbsp;            String declName = (rootElementDeclQName.getPrefix().equals(XMLConstants.DEFAULT_NS_PREFIX)) ?</b>
<i>3567</i>&nbsp;                    rootElementDeclQName.getLocalPart() :
<i>3568</i>&nbsp;                        rootElementDeclQName.getPrefix()+&quot;:&quot;+rootElementDeclQName.getLocalPart();
<b class="nc"><i>3569</i>&nbsp;                    reportSchemaError(&quot;cvc-elt.1.a&quot;, new Object[] {declName});</b>
<b class="nc"><i>3570</i>&nbsp;        }</b>
<b class="nc"><i>3571</i>&nbsp;        else {</b>
<b class="nc"><i>3572</i>&nbsp;            checkElementMatchesRootElementDecl(fCurrentElemDecl, element);</b>
<b class="nc"><i>3573</i>&nbsp;        }</b>
<b class="nc"><i>3574</i>&nbsp;    } // processRootElementDeclQName</b>
<i>3575</i>&nbsp;
<b class="nc"><i>3576</i>&nbsp;    void checkElementMatchesRootElementDecl(final XSElementDecl rootElementDecl, final QName element) {</b>
<b class="nc"><i>3577</i>&nbsp;        // Report an error if the name of the element does</b>
<b class="nc"><i>3578</i>&nbsp;        // not match the name of the specified element declaration.</b>
<b class="nc"><i>3579</i>&nbsp;        if (element.localpart != rootElementDecl.fName ||</b>
<b class="nc"><i>3580</i>&nbsp;            element.uri != rootElementDecl.fTargetNamespace) {</b>
<i>3581</i>&nbsp;            reportSchemaError(&quot;cvc-elt.1.b&quot;, new Object[] {element.rawname, rootElementDecl.fName});
<b class="nc"><i>3582</i>&nbsp;        }</b>
<b class="nc"><i>3583</i>&nbsp;    } // checkElementMatchesRootElementDecl</b>
<b class="nc"><i>3584</i>&nbsp;</b>
<b class="nc"><i>3585</i>&nbsp;    void reportSchemaError(String key, Object[] arguments) {</b>
<i>3586</i>&nbsp;        if (fDoValidation)
<i>3587</i>&nbsp;            fXSIErrorReporter.reportError(
<i>3588</i>&nbsp;                XSMessageFormatter.SCHEMA_DOMAIN,
<i>3589</i>&nbsp;                key,
<i>3590</i>&nbsp;                arguments,
<i>3591</i>&nbsp;                XMLErrorReporter.SEVERITY_ERROR);
<i>3592</i>&nbsp;    }
<i>3593</i>&nbsp;
<i>3594</i>&nbsp;    private String expectedStr(List&lt;Object&gt; expected) {
<i>3595</i>&nbsp;        StringBuilder ret = new StringBuilder(&quot;{&quot;);
<b class="nc"><i>3596</i>&nbsp;        int size = expected.size();</b>
<b class="nc"><i>3597</i>&nbsp;        for (int i = 0; i &lt; size; i++) {</b>
<b class="nc"><i>3598</i>&nbsp;            if (i &gt; 0)</b>
<b class="nc"><i>3599</i>&nbsp;                ret.append(&quot;, &quot;);</b>
<b class="nc"><i>3600</i>&nbsp;            ret.append(expected.get(i).toString());</b>
<b class="nc"><i>3601</i>&nbsp;        }</b>
<b class="nc"><i>3602</i>&nbsp;        ret.append(&#39;}&#39;);</b>
<b class="nc"><i>3603</i>&nbsp;        return ret.toString();</b>
<b class="nc"><i>3604</i>&nbsp;    }</b>
<b class="nc"><i>3605</i>&nbsp;</b>
<b class="nc"><i>3606</i>&nbsp;    /**********************************/</b>
<i>3607</i>&nbsp;
<b class="nc"><i>3608</i>&nbsp;    // xpath matcher information</b>
<b class="nc"><i>3609</i>&nbsp;</b>
<b class="nc"><i>3610</i>&nbsp;    /**</b>
<b class="nc"><i>3611</i>&nbsp;     * Stack of XPath matchers for identity constraints.</b>
<b class="nc"><i>3612</i>&nbsp;     *</b>
<i>3613</i>&nbsp;     * @author Andy Clark, IBM
<b class="nc"><i>3614</i>&nbsp;     */</b>
<i>3615</i>&nbsp;    protected static class XPathMatcherStack {
<i>3616</i>&nbsp;
<b class="nc"><i>3617</i>&nbsp;        //</b>
<i>3618</i>&nbsp;        // Data
<i>3619</i>&nbsp;        //
<b class="nc"><i>3620</i>&nbsp;</b>
<i>3621</i>&nbsp;        /** Active matchers. */
<i>3622</i>&nbsp;        protected XPathMatcher[] fMatchers = new XPathMatcher[4];
<i>3623</i>&nbsp;
<i>3624</i>&nbsp;        /** Count of active matchers. */
<i>3625</i>&nbsp;        protected int fMatchersCount;
<i>3626</i>&nbsp;
<i>3627</i>&nbsp;        /** Offset stack for contexts. */
<i>3628</i>&nbsp;        protected IntStack fContextStack = new IntStack();
<i>3629</i>&nbsp;
<b class="nc"><i>3630</i>&nbsp;        //</b>
<b class="nc"><i>3631</i>&nbsp;        // Constructors</b>
<b class="nc"><i>3632</i>&nbsp;        //</b>
<b class="nc"><i>3633</i>&nbsp;</b>
<b class="nc"><i>3634</i>&nbsp;        public XPathMatcherStack() {</b>
<b class="nc"><i>3635</i>&nbsp;        } // &lt;init&gt;()</b>
<b class="nc"><i>3636</i>&nbsp;</b>
<i>3637</i>&nbsp;        //
<b class="nc"><i>3638</i>&nbsp;        // Public methods</b>
<b class="nc"><i>3639</i>&nbsp;        //</b>
<b class="nc"><i>3640</i>&nbsp;</b>
<b class="nc"><i>3641</i>&nbsp;        /** Resets the XPath matcher stack. */</b>
<i>3642</i>&nbsp;        public void clear() {
<i>3643</i>&nbsp;            for (int i = 0; i &lt; fMatchersCount; i++) {
<i>3644</i>&nbsp;                fMatchers[i] = null;
<i>3645</i>&nbsp;            }
<i>3646</i>&nbsp;            fMatchersCount = 0;
<i>3647</i>&nbsp;            fContextStack.clear();
<b class="nc"><i>3648</i>&nbsp;        } // clear()</b>
<i>3649</i>&nbsp;
<b class="nc"><i>3650</i>&nbsp;        /** Returns the size of the stack. */</b>
<i>3651</i>&nbsp;        public int size() {
<b class="nc"><i>3652</i>&nbsp;            return fContextStack.size();</b>
<b class="nc"><i>3653</i>&nbsp;        } // size():int</b>
<b class="nc"><i>3654</i>&nbsp;</b>
<b class="nc"><i>3655</i>&nbsp;        /** Returns the count of XPath matchers. */</b>
<b class="nc"><i>3656</i>&nbsp;        public int getMatcherCount() {</b>
<b class="nc"><i>3657</i>&nbsp;            return fMatchersCount;</b>
<b class="nc"><i>3658</i>&nbsp;        } // getMatcherCount():int</b>
<b class="nc"><i>3659</i>&nbsp;</b>
<i>3660</i>&nbsp;        /** Adds a matcher. */
<b class="nc"><i>3661</i>&nbsp;        public void addMatcher(XPathMatcher matcher) {</b>
<b class="nc"><i>3662</i>&nbsp;            ensureMatcherCapacity();</b>
<b class="nc"><i>3663</i>&nbsp;            fMatchers[fMatchersCount++] = matcher;</b>
<b class="nc"><i>3664</i>&nbsp;        } // addMatcher(XPathMatcher)</b>
<b class="nc"><i>3665</i>&nbsp;</b>
<i>3666</i>&nbsp;        /** Returns the XPath matcher at the specified index. */
<i>3667</i>&nbsp;        public XPathMatcher getMatcherAt(int index) {
<i>3668</i>&nbsp;            return fMatchers[index];
<b class="nc"><i>3669</i>&nbsp;        } // getMatcherAt(index):XPathMatcher</b>
<i>3670</i>&nbsp;
<b class="nc"><i>3671</i>&nbsp;        /** Pushes a new context onto the stack. */</b>
<i>3672</i>&nbsp;        public void pushContext() {
<i>3673</i>&nbsp;            fContextStack.push(fMatchersCount);
<b class="nc"><i>3674</i>&nbsp;        } // pushContext()</b>
<i>3675</i>&nbsp;
<i>3676</i>&nbsp;        /** Pops a context off of the stack. */
<i>3677</i>&nbsp;        public void popContext() {
<i>3678</i>&nbsp;            fMatchersCount = fContextStack.pop();
<i>3679</i>&nbsp;        } // popContext()
<i>3680</i>&nbsp;
<i>3681</i>&nbsp;        //
<i>3682</i>&nbsp;        // Private methods
<i>3683</i>&nbsp;        //
<i>3684</i>&nbsp;
<i>3685</i>&nbsp;        /** Ensures the size of the matchers array. */
<i>3686</i>&nbsp;        private void ensureMatcherCapacity() {
<i>3687</i>&nbsp;            if (fMatchersCount == fMatchers.length) {
<i>3688</i>&nbsp;                XPathMatcher[] array = new XPathMatcher[fMatchers.length * 2];
<i>3689</i>&nbsp;                System.arraycopy(fMatchers, 0, array, 0, fMatchers.length);
<b class="nc"><i>3690</i>&nbsp;                fMatchers = array;</b>
<b class="nc"><i>3691</i>&nbsp;            }</b>
<b class="nc"><i>3692</i>&nbsp;        } // ensureMatcherCapacity()</b>
<i>3693</i>&nbsp;
<i>3694</i>&nbsp;    } // class XPathMatcherStack
<b class="nc"><i>3695</i>&nbsp;</b>
<i>3696</i>&nbsp;    // value store implementations
<i>3697</i>&nbsp;
<b class="nc"><i>3698</i>&nbsp;    /**</b>
<b class="nc"><i>3699</i>&nbsp;     * Value store implementation base class. There are specific subclasses</b>
<b class="nc"><i>3700</i>&nbsp;     * for handling unique, key, and keyref.</b>
<i>3701</i>&nbsp;     *
<b class="nc"><i>3702</i>&nbsp;     * @author Andy Clark, IBM</b>
<i>3703</i>&nbsp;     */
<b class="nc"><i>3704</i>&nbsp;    protected abstract class ValueStoreBase implements ValueStore {</b>
<i>3705</i>&nbsp;
<i>3706</i>&nbsp;        //
<i>3707</i>&nbsp;        // Data
<i>3708</i>&nbsp;        //
<i>3709</i>&nbsp;
<i>3710</i>&nbsp;        /** Identity constraint. */
<i>3711</i>&nbsp;        protected IdentityConstraint fIdentityConstraint;
<b class="nc"><i>3712</i>&nbsp;        protected int fFieldCount = 0;</b>
<b class="nc"><i>3713</i>&nbsp;        protected Field[] fFields = null;</b>
<i>3714</i>&nbsp;        /** current data */
<i>3715</i>&nbsp;        protected Object[] fLocalValues = null;
<i>3716</i>&nbsp;        protected short[] fLocalValueTypes = null;
<b class="nc"><i>3717</i>&nbsp;        protected ShortList[] fLocalItemValueTypes = null;</b>
<b class="nc"><i>3718</i>&nbsp;</b>
<i>3719</i>&nbsp;        /** Current data value count. */
<i>3720</i>&nbsp;        protected int fValuesCount;
<i>3721</i>&nbsp;
<b class="nc"><i>3722</i>&nbsp;        /** global data */</b>
<b class="nc"><i>3723</i>&nbsp;        public final Vector&lt;Object&gt; fValues = new Vector&lt;&gt;();</b>
<b class="nc"><i>3724</i>&nbsp;        public ShortVector fValueTypes = null;</b>
<b class="nc"><i>3725</i>&nbsp;        public Vector&lt;ShortList&gt; fItemValueTypes = null;</b>
<i>3726</i>&nbsp;
<b class="nc"><i>3727</i>&nbsp;        private boolean fUseValueTypeVector = false;</b>
<i>3728</i>&nbsp;        private int fValueTypesLength = 0;
<b class="nc"><i>3729</i>&nbsp;        private short fValueType = 0;</b>
<i>3730</i>&nbsp;
<i>3731</i>&nbsp;        private boolean fUseItemValueTypeVector = false;
<i>3732</i>&nbsp;        private int fItemValueTypesLength = 0;
<i>3733</i>&nbsp;        private ShortList fItemValueType = null;
<i>3734</i>&nbsp;
<i>3735</i>&nbsp;        /** buffer for error messages */
<i>3736</i>&nbsp;        final StringBuilder fTempBuffer = new StringBuilder();
<i>3737</i>&nbsp;
<i>3738</i>&nbsp;        //
<b class="nc"><i>3739</i>&nbsp;        // Constructors</b>
<b class="nc"><i>3740</i>&nbsp;        //</b>
<b class="nc"><i>3741</i>&nbsp;</b>
<b class="nc"><i>3742</i>&nbsp;        /** Constructs a value store for the specified identity constraint. */</b>
<i>3743</i>&nbsp;        protected ValueStoreBase(IdentityConstraint identityConstraint) {
<b class="nc"><i>3744</i>&nbsp;            fIdentityConstraint = identityConstraint;</b>
<b class="nc"><i>3745</i>&nbsp;            fFieldCount = fIdentityConstraint.getFieldCount();</b>
<b class="nc"><i>3746</i>&nbsp;            fFields = new Field[fFieldCount];</b>
<i>3747</i>&nbsp;            fLocalValues = new Object[fFieldCount];
<b class="nc"><i>3748</i>&nbsp;            fLocalValueTypes = new short[fFieldCount];</b>
<i>3749</i>&nbsp;            fLocalItemValueTypes = new ShortList[fFieldCount];
<i>3750</i>&nbsp;            for (int i = 0; i &lt; fFieldCount; i++) {
<i>3751</i>&nbsp;                fFields[i] = fIdentityConstraint.getFieldAt(i);
<i>3752</i>&nbsp;            }
<i>3753</i>&nbsp;        } // &lt;init&gt;(IdentityConstraint)
<i>3754</i>&nbsp;
<i>3755</i>&nbsp;        //
<b class="nc"><i>3756</i>&nbsp;        // Public methods</b>
<b class="nc"><i>3757</i>&nbsp;        //</b>
<i>3758</i>&nbsp;
<b class="nc"><i>3759</i>&nbsp;        // destroys this ValueStore; useful when, for instance, a</b>
<b class="nc"><i>3760</i>&nbsp;        // locally-scoped ID constraint is involved.</b>
<i>3761</i>&nbsp;        public void clear() {
<b class="nc"><i>3762</i>&nbsp;            fValuesCount = 0;</b>
<b class="nc"><i>3763</i>&nbsp;            fUseValueTypeVector = false;</b>
<b class="nc"><i>3764</i>&nbsp;            fValueTypesLength = 0;</b>
<b class="nc"><i>3765</i>&nbsp;            fValueType = 0;</b>
<i>3766</i>&nbsp;            fUseItemValueTypeVector = false;
<b class="nc"><i>3767</i>&nbsp;            fItemValueTypesLength = 0;</b>
<b class="nc"><i>3768</i>&nbsp;            fItemValueType = null;</b>
<i>3769</i>&nbsp;            fValues.setSize(0);
<b class="nc"><i>3770</i>&nbsp;            if (fValueTypes != null) {</b>
<i>3771</i>&nbsp;                fValueTypes.clear();
<i>3772</i>&nbsp;            }
<i>3773</i>&nbsp;            if (fItemValueTypes != null) {
<i>3774</i>&nbsp;                fItemValueTypes.setSize(0);
<b class="nc"><i>3775</i>&nbsp;            }</b>
<b class="nc"><i>3776</i>&nbsp;        } // end clear():void</b>
<i>3777</i>&nbsp;
<b class="nc"><i>3778</i>&nbsp;        // appends the contents of one ValueStore to those of us.</b>
<i>3779</i>&nbsp;        public void append(ValueStoreBase newVal) {
<i>3780</i>&nbsp;            for (int i = 0; i &lt; newVal.fValues.size(); i++) {
<i>3781</i>&nbsp;                fValues.add(newVal.fValues.get(i));
<b class="nc"><i>3782</i>&nbsp;            }</b>
<b class="nc"><i>3783</i>&nbsp;        } // append(ValueStoreBase)</b>
<i>3784</i>&nbsp;
<b class="nc"><i>3785</i>&nbsp;        /** Start scope for value store. */</b>
<i>3786</i>&nbsp;        public void startValueScope() {
<i>3787</i>&nbsp;            fValuesCount = 0;
<i>3788</i>&nbsp;            for (int i = 0; i &lt; fFieldCount; i++) {
<b class="nc"><i>3789</i>&nbsp;                fLocalValues[i] = null;</b>
<b class="nc"><i>3790</i>&nbsp;                fLocalValueTypes[i] = 0;</b>
<i>3791</i>&nbsp;                fLocalItemValueTypes[i] = null;
<b class="nc"><i>3792</i>&nbsp;            }</b>
<b class="nc"><i>3793</i>&nbsp;        } // startValueScope()</b>
<i>3794</i>&nbsp;
<b class="nc"><i>3795</i>&nbsp;        /** Ends scope for value store. */</b>
<b class="nc"><i>3796</i>&nbsp;        public void endValueScope() {</b>
<b class="nc"><i>3797</i>&nbsp;</b>
<b class="nc"><i>3798</i>&nbsp;            if (fValuesCount == 0) {</b>
<b class="nc"><i>3799</i>&nbsp;                if (fIdentityConstraint.getCategory() == IdentityConstraint.IC_KEY) {</b>
<i>3800</i>&nbsp;                    String code = &quot;AbsentKeyValue&quot;;
<b class="nc"><i>3801</i>&nbsp;                    String eName = fIdentityConstraint.getElementName();</b>
<b class="nc"><i>3802</i>&nbsp;                    String cName = fIdentityConstraint.getIdentityConstraintName();</b>
<i>3803</i>&nbsp;                    reportSchemaError(code, new Object[] { eName, cName });
<b class="nc"><i>3804</i>&nbsp;                }</b>
<i>3805</i>&nbsp;                return;
<i>3806</i>&nbsp;            }
<i>3807</i>&nbsp;
<i>3808</i>&nbsp;            // Validation Rule: Identity-constraint Satisfied
<b class="nc"><i>3809</i>&nbsp;            // 4.2 If the {identity-constraint category} is key, then all of the following must be true:</b>
<b class="nc"><i>3810</i>&nbsp;            // 4.2.1 The target node set and the qualified node set are equal, that is, every member of the</b>
<i>3811</i>&nbsp;            // target node set is also a member of the qualified node set and vice versa.
<b class="nc"><i>3812</i>&nbsp;            //</b>
<i>3813</i>&nbsp;            // If the IDC is a key check whether we have all the fields.
<i>3814</i>&nbsp;            if (fValuesCount != fFieldCount) {
<i>3815</i>&nbsp;                if (fIdentityConstraint.getCategory() == IdentityConstraint.IC_KEY) {
<b class="nc"><i>3816</i>&nbsp;                    String code = &quot;KeyNotEnoughValues&quot;;</b>
<b class="nc"><i>3817</i>&nbsp;                    UniqueOrKey key = (UniqueOrKey) fIdentityConstraint;</b>
<i>3818</i>&nbsp;                    String eName = fIdentityConstraint.getElementName();
<b class="nc"><i>3819</i>&nbsp;                    String cName = key.getIdentityConstraintName();</b>
<b class="nc"><i>3820</i>&nbsp;                    reportSchemaError(code, new Object[] { eName, cName });</b>
<i>3821</i>&nbsp;                }
<i>3822</i>&nbsp;                return;
<i>3823</i>&nbsp;            }
<i>3824</i>&nbsp;
<i>3825</i>&nbsp;        } // endValueScope()
<i>3826</i>&nbsp;
<i>3827</i>&nbsp;        // This is needed to allow keyref&#39;s to look for matched keys
<i>3828</i>&nbsp;        // in the correct scope.  Unique and Key may also need to
<i>3829</i>&nbsp;        // override this method for purposes of their own.
<i>3830</i>&nbsp;        // This method is called whenever the DocumentFragment
<i>3831</i>&nbsp;        // of an ID Constraint goes out of scope.
<i>3832</i>&nbsp;        public void endDocumentFragment() {
<i>3833</i>&nbsp;        } // endDocumentFragment():void
<i>3834</i>&nbsp;
<i>3835</i>&nbsp;        /**
<i>3836</i>&nbsp;         * Signals the end of the document. This is where the specific
<b class="nc"><i>3837</i>&nbsp;         * instances of value stores can verify the integrity of the</b>
<b class="nc"><i>3838</i>&nbsp;         * identity constraints.</b>
<i>3839</i>&nbsp;         */
<i>3840</i>&nbsp;        public void endDocument() {
<i>3841</i>&nbsp;        } // endDocument()
<i>3842</i>&nbsp;
<i>3843</i>&nbsp;        //
<i>3844</i>&nbsp;        // ValueStore methods
<i>3845</i>&nbsp;        //
<i>3846</i>&nbsp;
<i>3847</i>&nbsp;        /* reports an error if an element is matched
<i>3848</i>&nbsp;         * has nillable true and is matched by a key.
<i>3849</i>&nbsp;         */
<b class="nc"><i>3850</i>&nbsp;</b>
<b class="nc"><i>3851</i>&nbsp;        public void reportError(String key, Object[] args) {</b>
<b class="nc"><i>3852</i>&nbsp;            reportSchemaError(key, args);</b>
<b class="nc"><i>3853</i>&nbsp;        } // reportError(String,Object[])</b>
<b class="nc"><i>3854</i>&nbsp;</b>
<b class="nc"><i>3855</i>&nbsp;        /**</b>
<i>3856</i>&nbsp;         * Adds the specified value to the value store.
<i>3857</i>&nbsp;         *
<i>3858</i>&nbsp;         * @param field The field associated to the value. This reference
<i>3859</i>&nbsp;         *              is used to ensure that each field only adds a value
<i>3860</i>&nbsp;         *              once within a selection scope.
<i>3861</i>&nbsp;         * @param mayMatch a flag indiciating whether the field may be matched.
<i>3862</i>&nbsp;         * @param actualValue The value to add.
<i>3863</i>&nbsp;         * @param valueType Type of the value to add.
<i>3864</i>&nbsp;         * @param itemValueType If the value is a list, a list of types for each of the values in the list.
<i>3865</i>&nbsp;         */
<i>3866</i>&nbsp;        public void addValue(Field field, boolean mayMatch, Object actualValue, short valueType, ShortList itemValueType) {
<i>3867</i>&nbsp;            int i;
<i>3868</i>&nbsp;            for (i = fFieldCount - 1; i &gt; -1; i--) {
<i>3869</i>&nbsp;                if (fFields[i] == field) {
<i>3870</i>&nbsp;                    break;
<i>3871</i>&nbsp;                }
<i>3872</i>&nbsp;            }
<i>3873</i>&nbsp;            // do we even know this field?
<i>3874</i>&nbsp;            if (i == -1) {
<b class="nc"><i>3875</i>&nbsp;                String code = &quot;UnknownField&quot;;</b>
<b class="nc"><i>3876</i>&nbsp;                String eName = fIdentityConstraint.getElementName();</b>
<i>3877</i>&nbsp;                String cName = fIdentityConstraint.getIdentityConstraintName();
<i>3878</i>&nbsp;                reportSchemaError(code, new Object[] { field.toString(), eName, cName });
<i>3879</i>&nbsp;                return;
<i>3880</i>&nbsp;            }
<i>3881</i>&nbsp;            if (!mayMatch) {
<i>3882</i>&nbsp;                String code = &quot;FieldMultipleMatch&quot;;
<i>3883</i>&nbsp;                String cName = fIdentityConstraint.getIdentityConstraintName();
<i>3884</i>&nbsp;                reportSchemaError(code, new Object[] { field.toString(), cName });
<i>3885</i>&nbsp;            }
<i>3886</i>&nbsp;            else {
<b class="nc"><i>3887</i>&nbsp;                fValuesCount++;</b>
<b class="nc"><i>3888</i>&nbsp;            }</b>
<b class="nc"><i>3889</i>&nbsp;            fLocalValues[i] = actualValue;</b>
<b class="nc"><i>3890</i>&nbsp;            fLocalValueTypes[i] = valueType;</b>
<b class="nc"><i>3891</i>&nbsp;            fLocalItemValueTypes[i] = itemValueType;</b>
<b class="nc"><i>3892</i>&nbsp;            if (fValuesCount == fFieldCount) {</b>
<i>3893</i>&nbsp;                checkDuplicateValues();
<i>3894</i>&nbsp;                // store values
<i>3895</i>&nbsp;                for (i = 0; i &lt; fFieldCount; i++) {
<i>3896</i>&nbsp;                    fValues.add(fLocalValues[i]);
<i>3897</i>&nbsp;                    addValueType(fLocalValueTypes[i]);
<i>3898</i>&nbsp;                    addItemValueType(fLocalItemValueTypes[i]);
<i>3899</i>&nbsp;                }
<i>3900</i>&nbsp;            }
<i>3901</i>&nbsp;        } // addValue(String,Field)
<i>3902</i>&nbsp;
<i>3903</i>&nbsp;        /**
<i>3904</i>&nbsp;         * Returns true if this value store contains the locally scoped value stores
<i>3905</i>&nbsp;         */
<i>3906</i>&nbsp;        public boolean contains() {
<i>3907</i>&nbsp;            // REVISIT: we can improve performance by using hash codes, instead of
<i>3908</i>&nbsp;            // traversing global vector that could be quite large.
<i>3909</i>&nbsp;            int next = 0;
<i>3910</i>&nbsp;            final int size = fValues.size();
<i>3911</i>&nbsp;            LOOP : for (int i = 0; i &lt; size; i = next) {
<i>3912</i>&nbsp;                next = i + fFieldCount;
<i>3913</i>&nbsp;                for (int j = 0; j &lt; fFieldCount; j++) {
<i>3914</i>&nbsp;                    Object value1 = fLocalValues[j];
<i>3915</i>&nbsp;                    Object value2 = fValues.get(i);
<i>3916</i>&nbsp;                    short valueType1 = fLocalValueTypes[j];
<b class="nc"><i>3917</i>&nbsp;                    short valueType2 = getValueTypeAt(i);</b>
<b class="nc"><i>3918</i>&nbsp;                    if (value1 == null || value2 == null || valueType1 != valueType2 || !(value1.equals(value2))) {</b>
<b class="nc"><i>3919</i>&nbsp;                        continue LOOP;</b>
<i>3920</i>&nbsp;                    }
<i>3921</i>&nbsp;                    else if(valueType1 == XSConstants.LIST_DT || valueType1 == XSConstants.LISTOFUNION_DT) {
<i>3922</i>&nbsp;                        ShortList list1 = fLocalItemValueTypes[j];
<i>3923</i>&nbsp;                        ShortList list2 = getItemValueTypeAt(i);
<i>3924</i>&nbsp;                        if(list1 == null || list2 == null || !list1.equals(list2))
<i>3925</i>&nbsp;                            continue LOOP;
<i>3926</i>&nbsp;                    }
<i>3927</i>&nbsp;                    i++;
<i>3928</i>&nbsp;                }
<i>3929</i>&nbsp;                // found it
<i>3930</i>&nbsp;                return true;
<b class="nc"><i>3931</i>&nbsp;            }</b>
<i>3932</i>&nbsp;            // didn&#39;t find it
<i>3933</i>&nbsp;            return false;
<i>3934</i>&nbsp;        } // contains():boolean
<b class="nc"><i>3935</i>&nbsp;</b>
<b class="nc"><i>3936</i>&nbsp;        /**</b>
<b class="nc"><i>3937</i>&nbsp;         * Returns -1 if this value store contains the specified</b>
<i>3938</i>&nbsp;         * values, otherwise the index of the first field in the
<b class="nc"><i>3939</i>&nbsp;         * key sequence.</b>
<i>3940</i>&nbsp;         */
<b class="nc"><i>3941</i>&nbsp;        public int contains(ValueStoreBase vsb) {</b>
<b class="nc"><i>3942</i>&nbsp;</b>
<b class="nc"><i>3943</i>&nbsp;            final Vector&lt;Object&gt; values = vsb.fValues;</b>
<i>3944</i>&nbsp;            final int size1 = values.size();
<i>3945</i>&nbsp;            if (fFieldCount &lt;= 1) {
<b class="nc"><i>3946</i>&nbsp;                for (int i = 0; i &lt; size1; ++i) {</b>
<b class="nc"><i>3947</i>&nbsp;                    short val = vsb.getValueTypeAt(i);</b>
<b class="nc"><i>3948</i>&nbsp;                    if (!valueTypeContains(val) || !fValues.contains(values.get(i))) {</b>
<b class="nc"><i>3949</i>&nbsp;                        return i;</b>
<b class="nc"><i>3950</i>&nbsp;                    }</b>
<b class="nc"><i>3951</i>&nbsp;                    else if(val == XSConstants.LIST_DT || val == XSConstants.LISTOFUNION_DT) {</b>
<b class="nc"><i>3952</i>&nbsp;                        ShortList list1 = vsb.getItemValueTypeAt(i);</b>
<i>3953</i>&nbsp;                        if (!itemValueTypeContains(list1)) {
<i>3954</i>&nbsp;                            return i;
<i>3955</i>&nbsp;                        }
<i>3956</i>&nbsp;                    }
<i>3957</i>&nbsp;                }
<i>3958</i>&nbsp;            }
<b class="nc"><i>3959</i>&nbsp;            /** Handle n-tuples. **/</b>
<i>3960</i>&nbsp;            else {
<i>3961</i>&nbsp;                final int size2 = fValues.size();
<i>3962</i>&nbsp;                /** Iterate over each set of fields. **/
<i>3963</i>&nbsp;                OUTER: for (int i = 0; i &lt; size1; i += fFieldCount) {
<i>3964</i>&nbsp;                    /** Check whether this set is contained in the value store. **/
<i>3965</i>&nbsp;                    INNER: for (int j = 0; j &lt; size2; j += fFieldCount) {
<i>3966</i>&nbsp;                        for (int k = 0; k &lt; fFieldCount; ++k) {
<i>3967</i>&nbsp;                            final Object value1 = values.get(i+k);
<i>3968</i>&nbsp;                            final Object value2 = fValues.get(j+k);
<i>3969</i>&nbsp;                            final short valueType1 = vsb.getValueTypeAt(i+k);
<i>3970</i>&nbsp;                            final short valueType2 = getValueTypeAt(j+k);
<i>3971</i>&nbsp;                            if (value1 != value2 &amp;&amp; (valueType1 != valueType2 || value1 == null || !value1.equals(value2))) {
<i>3972</i>&nbsp;                                continue INNER;
<i>3973</i>&nbsp;                            }
<i>3974</i>&nbsp;                            else if(valueType1 == XSConstants.LIST_DT || valueType1 == XSConstants.LISTOFUNION_DT) {
<i>3975</i>&nbsp;                                ShortList list1 = vsb.getItemValueTypeAt(i+k);
<i>3976</i>&nbsp;                                ShortList list2 = getItemValueTypeAt(j+k);
<i>3977</i>&nbsp;                                if (list1 == null || list2 == null || !list1.equals(list2)) {
<b class="nc"><i>3978</i>&nbsp;                                    continue INNER;</b>
<i>3979</i>&nbsp;                                }
<i>3980</i>&nbsp;                            }
<i>3981</i>&nbsp;                        }
<b class="nc"><i>3982</i>&nbsp;                        continue OUTER;</b>
<i>3983</i>&nbsp;                    }
<i>3984</i>&nbsp;                    return i;
<i>3985</i>&nbsp;                }
<i>3986</i>&nbsp;            }
<i>3987</i>&nbsp;            return -1;
<i>3988</i>&nbsp;
<i>3989</i>&nbsp;        } // contains(Vector):Object
<i>3990</i>&nbsp;
<i>3991</i>&nbsp;        //
<i>3992</i>&nbsp;        // Protected methods
<b class="nc"><i>3993</i>&nbsp;        //</b>
<i>3994</i>&nbsp;
<i>3995</i>&nbsp;        protected void checkDuplicateValues() {
<i>3996</i>&nbsp;            // no-op
<i>3997</i>&nbsp;        } // duplicateValue(Map)
<i>3998</i>&nbsp;
<i>3999</i>&nbsp;        /** Returns a string of the specified values. */
<i>4000</i>&nbsp;        protected String toString(Object[] values) {
<i>4001</i>&nbsp;
<i>4002</i>&nbsp;            // no values
<i>4003</i>&nbsp;            int size = values.length;
<i>4004</i>&nbsp;            if (size == 0) {
<i>4005</i>&nbsp;                return &quot;&quot;;
<i>4006</i>&nbsp;            }
<i>4007</i>&nbsp;
<i>4008</i>&nbsp;            fTempBuffer.setLength(0);
<i>4009</i>&nbsp;
<i>4010</i>&nbsp;            // construct value string
<i>4011</i>&nbsp;            for (int i = 0; i &lt; size; i++) {
<i>4012</i>&nbsp;                if (i &gt; 0) {
<i>4013</i>&nbsp;                    fTempBuffer.append(&#39;,&#39;);
<i>4014</i>&nbsp;                }
<b class="nc"><i>4015</i>&nbsp;                fTempBuffer.append(values[i]);</b>
<i>4016</i>&nbsp;            }
<b class="nc"><i>4017</i>&nbsp;            return fTempBuffer.toString();</b>
<i>4018</i>&nbsp;
<i>4019</i>&nbsp;        } // toString(Object[]):String
<i>4020</i>&nbsp;
<i>4021</i>&nbsp;        /** Returns a string of the specified values. */
<i>4022</i>&nbsp;        protected String toString(Vector&lt;Object&gt; values, int start, int length) {
<i>4023</i>&nbsp;
<i>4024</i>&nbsp;            // no values
<b class="nc"><i>4025</i>&nbsp;            if (length == 0) {</b>
<i>4026</i>&nbsp;                return &quot;&quot;;
<i>4027</i>&nbsp;            }
<i>4028</i>&nbsp;
<i>4029</i>&nbsp;            // one value
<i>4030</i>&nbsp;            if (length == 1) {
<i>4031</i>&nbsp;                return String.valueOf(values.get(start));
<i>4032</i>&nbsp;            }
<i>4033</i>&nbsp;
<b class="nc"><i>4034</i>&nbsp;            // construct value string</b>
<b class="nc"><i>4035</i>&nbsp;            StringBuilder str = new StringBuilder();</b>
<b class="nc"><i>4036</i>&nbsp;            for (int i = 0; i &lt; length; i++) {</b>
<b class="nc"><i>4037</i>&nbsp;                if (i &gt; 0) {</b>
<i>4038</i>&nbsp;                    str.append(&#39;,&#39;);
<i>4039</i>&nbsp;                }
<i>4040</i>&nbsp;                str.append(values.get(start + i));
<i>4041</i>&nbsp;            }
<i>4042</i>&nbsp;            return str.toString();
<i>4043</i>&nbsp;
<b class="nc"><i>4044</i>&nbsp;        } // toString(Vector,int,int):String</b>
<b class="nc"><i>4045</i>&nbsp;</b>
<b class="nc"><i>4046</i>&nbsp;        //</b>
<i>4047</i>&nbsp;        // Object methods
<b class="nc"><i>4048</i>&nbsp;        //</b>
<b class="nc"><i>4049</i>&nbsp;</b>
<i>4050</i>&nbsp;        /** Returns a string representation of this object. */
<i>4051</i>&nbsp;        public String toString() {
<i>4052</i>&nbsp;            String s = super.toString();
<i>4053</i>&nbsp;            int index1 = s.lastIndexOf(&#39;$&#39;);
<i>4054</i>&nbsp;            if (index1 != -1) {
<i>4055</i>&nbsp;                s = s.substring(index1 + 1);
<b class="nc"><i>4056</i>&nbsp;            }</b>
<i>4057</i>&nbsp;            int index2 = s.lastIndexOf(&#39;.&#39;);
<i>4058</i>&nbsp;            if (index2 != -1) {
<b class="nc"><i>4059</i>&nbsp;                s = s.substring(index2 + 1);</b>
<i>4060</i>&nbsp;            }
<b class="nc"><i>4061</i>&nbsp;            return s + &#39;[&#39; + fIdentityConstraint + &#39;]&#39;;</b>
<i>4062</i>&nbsp;        } // toString():String
<i>4063</i>&nbsp;
<i>4064</i>&nbsp;        //
<b class="nc"><i>4065</i>&nbsp;        // Private methods</b>
<b class="nc"><i>4066</i>&nbsp;        //</b>
<b class="nc"><i>4067</i>&nbsp;</b>
<b class="nc"><i>4068</i>&nbsp;        private void addValueType(short type) {</b>
<b class="nc"><i>4069</i>&nbsp;            if (fUseValueTypeVector) {</b>
<b class="nc"><i>4070</i>&nbsp;                fValueTypes.add(type);</b>
<b class="nc"><i>4071</i>&nbsp;            }</b>
<i>4072</i>&nbsp;            else if (fValueTypesLength++ == 0) {
<b class="nc"><i>4073</i>&nbsp;                fValueType = type;</b>
<b class="nc"><i>4074</i>&nbsp;            }</b>
<i>4075</i>&nbsp;            else if (fValueType != type) {
<i>4076</i>&nbsp;                fUseValueTypeVector = true;
<b class="nc"><i>4077</i>&nbsp;                if (fValueTypes == null) {</b>
<i>4078</i>&nbsp;                    fValueTypes = new ShortVector(fValueTypesLength * 2);
<i>4079</i>&nbsp;                }
<i>4080</i>&nbsp;                for (int i = 1; i &lt; fValueTypesLength; ++i) {
<i>4081</i>&nbsp;                    fValueTypes.add(fValueType);
<i>4082</i>&nbsp;                }
<i>4083</i>&nbsp;                fValueTypes.add(type);
<i>4084</i>&nbsp;            }
<i>4085</i>&nbsp;        }
<b class="nc"><i>4086</i>&nbsp;</b>
<b class="nc"><i>4087</i>&nbsp;        private short getValueTypeAt(int index) {</b>
<b class="nc"><i>4088</i>&nbsp;            if (fUseValueTypeVector) {</b>
<b class="nc"><i>4089</i>&nbsp;                return fValueTypes.valueAt(index);</b>
<i>4090</i>&nbsp;            }
<i>4091</i>&nbsp;            return fValueType;
<b class="nc"><i>4092</i>&nbsp;        }</b>
<b class="nc"><i>4093</i>&nbsp;</b>
<b class="nc"><i>4094</i>&nbsp;        private boolean valueTypeContains(short value) {</b>
<b class="nc"><i>4095</i>&nbsp;            if (fUseValueTypeVector) {</b>
<b class="nc"><i>4096</i>&nbsp;                return fValueTypes.contains(value);</b>
<b class="nc"><i>4097</i>&nbsp;            }</b>
<b class="nc"><i>4098</i>&nbsp;            return fValueType == value;</b>
<i>4099</i>&nbsp;        }
<b class="nc"><i>4100</i>&nbsp;</b>
<i>4101</i>&nbsp;        private void addItemValueType(ShortList itemValueType) {
<b class="nc"><i>4102</i>&nbsp;            if (fUseItemValueTypeVector) {</b>
<b class="nc"><i>4103</i>&nbsp;                fItemValueTypes.add(itemValueType);</b>
<b class="nc"><i>4104</i>&nbsp;            }</b>
<i>4105</i>&nbsp;            else if (fItemValueTypesLength++ == 0) {
<i>4106</i>&nbsp;                fItemValueType = itemValueType;
<b class="nc"><i>4107</i>&nbsp;            }</b>
<b class="nc"><i>4108</i>&nbsp;            else if (!(fItemValueType == itemValueType ||</b>
<b class="nc"><i>4109</i>&nbsp;                    (fItemValueType != null &amp;&amp; fItemValueType.equals(itemValueType)))) {</b>
<b class="nc"><i>4110</i>&nbsp;                fUseItemValueTypeVector = true;</b>
<b class="nc"><i>4111</i>&nbsp;                if (fItemValueTypes == null) {</b>
<b class="nc"><i>4112</i>&nbsp;                    fItemValueTypes = new Vector&lt;&gt;(fItemValueTypesLength * 2);</b>
<b class="nc"><i>4113</i>&nbsp;                }</b>
<i>4114</i>&nbsp;                for (int i = 1; i &lt; fItemValueTypesLength; ++i) {
<b class="nc"><i>4115</i>&nbsp;                    fItemValueTypes.add(fItemValueType);</b>
<i>4116</i>&nbsp;                }
<b class="nc"><i>4117</i>&nbsp;                fItemValueTypes.add(itemValueType);</b>
<b class="nc"><i>4118</i>&nbsp;            }</b>
<b class="nc"><i>4119</i>&nbsp;        }</b>
<i>4120</i>&nbsp;
<i>4121</i>&nbsp;        private ShortList getItemValueTypeAt(int index) {
<b class="nc"><i>4122</i>&nbsp;            if (fUseItemValueTypeVector) {</b>
<b class="nc"><i>4123</i>&nbsp;                return fItemValueTypes.get(index);</b>
<b class="nc"><i>4124</i>&nbsp;            }</b>
<b class="nc"><i>4125</i>&nbsp;            return fItemValueType;</b>
<b class="nc"><i>4126</i>&nbsp;        }</b>
<b class="nc"><i>4127</i>&nbsp;</b>
<b class="nc"><i>4128</i>&nbsp;        private boolean itemValueTypeContains(ShortList value) {</b>
<i>4129</i>&nbsp;            if (fUseItemValueTypeVector) {
<b class="nc"><i>4130</i>&nbsp;                return fItemValueTypes.contains(value);</b>
<i>4131</i>&nbsp;            }
<b class="nc"><i>4132</i>&nbsp;            return fItemValueType == value ||</b>
<b class="nc"><i>4133</i>&nbsp;                (fItemValueType != null &amp;&amp; fItemValueType.equals(value));</b>
<i>4134</i>&nbsp;        }
<i>4135</i>&nbsp;
<i>4136</i>&nbsp;    } // class ValueStoreBase
<i>4137</i>&nbsp;
<i>4138</i>&nbsp;    /**
<i>4139</i>&nbsp;     * Unique value store.
<i>4140</i>&nbsp;     *
<b class="nc"><i>4141</i>&nbsp;     * @author Andy Clark, IBM</b>
<b class="nc"><i>4142</i>&nbsp;     */</b>
<b class="nc"><i>4143</i>&nbsp;    protected class UniqueValueStore extends ValueStoreBase {</b>
<i>4144</i>&nbsp;
<i>4145</i>&nbsp;        //
<i>4146</i>&nbsp;        // Constructors
<i>4147</i>&nbsp;        //
<b class="nc"><i>4148</i>&nbsp;</b>
<i>4149</i>&nbsp;        /** Constructs a unique value store. */
<i>4150</i>&nbsp;        public UniqueValueStore(UniqueOrKey unique) {
<i>4151</i>&nbsp;            super(unique);
<i>4152</i>&nbsp;        } // &lt;init&gt;(Unique)
<i>4153</i>&nbsp;
<i>4154</i>&nbsp;        //
<i>4155</i>&nbsp;        // ValueStoreBase protected methods
<b class="nc"><i>4156</i>&nbsp;        //</b>
<b class="nc"><i>4157</i>&nbsp;</b>
<b class="nc"><i>4158</i>&nbsp;        /**</b>
<b class="nc"><i>4159</i>&nbsp;         * Called when a duplicate value is added.</b>
<i>4160</i>&nbsp;         */
<b class="nc"><i>4161</i>&nbsp;        protected void checkDuplicateValues() {</b>
<b class="nc"><i>4162</i>&nbsp;            // is this value as a group duplicated?</b>
<b class="nc"><i>4163</i>&nbsp;            if (contains()) {</b>
<b class="nc"><i>4164</i>&nbsp;                String code = &quot;DuplicateUnique&quot;;</b>
<i>4165</i>&nbsp;                String value = toString(fLocalValues);
<b class="nc"><i>4166</i>&nbsp;                String eName = fIdentityConstraint.getElementName();</b>
<i>4167</i>&nbsp;                String cName = fIdentityConstraint.getIdentityConstraintName();
<i>4168</i>&nbsp;                reportSchemaError(code, new Object[] { value, eName, cName });
<i>4169</i>&nbsp;            }
<i>4170</i>&nbsp;        } // duplicateValue(Map)
<i>4171</i>&nbsp;
<i>4172</i>&nbsp;    } // class UniqueValueStore
<b class="nc"><i>4173</i>&nbsp;</b>
<b class="nc"><i>4174</i>&nbsp;    /**</b>
<b class="nc"><i>4175</i>&nbsp;     * Key value store.</b>
<b class="nc"><i>4176</i>&nbsp;     *</b>
<i>4177</i>&nbsp;     * @author Andy Clark, IBM
<i>4178</i>&nbsp;     */
<i>4179</i>&nbsp;    protected class KeyValueStore extends ValueStoreBase {
<i>4180</i>&nbsp;
<i>4181</i>&nbsp;        // REVISIT: Implement a more efficient storage mechanism. -Ac
<i>4182</i>&nbsp;
<i>4183</i>&nbsp;        //
<i>4184</i>&nbsp;        // Constructors
<i>4185</i>&nbsp;        //
<i>4186</i>&nbsp;
<b class="nc"><i>4187</i>&nbsp;        /** Constructs a key value store. */</b>
<b class="nc"><i>4188</i>&nbsp;        public KeyValueStore(UniqueOrKey key) {</b>
<b class="nc"><i>4189</i>&nbsp;            super(key);</b>
<b class="nc"><i>4190</i>&nbsp;        } // &lt;init&gt;(Key)</b>
<i>4191</i>&nbsp;
<b class="nc"><i>4192</i>&nbsp;        //</b>
<b class="nc"><i>4193</i>&nbsp;        // ValueStoreBase protected methods</b>
<b class="nc"><i>4194</i>&nbsp;        //</b>
<i>4195</i>&nbsp;
<b class="nc"><i>4196</i>&nbsp;        /**</b>
<i>4197</i>&nbsp;         * Called when a duplicate value is added.
<i>4198</i>&nbsp;         */
<i>4199</i>&nbsp;        protected void checkDuplicateValues() {
<i>4200</i>&nbsp;            if (contains()) {
<i>4201</i>&nbsp;                String code = &quot;DuplicateKey&quot;;
<i>4202</i>&nbsp;                String value = toString(fLocalValues);
<i>4203</i>&nbsp;                String eName = fIdentityConstraint.getElementName();
<i>4204</i>&nbsp;                String cName = fIdentityConstraint.getIdentityConstraintName();
<i>4205</i>&nbsp;                reportSchemaError(code, new Object[] { value, eName, cName });
<i>4206</i>&nbsp;            }
<i>4207</i>&nbsp;        } // duplicateValue(Map)
<b class="nc"><i>4208</i>&nbsp;</b>
<i>4209</i>&nbsp;    } // class KeyValueStore
<i>4210</i>&nbsp;
<b class="nc"><i>4211</i>&nbsp;    /**</b>
<b class="nc"><i>4212</i>&nbsp;     * Key reference value store.</b>
<b class="nc"><i>4213</i>&nbsp;     *</b>
<i>4214</i>&nbsp;     * @author Andy Clark, IBM
<i>4215</i>&nbsp;     */
<i>4216</i>&nbsp;    protected class KeyRefValueStore extends ValueStoreBase {
<i>4217</i>&nbsp;
<b class="nc"><i>4218</i>&nbsp;        //</b>
<i>4219</i>&nbsp;        // Data
<i>4220</i>&nbsp;        //
<i>4221</i>&nbsp;
<b class="nc"><i>4222</i>&nbsp;        /** Key value store. */</b>
<b class="nc"><i>4223</i>&nbsp;        protected ValueStoreBase fKeyValueStore;</b>
<b class="nc"><i>4224</i>&nbsp;</b>
<i>4225</i>&nbsp;        //
<b class="nc"><i>4226</i>&nbsp;        // Constructors</b>
<i>4227</i>&nbsp;        //
<i>4228</i>&nbsp;
<i>4229</i>&nbsp;        /** Constructs a key value store. */
<i>4230</i>&nbsp;        public KeyRefValueStore(KeyRef keyRef, KeyValueStore keyValueStore) {
<i>4231</i>&nbsp;            super(keyRef);
<i>4232</i>&nbsp;            fKeyValueStore = keyValueStore;
<i>4233</i>&nbsp;        } // &lt;init&gt;(KeyRef)
<i>4234</i>&nbsp;
<i>4235</i>&nbsp;        //
<i>4236</i>&nbsp;        // ValueStoreBase methods
<i>4237</i>&nbsp;        //
<i>4238</i>&nbsp;
<i>4239</i>&nbsp;        // end the value Scope; here&#39;s where we have to tie
<i>4240</i>&nbsp;        // up keyRef loose ends.
<i>4241</i>&nbsp;        public void endDocumentFragment() {
<i>4242</i>&nbsp;
<i>4243</i>&nbsp;            // do all the necessary management...
<i>4244</i>&nbsp;            super.endDocumentFragment();
<i>4245</i>&nbsp;
<i>4246</i>&nbsp;            // verify references
<i>4247</i>&nbsp;            // get the key store corresponding (if it exists):
<i>4248</i>&nbsp;            fKeyValueStore = fValueStoreCache.fGlobalIDConstraintMap.get(
<b class="nc"><i>4249</i>&nbsp;                    ((KeyRef) fIdentityConstraint).getKey());</b>
<i>4250</i>&nbsp;
<b class="nc"><i>4251</i>&nbsp;            if (fKeyValueStore == null) {</b>
<b class="nc"><i>4252</i>&nbsp;                // report error</b>
<i>4253</i>&nbsp;                String code = &quot;KeyRefOutOfScope&quot;;
<i>4254</i>&nbsp;                String value = fIdentityConstraint.toString();
<i>4255</i>&nbsp;                reportSchemaError(code, new Object[] { value });
<i>4256</i>&nbsp;                return;
<i>4257</i>&nbsp;            }
<i>4258</i>&nbsp;            int errorIndex = fKeyValueStore.contains(this);
<i>4259</i>&nbsp;            if (errorIndex != -1) {
<i>4260</i>&nbsp;                String code = &quot;KeyNotFound&quot;;
<b class="nc"><i>4261</i>&nbsp;                String values = toString(fValues, errorIndex, fFieldCount);</b>
<i>4262</i>&nbsp;                String element = fIdentityConstraint.getElementName();
<i>4263</i>&nbsp;                String name = fIdentityConstraint.getName();
<i>4264</i>&nbsp;                reportSchemaError(code, new Object[] { name, values, element });
<i>4265</i>&nbsp;            }
<b class="nc"><i>4266</i>&nbsp;</b>
<b class="nc"><i>4267</i>&nbsp;        } // endDocumentFragment()</b>
<i>4268</i>&nbsp;
<i>4269</i>&nbsp;        /** End document. */
<i>4270</i>&nbsp;        public void endDocument() {
<i>4271</i>&nbsp;            super.endDocument();
<b class="nc"><i>4272</i>&nbsp;</b>
<i>4273</i>&nbsp;        } // endDocument()
<i>4274</i>&nbsp;
<i>4275</i>&nbsp;    } // class KeyRefValueStore
<i>4276</i>&nbsp;
<b class="nc"><i>4277</i>&nbsp;    // value store management</b>
<i>4278</i>&nbsp;
<i>4279</i>&nbsp;    /**
<i>4280</i>&nbsp;     * Value store cache. This class is used to store the values for
<i>4281</i>&nbsp;     * identity constraints.
<b class="nc"><i>4282</i>&nbsp;     *</b>
<b class="nc"><i>4283</i>&nbsp;     * @author Andy Clark, IBM</b>
<b class="nc"><i>4284</i>&nbsp;     */</b>
<i>4285</i>&nbsp;    protected class ValueStoreCache {
<i>4286</i>&nbsp;
<b class="nc"><i>4287</i>&nbsp;        //</b>
<i>4288</i>&nbsp;        // Data
<i>4289</i>&nbsp;        //
<i>4290</i>&nbsp;        final LocalIDKey fLocalId = new LocalIDKey();
<i>4291</i>&nbsp;        // values stores
<i>4292</i>&nbsp;
<i>4293</i>&nbsp;        /** stores all global Values stores. */
<i>4294</i>&nbsp;        protected final List&lt;ValueStoreBase&gt; fValueStores = new ArrayList&lt;&gt;();
<i>4295</i>&nbsp;
<b class="nc"><i>4296</i>&nbsp;        /**</b>
<b class="nc"><i>4297</i>&nbsp;         * Values stores associated to specific identity constraints.</b>
<i>4298</i>&nbsp;         * This map maps IdentityConstraints and
<b class="nc"><i>4299</i>&nbsp;         * the 0-based element on which their selectors first matched to</b>
<b class="nc"><i>4300</i>&nbsp;         * a corresponding ValueStore.  This should take care</b>
<b class="nc"><i>4301</i>&nbsp;         * of all cases, including where ID constraints with</b>
<b class="nc"><i>4302</i>&nbsp;         * descendant-or-self axes occur on recursively-defined</b>
<i>4303</i>&nbsp;         * elements.
<i>4304</i>&nbsp;         */
<i>4305</i>&nbsp;        protected final Map&lt;LocalIDKey, ValueStoreBase&gt;
<i>4306</i>&nbsp;                fIdentityConstraint2ValueStoreMap = new HashMap&lt;&gt;();
<i>4307</i>&nbsp;
<i>4308</i>&nbsp;        // sketch of algorithm:
<i>4309</i>&nbsp;        // - when a constraint is first encountered, its
<i>4310</i>&nbsp;        //   values are stored in the (local) fIdentityConstraint2ValueStoreMap;
<i>4311</i>&nbsp;        // - Once it is validated (i.e., when it goes out of scope),
<i>4312</i>&nbsp;        //   its values are merged into the fGlobalIDConstraintMap;
<i>4313</i>&nbsp;        // - as we encounter keyref&#39;s, we look at the global table to
<i>4314</i>&nbsp;        //    validate them.
<i>4315</i>&nbsp;        //
<i>4316</i>&nbsp;        // The fGlobalIDMapStack has the following structure:
<i>4317</i>&nbsp;        // - validation always occurs against the fGlobalIDConstraintMap
<i>4318</i>&nbsp;        // (which comprises all the &quot;eligible&quot; id constraints);
<i>4319</i>&nbsp;        // When an endElement is found, this Map is merged with the one
<i>4320</i>&nbsp;        // below in the stack.
<i>4321</i>&nbsp;        // When a start tag is encountered, we create a new
<i>4322</i>&nbsp;        // fGlobalIDConstraintMap.
<i>4323</i>&nbsp;        // i.e., the top of the fGlobalIDMapStack always contains
<i>4324</i>&nbsp;        // the preceding siblings&#39; eligible id constraints;
<i>4325</i>&nbsp;        // the fGlobalIDConstraintMap contains descendants+self.
<i>4326</i>&nbsp;        // keyrefs can only match descendants+self.
<i>4327</i>&nbsp;        protected final Stack&lt;Map&lt;IdentityConstraint, ValueStoreBase&gt;&gt;
<i>4328</i>&nbsp;                fGlobalMapStack = new Stack&lt;&gt;();
<i>4329</i>&nbsp;        protected final Map&lt;IdentityConstraint, ValueStoreBase&gt;
<i>4330</i>&nbsp;                fGlobalIDConstraintMap = new HashMap&lt;&gt;();
<i>4331</i>&nbsp;
<i>4332</i>&nbsp;        //
<i>4333</i>&nbsp;        // Constructors
<i>4334</i>&nbsp;        //
<i>4335</i>&nbsp;
<i>4336</i>&nbsp;        /** Default constructor. */
<i>4337</i>&nbsp;        public ValueStoreCache() {
<i>4338</i>&nbsp;        } // &lt;init&gt;()
<i>4339</i>&nbsp;
<i>4340</i>&nbsp;        //
<i>4341</i>&nbsp;        // Public methods
<i>4342</i>&nbsp;        //
<i>4343</i>&nbsp;
<i>4344</i>&nbsp;        /** Resets the identity constraint cache. */
<i>4345</i>&nbsp;        public void startDocument() {
<i>4346</i>&nbsp;            fValueStores.clear();
<i>4347</i>&nbsp;            fIdentityConstraint2ValueStoreMap.clear();
<i>4348</i>&nbsp;            fGlobalIDConstraintMap.clear();
<i>4349</i>&nbsp;            fGlobalMapStack.removeAllElements();
<i>4350</i>&nbsp;        } // startDocument()
<i>4351</i>&nbsp;
<i>4352</i>&nbsp;        // startElement:  pushes the current fGlobalIDConstraintMap
<i>4353</i>&nbsp;        // onto fGlobalMapStack and clears fGlobalIDConstraint map.
<i>4354</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<i>4355</i>&nbsp;        public void startElement() {
<i>4356</i>&nbsp;            // only clone the map when there are elements
<i>4357</i>&nbsp;            if (fGlobalIDConstraintMap.size() &gt; 0)
<i>4358</i>&nbsp;                fGlobalMapStack.push((Map&lt;IdentityConstraint, ValueStoreBase&gt;)
<i>4359</i>&nbsp;                        ((HashMap&lt;IdentityConstraint, ValueStoreBase&gt;)fGlobalIDConstraintMap).clone());
<i>4360</i>&nbsp;            else
<i>4361</i>&nbsp;                fGlobalMapStack.push(null);
<i>4362</i>&nbsp;            fGlobalIDConstraintMap.clear();
<i>4363</i>&nbsp;        } // startElement(void)
<i>4364</i>&nbsp;
<i>4365</i>&nbsp;        /** endElement():  merges contents of fGlobalIDConstraintMap with the
<i>4366</i>&nbsp;         * top of fGlobalMapStack into fGlobalIDConstraintMap.
<i>4367</i>&nbsp;         */
<i>4368</i>&nbsp;        public void endElement() {
<i>4369</i>&nbsp;            if (fGlobalMapStack.isEmpty()) {
<i>4370</i>&nbsp;                return; // must be an invalid doc!
<i>4371</i>&nbsp;            }
<i>4372</i>&nbsp;            Map&lt;IdentityConstraint, ValueStoreBase&gt; oldMap = fGlobalMapStack.pop();
<i>4373</i>&nbsp;            // return if there is no element
<i>4374</i>&nbsp;            if (oldMap == null) {
<i>4375</i>&nbsp;                return;
<i>4376</i>&nbsp;            }
<i>4377</i>&nbsp;
<i>4378</i>&nbsp;            for (Map.Entry&lt;IdentityConstraint, ValueStoreBase&gt; entry : oldMap.entrySet()) {
<i>4379</i>&nbsp;                IdentityConstraint id = entry.getKey();
<i>4380</i>&nbsp;                ValueStoreBase oldVal = entry.getValue();
<i>4381</i>&nbsp;                if (oldVal != null) {
<i>4382</i>&nbsp;                    ValueStoreBase currVal = fGlobalIDConstraintMap.get(id);
<i>4383</i>&nbsp;                    if (currVal == null) {
<i>4384</i>&nbsp;                        fGlobalIDConstraintMap.put(id, oldVal);
<i>4385</i>&nbsp;                    }
<i>4386</i>&nbsp;                    else if (currVal != oldVal) {
<i>4387</i>&nbsp;                        currVal.append(oldVal);
<i>4388</i>&nbsp;                    }
<i>4389</i>&nbsp;                }
<i>4390</i>&nbsp;            }
<i>4391</i>&nbsp;        } // endElement()
<i>4392</i>&nbsp;
<i>4393</i>&nbsp;        /**
<i>4394</i>&nbsp;         * Initializes the value stores for the specified element
<i>4395</i>&nbsp;         * declaration.
<i>4396</i>&nbsp;         */
<i>4397</i>&nbsp;        public void initValueStoresFor(XSElementDecl eDecl, FieldActivator activator) {
<i>4398</i>&nbsp;            // initialize value stores for unique fields
<i>4399</i>&nbsp;            IdentityConstraint[] icArray = eDecl.fIDConstraints;
<i>4400</i>&nbsp;            int icCount = eDecl.fIDCPos;
<i>4401</i>&nbsp;            for (int i = 0; i &lt; icCount; i++) {
<i>4402</i>&nbsp;                switch (icArray[i].getCategory()) {
<i>4403</i>&nbsp;                    case (IdentityConstraint.IC_UNIQUE) :
<i>4404</i>&nbsp;                        // initialize value stores for unique fields
<i>4405</i>&nbsp;                        UniqueOrKey unique = (UniqueOrKey) icArray[i];
<i>4406</i>&nbsp;                        LocalIDKey toHash = new LocalIDKey(unique, fElementDepth);
<i>4407</i>&nbsp;                        UniqueValueStore uniqueValueStore =
<i>4408</i>&nbsp;                            (UniqueValueStore) fIdentityConstraint2ValueStoreMap.get(toHash);
<i>4409</i>&nbsp;                        if (uniqueValueStore == null) {
<i>4410</i>&nbsp;                            uniqueValueStore = new UniqueValueStore(unique);
<i>4411</i>&nbsp;                            fIdentityConstraint2ValueStoreMap.put(toHash, uniqueValueStore);
<i>4412</i>&nbsp;                        } else {
<i>4413</i>&nbsp;                            uniqueValueStore.clear();
<i>4414</i>&nbsp;                        }
<i>4415</i>&nbsp;                        fValueStores.add(uniqueValueStore);
<i>4416</i>&nbsp;                        activateSelectorFor(icArray[i]);
<i>4417</i>&nbsp;                        break;
<i>4418</i>&nbsp;                    case (IdentityConstraint.IC_KEY) :
<i>4419</i>&nbsp;                        // initialize value stores for key fields
<i>4420</i>&nbsp;                        UniqueOrKey key = (UniqueOrKey) icArray[i];
<i>4421</i>&nbsp;                        toHash = new LocalIDKey(key, fElementDepth);
<i>4422</i>&nbsp;                        KeyValueStore keyValueStore =
<i>4423</i>&nbsp;                            (KeyValueStore) fIdentityConstraint2ValueStoreMap.get(toHash);
<i>4424</i>&nbsp;                        if (keyValueStore == null) {
<i>4425</i>&nbsp;                            keyValueStore = new KeyValueStore(key);
<i>4426</i>&nbsp;                            fIdentityConstraint2ValueStoreMap.put(toHash, keyValueStore);
<i>4427</i>&nbsp;                        } else {
<i>4428</i>&nbsp;                            keyValueStore.clear();
<i>4429</i>&nbsp;                        }
<i>4430</i>&nbsp;                        fValueStores.add(keyValueStore);
<i>4431</i>&nbsp;                        activateSelectorFor(icArray[i]);
<i>4432</i>&nbsp;                        break;
<i>4433</i>&nbsp;                    case (IdentityConstraint.IC_KEYREF) :
<i>4434</i>&nbsp;                        // initialize value stores for keyRef fields
<i>4435</i>&nbsp;                        KeyRef keyRef = (KeyRef) icArray[i];
<i>4436</i>&nbsp;                        toHash = new LocalIDKey(keyRef, fElementDepth);
<i>4437</i>&nbsp;                        KeyRefValueStore keyRefValueStore =
<i>4438</i>&nbsp;                            (KeyRefValueStore) fIdentityConstraint2ValueStoreMap.get(toHash);
<i>4439</i>&nbsp;                        if (keyRefValueStore == null) {
<i>4440</i>&nbsp;                            keyRefValueStore = new KeyRefValueStore(keyRef, null);
<i>4441</i>&nbsp;                            fIdentityConstraint2ValueStoreMap.put(toHash, keyRefValueStore);
<i>4442</i>&nbsp;                        } else {
<i>4443</i>&nbsp;                            keyRefValueStore.clear();
<i>4444</i>&nbsp;                        }
<i>4445</i>&nbsp;                        fValueStores.add(keyRefValueStore);
<i>4446</i>&nbsp;                        activateSelectorFor(icArray[i]);
<i>4447</i>&nbsp;                        break;
<i>4448</i>&nbsp;                }
<i>4449</i>&nbsp;            }
<i>4450</i>&nbsp;        } // initValueStoresFor(XSElementDecl)
<i>4451</i>&nbsp;
<i>4452</i>&nbsp;        /** Returns the value store associated to the specified IdentityConstraint. */
<i>4453</i>&nbsp;        public ValueStoreBase getValueStoreFor(IdentityConstraint id, int initialDepth) {
<i>4454</i>&nbsp;            fLocalId.fDepth = initialDepth;
<i>4455</i>&nbsp;            fLocalId.fId = id;
<i>4456</i>&nbsp;            return fIdentityConstraint2ValueStoreMap.get(fLocalId);
<i>4457</i>&nbsp;        } // getValueStoreFor(IdentityConstraint, int):ValueStoreBase
<i>4458</i>&nbsp;
<i>4459</i>&nbsp;        /** Returns the global value store associated to the specified IdentityConstraint. */
<i>4460</i>&nbsp;        public ValueStoreBase getGlobalValueStoreFor(IdentityConstraint id) {
<i>4461</i>&nbsp;            return fGlobalIDConstraintMap.get(id);
<i>4462</i>&nbsp;        } // getValueStoreFor(IdentityConstraint):ValueStoreBase
<i>4463</i>&nbsp;
<i>4464</i>&nbsp;        // This method takes the contents of the (local) ValueStore
<i>4465</i>&nbsp;        // associated with id and moves them into the global
<i>4466</i>&nbsp;        // map, if id is a &lt;unique&gt; or a &lt;key&gt;.
<i>4467</i>&nbsp;        // If it&#39;s a &lt;keyRef&gt;, then we leave it for later.
<i>4468</i>&nbsp;        public void transplant(IdentityConstraint id, int initialDepth) {
<i>4469</i>&nbsp;            fLocalId.fDepth = initialDepth;
<i>4470</i>&nbsp;            fLocalId.fId = id;
<i>4471</i>&nbsp;            ValueStoreBase newVals = fIdentityConstraint2ValueStoreMap.get(fLocalId);
<i>4472</i>&nbsp;            if (id.getCategory() == IdentityConstraint.IC_KEYREF)
<i>4473</i>&nbsp;                return;
<i>4474</i>&nbsp;            ValueStoreBase currVals = fGlobalIDConstraintMap.get(id);
<i>4475</i>&nbsp;            if (currVals != null) {
<i>4476</i>&nbsp;                currVals.append(newVals);
<i>4477</i>&nbsp;                fGlobalIDConstraintMap.put(id, currVals);
<i>4478</i>&nbsp;            } else
<i>4479</i>&nbsp;                fGlobalIDConstraintMap.put(id, newVals);
<i>4480</i>&nbsp;
<i>4481</i>&nbsp;        } // transplant(id)
<i>4482</i>&nbsp;
<i>4483</i>&nbsp;        /** Check identity constraints. */
<i>4484</i>&nbsp;        public void endDocument() {
<i>4485</i>&nbsp;
<i>4486</i>&nbsp;            for (ValueStoreBase valueStore : fValueStores) {
<i>4487</i>&nbsp;                valueStore.endDocument();
<i>4488</i>&nbsp;            }
<i>4489</i>&nbsp;
<i>4490</i>&nbsp;        } // endDocument()
<i>4491</i>&nbsp;
<i>4492</i>&nbsp;        //
<i>4493</i>&nbsp;        // Object methods
<i>4494</i>&nbsp;        //
<i>4495</i>&nbsp;
<i>4496</i>&nbsp;        /** Returns a string representation of this object. */
<i>4497</i>&nbsp;        public String toString() {
<i>4498</i>&nbsp;            String s = super.toString();
<i>4499</i>&nbsp;            int index1 = s.lastIndexOf(&#39;$&#39;);
<i>4500</i>&nbsp;            if (index1 != -1) {
<i>4501</i>&nbsp;                return s.substring(index1 + 1);
<i>4502</i>&nbsp;            }
<i>4503</i>&nbsp;            int index2 = s.lastIndexOf(&#39;.&#39;);
<i>4504</i>&nbsp;            if (index2 != -1) {
<i>4505</i>&nbsp;                return s.substring(index2 + 1);
<i>4506</i>&nbsp;            }
<i>4507</i>&nbsp;            return s;
<i>4508</i>&nbsp;        } // toString():String
<i>4509</i>&nbsp;
<i>4510</i>&nbsp;    } // class ValueStoreCache
<i>4511</i>&nbsp;
<i>4512</i>&nbsp;    // the purpose of this class is to enable IdentityConstraint,int
<i>4513</i>&nbsp;    // pairs to be used easily as keys in Maps.
<i>4514</i>&nbsp;    protected static final class LocalIDKey {
<i>4515</i>&nbsp;
<i>4516</i>&nbsp;        public IdentityConstraint fId;
<i>4517</i>&nbsp;        public int fDepth;
<i>4518</i>&nbsp;
<i>4519</i>&nbsp;        public LocalIDKey() {
<i>4520</i>&nbsp;        }
<i>4521</i>&nbsp;
<i>4522</i>&nbsp;        public LocalIDKey(IdentityConstraint id, int depth) {
<i>4523</i>&nbsp;            fId = id;
<i>4524</i>&nbsp;            fDepth = depth;
<i>4525</i>&nbsp;        } // init(IdentityConstraint, int)
<i>4526</i>&nbsp;
<i>4527</i>&nbsp;        // object method
<i>4528</i>&nbsp;        public int hashCode() {
<i>4529</i>&nbsp;            return fId.hashCode() + fDepth;
<i>4530</i>&nbsp;        }
<i>4531</i>&nbsp;
<i>4532</i>&nbsp;        public boolean equals(Object localIDKey) {
<i>4533</i>&nbsp;            if (localIDKey instanceof LocalIDKey) {
<i>4534</i>&nbsp;                LocalIDKey lIDKey = (LocalIDKey) localIDKey;
<i>4535</i>&nbsp;                return (lIDKey.fId == fId &amp;&amp; lIDKey.fDepth == fDepth);
<i>4536</i>&nbsp;            }
<i>4537</i>&nbsp;            return false;
<i>4538</i>&nbsp;        }
<i>4539</i>&nbsp;    } // class LocalIDKey
<i>4540</i>&nbsp;
<i>4541</i>&nbsp;    /**
<i>4542</i>&nbsp;     * A simple vector for &lt;code&gt;short&lt;/code&gt;s.
<i>4543</i>&nbsp;     */
<i>4544</i>&nbsp;    protected static final class ShortVector {
<i>4545</i>&nbsp;
<i>4546</i>&nbsp;        //
<i>4547</i>&nbsp;        // Data
<i>4548</i>&nbsp;        //
<i>4549</i>&nbsp;
<i>4550</i>&nbsp;        /** Current length. */
<i>4551</i>&nbsp;        private int fLength;
<i>4552</i>&nbsp;
<i>4553</i>&nbsp;        /** Data. */
<i>4554</i>&nbsp;        private short[] fData;
<i>4555</i>&nbsp;
<i>4556</i>&nbsp;        //
<i>4557</i>&nbsp;        // Constructors
<i>4558</i>&nbsp;        //
<i>4559</i>&nbsp;
<i>4560</i>&nbsp;        public ShortVector() {}
<i>4561</i>&nbsp;
<i>4562</i>&nbsp;        public ShortVector(int initialCapacity) {
<i>4563</i>&nbsp;            fData = new short[initialCapacity];
<i>4564</i>&nbsp;        }
<i>4565</i>&nbsp;
<i>4566</i>&nbsp;        //
<i>4567</i>&nbsp;        // Public methods
<i>4568</i>&nbsp;        //
<i>4569</i>&nbsp;
<i>4570</i>&nbsp;        /** Returns the length of the vector. */
<i>4571</i>&nbsp;        public int length() {
<i>4572</i>&nbsp;            return fLength;
<i>4573</i>&nbsp;        }
<i>4574</i>&nbsp;
<i>4575</i>&nbsp;        /** Adds the value to the vector. */
<i>4576</i>&nbsp;        public void add(short value) {
<i>4577</i>&nbsp;            ensureCapacity(fLength + 1);
<i>4578</i>&nbsp;            fData[fLength++] = value;
<i>4579</i>&nbsp;        }
<i>4580</i>&nbsp;
<i>4581</i>&nbsp;        /** Returns the short value at the specified position in the vector. */
<i>4582</i>&nbsp;        public short valueAt(int position) {
<i>4583</i>&nbsp;            return fData[position];
<i>4584</i>&nbsp;        }
<i>4585</i>&nbsp;
<i>4586</i>&nbsp;        /** Clears the vector. */
<i>4587</i>&nbsp;        public void clear() {
<i>4588</i>&nbsp;            fLength = 0;
<i>4589</i>&nbsp;        }
<i>4590</i>&nbsp;
<i>4591</i>&nbsp;        /** Returns whether the short is contained in the vector. */
<i>4592</i>&nbsp;        public boolean contains(short value) {
<i>4593</i>&nbsp;            for (int i = 0; i &lt; fLength; ++i) {
<i>4594</i>&nbsp;                if (fData[i] == value) {
<i>4595</i>&nbsp;                    return true;
<i>4596</i>&nbsp;                }
<i>4597</i>&nbsp;            }
<i>4598</i>&nbsp;            return false;
<i>4599</i>&nbsp;        }
<i>4600</i>&nbsp;
<i>4601</i>&nbsp;        //
<i>4602</i>&nbsp;        // Private methods
<i>4603</i>&nbsp;        //
<i>4604</i>&nbsp;
<i>4605</i>&nbsp;        /** Ensures capacity. */
<i>4606</i>&nbsp;        private void ensureCapacity(int size) {
<i>4607</i>&nbsp;            if (fData == null) {
<i>4608</i>&nbsp;                fData = new short[8];
<i>4609</i>&nbsp;            }
<i>4610</i>&nbsp;            else if (fData.length &lt;= size) {
<i>4611</i>&nbsp;                short[] newdata = new short[fData.length * 2];
<i>4612</i>&nbsp;                System.arraycopy(fData, 0, newdata, 0, fData.length);
<i>4613</i>&nbsp;                fData = newdata;
<i>4614</i>&nbsp;            }
<i>4615</i>&nbsp;        }
<i>4616</i>&nbsp;    }
<i>4617</i>&nbsp;
<i>4618</i>&nbsp;} // class SchemaValidator
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
