


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: XSConstraints</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.org.apache.xerces.internal.impl.xs</a> ]
</div>

<h1>Coverage Summary for Class: XSConstraints (com.sun.org.apache.xerces.internal.impl.xs)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">XSConstraints</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 528)
  </span>
</td>
</tr>
  <tr>
    <td class="name">XSConstraints$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 546)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; */
<i>4</i>&nbsp;/*
<i>5</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>6</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>7</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>8</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>9</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>10</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>13</i>&nbsp; *
<i>14</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>15</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>16</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>17</i>&nbsp; * See the License for the specific language governing permissions and
<i>18</i>&nbsp; * limitations under the License.
<i>19</i>&nbsp; */
<i>20</i>&nbsp;
<i>21</i>&nbsp;package com.sun.org.apache.xerces.internal.impl.xs;
<i>22</i>&nbsp;
<i>23</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
<i>24</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.InvalidDatatypeValueException;
<i>25</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.ValidatedInfo;
<i>26</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.ValidationContext;
<i>27</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
<i>28</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.models.CMBuilder;
<i>29</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.models.XSCMValidator;
<i>30</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.util.SimpleLocator;
<i>31</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.xs.util.XSObjectListImpl;
<i>32</i>&nbsp;import com.sun.org.apache.xerces.internal.util.SymbolHash;
<i>33</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.XSConstants;
<i>34</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.XSObjectList;
<i>35</i>&nbsp;import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
<i>36</i>&nbsp;import java.util.ArrayList;
<i>37</i>&nbsp;import java.util.Collections;
<i>38</i>&nbsp;import java.util.Comparator;
<i>39</i>&nbsp;import java.util.List;
<i>40</i>&nbsp;
<i>41</i>&nbsp;/**
<i>42</i>&nbsp; * Constaints shared by traversers and validator
<i>43</i>&nbsp; *
<i>44</i>&nbsp; * @xerces.internal
<i>45</i>&nbsp; *
<i>46</i>&nbsp; * @author Sandy Gao, IBM
<i>47</i>&nbsp; *
<i>48</i>&nbsp; * @LastModified: Nov 2017
<i>49</i>&nbsp; */
<b class="nc"><i>50</i>&nbsp;public class XSConstraints {</b>
<i>51</i>&nbsp;
<i>52</i>&nbsp;    // IHR: Visited on 2006-11-17
<i>53</i>&nbsp;    // Added a boolean return value to particleValidRestriction (it was a void function)
<i>54</i>&nbsp;    // to help the checkRecurseLax to know when expansion has happened and no order is required
<i>55</i>&nbsp;    // (IHR@xbrl.org) (Ignacio@Hernandez-Ros.com)
<i>56</i>&nbsp;
<i>57</i>&nbsp;    static final int OCCURRENCE_UNKNOWN = SchemaSymbols.OCCURRENCE_UNBOUNDED-1;
<b class="nc"><i>58</i>&nbsp;    static final XSSimpleType STRING_TYPE =</b>
<i>59</i>&nbsp;            (XSSimpleType)SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(SchemaSymbols.ATTVAL_STRING);
<b class="nc"><i>60</i>&nbsp;</b>
<i>61</i>&nbsp;    private static XSParticleDecl fEmptyParticle = null;
<b class="nc"><i>62</i>&nbsp;    public static XSParticleDecl getEmptySequence() {</b>
<b class="nc"><i>63</i>&nbsp;        if (fEmptyParticle == null) {</b>
<b class="nc"><i>64</i>&nbsp;            XSModelGroupImpl group = new XSModelGroupImpl();</b>
<b class="nc"><i>65</i>&nbsp;            group.fCompositor = XSModelGroupImpl.MODELGROUP_SEQUENCE;</b>
<b class="nc"><i>66</i>&nbsp;            group.fParticleCount = 0;</b>
<b class="nc"><i>67</i>&nbsp;            group.fParticles = null;</b>
<b class="nc"><i>68</i>&nbsp;            group.fAnnotations = XSObjectListImpl.EMPTY_LIST;</b>
<b class="nc"><i>69</i>&nbsp;            XSParticleDecl particle = new XSParticleDecl();</b>
<b class="nc"><i>70</i>&nbsp;            particle.fType = XSParticleDecl.PARTICLE_MODELGROUP;</b>
<b class="nc"><i>71</i>&nbsp;            particle.fValue = group;</b>
<b class="nc"><i>72</i>&nbsp;            particle.fAnnotations = XSObjectListImpl.EMPTY_LIST;</b>
<i>73</i>&nbsp;            fEmptyParticle = particle;
<b class="nc"><i>74</i>&nbsp;        }</b>
<i>75</i>&nbsp;        return fEmptyParticle;
<i>76</i>&nbsp;    }
<b class="nc"><i>77</i>&nbsp;</b>
<i>78</i>&nbsp;    private static final Comparator&lt;XSParticleDecl&gt; ELEMENT_PARTICLE_COMPARATOR =
<i>79</i>&nbsp;            new Comparator&lt;XSParticleDecl&gt;() {
<b class="nc"><i>80</i>&nbsp;</b>
<b class="nc"><i>81</i>&nbsp;        public int compare(XSParticleDecl o1, XSParticleDecl o2) {</b>
<b class="nc"><i>82</i>&nbsp;            XSParticleDecl pDecl1 = o1;</b>
<b class="nc"><i>83</i>&nbsp;            XSParticleDecl pDecl2 = o2;</b>
<i>84</i>&nbsp;            XSElementDecl decl1 = (XSElementDecl) pDecl1.fValue;
<b class="nc"><i>85</i>&nbsp;            XSElementDecl decl2 = (XSElementDecl) pDecl2.fValue;</b>
<b class="nc"><i>86</i>&nbsp;</b>
<b class="nc"><i>87</i>&nbsp;            String namespace1 = decl1.getNamespace();</b>
<b class="nc"><i>88</i>&nbsp;            String namespace2 = decl2.getNamespace();</b>
<i>89</i>&nbsp;            String name1 = decl1.getName();
<b class="nc"><i>90</i>&nbsp;            String name2 = decl2.getName();</b>
<b class="nc"><i>91</i>&nbsp;</b>
<i>92</i>&nbsp;            boolean sameNamespace = (namespace1 == namespace2);
<b class="nc"><i>93</i>&nbsp;            int namespaceComparison = 0;</b>
<b class="nc"><i>94</i>&nbsp;</b>
<b class="nc"><i>95</i>&nbsp;            if (!sameNamespace) {</b>
<b class="nc"><i>96</i>&nbsp;                if (namespace1 != null) {</b>
<i>97</i>&nbsp;                    if (namespace2 != null){
<i>98</i>&nbsp;                        namespaceComparison = namespace1.compareTo(namespace2);
<b class="nc"><i>99</i>&nbsp;                    }</b>
<i>100</i>&nbsp;                    else {
<i>101</i>&nbsp;                        namespaceComparison = 1;
<i>102</i>&nbsp;                    }
<b class="nc"><i>103</i>&nbsp;                }</b>
<i>104</i>&nbsp;                else {
<i>105</i>&nbsp;                    namespaceComparison = -1;
<i>106</i>&nbsp;                }
<b class="nc"><i>107</i>&nbsp;            }</b>
<i>108</i>&nbsp;            //This assumes that the names are never null.
<i>109</i>&nbsp;            return namespaceComparison != 0 ? namespaceComparison : name1.compareTo(name2);
<i>110</i>&nbsp;        }
<i>111</i>&nbsp;    };
<i>112</i>&nbsp;
<i>113</i>&nbsp;    /**
<i>114</i>&nbsp;     * check whether derived is valid derived from base, given a subset
<i>115</i>&nbsp;     * of {restriction, extension}.B
<i>116</i>&nbsp;     */
<b class="nc"><i>117</i>&nbsp;    public static boolean checkTypeDerivationOk(XSTypeDefinition derived, XSTypeDefinition base, short block) {</b>
<b class="nc"><i>118</i>&nbsp;        // if derived is anyType, then it&#39;s valid only if base is anyType too</b>
<i>119</i>&nbsp;        if (derived == SchemaGrammar.fAnyType)
<i>120</i>&nbsp;            return derived == base;
<b class="nc"><i>121</i>&nbsp;        // if derived is anySimpleType, then it&#39;s valid only if the base</b>
<b class="nc"><i>122</i>&nbsp;        // is ur-type</b>
<i>123</i>&nbsp;        if (derived == SchemaGrammar.fAnySimpleType) {
<i>124</i>&nbsp;            return (base == SchemaGrammar.fAnyType ||
<i>125</i>&nbsp;                    base == SchemaGrammar.fAnySimpleType);
<i>126</i>&nbsp;        }
<b class="nc"><i>127</i>&nbsp;</b>
<i>128</i>&nbsp;        // if derived is simple type
<b class="nc"><i>129</i>&nbsp;        if (derived.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {</b>
<i>130</i>&nbsp;            // if base is complex type
<i>131</i>&nbsp;            if (base.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<b class="nc"><i>132</i>&nbsp;                // if base is anyType, change base to anySimpleType,</b>
<b class="nc"><i>133</i>&nbsp;                // otherwise, not valid</b>
<i>134</i>&nbsp;                if (base == SchemaGrammar.fAnyType)
<b class="nc"><i>135</i>&nbsp;                    base = SchemaGrammar.fAnySimpleType;</b>
<i>136</i>&nbsp;                else
<b class="nc"><i>137</i>&nbsp;                    return false;</b>
<i>138</i>&nbsp;            }
<i>139</i>&nbsp;            return checkSimpleDerivation((XSSimpleType)derived,
<i>140</i>&nbsp;                    (XSSimpleType)base, block);
<b class="nc"><i>141</i>&nbsp;        }</b>
<i>142</i>&nbsp;        else {
<i>143</i>&nbsp;            return checkComplexDerivation((XSComplexTypeDecl)derived, base, block);
<i>144</i>&nbsp;        }
<i>145</i>&nbsp;    }
<i>146</i>&nbsp;
<i>147</i>&nbsp;    /**
<i>148</i>&nbsp;     * check whether simple type derived is valid derived from base,
<i>149</i>&nbsp;     * given a subset of {restriction, extension}.
<i>150</i>&nbsp;     */
<i>151</i>&nbsp;    public static boolean checkSimpleDerivationOk(XSSimpleType derived, XSTypeDefinition base, short block) {
<b class="nc"><i>152</i>&nbsp;        // if derived is anySimpleType, then it&#39;s valid only if the base</b>
<b class="nc"><i>153</i>&nbsp;        // is ur-type</b>
<i>154</i>&nbsp;        if (derived == SchemaGrammar.fAnySimpleType) {
<i>155</i>&nbsp;            return (base == SchemaGrammar.fAnyType ||
<i>156</i>&nbsp;                    base == SchemaGrammar.fAnySimpleType);
<i>157</i>&nbsp;        }
<b class="nc"><i>158</i>&nbsp;</b>
<i>159</i>&nbsp;        // if base is complex type
<i>160</i>&nbsp;        if (base.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<b class="nc"><i>161</i>&nbsp;            // if base is anyType, change base to anySimpleType,</b>
<b class="nc"><i>162</i>&nbsp;            // otherwise, not valid</b>
<i>163</i>&nbsp;            if (base == SchemaGrammar.fAnyType)
<b class="nc"><i>164</i>&nbsp;                base = SchemaGrammar.fAnySimpleType;</b>
<i>165</i>&nbsp;            else
<b class="nc"><i>166</i>&nbsp;                return false;</b>
<i>167</i>&nbsp;        }
<i>168</i>&nbsp;        return checkSimpleDerivation(derived, (XSSimpleType)base, block);
<i>169</i>&nbsp;    }
<i>170</i>&nbsp;
<i>171</i>&nbsp;    /**
<i>172</i>&nbsp;     * check whether complex type derived is valid derived from base,
<i>173</i>&nbsp;     * given a subset of {restriction, extension}.
<i>174</i>&nbsp;     */
<i>175</i>&nbsp;    public static boolean checkComplexDerivationOk(XSComplexTypeDecl derived, XSTypeDefinition base, short block) {
<b class="nc"><i>176</i>&nbsp;        // if derived is anyType, then it&#39;s valid only if base is anyType too</b>
<b class="nc"><i>177</i>&nbsp;        if (derived == SchemaGrammar.fAnyType)</b>
<b class="nc"><i>178</i>&nbsp;            return derived == base;</b>
<i>179</i>&nbsp;        return checkComplexDerivation(derived, base, block);
<i>180</i>&nbsp;    }
<i>181</i>&nbsp;
<i>182</i>&nbsp;    /**
<i>183</i>&nbsp;     * Note: this will be a private method, and it assumes that derived is not
<i>184</i>&nbsp;     *       anySimpleType, and base is not anyType. Another method will be
<i>185</i>&nbsp;     *       introduced for public use, which will call this method.
<i>186</i>&nbsp;     */
<i>187</i>&nbsp;    private static boolean checkSimpleDerivation(XSSimpleType derived, XSSimpleType base, short block) {
<b class="nc"><i>188</i>&nbsp;        // 1 They are the same type definition.</b>
<b class="nc"><i>189</i>&nbsp;        if (derived == base)</b>
<i>190</i>&nbsp;            return true;
<i>191</i>&nbsp;
<i>192</i>&nbsp;        // 2 All of the following must be true:
<b class="nc"><i>193</i>&nbsp;        // 2.1 restriction is not in the subset, or in the {final} of its own {base type definition};</b>
<b class="nc"><i>194</i>&nbsp;        if ((block &amp; XSConstants.DERIVATION_RESTRICTION) != 0 ||</b>
<b class="nc"><i>195</i>&nbsp;                (derived.getBaseType().getFinal() &amp; XSConstants.DERIVATION_RESTRICTION) != 0) {</b>
<i>196</i>&nbsp;            return false;
<i>197</i>&nbsp;        }
<i>198</i>&nbsp;
<i>199</i>&nbsp;        // 2.2 One of the following must be true:
<b class="nc"><i>200</i>&nbsp;        // 2.2.1 D&#39;s base type definition is B.</b>
<b class="nc"><i>201</i>&nbsp;        XSSimpleType directBase = (XSSimpleType)derived.getBaseType();</b>
<b class="nc"><i>202</i>&nbsp;        if (directBase == base)</b>
<i>203</i>&nbsp;            return true;
<i>204</i>&nbsp;
<b class="nc"><i>205</i>&nbsp;        // 2.2.2 D&#39;s base type definition is not the simple ur-type definition and is validly derived from B given the subset, as defined by this constraint.</b>
<b class="nc"><i>206</i>&nbsp;        if (directBase != SchemaGrammar.fAnySimpleType &amp;&amp;</b>
<b class="nc"><i>207</i>&nbsp;                checkSimpleDerivation(directBase, base, block)) {</b>
<i>208</i>&nbsp;            return true;
<i>209</i>&nbsp;        }
<i>210</i>&nbsp;
<b class="nc"><i>211</i>&nbsp;        // 2.2.3 D&#39;s {variety} is list or union and B is the simple ur-type definition.</b>
<b class="nc"><i>212</i>&nbsp;        if ((derived.getVariety() == XSSimpleType.VARIETY_LIST ||</b>
<i>213</i>&nbsp;                derived.getVariety() == XSSimpleType.VARIETY_UNION) &amp;&amp;
<b class="nc"><i>214</i>&nbsp;                base == SchemaGrammar.fAnySimpleType) {</b>
<i>215</i>&nbsp;            return true;
<i>216</i>&nbsp;        }
<i>217</i>&nbsp;
<b class="nc"><i>218</i>&nbsp;        // 2.2.4 B&#39;s {variety} is union and D is validly derived from a type definition in B&#39;s {member type definitions} given the subset, as defined by this constraint.</b>
<b class="nc"><i>219</i>&nbsp;        if (base.getVariety() == XSSimpleType.VARIETY_UNION) {</b>
<b class="nc"><i>220</i>&nbsp;            XSObjectList subUnionMemberDV = base.getMemberTypes();</b>
<b class="nc"><i>221</i>&nbsp;            int subUnionSize = subUnionMemberDV.getLength();</b>
<b class="nc"><i>222</i>&nbsp;            for (int i=0; i&lt;subUnionSize; i++) {</b>
<b class="nc"><i>223</i>&nbsp;                base = (XSSimpleType)subUnionMemberDV.item(i);</b>
<b class="nc"><i>224</i>&nbsp;                if (checkSimpleDerivation(derived, base, block))</b>
<i>225</i>&nbsp;                    return true;
<i>226</i>&nbsp;            }
<i>227</i>&nbsp;        }
<b class="nc"><i>228</i>&nbsp;</b>
<i>229</i>&nbsp;        return false;
<i>230</i>&nbsp;    }
<i>231</i>&nbsp;
<i>232</i>&nbsp;    /**
<i>233</i>&nbsp;     * Note: this will be a private method, and it assumes that derived is not
<i>234</i>&nbsp;     *       anyType. Another method will be introduced for public use,
<i>235</i>&nbsp;     *       which will call this method.
<i>236</i>&nbsp;     */
<i>237</i>&nbsp;    private static boolean checkComplexDerivation(XSComplexTypeDecl derived, XSTypeDefinition base, short block) {
<b class="nc"><i>238</i>&nbsp;        // 2.1 B and D must be the same type definition.</b>
<b class="nc"><i>239</i>&nbsp;        if (derived == base)</b>
<i>240</i>&nbsp;            return true;
<i>241</i>&nbsp;
<b class="nc"><i>242</i>&nbsp;        // 1 If B and D are not the same type definition, then the {derivation method} of D must not be in the subset.</b>
<b class="nc"><i>243</i>&nbsp;        if ((derived.fDerivedBy &amp; block) != 0)</b>
<i>244</i>&nbsp;            return false;
<i>245</i>&nbsp;
<b class="nc"><i>246</i>&nbsp;        // 2 One of the following must be true:</b>
<i>247</i>&nbsp;        XSTypeDefinition directBase = derived.fBaseType;
<b class="nc"><i>248</i>&nbsp;        // 2.2 B must be D&#39;s {base type definition}.</b>
<b class="nc"><i>249</i>&nbsp;        if (directBase == base)</b>
<i>250</i>&nbsp;            return true;
<i>251</i>&nbsp;
<i>252</i>&nbsp;        // 2.3 All of the following must be true:
<b class="nc"><i>253</i>&nbsp;        // 2.3.1 D&#39;s {base type definition} must not be the ur-type definition.</b>
<i>254</i>&nbsp;        if (directBase == SchemaGrammar.fAnyType ||
<b class="nc"><i>255</i>&nbsp;                directBase == SchemaGrammar.fAnySimpleType) {</b>
<i>256</i>&nbsp;            return false;
<i>257</i>&nbsp;        }
<i>258</i>&nbsp;
<i>259</i>&nbsp;        // 2.3.2 The appropriate case among the following must be true:
<b class="nc"><i>260</i>&nbsp;        // 2.3.2.1 If D&#39;s {base type definition} is complex, then it must be validly derived from B given the subset as defined by this constraint.</b>
<b class="nc"><i>261</i>&nbsp;        if (directBase.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE)</b>
<i>262</i>&nbsp;            return checkComplexDerivation((XSComplexTypeDecl)directBase, base, block);
<i>263</i>&nbsp;
<b class="nc"><i>264</i>&nbsp;        // 2.3.2.2 If D&#39;s {base type definition} is simple, then it must be validly derived from B given the subset as defined in Type Derivation OK (Simple) (3.14.6).</b>
<i>265</i>&nbsp;        if (directBase.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {
<b class="nc"><i>266</i>&nbsp;            // if base is complex type</b>
<i>267</i>&nbsp;            if (base.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {
<i>268</i>&nbsp;                // if base is anyType, change base to anySimpleType,
<b class="nc"><i>269</i>&nbsp;                // otherwise, not valid</b>
<b class="nc"><i>270</i>&nbsp;                if (base == SchemaGrammar.fAnyType)</b>
<i>271</i>&nbsp;                    base = SchemaGrammar.fAnySimpleType;
<b class="nc"><i>272</i>&nbsp;                else</b>
<i>273</i>&nbsp;                    return false;
<b class="nc"><i>274</i>&nbsp;            }</b>
<i>275</i>&nbsp;            return checkSimpleDerivation((XSSimpleType)directBase,
<i>276</i>&nbsp;                    (XSSimpleType)base, block);
<i>277</i>&nbsp;        }
<b class="nc"><i>278</i>&nbsp;</b>
<i>279</i>&nbsp;        return false;
<i>280</i>&nbsp;    }
<i>281</i>&nbsp;
<i>282</i>&nbsp;    /**
<i>283</i>&nbsp;     * check whether a value is a valid default for some type
<i>284</i>&nbsp;     * returns the compiled form of the value
<i>285</i>&nbsp;     * The parameter value could be either a String or a ValidatedInfo object
<i>286</i>&nbsp;     */
<i>287</i>&nbsp;    public static Object ElementDefaultValidImmediate(XSTypeDefinition type, String value, ValidationContext context, ValidatedInfo vinfo) {
<b class="nc"><i>288</i>&nbsp;</b>
<i>289</i>&nbsp;        XSSimpleType dv = null;
<i>290</i>&nbsp;
<i>291</i>&nbsp;        // e-props-correct
<i>292</i>&nbsp;        // For a string to be a valid default with respect to a type definition the appropriate case among the following must be true:
<b class="nc"><i>293</i>&nbsp;        // 1 If the type definition is a simple type definition, then the string must be valid with respect to that definition as defined by String Valid (3.14.4).</b>
<b class="nc"><i>294</i>&nbsp;        if (type.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {</b>
<i>295</i>&nbsp;            dv = (XSSimpleType)type;
<i>296</i>&nbsp;        }
<i>297</i>&nbsp;
<i>298</i>&nbsp;        // 2 If the type definition is a complex type definition, then all of the following must be true:
<i>299</i>&nbsp;        else {
<b class="nc"><i>300</i>&nbsp;            // 2.1 its {content type} must be a simple type definition or mixed.</b>
<i>301</i>&nbsp;            XSComplexTypeDecl ctype = (XSComplexTypeDecl)type;
<i>302</i>&nbsp;            // 2.2 The appropriate case among the following must be true:
<b class="nc"><i>303</i>&nbsp;            // 2.2.1 If the {content type} is a simple type definition, then the string must be valid with respect to that simple type definition as defined by String Valid (3.14.4).</b>
<b class="nc"><i>304</i>&nbsp;            if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {</b>
<i>305</i>&nbsp;                dv = ctype.fXSSimpleType;
<i>306</i>&nbsp;            }
<b class="nc"><i>307</i>&nbsp;            // 2.2.2 If the {content type} is mixed, then the {content type}&#39;s particle must be emptiable as defined by Particle Emptiable (3.9.6).</b>
<b class="nc"><i>308</i>&nbsp;            else if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_MIXED) {</b>
<b class="nc"><i>309</i>&nbsp;                if (!((XSParticleDecl)ctype.getParticle()).emptiable())</b>
<i>310</i>&nbsp;                    return null;
<i>311</i>&nbsp;            }
<b class="nc"><i>312</i>&nbsp;            else {</b>
<i>313</i>&nbsp;                return null;
<i>314</i>&nbsp;            }
<i>315</i>&nbsp;        }
<i>316</i>&nbsp;
<b class="nc"><i>317</i>&nbsp;        // get the simple type declaration, and validate</b>
<b class="nc"><i>318</i>&nbsp;        Object actualValue = null;</b>
<i>319</i>&nbsp;        if (dv == null) {
<i>320</i>&nbsp;            // complex type with mixed. to make sure that we store correct
<i>321</i>&nbsp;            // information in vinfo and return the correct value, we use
<b class="nc"><i>322</i>&nbsp;            // &quot;string&quot; type for validation</b>
<i>323</i>&nbsp;            dv = STRING_TYPE;
<i>324</i>&nbsp;        }
<i>325</i>&nbsp;        try {
<b class="nc"><i>326</i>&nbsp;            // validate the original lexical rep, and set the actual value</b>
<i>327</i>&nbsp;            actualValue = dv.validate(value, context, vinfo);
<b class="nc"><i>328</i>&nbsp;            // validate the canonical lexical rep</b>
<b class="nc"><i>329</i>&nbsp;            if (vinfo != null)</b>
<b class="nc"><i>330</i>&nbsp;                actualValue = dv.validate(vinfo.stringValue(), context, vinfo);</b>
<b class="nc"><i>331</i>&nbsp;        } catch (InvalidDatatypeValueException ide) {</b>
<b class="nc"><i>332</i>&nbsp;            return null;</b>
<i>333</i>&nbsp;        }
<b class="nc"><i>334</i>&nbsp;</b>
<i>335</i>&nbsp;        return actualValue;
<i>336</i>&nbsp;    }
<i>337</i>&nbsp;
<i>338</i>&nbsp;    static void reportSchemaError(XMLErrorReporter errorReporter,
<i>339</i>&nbsp;            SimpleLocator loc,
<b class="nc"><i>340</i>&nbsp;            String key, Object[] args) {</b>
<b class="nc"><i>341</i>&nbsp;        if (loc != null) {</b>
<i>342</i>&nbsp;            errorReporter.reportError(loc, XSMessageFormatter.SCHEMA_DOMAIN,
<i>343</i>&nbsp;                    key, args, XMLErrorReporter.SEVERITY_ERROR);
<i>344</i>&nbsp;        }
<b class="nc"><i>345</i>&nbsp;        else {</b>
<i>346</i>&nbsp;            errorReporter.reportError(XSMessageFormatter.SCHEMA_DOMAIN,
<i>347</i>&nbsp;                    key, args, XMLErrorReporter.SEVERITY_ERROR);
<i>348</i>&nbsp;        }
<i>349</i>&nbsp;    }
<i>350</i>&nbsp;
<i>351</i>&nbsp;    /**
<i>352</i>&nbsp;     * used to check the 3 constraints against each complex type
<i>353</i>&nbsp;     * (should be each model group):
<i>354</i>&nbsp;     * Unique Particle Attribution, Particle Derivation (Restriction),
<i>355</i>&nbsp;     * Element Declrations Consistent.
<i>356</i>&nbsp;     */
<i>357</i>&nbsp;    public static void fullSchemaChecking(XSGrammarBucket grammarBucket,
<i>358</i>&nbsp;            SubstitutionGroupHandler SGHandler,
<i>359</i>&nbsp;            CMBuilder cmBuilder,
<i>360</i>&nbsp;            XMLErrorReporter errorReporter) {
<i>361</i>&nbsp;        // get all grammars, and put all substitution group information
<b class="nc"><i>362</i>&nbsp;        // in the substitution group handler</b>
<b class="nc"><i>363</i>&nbsp;        SchemaGrammar[] grammars = grammarBucket.getGrammars();</b>
<b class="nc"><i>364</i>&nbsp;        for (int i = grammars.length-1; i &gt;= 0; i--) {</b>
<i>365</i>&nbsp;            SGHandler.addSubstitutionGroup(grammars[i].getSubstitutionGroups());
<i>366</i>&nbsp;        }
<b class="nc"><i>367</i>&nbsp;</b>
<b class="nc"><i>368</i>&nbsp;        XSParticleDecl fakeDerived = new XSParticleDecl();</b>
<b class="nc"><i>369</i>&nbsp;        XSParticleDecl fakeBase = new XSParticleDecl();</b>
<b class="nc"><i>370</i>&nbsp;        fakeDerived.fType = XSParticleDecl.PARTICLE_MODELGROUP;</b>
<i>371</i>&nbsp;        fakeBase.fType = XSParticleDecl.PARTICLE_MODELGROUP;
<i>372</i>&nbsp;        // before worrying about complexTypes, let&#39;s get
<b class="nc"><i>373</i>&nbsp;        // groups redefined by restriction out of the way.</b>
<b class="nc"><i>374</i>&nbsp;        for (int g = grammars.length-1; g &gt;= 0; g--) {</b>
<b class="nc"><i>375</i>&nbsp;            XSGroupDecl [] redefinedGroups = grammars[g].getRedefinedGroupDecls();</b>
<b class="nc"><i>376</i>&nbsp;            SimpleLocator [] rgLocators = grammars[g].getRGLocators();</b>
<b class="nc"><i>377</i>&nbsp;            for(int i=0; i&lt;redefinedGroups.length; ) {</b>
<b class="nc"><i>378</i>&nbsp;                XSGroupDecl derivedGrp = redefinedGroups[i++];</b>
<b class="nc"><i>379</i>&nbsp;                XSModelGroupImpl derivedMG = derivedGrp.fModelGroup;</b>
<b class="nc"><i>380</i>&nbsp;                XSGroupDecl baseGrp = redefinedGroups[i++];</b>
<b class="nc"><i>381</i>&nbsp;                XSModelGroupImpl baseMG = baseGrp.fModelGroup;</b>
<b class="nc"><i>382</i>&nbsp;                fakeDerived.fValue = derivedMG;</b>
<b class="nc"><i>383</i>&nbsp;                fakeBase.fValue = baseMG;</b>
<b class="nc"><i>384</i>&nbsp;                if(baseMG == null) {</b>
<b class="nc"><i>385</i>&nbsp;                    if(derivedMG != null) { // can&#39;t be a restriction!</b>
<i>386</i>&nbsp;                        reportSchemaError(errorReporter, rgLocators[i/2-1],
<i>387</i>&nbsp;                                &quot;src-redefine.6.2.2&quot;,
<i>388</i>&nbsp;                                new Object[]{derivedGrp.fName, &quot;rcase-Recurse.2&quot;});
<b class="nc"><i>389</i>&nbsp;                    }</b>
<b class="nc"><i>390</i>&nbsp;                } else if (derivedMG == null) {</b>
<b class="nc"><i>391</i>&nbsp;                    if (!fakeBase.emptiable()) {</b>
<i>392</i>&nbsp;                        reportSchemaError(errorReporter, rgLocators[i/2-1],
<i>393</i>&nbsp;                                &quot;src-redefine.6.2.2&quot;,
<i>394</i>&nbsp;                                new Object[]{derivedGrp.fName, &quot;rcase-Recurse.2&quot;});
<i>395</i>&nbsp;                    }
<i>396</i>&nbsp;                } else {
<b class="nc"><i>397</i>&nbsp;                    try {</b>
<b class="nc"><i>398</i>&nbsp;                        particleValidRestriction(fakeDerived, SGHandler, fakeBase, SGHandler);</b>
<b class="nc"><i>399</i>&nbsp;                    } catch (XMLSchemaException e) {</b>
<b class="nc"><i>400</i>&nbsp;                        String key = e.getKey();</b>
<i>401</i>&nbsp;                        reportSchemaError(errorReporter, rgLocators[i/2-1],
<b class="nc"><i>402</i>&nbsp;                                key,</b>
<b class="nc"><i>403</i>&nbsp;                                e.getArgs());</b>
<i>404</i>&nbsp;                        reportSchemaError(errorReporter, rgLocators[i/2-1],
<i>405</i>&nbsp;                                &quot;src-redefine.6.2.2&quot;,
<b class="nc"><i>406</i>&nbsp;                                new Object[]{derivedGrp.fName, key});</b>
<i>407</i>&nbsp;                    }
<b class="nc"><i>408</i>&nbsp;                }</b>
<i>409</i>&nbsp;            }
<i>410</i>&nbsp;        }
<i>411</i>&nbsp;
<i>412</i>&nbsp;        // for each complex type, check the 3 constraints.
<i>413</i>&nbsp;        // types need to be checked
<i>414</i>&nbsp;        XSComplexTypeDecl[] types;
<i>415</i>&nbsp;        SimpleLocator [] ctLocators;
<i>416</i>&nbsp;        // to hold the errors
<i>417</i>&nbsp;        // REVISIT: do we want to report all errors? or just one?
<i>418</i>&nbsp;        //XMLSchemaError1D errors = new XMLSchemaError1D();
<i>419</i>&nbsp;        // whether need to check this type again;
<i>420</i>&nbsp;        // whether only do UPA checking
<i>421</i>&nbsp;        boolean further, fullChecked;
<i>422</i>&nbsp;        // if do all checkings, how many need to be checked again.
<i>423</i>&nbsp;        int keepType;
<i>424</i>&nbsp;        // i: grammar; j: type; k: error
<b class="nc"><i>425</i>&nbsp;        // for all grammars</b>
<b class="nc"><i>426</i>&nbsp;        SymbolHash elemTable = new SymbolHash();</b>
<i>427</i>&nbsp;        for (int i = grammars.length-1, j; i &gt;= 0; i--) {
<b class="nc"><i>428</i>&nbsp;            // get whether to skip EDC, and types need to be checked</b>
<b class="nc"><i>429</i>&nbsp;            keepType = 0;</b>
<b class="nc"><i>430</i>&nbsp;            fullChecked = grammars[i].fFullChecked;</b>
<b class="nc"><i>431</i>&nbsp;            types = grammars[i].getUncheckedComplexTypeDecls();</b>
<i>432</i>&nbsp;            ctLocators = grammars[i].getUncheckedCTLocators();
<b class="nc"><i>433</i>&nbsp;            // for each type</b>
<i>434</i>&nbsp;            for (j = 0; j &lt; types.length; j++) {
<i>435</i>&nbsp;                // if we&#39;ve already full-checked this grammar, then
<b class="nc"><i>436</i>&nbsp;                // skip the EDC constraint</b>
<i>437</i>&nbsp;                if (!fullChecked) {
<b class="nc"><i>438</i>&nbsp;                    // 1. Element Decl Consistent</b>
<b class="nc"><i>439</i>&nbsp;                    if (types[j].fParticle!=null) {</b>
<i>440</i>&nbsp;                        elemTable.clear();
<b class="nc"><i>441</i>&nbsp;                        try {</b>
<i>442</i>&nbsp;                            checkElementDeclsConsistent(types[j], types[j].fParticle,
<i>443</i>&nbsp;                                    elemTable, SGHandler);
<b class="nc"><i>444</i>&nbsp;                        }</b>
<b class="nc"><i>445</i>&nbsp;                        catch (XMLSchemaException e) {</b>
<b class="nc"><i>446</i>&nbsp;                            reportSchemaError(errorReporter, ctLocators[j],</b>
<b class="nc"><i>447</i>&nbsp;                                    e.getKey(),</b>
<b class="nc"><i>448</i>&nbsp;                                    e.getArgs());</b>
<i>449</i>&nbsp;                        }
<i>450</i>&nbsp;                    }
<i>451</i>&nbsp;                }
<i>452</i>&nbsp;
<i>453</i>&nbsp;                // 2. Particle Derivation
<b class="nc"><i>454</i>&nbsp;</b>
<i>455</i>&nbsp;                if (types[j].fBaseType != null &amp;&amp;
<i>456</i>&nbsp;                        types[j].fBaseType != SchemaGrammar.fAnyType &amp;&amp;
<i>457</i>&nbsp;                        types[j].fDerivedBy == XSConstants.DERIVATION_RESTRICTION &amp;&amp;
<i>458</i>&nbsp;                        (types[j].fBaseType instanceof XSComplexTypeDecl)) {
<b class="nc"><i>459</i>&nbsp;</b>
<b class="nc"><i>460</i>&nbsp;                    XSParticleDecl derivedParticle=types[j].fParticle;</b>
<i>461</i>&nbsp;                    XSParticleDecl baseParticle=
<b class="nc"><i>462</i>&nbsp;                        ((XSComplexTypeDecl)(types[j].fBaseType)).fParticle;</b>
<b class="nc"><i>463</i>&nbsp;                    if (derivedParticle==null) {</b>
<b class="nc"><i>464</i>&nbsp;                        if (baseParticle!=null &amp;&amp; !baseParticle.emptiable()) {</b>
<i>465</i>&nbsp;                            reportSchemaError(errorReporter,ctLocators[j],
<b class="nc"><i>466</i>&nbsp;                                    &quot;derivation-ok-restriction.5.3.2&quot;,</b>
<i>467</i>&nbsp;                                    new Object[]{types[j].fName, types[j].fBaseType.getName()});
<i>468</i>&nbsp;                        }
<b class="nc"><i>469</i>&nbsp;                    }</b>
<i>470</i>&nbsp;                    else if (baseParticle!=null) {
<b class="nc"><i>471</i>&nbsp;                        try {</b>
<i>472</i>&nbsp;                            particleValidRestriction(types[j].fParticle,
<i>473</i>&nbsp;                                    SGHandler,
<i>474</i>&nbsp;                                    ((XSComplexTypeDecl)(types[j].fBaseType)).fParticle,
<b class="nc"><i>475</i>&nbsp;                                    SGHandler);</b>
<b class="nc"><i>476</i>&nbsp;                        } catch (XMLSchemaException e) {</b>
<b class="nc"><i>477</i>&nbsp;                            reportSchemaError(errorReporter, ctLocators[j],</b>
<b class="nc"><i>478</i>&nbsp;                                    e.getKey(),</b>
<b class="nc"><i>479</i>&nbsp;                                    e.getArgs());</b>
<i>480</i>&nbsp;                            reportSchemaError(errorReporter, ctLocators[j],
<i>481</i>&nbsp;                                    &quot;derivation-ok-restriction.5.4.2&quot;,
<b class="nc"><i>482</i>&nbsp;                                    new Object[]{types[j].fName});</b>
<i>483</i>&nbsp;                        }
<i>484</i>&nbsp;                    }
<b class="nc"><i>485</i>&nbsp;                    else {</b>
<i>486</i>&nbsp;                        reportSchemaError(errorReporter, ctLocators[j],
<i>487</i>&nbsp;                                &quot;derivation-ok-restriction.5.4.2&quot;,
<i>488</i>&nbsp;                                new Object[]{types[j].fName});
<i>489</i>&nbsp;                    }
<i>490</i>&nbsp;                }
<i>491</i>&nbsp;                // 3. UPA
<b class="nc"><i>492</i>&nbsp;                // get the content model and check UPA</b>
<b class="nc"><i>493</i>&nbsp;                XSCMValidator cm = types[j].getContentModel(cmBuilder, true);</b>
<b class="nc"><i>494</i>&nbsp;                further = false;</b>
<i>495</i>&nbsp;                if (cm != null) {
<b class="nc"><i>496</i>&nbsp;                    try {</b>
<b class="nc"><i>497</i>&nbsp;                        further = cm.checkUniqueParticleAttribution(SGHandler);</b>
<b class="nc"><i>498</i>&nbsp;                    } catch (XMLSchemaException e) {</b>
<b class="nc"><i>499</i>&nbsp;                        reportSchemaError(errorReporter, ctLocators[j],</b>
<b class="nc"><i>500</i>&nbsp;                                e.getKey(),</b>
<b class="nc"><i>501</i>&nbsp;                                e.getArgs());</b>
<i>502</i>&nbsp;                    }
<i>503</i>&nbsp;                }
<i>504</i>&nbsp;                // now report all errors
<i>505</i>&nbsp;                // REVISIT: do we want to report all errors? or just one?
<i>506</i>&nbsp;                /*for (k = errors.getErrorCodeNum()-1; k &gt;= 0; k--) {
<i>507</i>&nbsp;                    reportSchemaError(errorReporter, ctLocators[j],
<i>508</i>&nbsp;                                      errors.getErrorCode(k),
<i>509</i>&nbsp;                                      errors.getArgs(k));
<i>510</i>&nbsp;                }*/
<i>511</i>&nbsp;
<i>512</i>&nbsp;                // if we are doing all checkings, and this one needs further
<b class="nc"><i>513</i>&nbsp;                // checking, store it in the type array.</b>
<b class="nc"><i>514</i>&nbsp;                if (!fullChecked &amp;&amp; further)</b>
<i>515</i>&nbsp;                    types[keepType++] = types[j];
<i>516</i>&nbsp;
<i>517</i>&nbsp;                // clear errors for the next type.
<i>518</i>&nbsp;                // REVISIT: do we want to report all errors? or just one?
<i>519</i>&nbsp;                //errors.clear();
<i>520</i>&nbsp;            }
<i>521</i>&nbsp;            // we&#39;ve done with the types in this grammar. if we are checking
<i>522</i>&nbsp;            // all constraints, need to trim type array to a proper size:
<i>523</i>&nbsp;            // only contain those need further checking.
<b class="nc"><i>524</i>&nbsp;            // and mark this grammar that it only needs UPA checking.</b>
<b class="nc"><i>525</i>&nbsp;            if (!fullChecked) {</b>
<b class="nc"><i>526</i>&nbsp;                grammars[i].setUncheckedTypeNum(keepType);</b>
<i>527</i>&nbsp;                grammars[i].fFullChecked = true;
<i>528</i>&nbsp;            }
<i>529</i>&nbsp;        }
<i>530</i>&nbsp;    }
<i>531</i>&nbsp;
<i>532</i>&nbsp;    /*
<i>533</i>&nbsp;       Check that a given particle is a valid restriction of a base particle.
<i>534</i>&nbsp;     */
<i>535</i>&nbsp;
<i>536</i>&nbsp;    public static void checkElementDeclsConsistent(XSComplexTypeDecl type,
<i>537</i>&nbsp;            XSParticleDecl particle,
<i>538</i>&nbsp;            SymbolHash elemDeclHash,
<i>539</i>&nbsp;            SubstitutionGroupHandler sgHandler)
<i>540</i>&nbsp;        throws XMLSchemaException {
<i>541</i>&nbsp;
<i>542</i>&nbsp;        // check for elements in the tree with the same name and namespace
<b class="nc"><i>543</i>&nbsp;</b>
<i>544</i>&nbsp;        int pType = particle.fType;
<b class="nc"><i>545</i>&nbsp;</b>
<i>546</i>&nbsp;        if (pType == XSParticleDecl.PARTICLE_WILDCARD)
<i>547</i>&nbsp;            return;
<b class="nc"><i>548</i>&nbsp;</b>
<b class="nc"><i>549</i>&nbsp;        if (pType == XSParticleDecl.PARTICLE_ELEMENT) {</b>
<b class="nc"><i>550</i>&nbsp;            XSElementDecl elem = (XSElementDecl)(particle.fValue);</b>
<i>551</i>&nbsp;            findElemInTable(type, elem, elemDeclHash);
<b class="nc"><i>552</i>&nbsp;</b>
<i>553</i>&nbsp;            if (elem.fScope == XSConstants.SCOPE_GLOBAL) {
<b class="nc"><i>554</i>&nbsp;                // Check for subsitution groups.</b>
<b class="nc"><i>555</i>&nbsp;                XSElementDecl[] subGroup = sgHandler.getSubstitutionGroup(elem);</b>
<b class="nc"><i>556</i>&nbsp;                for (int i = 0; i &lt; subGroup.length; i++) {</b>
<i>557</i>&nbsp;                    findElemInTable(type, subGroup[i], elemDeclHash);
<i>558</i>&nbsp;                }
<i>559</i>&nbsp;            }
<i>560</i>&nbsp;            return;
<i>561</i>&nbsp;        }
<b class="nc"><i>562</i>&nbsp;</b>
<b class="nc"><i>563</i>&nbsp;        XSModelGroupImpl group = (XSModelGroupImpl)particle.fValue;</b>
<b class="nc"><i>564</i>&nbsp;        for (int i = 0; i &lt; group.fParticleCount; i++)</b>
<i>565</i>&nbsp;            checkElementDeclsConsistent(type, group.fParticles[i], elemDeclHash, sgHandler);
<i>566</i>&nbsp;    }
<i>567</i>&nbsp;
<i>568</i>&nbsp;    public static void findElemInTable(XSComplexTypeDecl type, XSElementDecl elem,
<i>569</i>&nbsp;            SymbolHash elemDeclHash)
<i>570</i>&nbsp;        throws XMLSchemaException {
<i>571</i>&nbsp;
<b class="nc"><i>572</i>&nbsp;        // How can we avoid this concat?  LM.</b>
<i>573</i>&nbsp;        String name = elem.fName + &quot;,&quot; + elem.fTargetNamespace;
<b class="nc"><i>574</i>&nbsp;</b>
<b class="nc"><i>575</i>&nbsp;        XSElementDecl existingElem = null;</b>
<i>576</i>&nbsp;        if ((existingElem = (XSElementDecl)(elemDeclHash.get(name))) == null) {
<b class="nc"><i>577</i>&nbsp;            // just add it in</b>
<i>578</i>&nbsp;            elemDeclHash.put(name, elem);
<i>579</i>&nbsp;        }
<i>580</i>&nbsp;        else {
<b class="nc"><i>581</i>&nbsp;            // If this is the same check element, we&#39;re O.K.</b>
<i>582</i>&nbsp;            if (elem == existingElem)
<i>583</i>&nbsp;                return;
<b class="nc"><i>584</i>&nbsp;</b>
<i>585</i>&nbsp;            if (elem.fType != existingElem.fType) {
<b class="nc"><i>586</i>&nbsp;                // Types are not the same</b>
<i>587</i>&nbsp;                throw new XMLSchemaException(&quot;cos-element-consistent&quot;,
<i>588</i>&nbsp;                        new Object[] {type.fName, elem.fName});
<i>589</i>&nbsp;
<i>590</i>&nbsp;            }
<i>591</i>&nbsp;        }
<i>592</i>&nbsp;    }
<i>593</i>&nbsp;
<i>594</i>&nbsp;    // Check that a given particle is a valid restriction of a base particle.
<i>595</i>&nbsp;    //
<i>596</i>&nbsp;    // IHR: 2006/11/17
<i>597</i>&nbsp;    // Returns a boolean indicating if there has been expansion of substitution group
<i>598</i>&nbsp;    // in the bParticle.
<i>599</i>&nbsp;    // With this information the checkRecurseLax function knows when is
<i>600</i>&nbsp;    // to keep the order and when to ignore it.
<i>601</i>&nbsp;    private static boolean particleValidRestriction(XSParticleDecl dParticle,
<i>602</i>&nbsp;            SubstitutionGroupHandler dSGHandler,
<i>603</i>&nbsp;            XSParticleDecl bParticle,
<i>604</i>&nbsp;            SubstitutionGroupHandler bSGHandler)
<b class="nc"><i>605</i>&nbsp;        throws XMLSchemaException {</b>
<i>606</i>&nbsp;        return particleValidRestriction(dParticle, dSGHandler, bParticle, bSGHandler, true);
<i>607</i>&nbsp;    }
<i>608</i>&nbsp;
<i>609</i>&nbsp;    private static boolean particleValidRestriction(XSParticleDecl dParticle,
<i>610</i>&nbsp;            SubstitutionGroupHandler dSGHandler,
<i>611</i>&nbsp;            XSParticleDecl bParticle,
<i>612</i>&nbsp;            SubstitutionGroupHandler bSGHandler,
<i>613</i>&nbsp;            boolean checkWCOccurrence)
<i>614</i>&nbsp;        throws XMLSchemaException {
<b class="nc"><i>615</i>&nbsp;</b>
<b class="nc"><i>616</i>&nbsp;        List&lt;XSParticleDecl&gt; dChildren = null;</b>
<b class="nc"><i>617</i>&nbsp;        List&lt;XSParticleDecl&gt; bChildren = null;</b>
<b class="nc"><i>618</i>&nbsp;        int dMinEffectiveTotalRange=OCCURRENCE_UNKNOWN;</b>
<i>619</i>&nbsp;        int dMaxEffectiveTotalRange=OCCURRENCE_UNKNOWN;
<i>620</i>&nbsp;
<b class="nc"><i>621</i>&nbsp;        // By default there has been no expansion</b>
<i>622</i>&nbsp;        boolean bExpansionHappened = false;
<i>623</i>&nbsp;
<i>624</i>&nbsp;        // Check for empty particles.   If either base or derived particle is empty,
<b class="nc"><i>625</i>&nbsp;        // (and the other isn&#39;t) it&#39;s an error.</b>
<b class="nc"><i>626</i>&nbsp;        if (dParticle.isEmpty() &amp;&amp; !bParticle.emptiable()) {</b>
<i>627</i>&nbsp;            throw new XMLSchemaException(&quot;cos-particle-restrict.a&quot;, null);
<b class="nc"><i>628</i>&nbsp;        }</b>
<b class="nc"><i>629</i>&nbsp;        else if (!dParticle.isEmpty() &amp;&amp; bParticle.isEmpty()) {</b>
<i>630</i>&nbsp;            throw new XMLSchemaException(&quot;cos-particle-restrict.b&quot;, null);
<i>631</i>&nbsp;        }
<i>632</i>&nbsp;
<i>633</i>&nbsp;        //
<i>634</i>&nbsp;        // Do setup prior to invoking the Particle (Restriction) cases.
<i>635</i>&nbsp;        // This involves:
<i>636</i>&nbsp;        //   - removing pointless occurrences for groups, and retrieving a vector of
<i>637</i>&nbsp;        //     non-pointless children
<i>638</i>&nbsp;        //   - turning top-level elements with substitution groups into CHOICE groups.
<i>639</i>&nbsp;        //
<b class="nc"><i>640</i>&nbsp;</b>
<i>641</i>&nbsp;        short dType = dParticle.fType;
<i>642</i>&nbsp;        //
<i>643</i>&nbsp;        // Handle pointless groups for the derived particle
<b class="nc"><i>644</i>&nbsp;        //</b>
<b class="nc"><i>645</i>&nbsp;        if (dType == XSParticleDecl.PARTICLE_MODELGROUP) {</b>
<i>646</i>&nbsp;            dType = ((XSModelGroupImpl)dParticle.fValue).fCompositor;
<i>647</i>&nbsp;
<i>648</i>&nbsp;            // Find a group, starting with this particle, with more than 1 child.   There
<i>649</i>&nbsp;            // may be none, and the particle of interest trivially becomes an element or
<b class="nc"><i>650</i>&nbsp;            // wildcard.</b>
<b class="nc"><i>651</i>&nbsp;            XSParticleDecl dtmp = getNonUnaryGroup(dParticle);</b>
<i>652</i>&nbsp;            if (dtmp != dParticle) {
<b class="nc"><i>653</i>&nbsp;                // Particle has been replaced.   Retrieve new type info.</b>
<b class="nc"><i>654</i>&nbsp;                dParticle = dtmp;</b>
<b class="nc"><i>655</i>&nbsp;                dType = dParticle.fType;</b>
<b class="nc"><i>656</i>&nbsp;                if (dType == XSParticleDecl.PARTICLE_MODELGROUP)</b>
<i>657</i>&nbsp;                    dType = ((XSModelGroupImpl)dParticle.fValue).fCompositor;
<i>658</i>&nbsp;            }
<i>659</i>&nbsp;
<i>660</i>&nbsp;            // Fill in a vector with the children of the particle, removing any
<b class="nc"><i>661</i>&nbsp;            // pointless model groups in the process.</b>
<i>662</i>&nbsp;            dChildren = removePointlessChildren(dParticle);
<i>663</i>&nbsp;        }
<b class="nc"><i>664</i>&nbsp;</b>
<b class="nc"><i>665</i>&nbsp;        int dMinOccurs = dParticle.fMinOccurs;</b>
<i>666</i>&nbsp;        int dMaxOccurs = dParticle.fMaxOccurs;
<i>667</i>&nbsp;
<i>668</i>&nbsp;        //
<i>669</i>&nbsp;        // For elements which are the heads of substitution groups, treat as CHOICE
<b class="nc"><i>670</i>&nbsp;        //</b>
<b class="nc"><i>671</i>&nbsp;        if (dSGHandler != null &amp;&amp; dType == XSParticleDecl.PARTICLE_ELEMENT) {</b>
<i>672</i>&nbsp;            XSElementDecl dElement = (XSElementDecl)dParticle.fValue;
<b class="nc"><i>673</i>&nbsp;</b>
<i>674</i>&nbsp;            if (dElement.fScope == XSConstants.SCOPE_GLOBAL) {
<i>675</i>&nbsp;                // Check for subsitution groups.   Treat any element that has a
<i>676</i>&nbsp;                // subsitution group as a choice.   Fill in the children vector with the
<b class="nc"><i>677</i>&nbsp;                // members of the substitution group</b>
<b class="nc"><i>678</i>&nbsp;                XSElementDecl[] subGroup = dSGHandler.getSubstitutionGroup(dElement);</b>
<i>679</i>&nbsp;                if (subGroup.length &gt;0 ) {
<i>680</i>&nbsp;                    // Now, set the type to be CHOICE.  The &quot;group&quot; will have the same
<b class="nc"><i>681</i>&nbsp;                    // occurrence information as the original particle.</b>
<b class="nc"><i>682</i>&nbsp;                    dType = XSModelGroupImpl.MODELGROUP_CHOICE;</b>
<b class="nc"><i>683</i>&nbsp;                    dMinEffectiveTotalRange = dMinOccurs;</b>
<i>684</i>&nbsp;                    dMaxEffectiveTotalRange = dMaxOccurs;
<i>685</i>&nbsp;
<b class="nc"><i>686</i>&nbsp;                    // Fill in the vector of children</b>
<b class="nc"><i>687</i>&nbsp;                    dChildren = new ArrayList&lt;&gt;(subGroup.length+1);</b>
<b class="nc"><i>688</i>&nbsp;                    for (int i = 0; i &lt; subGroup.length; i++) {</b>
<i>689</i>&nbsp;                        addElementToParticleVector(dChildren, subGroup[i]);
<b class="nc"><i>690</i>&nbsp;                    }</b>
<b class="nc"><i>691</i>&nbsp;                    addElementToParticleVector(dChildren, dElement);</b>
<i>692</i>&nbsp;                    Collections.sort(dChildren, ELEMENT_PARTICLE_COMPARATOR);
<i>693</i>&nbsp;
<i>694</i>&nbsp;                    // Set the handler to null, to indicate that we&#39;ve finished handling
<b class="nc"><i>695</i>&nbsp;                    // substitution groups for this particle.</b>
<i>696</i>&nbsp;                    dSGHandler = null;
<i>697</i>&nbsp;                }
<i>698</i>&nbsp;            }
<i>699</i>&nbsp;        }
<b class="nc"><i>700</i>&nbsp;</b>
<i>701</i>&nbsp;        short bType = bParticle.fType;
<i>702</i>&nbsp;        //
<i>703</i>&nbsp;        // Handle pointless groups for the base particle
<b class="nc"><i>704</i>&nbsp;        //</b>
<b class="nc"><i>705</i>&nbsp;        if (bType == XSParticleDecl.PARTICLE_MODELGROUP) {</b>
<i>706</i>&nbsp;            bType = ((XSModelGroupImpl)bParticle.fValue).fCompositor;
<i>707</i>&nbsp;
<i>708</i>&nbsp;            // Find a group, starting with this particle, with more than 1 child.   There
<i>709</i>&nbsp;            // may be none, and the particle of interest trivially becomes an element or
<b class="nc"><i>710</i>&nbsp;            // wildcard.</b>
<b class="nc"><i>711</i>&nbsp;            XSParticleDecl btmp = getNonUnaryGroup(bParticle);</b>
<i>712</i>&nbsp;            if (btmp != bParticle) {
<b class="nc"><i>713</i>&nbsp;                // Particle has been replaced.   Retrieve new type info.</b>
<b class="nc"><i>714</i>&nbsp;                bParticle = btmp;</b>
<b class="nc"><i>715</i>&nbsp;                bType = bParticle.fType;</b>
<b class="nc"><i>716</i>&nbsp;                if (bType == XSParticleDecl.PARTICLE_MODELGROUP)</b>
<i>717</i>&nbsp;                    bType = ((XSModelGroupImpl)bParticle.fValue).fCompositor;
<i>718</i>&nbsp;            }
<i>719</i>&nbsp;
<i>720</i>&nbsp;            // Fill in a vector with the children of the particle, removing any
<b class="nc"><i>721</i>&nbsp;            // pointless model groups in the process.</b>
<i>722</i>&nbsp;            bChildren = removePointlessChildren(bParticle);
<i>723</i>&nbsp;        }
<b class="nc"><i>724</i>&nbsp;</b>
<b class="nc"><i>725</i>&nbsp;        int bMinOccurs = bParticle.fMinOccurs;</b>
<i>726</i>&nbsp;        int bMaxOccurs = bParticle.fMaxOccurs;
<b class="nc"><i>727</i>&nbsp;</b>
<b class="nc"><i>728</i>&nbsp;        if (bSGHandler != null &amp;&amp; bType == XSParticleDecl.PARTICLE_ELEMENT) {</b>
<i>729</i>&nbsp;            XSElementDecl bElement = (XSElementDecl)bParticle.fValue;
<b class="nc"><i>730</i>&nbsp;</b>
<i>731</i>&nbsp;            if (bElement.fScope == XSConstants.SCOPE_GLOBAL) {
<i>732</i>&nbsp;                // Check for subsitution groups.   Treat any element that has a
<i>733</i>&nbsp;                // subsitution group as a choice.   Fill in the children vector with the
<b class="nc"><i>734</i>&nbsp;                // members of the substitution group</b>
<b class="nc"><i>735</i>&nbsp;                XSElementDecl[] bsubGroup = bSGHandler.getSubstitutionGroup(bElement);</b>
<i>736</i>&nbsp;                if (bsubGroup.length &gt;0 ) {
<b class="nc"><i>737</i>&nbsp;                    // Now, set the type to be CHOICE</b>
<i>738</i>&nbsp;                    bType = XSModelGroupImpl.MODELGROUP_CHOICE;
<b class="nc"><i>739</i>&nbsp;</b>
<b class="nc"><i>740</i>&nbsp;                    bChildren = new ArrayList&lt;&gt;(bsubGroup.length+1);</b>
<b class="nc"><i>741</i>&nbsp;                    for (int i = 0; i &lt; bsubGroup.length; i++) {</b>
<i>742</i>&nbsp;                        addElementToParticleVector(bChildren, bsubGroup[i]);
<b class="nc"><i>743</i>&nbsp;                    }</b>
<b class="nc"><i>744</i>&nbsp;                    addElementToParticleVector(bChildren, bElement);</b>
<i>745</i>&nbsp;                    Collections.sort(bChildren, ELEMENT_PARTICLE_COMPARATOR);
<i>746</i>&nbsp;                    // Set the handler to null, to indicate that we&#39;ve finished handling
<b class="nc"><i>747</i>&nbsp;                    // substitution groups for this particle.</b>
<i>748</i>&nbsp;                    bSGHandler = null;
<i>749</i>&nbsp;
<b class="nc"><i>750</i>&nbsp;                    // if we are here expansion of bParticle happened</b>
<i>751</i>&nbsp;                    bExpansionHappened = true;
<i>752</i>&nbsp;                }
<i>753</i>&nbsp;            }
<i>754</i>&nbsp;        }
<i>755</i>&nbsp;
<i>756</i>&nbsp;        //
<i>757</i>&nbsp;        // O.K. - Figure out which particle derivation rule applies and call it
<b class="nc"><i>758</i>&nbsp;        //</b>
<i>759</i>&nbsp;        switch (dType) {
<i>760</i>&nbsp;            case XSParticleDecl.PARTICLE_ELEMENT:
<b class="nc"><i>761</i>&nbsp;            {</b>
<i>762</i>&nbsp;                switch (bType) {
<i>763</i>&nbsp;
<i>764</i>&nbsp;                    // Elt:Elt NameAndTypeOK
<i>765</i>&nbsp;                    case XSParticleDecl.PARTICLE_ELEMENT:
<b class="nc"><i>766</i>&nbsp;                    {</b>
<i>767</i>&nbsp;                        checkNameAndTypeOK((XSElementDecl)dParticle.fValue,dMinOccurs,dMaxOccurs,
<b class="nc"><i>768</i>&nbsp;                                (XSElementDecl)bParticle.fValue,bMinOccurs,bMaxOccurs);</b>
<i>769</i>&nbsp;                        return bExpansionHappened;
<i>770</i>&nbsp;                    }
<i>771</i>&nbsp;
<i>772</i>&nbsp;                    // Elt:Any NSCompat
<i>773</i>&nbsp;                    case XSParticleDecl.PARTICLE_WILDCARD:
<b class="nc"><i>774</i>&nbsp;                    {</b>
<i>775</i>&nbsp;                        checkNSCompat((XSElementDecl)dParticle.fValue,dMinOccurs,dMaxOccurs,
<i>776</i>&nbsp;                                (XSWildcardDecl)bParticle.fValue,bMinOccurs,bMaxOccurs,
<b class="nc"><i>777</i>&nbsp;                                checkWCOccurrence);</b>
<i>778</i>&nbsp;                        return bExpansionHappened;
<i>779</i>&nbsp;                    }
<i>780</i>&nbsp;
<i>781</i>&nbsp;                    // Elt:All RecurseAsIfGroup
<i>782</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_CHOICE:
<i>783</i>&nbsp;                    {
<i>784</i>&nbsp;                        // Treat the element as if it were in a group of the same type
<b class="nc"><i>785</i>&nbsp;                        // as the base Particle</b>
<b class="nc"><i>786</i>&nbsp;                        dChildren = new ArrayList&lt;&gt;();</b>
<i>787</i>&nbsp;                        dChildren.add(dParticle);
<b class="nc"><i>788</i>&nbsp;</b>
<i>789</i>&nbsp;                        checkRecurseLax(dChildren, 1, 1, dSGHandler,
<b class="nc"><i>790</i>&nbsp;                                bChildren, bMinOccurs, bMaxOccurs, bSGHandler);</b>
<i>791</i>&nbsp;                        return bExpansionHappened;
<i>792</i>&nbsp;                    }
<i>793</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_SEQUENCE:
<i>794</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_ALL:
<i>795</i>&nbsp;                    {
<i>796</i>&nbsp;                        // Treat the element as if it were in a group of the same type
<b class="nc"><i>797</i>&nbsp;                        // as the base Particle</b>
<b class="nc"><i>798</i>&nbsp;                        dChildren = new ArrayList&lt;&gt;();</b>
<i>799</i>&nbsp;                        dChildren.add(dParticle);
<b class="nc"><i>800</i>&nbsp;</b>
<i>801</i>&nbsp;                        checkRecurse(dChildren, 1, 1, dSGHandler,
<b class="nc"><i>802</i>&nbsp;                                bChildren, bMinOccurs, bMaxOccurs, bSGHandler);</b>
<i>803</i>&nbsp;                        return bExpansionHappened;
<i>804</i>&nbsp;                    }
<i>805</i>&nbsp;
<i>806</i>&nbsp;                    default:
<b class="nc"><i>807</i>&nbsp;                    {</b>
<i>808</i>&nbsp;                        throw new XMLSchemaException(&quot;Internal-Error&quot;,
<i>809</i>&nbsp;                                new Object[]{&quot;in particleValidRestriction&quot;});
<i>810</i>&nbsp;                    }
<i>811</i>&nbsp;                }
<i>812</i>&nbsp;            }
<i>813</i>&nbsp;
<i>814</i>&nbsp;            case XSParticleDecl.PARTICLE_WILDCARD:
<b class="nc"><i>815</i>&nbsp;            {</b>
<i>816</i>&nbsp;                switch (bType) {
<i>817</i>&nbsp;
<i>818</i>&nbsp;                    // Any:Any NSSubset
<i>819</i>&nbsp;                    case XSParticleDecl.PARTICLE_WILDCARD:
<b class="nc"><i>820</i>&nbsp;                    {</b>
<i>821</i>&nbsp;                        checkNSSubset((XSWildcardDecl)dParticle.fValue, dMinOccurs, dMaxOccurs,
<b class="nc"><i>822</i>&nbsp;                                (XSWildcardDecl)bParticle.fValue, bMinOccurs, bMaxOccurs);</b>
<i>823</i>&nbsp;                        return bExpansionHappened;
<i>824</i>&nbsp;                    }
<i>825</i>&nbsp;
<i>826</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_CHOICE:
<i>827</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_SEQUENCE:
<i>828</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_ALL:
<i>829</i>&nbsp;                    case XSParticleDecl.PARTICLE_ELEMENT:
<b class="nc"><i>830</i>&nbsp;                    {</b>
<i>831</i>&nbsp;                        throw new XMLSchemaException(&quot;cos-particle-restrict.2&quot;,
<i>832</i>&nbsp;                                new Object[]{&quot;any:choice,sequence,all,elt&quot;});
<i>833</i>&nbsp;                    }
<i>834</i>&nbsp;
<i>835</i>&nbsp;                    default:
<b class="nc"><i>836</i>&nbsp;                    {</b>
<i>837</i>&nbsp;                        throw new XMLSchemaException(&quot;Internal-Error&quot;,
<i>838</i>&nbsp;                                new Object[]{&quot;in particleValidRestriction&quot;});
<i>839</i>&nbsp;                    }
<i>840</i>&nbsp;                }
<i>841</i>&nbsp;            }
<i>842</i>&nbsp;
<i>843</i>&nbsp;            case XSModelGroupImpl.MODELGROUP_ALL:
<b class="nc"><i>844</i>&nbsp;            {</b>
<i>845</i>&nbsp;                switch (bType) {
<i>846</i>&nbsp;
<i>847</i>&nbsp;                    // All:Any NSRecurseCheckCardinality
<i>848</i>&nbsp;                    case XSParticleDecl.PARTICLE_WILDCARD:
<b class="nc"><i>849</i>&nbsp;                    {</b>
<b class="nc"><i>850</i>&nbsp;                        if (dMinEffectiveTotalRange == OCCURRENCE_UNKNOWN)</b>
<b class="nc"><i>851</i>&nbsp;                            dMinEffectiveTotalRange = dParticle.minEffectiveTotalRange();</b>
<b class="nc"><i>852</i>&nbsp;                        if (dMaxEffectiveTotalRange == OCCURRENCE_UNKNOWN)</b>
<i>853</i>&nbsp;                            dMaxEffectiveTotalRange = dParticle.maxEffectiveTotalRange();
<b class="nc"><i>854</i>&nbsp;</b>
<i>855</i>&nbsp;                        checkNSRecurseCheckCardinality(dChildren, dMinEffectiveTotalRange,
<i>856</i>&nbsp;                                dMaxEffectiveTotalRange,
<i>857</i>&nbsp;                                dSGHandler,
<i>858</i>&nbsp;                                bParticle,bMinOccurs,bMaxOccurs,
<i>859</i>&nbsp;                                checkWCOccurrence);
<b class="nc"><i>860</i>&nbsp;</b>
<i>861</i>&nbsp;                        return bExpansionHappened;
<i>862</i>&nbsp;                    }
<i>863</i>&nbsp;
<i>864</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_ALL:
<b class="nc"><i>865</i>&nbsp;                    {</b>
<i>866</i>&nbsp;                        checkRecurse(dChildren, dMinOccurs, dMaxOccurs, dSGHandler,
<b class="nc"><i>867</i>&nbsp;                                bChildren, bMinOccurs, bMaxOccurs, bSGHandler);</b>
<i>868</i>&nbsp;                        return bExpansionHappened;
<i>869</i>&nbsp;                    }
<i>870</i>&nbsp;
<i>871</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_CHOICE:
<i>872</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_SEQUENCE:
<i>873</i>&nbsp;                    case XSParticleDecl.PARTICLE_ELEMENT:
<b class="nc"><i>874</i>&nbsp;                    {</b>
<i>875</i>&nbsp;                        throw new XMLSchemaException(&quot;cos-particle-restrict.2&quot;,
<i>876</i>&nbsp;                                new Object[]{&quot;all:choice,sequence,elt&quot;});
<i>877</i>&nbsp;                    }
<i>878</i>&nbsp;
<i>879</i>&nbsp;                    default:
<b class="nc"><i>880</i>&nbsp;                    {</b>
<i>881</i>&nbsp;                        throw new XMLSchemaException(&quot;Internal-Error&quot;,
<i>882</i>&nbsp;                                new Object[]{&quot;in particleValidRestriction&quot;});
<i>883</i>&nbsp;                    }
<i>884</i>&nbsp;                }
<i>885</i>&nbsp;            }
<i>886</i>&nbsp;
<i>887</i>&nbsp;            case XSModelGroupImpl.MODELGROUP_CHOICE:
<b class="nc"><i>888</i>&nbsp;            {</b>
<i>889</i>&nbsp;                switch (bType) {
<i>890</i>&nbsp;
<i>891</i>&nbsp;                    // Choice:Any NSRecurseCheckCardinality
<i>892</i>&nbsp;                    case XSParticleDecl.PARTICLE_WILDCARD:
<b class="nc"><i>893</i>&nbsp;                    {</b>
<b class="nc"><i>894</i>&nbsp;                        if (dMinEffectiveTotalRange == OCCURRENCE_UNKNOWN)</b>
<b class="nc"><i>895</i>&nbsp;                            dMinEffectiveTotalRange = dParticle.minEffectiveTotalRange();</b>
<b class="nc"><i>896</i>&nbsp;                        if (dMaxEffectiveTotalRange == OCCURRENCE_UNKNOWN)</b>
<i>897</i>&nbsp;                            dMaxEffectiveTotalRange = dParticle.maxEffectiveTotalRange();
<b class="nc"><i>898</i>&nbsp;</b>
<i>899</i>&nbsp;                        checkNSRecurseCheckCardinality(dChildren, dMinEffectiveTotalRange,
<i>900</i>&nbsp;                                dMaxEffectiveTotalRange,
<i>901</i>&nbsp;                                dSGHandler,
<i>902</i>&nbsp;                                bParticle,bMinOccurs,bMaxOccurs,
<b class="nc"><i>903</i>&nbsp;                                checkWCOccurrence);</b>
<i>904</i>&nbsp;                        return bExpansionHappened;
<i>905</i>&nbsp;                    }
<i>906</i>&nbsp;
<i>907</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_CHOICE:
<b class="nc"><i>908</i>&nbsp;                    {</b>
<i>909</i>&nbsp;                        checkRecurseLax(dChildren, dMinOccurs, dMaxOccurs, dSGHandler,
<b class="nc"><i>910</i>&nbsp;                                bChildren, bMinOccurs, bMaxOccurs, bSGHandler);</b>
<i>911</i>&nbsp;                        return bExpansionHappened;
<i>912</i>&nbsp;                    }
<i>913</i>&nbsp;
<i>914</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_ALL:
<i>915</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_SEQUENCE:
<i>916</i>&nbsp;                    case XSParticleDecl.PARTICLE_ELEMENT:
<b class="nc"><i>917</i>&nbsp;                    {</b>
<i>918</i>&nbsp;                        throw new XMLSchemaException(&quot;cos-particle-restrict.2&quot;,
<i>919</i>&nbsp;                                new Object[]{&quot;choice:all,sequence,elt&quot;});
<i>920</i>&nbsp;                    }
<i>921</i>&nbsp;
<i>922</i>&nbsp;                    default:
<b class="nc"><i>923</i>&nbsp;                    {</b>
<i>924</i>&nbsp;                        throw new XMLSchemaException(&quot;Internal-Error&quot;,
<i>925</i>&nbsp;                                new Object[]{&quot;in particleValidRestriction&quot;});
<i>926</i>&nbsp;                    }
<i>927</i>&nbsp;                }
<i>928</i>&nbsp;            }
<i>929</i>&nbsp;
<i>930</i>&nbsp;
<i>931</i>&nbsp;            case XSModelGroupImpl.MODELGROUP_SEQUENCE:
<b class="nc"><i>932</i>&nbsp;            {</b>
<i>933</i>&nbsp;                switch (bType) {
<i>934</i>&nbsp;
<i>935</i>&nbsp;                    // Choice:Any NSRecurseCheckCardinality
<i>936</i>&nbsp;                    case XSParticleDecl.PARTICLE_WILDCARD:
<b class="nc"><i>937</i>&nbsp;                    {</b>
<b class="nc"><i>938</i>&nbsp;                        if (dMinEffectiveTotalRange == OCCURRENCE_UNKNOWN)</b>
<b class="nc"><i>939</i>&nbsp;                            dMinEffectiveTotalRange = dParticle.minEffectiveTotalRange();</b>
<b class="nc"><i>940</i>&nbsp;                        if (dMaxEffectiveTotalRange == OCCURRENCE_UNKNOWN)</b>
<i>941</i>&nbsp;                            dMaxEffectiveTotalRange = dParticle.maxEffectiveTotalRange();
<b class="nc"><i>942</i>&nbsp;</b>
<i>943</i>&nbsp;                        checkNSRecurseCheckCardinality(dChildren, dMinEffectiveTotalRange,
<i>944</i>&nbsp;                                dMaxEffectiveTotalRange,
<i>945</i>&nbsp;                                dSGHandler,
<i>946</i>&nbsp;                                bParticle,bMinOccurs,bMaxOccurs,
<b class="nc"><i>947</i>&nbsp;                                checkWCOccurrence);</b>
<i>948</i>&nbsp;                        return bExpansionHappened;
<i>949</i>&nbsp;                    }
<i>950</i>&nbsp;
<i>951</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_ALL:
<b class="nc"><i>952</i>&nbsp;                    {</b>
<i>953</i>&nbsp;                        checkRecurseUnordered(dChildren, dMinOccurs, dMaxOccurs, dSGHandler,
<b class="nc"><i>954</i>&nbsp;                                bChildren, bMinOccurs, bMaxOccurs, bSGHandler);</b>
<i>955</i>&nbsp;                        return bExpansionHappened;
<i>956</i>&nbsp;                    }
<i>957</i>&nbsp;
<i>958</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_SEQUENCE:
<b class="nc"><i>959</i>&nbsp;                    {</b>
<i>960</i>&nbsp;                        checkRecurse(dChildren, dMinOccurs, dMaxOccurs, dSGHandler,
<b class="nc"><i>961</i>&nbsp;                                bChildren, bMinOccurs, bMaxOccurs, bSGHandler);</b>
<i>962</i>&nbsp;                        return bExpansionHappened;
<i>963</i>&nbsp;                    }
<i>964</i>&nbsp;
<i>965</i>&nbsp;                    case XSModelGroupImpl.MODELGROUP_CHOICE:
<b class="nc"><i>966</i>&nbsp;                    {</b>
<b class="nc"><i>967</i>&nbsp;                        int min1 = dMinOccurs * dChildren.size();</b>
<b class="nc"><i>968</i>&nbsp;                        int max1 = (dMaxOccurs == SchemaSymbols.OCCURRENCE_UNBOUNDED)?</b>
<b class="nc"><i>969</i>&nbsp;                                dMaxOccurs : dMaxOccurs * dChildren.size();</b>
<i>970</i>&nbsp;                        checkMapAndSum(dChildren, min1, max1, dSGHandler,
<b class="nc"><i>971</i>&nbsp;                                bChildren, bMinOccurs, bMaxOccurs, bSGHandler);</b>
<i>972</i>&nbsp;                        return bExpansionHappened;
<i>973</i>&nbsp;                    }
<i>974</i>&nbsp;
<i>975</i>&nbsp;                    case XSParticleDecl.PARTICLE_ELEMENT:
<b class="nc"><i>976</i>&nbsp;                    {</b>
<i>977</i>&nbsp;                        throw new XMLSchemaException(&quot;cos-particle-restrict.2&quot;,
<i>978</i>&nbsp;                                new Object[]{&quot;seq:elt&quot;});
<i>979</i>&nbsp;                    }
<i>980</i>&nbsp;
<i>981</i>&nbsp;                    default:
<b class="nc"><i>982</i>&nbsp;                    {</b>
<i>983</i>&nbsp;                        throw new XMLSchemaException(&quot;Internal-Error&quot;,
<i>984</i>&nbsp;                                new Object[]{&quot;in particleValidRestriction&quot;});
<i>985</i>&nbsp;                    }
<i>986</i>&nbsp;                }
<i>987</i>&nbsp;            }
<i>988</i>&nbsp;
<i>989</i>&nbsp;        }
<b class="nc"><i>990</i>&nbsp;</b>
<i>991</i>&nbsp;        return bExpansionHappened;
<i>992</i>&nbsp;    }
<i>993</i>&nbsp;
<i>994</i>&nbsp;    private static void addElementToParticleVector (List&lt;XSParticleDecl&gt; v, XSElementDecl d)  {
<b class="nc"><i>995</i>&nbsp;</b>
<b class="nc"><i>996</i>&nbsp;        XSParticleDecl p = new XSParticleDecl();</b>
<b class="nc"><i>997</i>&nbsp;        p.fValue = d;</b>
<b class="nc"><i>998</i>&nbsp;        p.fType = XSParticleDecl.PARTICLE_ELEMENT;</b>
<i>999</i>&nbsp;        v.add(p);
<i>1000</i>&nbsp;
<i>1001</i>&nbsp;    }
<i>1002</i>&nbsp;
<i>1003</i>&nbsp;    private static XSParticleDecl getNonUnaryGroup(XSParticleDecl p) {
<b class="nc"><i>1004</i>&nbsp;</b>
<i>1005</i>&nbsp;        if (p.fType == XSParticleDecl.PARTICLE_ELEMENT ||
<b class="nc"><i>1006</i>&nbsp;                p.fType == XSParticleDecl.PARTICLE_WILDCARD)</b>
<i>1007</i>&nbsp;            return p;
<b class="nc"><i>1008</i>&nbsp;</b>
<i>1009</i>&nbsp;        if (p.fMinOccurs==1 &amp;&amp; p.fMaxOccurs==1 &amp;&amp;
<b class="nc"><i>1010</i>&nbsp;                p.fValue!=null &amp;&amp; ((XSModelGroupImpl)p.fValue).fParticleCount == 1)</b>
<i>1011</i>&nbsp;            return getNonUnaryGroup(((XSModelGroupImpl)p.fValue).fParticles[0]);
<b class="nc"><i>1012</i>&nbsp;        else</b>
<i>1013</i>&nbsp;            return p;
<i>1014</i>&nbsp;    }
<i>1015</i>&nbsp;
<i>1016</i>&nbsp;    private static List&lt;XSParticleDecl&gt; removePointlessChildren(XSParticleDecl p)  {
<b class="nc"><i>1017</i>&nbsp;</b>
<i>1018</i>&nbsp;        if (p.fType == XSParticleDecl.PARTICLE_ELEMENT ||
<b class="nc"><i>1019</i>&nbsp;                p.fType == XSParticleDecl.PARTICLE_WILDCARD)</b>
<i>1020</i>&nbsp;            return null;
<b class="nc"><i>1021</i>&nbsp;</b>
<i>1022</i>&nbsp;        List&lt;XSParticleDecl&gt; children = new ArrayList&lt;&gt;();
<b class="nc"><i>1023</i>&nbsp;</b>
<b class="nc"><i>1024</i>&nbsp;        XSModelGroupImpl group = (XSModelGroupImpl)p.fValue;</b>
<b class="nc"><i>1025</i>&nbsp;        for (int i = 0; i &lt; group.fParticleCount; i++)</b>
<i>1026</i>&nbsp;            gatherChildren(group.fCompositor, group.fParticles[i], children);
<b class="nc"><i>1027</i>&nbsp;</b>
<i>1028</i>&nbsp;        return children;
<i>1029</i>&nbsp;    }
<i>1030</i>&nbsp;
<i>1031</i>&nbsp;
<i>1032</i>&nbsp;    private static void gatherChildren(int parentType, XSParticleDecl p, List&lt;XSParticleDecl&gt; children) {
<b class="nc"><i>1033</i>&nbsp;</b>
<b class="nc"><i>1034</i>&nbsp;        int min = p.fMinOccurs;</b>
<b class="nc"><i>1035</i>&nbsp;        int max = p.fMaxOccurs;</b>
<b class="nc"><i>1036</i>&nbsp;        int type = p.fType;</b>
<b class="nc"><i>1037</i>&nbsp;        if (type == XSParticleDecl.PARTICLE_MODELGROUP)</b>
<i>1038</i>&nbsp;            type = ((XSModelGroupImpl)p.fValue).fCompositor;
<b class="nc"><i>1039</i>&nbsp;</b>
<i>1040</i>&nbsp;        if (type == XSParticleDecl.PARTICLE_ELEMENT ||
<b class="nc"><i>1041</i>&nbsp;                type== XSParticleDecl.PARTICLE_WILDCARD) {</b>
<i>1042</i>&nbsp;            children.add(p);
<i>1043</i>&nbsp;            return;
<i>1044</i>&nbsp;        }
<b class="nc"><i>1045</i>&nbsp;</b>
<b class="nc"><i>1046</i>&nbsp;        if (! (min==1 &amp;&amp; max==1)) {</b>
<i>1047</i>&nbsp;            children.add(p);
<b class="nc"><i>1048</i>&nbsp;        }</b>
<b class="nc"><i>1049</i>&nbsp;        else if (parentType == type) {</b>
<b class="nc"><i>1050</i>&nbsp;            XSModelGroupImpl group = (XSModelGroupImpl)p.fValue;</b>
<b class="nc"><i>1051</i>&nbsp;            for (int i = 0; i &lt; group.fParticleCount; i++)</b>
<b class="nc"><i>1052</i>&nbsp;                gatherChildren(type, group.fParticles[i], children);</b>
<b class="nc"><i>1053</i>&nbsp;        }</b>
<b class="nc"><i>1054</i>&nbsp;        else if (!p.isEmpty()) {</b>
<i>1055</i>&nbsp;            children.add(p);
<i>1056</i>&nbsp;        }
<i>1057</i>&nbsp;
<i>1058</i>&nbsp;    }
<i>1059</i>&nbsp;
<i>1060</i>&nbsp;    private static void checkNameAndTypeOK(XSElementDecl dElement, int dMin, int dMax,
<i>1061</i>&nbsp;            XSElementDecl bElement, int bMin, int bMax)
<i>1062</i>&nbsp;        throws XMLSchemaException {
<i>1063</i>&nbsp;
<i>1064</i>&nbsp;
<i>1065</i>&nbsp;        //
<i>1066</i>&nbsp;        // Check that the names are the same
<b class="nc"><i>1067</i>&nbsp;        //</b>
<i>1068</i>&nbsp;        if (dElement.fName != bElement.fName ||
<b class="nc"><i>1069</i>&nbsp;                dElement.fTargetNamespace != bElement.fTargetNamespace) {</b>
<i>1070</i>&nbsp;            throw new XMLSchemaException(
<i>1071</i>&nbsp;                    &quot;rcase-NameAndTypeOK.1&quot;,new Object[]{dElement.fName,
<i>1072</i>&nbsp;                            dElement.fTargetNamespace, bElement.fName, bElement.fTargetNamespace});
<i>1073</i>&nbsp;        }
<i>1074</i>&nbsp;
<i>1075</i>&nbsp;        //
<i>1076</i>&nbsp;        // Check nillable
<b class="nc"><i>1077</i>&nbsp;        //</b>
<b class="nc"><i>1078</i>&nbsp;        if (!bElement.getNillable() &amp;&amp; dElement.getNillable()) {</b>
<i>1079</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NameAndTypeOK.2&quot;,
<i>1080</i>&nbsp;                    new Object[]{dElement.fName});
<i>1081</i>&nbsp;        }
<i>1082</i>&nbsp;
<i>1083</i>&nbsp;        //
<i>1084</i>&nbsp;        // Check occurrence range
<b class="nc"><i>1085</i>&nbsp;        //</b>
<b class="nc"><i>1086</i>&nbsp;        if (!checkOccurrenceRange(dMin, dMax, bMin, bMax)) {</b>
<i>1087</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NameAndTypeOK.3&quot;,
<i>1088</i>&nbsp;                    new Object[]{
<b class="nc"><i>1089</i>&nbsp;                    dElement.fName,</b>
<b class="nc"><i>1090</i>&nbsp;                    Integer.toString(dMin),</b>
<b class="nc"><i>1091</i>&nbsp;                    dMax==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(dMax),</b>
<b class="nc"><i>1092</i>&nbsp;                            Integer.toString(bMin),</b>
<i>1093</i>&nbsp;                            bMax==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(bMax)});
<i>1094</i>&nbsp;        }
<i>1095</i>&nbsp;
<i>1096</i>&nbsp;        //
<i>1097</i>&nbsp;        // Check for consistent fixed values
<b class="nc"><i>1098</i>&nbsp;        //</b>
<i>1099</i>&nbsp;        if (bElement.getConstraintType() == XSConstants.VC_FIXED) {
<b class="nc"><i>1100</i>&nbsp;            // derived one has to have a fixed value</b>
<b class="nc"><i>1101</i>&nbsp;            if (dElement.getConstraintType() != XSConstants.VC_FIXED) {</b>
<b class="nc"><i>1102</i>&nbsp;                throw new XMLSchemaException(&quot;rcase-NameAndTypeOK.4.a&quot;,</b>
<i>1103</i>&nbsp;                        new Object[]{dElement.fName, bElement.fDefault.stringValue()});
<i>1104</i>&nbsp;            }
<i>1105</i>&nbsp;
<b class="nc"><i>1106</i>&nbsp;            // get simple type</b>
<b class="nc"><i>1107</i>&nbsp;            boolean isSimple = false;</b>
<i>1108</i>&nbsp;            if (dElement.fType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE ||
<b class="nc"><i>1109</i>&nbsp;                    ((XSComplexTypeDecl)dElement.fType).fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {</b>
<i>1110</i>&nbsp;                isSimple = true;
<i>1111</i>&nbsp;            }
<i>1112</i>&nbsp;
<b class="nc"><i>1113</i>&nbsp;            // if there is no simple type, then compare based on string</b>
<b class="nc"><i>1114</i>&nbsp;            if (!isSimple &amp;&amp; !bElement.fDefault.normalizedValue.equals(dElement.fDefault.normalizedValue) ||</b>
<b class="nc"><i>1115</i>&nbsp;                    isSimple &amp;&amp; !bElement.fDefault.actualValue.equals(dElement.fDefault.actualValue)) {</b>
<i>1116</i>&nbsp;                throw new XMLSchemaException(&quot;rcase-NameAndTypeOK.4.b&quot;,
<b class="nc"><i>1117</i>&nbsp;                        new Object[]{dElement.fName,</b>
<b class="nc"><i>1118</i>&nbsp;                        dElement.fDefault.stringValue(),</b>
<i>1119</i>&nbsp;                        bElement.fDefault.stringValue()});
<i>1120</i>&nbsp;            }
<i>1121</i>&nbsp;        }
<i>1122</i>&nbsp;
<i>1123</i>&nbsp;        //
<i>1124</i>&nbsp;        // Check identity constraints
<b class="nc"><i>1125</i>&nbsp;        //</b>
<i>1126</i>&nbsp;        checkIDConstraintRestriction(dElement, bElement);
<i>1127</i>&nbsp;
<i>1128</i>&nbsp;        //
<i>1129</i>&nbsp;        // Check for disallowed substitutions
<b class="nc"><i>1130</i>&nbsp;        //</b>
<b class="nc"><i>1131</i>&nbsp;        int blockSet1 = dElement.fBlock;</b>
<b class="nc"><i>1132</i>&nbsp;        int blockSet2 = bElement.fBlock;</b>
<i>1133</i>&nbsp;        if (((blockSet1 &amp; blockSet2)!=blockSet2) ||
<b class="nc"><i>1134</i>&nbsp;                (blockSet1==XSConstants.DERIVATION_NONE &amp;&amp; blockSet2!=XSConstants.DERIVATION_NONE))</b>
<i>1135</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NameAndTypeOK.6&quot;,
<i>1136</i>&nbsp;                    new Object[]{dElement.fName});
<i>1137</i>&nbsp;
<i>1138</i>&nbsp;
<i>1139</i>&nbsp;        //
<i>1140</i>&nbsp;        // Check that the derived element&#39;s type is derived from the base&#39;s.
<b class="nc"><i>1141</i>&nbsp;        //</b>
<i>1142</i>&nbsp;        if (!checkTypeDerivationOk(dElement.fType, bElement.fType,
<b class="nc"><i>1143</i>&nbsp;                (short)(XSConstants.DERIVATION_EXTENSION|XSConstants.DERIVATION_LIST|XSConstants.DERIVATION_UNION))) {</b>
<b class="nc"><i>1144</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NameAndTypeOK.7&quot;,</b>
<i>1145</i>&nbsp;                    new Object[]{dElement.fName, dElement.fType.getName(), bElement.fType.getName()});
<i>1146</i>&nbsp;        }
<i>1147</i>&nbsp;
<i>1148</i>&nbsp;    }
<i>1149</i>&nbsp;
<i>1150</i>&nbsp;
<i>1151</i>&nbsp;    private static void checkIDConstraintRestriction(XSElementDecl derivedElemDecl,
<i>1152</i>&nbsp;            XSElementDecl baseElemDecl)
<i>1153</i>&nbsp;        throws XMLSchemaException {
<i>1154</i>&nbsp;        // TODO
<i>1155</i>&nbsp;    } // checkIDConstraintRestriction
<i>1156</i>&nbsp;
<i>1157</i>&nbsp;
<i>1158</i>&nbsp;    private static boolean checkOccurrenceRange(int min1, int max1, int min2, int max2) {
<b class="nc"><i>1159</i>&nbsp;</b>
<i>1160</i>&nbsp;        if ((min1 &gt;= min2) &amp;&amp;
<i>1161</i>&nbsp;                ((max2==SchemaSymbols.OCCURRENCE_UNBOUNDED) ||
<b class="nc"><i>1162</i>&nbsp;                        (max1!=SchemaSymbols.OCCURRENCE_UNBOUNDED &amp;&amp; max1&lt;=max2)))</b>
<i>1163</i>&nbsp;            return true;
<b class="nc"><i>1164</i>&nbsp;        else</b>
<i>1165</i>&nbsp;            return false;
<i>1166</i>&nbsp;    }
<i>1167</i>&nbsp;
<i>1168</i>&nbsp;    private static void checkNSCompat(XSElementDecl elem, int min1, int max1,
<i>1169</i>&nbsp;            XSWildcardDecl wildcard, int min2, int max2,
<i>1170</i>&nbsp;            boolean checkWCOccurrence)
<i>1171</i>&nbsp;        throws XMLSchemaException {
<i>1172</i>&nbsp;
<b class="nc"><i>1173</i>&nbsp;        // check Occurrence ranges</b>
<b class="nc"><i>1174</i>&nbsp;        if (checkWCOccurrence &amp;&amp; !checkOccurrenceRange(min1,max1,min2,max2)) {</b>
<i>1175</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NSCompat.2&quot;,
<i>1176</i>&nbsp;                    new Object[]{
<b class="nc"><i>1177</i>&nbsp;                    elem.fName,</b>
<b class="nc"><i>1178</i>&nbsp;                    Integer.toString(min1),</b>
<b class="nc"><i>1179</i>&nbsp;                    max1==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max1),</b>
<b class="nc"><i>1180</i>&nbsp;                            Integer.toString(min2),</b>
<i>1181</i>&nbsp;                            max2==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max2)});
<i>1182</i>&nbsp;        }
<i>1183</i>&nbsp;
<b class="nc"><i>1184</i>&nbsp;        // check wildcard allows namespace of element</b>
<b class="nc"><i>1185</i>&nbsp;        if (!wildcard.allowNamespace(elem.fTargetNamespace))  {</b>
<i>1186</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NSCompat.1&quot;,
<i>1187</i>&nbsp;                    new Object[]{elem.fName,elem.fTargetNamespace});
<i>1188</i>&nbsp;        }
<i>1189</i>&nbsp;
<i>1190</i>&nbsp;    }
<i>1191</i>&nbsp;
<i>1192</i>&nbsp;    private static void checkNSSubset(XSWildcardDecl dWildcard, int min1, int max1,
<i>1193</i>&nbsp;            XSWildcardDecl bWildcard, int min2, int max2)
<i>1194</i>&nbsp;        throws XMLSchemaException {
<i>1195</i>&nbsp;
<b class="nc"><i>1196</i>&nbsp;        // check Occurrence ranges</b>
<b class="nc"><i>1197</i>&nbsp;        if (!checkOccurrenceRange(min1,max1,min2,max2)) {</b>
<b class="nc"><i>1198</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NSSubset.2&quot;, new Object[]{</b>
<b class="nc"><i>1199</i>&nbsp;                    Integer.toString(min1),</b>
<b class="nc"><i>1200</i>&nbsp;                    max1==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max1),</b>
<b class="nc"><i>1201</i>&nbsp;                            Integer.toString(min2),</b>
<i>1202</i>&nbsp;                            max2==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max2)});
<i>1203</i>&nbsp;        }
<i>1204</i>&nbsp;
<b class="nc"><i>1205</i>&nbsp;        // check wildcard subset</b>
<b class="nc"><i>1206</i>&nbsp;        if (!dWildcard.isSubsetOf(bWildcard)) {</b>
<i>1207</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NSSubset.1&quot;, null);
<i>1208</i>&nbsp;        }
<b class="nc"><i>1209</i>&nbsp;</b>
<b class="nc"><i>1210</i>&nbsp;        if (dWildcard.weakerProcessContents(bWildcard)) {</b>
<b class="nc"><i>1211</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NSSubset.3&quot;,</b>
<b class="nc"><i>1212</i>&nbsp;                    new Object[]{dWildcard.getProcessContentsAsString(),</b>
<i>1213</i>&nbsp;                    bWildcard.getProcessContentsAsString()});
<i>1214</i>&nbsp;        }
<i>1215</i>&nbsp;
<i>1216</i>&nbsp;    }
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;
<i>1219</i>&nbsp;    private static void checkNSRecurseCheckCardinality(List&lt;XSParticleDecl&gt; children, int min1, int max1,
<i>1220</i>&nbsp;            SubstitutionGroupHandler dSGHandler,
<i>1221</i>&nbsp;            XSParticleDecl wildcard, int min2, int max2,
<i>1222</i>&nbsp;            boolean checkWCOccurrence)
<i>1223</i>&nbsp;        throws XMLSchemaException {
<i>1224</i>&nbsp;
<i>1225</i>&nbsp;
<b class="nc"><i>1226</i>&nbsp;        // check Occurrence ranges</b>
<b class="nc"><i>1227</i>&nbsp;        if (checkWCOccurrence &amp;&amp; !checkOccurrenceRange(min1,max1,min2,max2)) {</b>
<b class="nc"><i>1228</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NSRecurseCheckCardinality.2&quot;, new Object[]{</b>
<b class="nc"><i>1229</i>&nbsp;                    Integer.toString(min1),</b>
<b class="nc"><i>1230</i>&nbsp;                    max1==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max1),</b>
<b class="nc"><i>1231</i>&nbsp;                            Integer.toString(min2),</b>
<i>1232</i>&nbsp;                            max2==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max2)});
<i>1233</i>&nbsp;        }
<i>1234</i>&nbsp;
<b class="nc"><i>1235</i>&nbsp;        // Check that each member of the group is a valid restriction of the wildcard</b>
<i>1236</i>&nbsp;        int count = children.size();
<b class="nc"><i>1237</i>&nbsp;        try {</b>
<b class="nc"><i>1238</i>&nbsp;            for (int i = 0; i &lt; count; i++) {</b>
<b class="nc"><i>1239</i>&nbsp;                XSParticleDecl particle1 = children.get(i);</b>
<i>1240</i>&nbsp;                particleValidRestriction(particle1, dSGHandler, wildcard, null, false);
<i>1241</i>&nbsp;
<i>1242</i>&nbsp;            }
<i>1243</i>&nbsp;        }
<i>1244</i>&nbsp;        // REVISIT: should we really just ignore original cause of this error?
<b class="nc"><i>1245</i>&nbsp;        //          how can we report it?</b>
<b class="nc"><i>1246</i>&nbsp;        catch (XMLSchemaException e) {</b>
<b class="nc"><i>1247</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-NSRecurseCheckCardinality.1&quot;, null);</b>
<i>1248</i>&nbsp;        }
<i>1249</i>&nbsp;
<i>1250</i>&nbsp;    }
<i>1251</i>&nbsp;
<i>1252</i>&nbsp;    private static void checkRecurse(List&lt;XSParticleDecl&gt; dChildren, int min1, int max1,
<i>1253</i>&nbsp;            SubstitutionGroupHandler dSGHandler,
<i>1254</i>&nbsp;            List&lt;XSParticleDecl&gt; bChildren, int min2, int max2,
<i>1255</i>&nbsp;            SubstitutionGroupHandler bSGHandler)
<i>1256</i>&nbsp;        throws XMLSchemaException {
<i>1257</i>&nbsp;
<b class="nc"><i>1258</i>&nbsp;        // check Occurrence ranges</b>
<b class="nc"><i>1259</i>&nbsp;        if (!checkOccurrenceRange(min1,max1,min2,max2)) {</b>
<b class="nc"><i>1260</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-Recurse.1&quot;, new Object[]{</b>
<b class="nc"><i>1261</i>&nbsp;                    Integer.toString(min1),</b>
<b class="nc"><i>1262</i>&nbsp;                    max1==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max1),</b>
<b class="nc"><i>1263</i>&nbsp;                    Integer.toString(min2),</b>
<i>1264</i>&nbsp;                    max2==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max2)});
<i>1265</i>&nbsp;        }
<b class="nc"><i>1266</i>&nbsp;</b>
<b class="nc"><i>1267</i>&nbsp;        int count1= dChildren.size();</b>
<i>1268</i>&nbsp;        int count2= bChildren.size();
<b class="nc"><i>1269</i>&nbsp;</b>
<b class="nc"><i>1270</i>&nbsp;        int current = 0;</b>
<i>1271</i>&nbsp;        label: for (int i = 0; i&lt;count1; i++) {
<b class="nc"><i>1272</i>&nbsp;</b>
<b class="nc"><i>1273</i>&nbsp;            XSParticleDecl particle1 = dChildren.get(i);</b>
<b class="nc"><i>1274</i>&nbsp;            for (int j = current; j&lt;count2; j++) {</b>
<b class="nc"><i>1275</i>&nbsp;                XSParticleDecl particle2 = bChildren.get(j);</b>
<i>1276</i>&nbsp;                current +=1;
<b class="nc"><i>1277</i>&nbsp;                try {</b>
<b class="nc"><i>1278</i>&nbsp;                    particleValidRestriction(particle1, dSGHandler, particle2, bSGHandler);</b>
<i>1279</i>&nbsp;                    continue label;
<b class="nc"><i>1280</i>&nbsp;                }</b>
<b class="nc"><i>1281</i>&nbsp;                catch (XMLSchemaException e) {</b>
<b class="nc"><i>1282</i>&nbsp;                    if (!particle2.emptiable())</b>
<i>1283</i>&nbsp;                        throw new XMLSchemaException(&quot;rcase-Recurse.2&quot;, null);
<i>1284</i>&nbsp;                }
<b class="nc"><i>1285</i>&nbsp;            }</b>
<i>1286</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-Recurse.2&quot;, null);
<i>1287</i>&nbsp;        }
<i>1288</i>&nbsp;
<b class="nc"><i>1289</i>&nbsp;        // Now, see if there are some elements in the base we didn&#39;t match up</b>
<b class="nc"><i>1290</i>&nbsp;        for (int j=current; j &lt; count2; j++) {</b>
<b class="nc"><i>1291</i>&nbsp;            XSParticleDecl particle2 = bChildren.get(j);</b>
<b class="nc"><i>1292</i>&nbsp;            if (!particle2.emptiable()) {</b>
<i>1293</i>&nbsp;                throw new XMLSchemaException(&quot;rcase-Recurse.2&quot;, null);
<i>1294</i>&nbsp;            }
<i>1295</i>&nbsp;        }
<i>1296</i>&nbsp;
<i>1297</i>&nbsp;    }
<i>1298</i>&nbsp;
<i>1299</i>&nbsp;    private static void checkRecurseUnordered(List&lt;XSParticleDecl&gt; dChildren, int min1, int max1,
<i>1300</i>&nbsp;            SubstitutionGroupHandler dSGHandler,
<i>1301</i>&nbsp;            List&lt;XSParticleDecl&gt; bChildren, int min2, int max2,
<i>1302</i>&nbsp;            SubstitutionGroupHandler bSGHandler)
<i>1303</i>&nbsp;        throws XMLSchemaException {
<i>1304</i>&nbsp;
<i>1305</i>&nbsp;
<b class="nc"><i>1306</i>&nbsp;        // check Occurrence ranges</b>
<b class="nc"><i>1307</i>&nbsp;        if (!checkOccurrenceRange(min1,max1,min2,max2)) {</b>
<b class="nc"><i>1308</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-RecurseUnordered.1&quot;, new Object[]{</b>
<b class="nc"><i>1309</i>&nbsp;                    Integer.toString(min1),</b>
<b class="nc"><i>1310</i>&nbsp;                    max1==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max1),</b>
<b class="nc"><i>1311</i>&nbsp;                    Integer.toString(min2),</b>
<i>1312</i>&nbsp;                    max2==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max2)});
<i>1313</i>&nbsp;        }
<b class="nc"><i>1314</i>&nbsp;</b>
<b class="nc"><i>1315</i>&nbsp;        int count1= dChildren.size();</b>
<i>1316</i>&nbsp;        int count2 = bChildren.size();
<b class="nc"><i>1317</i>&nbsp;</b>
<i>1318</i>&nbsp;        boolean foundIt[] = new boolean[count2];
<b class="nc"><i>1319</i>&nbsp;</b>
<b class="nc"><i>1320</i>&nbsp;        label: for (int i = 0; i&lt;count1; i++) {</b>
<i>1321</i>&nbsp;            XSParticleDecl particle1 = dChildren.get(i);
<b class="nc"><i>1322</i>&nbsp;</b>
<b class="nc"><i>1323</i>&nbsp;            for (int j = 0; j&lt;count2; j++) {</b>
<i>1324</i>&nbsp;                XSParticleDecl particle2 = bChildren.get(j);
<b class="nc"><i>1325</i>&nbsp;                try {</b>
<b class="nc"><i>1326</i>&nbsp;                    particleValidRestriction(particle1, dSGHandler, particle2, bSGHandler);</b>
<b class="nc"><i>1327</i>&nbsp;                    if (foundIt[j])</b>
<i>1328</i>&nbsp;                        throw new XMLSchemaException(&quot;rcase-RecurseUnordered.2&quot;, null);
<b class="nc"><i>1329</i>&nbsp;                    else</b>
<i>1330</i>&nbsp;                        foundIt[j]=true;
<b class="nc"><i>1331</i>&nbsp;</b>
<i>1332</i>&nbsp;                    continue label;
<b class="nc"><i>1333</i>&nbsp;                }</b>
<i>1334</i>&nbsp;                catch (XMLSchemaException e) {
<i>1335</i>&nbsp;                }
<i>1336</i>&nbsp;            }
<b class="nc"><i>1337</i>&nbsp;            // didn&#39;t find a match.  Detect an error</b>
<i>1338</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-RecurseUnordered.2&quot;, null);
<i>1339</i>&nbsp;        }
<i>1340</i>&nbsp;
<b class="nc"><i>1341</i>&nbsp;        // Now, see if there are some elements in the base we didn&#39;t match up</b>
<b class="nc"><i>1342</i>&nbsp;        for (int j=0; j &lt; count2; j++) {</b>
<b class="nc"><i>1343</i>&nbsp;            XSParticleDecl particle2 = bChildren.get(j);</b>
<b class="nc"><i>1344</i>&nbsp;            if (!foundIt[j] &amp;&amp; !particle2.emptiable()) {</b>
<i>1345</i>&nbsp;                throw new XMLSchemaException(&quot;rcase-RecurseUnordered.2&quot;, null);
<i>1346</i>&nbsp;            }
<i>1347</i>&nbsp;        }
<i>1348</i>&nbsp;
<i>1349</i>&nbsp;    }
<i>1350</i>&nbsp;
<i>1351</i>&nbsp;    private static void checkRecurseLax(List&lt;XSParticleDecl&gt; dChildren, int min1, int max1,
<i>1352</i>&nbsp;            SubstitutionGroupHandler dSGHandler,
<i>1353</i>&nbsp;            List&lt;XSParticleDecl&gt; bChildren, int min2, int max2,
<i>1354</i>&nbsp;            SubstitutionGroupHandler  bSGHandler)
<i>1355</i>&nbsp;        throws XMLSchemaException {
<i>1356</i>&nbsp;
<b class="nc"><i>1357</i>&nbsp;        // check Occurrence ranges</b>
<b class="nc"><i>1358</i>&nbsp;        if (!checkOccurrenceRange(min1,max1,min2,max2)) {</b>
<b class="nc"><i>1359</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-RecurseLax.1&quot;, new Object[]{</b>
<b class="nc"><i>1360</i>&nbsp;                    Integer.toString(min1),</b>
<b class="nc"><i>1361</i>&nbsp;                    max1==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max1),</b>
<b class="nc"><i>1362</i>&nbsp;                            Integer.toString(min2),</b>
<i>1363</i>&nbsp;                            max2==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max2)});
<i>1364</i>&nbsp;        }
<b class="nc"><i>1365</i>&nbsp;</b>
<b class="nc"><i>1366</i>&nbsp;        int count1= dChildren.size();</b>
<i>1367</i>&nbsp;        int count2 = bChildren.size();
<b class="nc"><i>1368</i>&nbsp;</b>
<b class="nc"><i>1369</i>&nbsp;        int current = 0;</b>
<i>1370</i>&nbsp;        label: for (int i = 0; i&lt;count1; i++) {
<b class="nc"><i>1371</i>&nbsp;</b>
<b class="nc"><i>1372</i>&nbsp;            XSParticleDecl particle1 = dChildren.get(i);</b>
<b class="nc"><i>1373</i>&nbsp;            for (int j = current; j&lt;count2; j++) {</b>
<b class="nc"><i>1374</i>&nbsp;                XSParticleDecl particle2 = bChildren.get(j);</b>
<i>1375</i>&nbsp;                current +=1;
<i>1376</i>&nbsp;                try {
<i>1377</i>&nbsp;                    // IHR: go back one element on b list because the next element may match
<b class="nc"><i>1378</i>&nbsp;                    // this as well.</b>
<b class="nc"><i>1379</i>&nbsp;                    if (particleValidRestriction(particle1, dSGHandler, particle2, bSGHandler))</b>
<b class="nc"><i>1380</i>&nbsp;                        current--;</b>
<i>1381</i>&nbsp;                    continue label;
<b class="nc"><i>1382</i>&nbsp;                }</b>
<i>1383</i>&nbsp;                catch (XMLSchemaException e) {
<i>1384</i>&nbsp;                }
<i>1385</i>&nbsp;            }
<b class="nc"><i>1386</i>&nbsp;            // didn&#39;t find a match.  Detect an error</b>
<i>1387</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-RecurseLax.2&quot;, null);
<i>1388</i>&nbsp;
<i>1389</i>&nbsp;        }
<i>1390</i>&nbsp;
<i>1391</i>&nbsp;    }
<i>1392</i>&nbsp;
<i>1393</i>&nbsp;    private static void checkMapAndSum(List&lt;XSParticleDecl&gt; dChildren, int min1, int max1,
<i>1394</i>&nbsp;            SubstitutionGroupHandler dSGHandler,
<i>1395</i>&nbsp;            List&lt;XSParticleDecl&gt; bChildren, int min2, int max2,
<i>1396</i>&nbsp;            SubstitutionGroupHandler bSGHandler)
<i>1397</i>&nbsp;        throws XMLSchemaException {
<i>1398</i>&nbsp;
<i>1399</i>&nbsp;        // See if the sequence group is a valid restriction of the choice
<i>1400</i>&nbsp;
<i>1401</i>&nbsp;        // Here is an example of a valid restriction:
<i>1402</i>&nbsp;        //   &lt;choice minOccurs=&quot;2&quot;&gt;
<i>1403</i>&nbsp;        //       &lt;a/&gt;
<i>1404</i>&nbsp;        //       &lt;b/&gt;
<i>1405</i>&nbsp;        //       &lt;c/&gt;
<i>1406</i>&nbsp;        //   &lt;/choice&gt;
<i>1407</i>&nbsp;        //
<i>1408</i>&nbsp;        //   &lt;sequence&gt;
<i>1409</i>&nbsp;        //        &lt;b/&gt;
<i>1410</i>&nbsp;        //        &lt;a/&gt;
<i>1411</i>&nbsp;        //   &lt;/sequence&gt;
<i>1412</i>&nbsp;
<b class="nc"><i>1413</i>&nbsp;        // check Occurrence ranges</b>
<b class="nc"><i>1414</i>&nbsp;        if (!checkOccurrenceRange(min1,max1,min2,max2)) {</b>
<b class="nc"><i>1415</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-MapAndSum.2&quot;,</b>
<b class="nc"><i>1416</i>&nbsp;                    new Object[]{Integer.toString(min1),</b>
<b class="nc"><i>1417</i>&nbsp;                    max1==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max1),</b>
<b class="nc"><i>1418</i>&nbsp;                            Integer.toString(min2),</b>
<i>1419</i>&nbsp;                            max2==SchemaSymbols.OCCURRENCE_UNBOUNDED?&quot;unbounded&quot;:Integer.toString(max2)});
<i>1420</i>&nbsp;        }
<b class="nc"><i>1421</i>&nbsp;</b>
<b class="nc"><i>1422</i>&nbsp;        int count1 = dChildren.size();</b>
<i>1423</i>&nbsp;        int count2 = bChildren.size();
<b class="nc"><i>1424</i>&nbsp;</b>
<i>1425</i>&nbsp;        label: for (int i = 0; i&lt;count1; i++) {
<b class="nc"><i>1426</i>&nbsp;</b>
<b class="nc"><i>1427</i>&nbsp;            XSParticleDecl particle1 = dChildren.get(i);</b>
<b class="nc"><i>1428</i>&nbsp;            for (int j = 0; j&lt;count2; j++) {</b>
<i>1429</i>&nbsp;                XSParticleDecl particle2 = bChildren.get(j);
<b class="nc"><i>1430</i>&nbsp;                try {</b>
<b class="nc"><i>1431</i>&nbsp;                    particleValidRestriction(particle1, dSGHandler, particle2, bSGHandler);</b>
<i>1432</i>&nbsp;                    continue label;
<b class="nc"><i>1433</i>&nbsp;                }</b>
<i>1434</i>&nbsp;                catch (XMLSchemaException e) {
<i>1435</i>&nbsp;                }
<i>1436</i>&nbsp;            }
<b class="nc"><i>1437</i>&nbsp;            // didn&#39;t find a match.  Detect an error</b>
<i>1438</i>&nbsp;            throw new XMLSchemaException(&quot;rcase-MapAndSum.1&quot;, null);
<i>1439</i>&nbsp;        }
<i>1440</i>&nbsp;    }
<i>1441</i>&nbsp;    // to check whether two element overlap, as defined in constraint UPA
<i>1442</i>&nbsp;    public static boolean overlapUPA(XSElementDecl element1,
<i>1443</i>&nbsp;            XSElementDecl element2,
<i>1444</i>&nbsp;            SubstitutionGroupHandler sgHandler) {
<b class="nc"><i>1445</i>&nbsp;        // if the two element have the same name and namespace,</b>
<i>1446</i>&nbsp;        if (element1.fName == element2.fName &amp;&amp;
<b class="nc"><i>1447</i>&nbsp;                element1.fTargetNamespace == element2.fTargetNamespace) {</b>
<i>1448</i>&nbsp;            return true;
<i>1449</i>&nbsp;        }
<i>1450</i>&nbsp;
<i>1451</i>&nbsp;        // or if there is an element decl in element1&#39;s substitution group,
<b class="nc"><i>1452</i>&nbsp;        // who has the same name/namespace with element2</b>
<b class="nc"><i>1453</i>&nbsp;        XSElementDecl[] subGroup = sgHandler.getSubstitutionGroup(element1);</b>
<b class="nc"><i>1454</i>&nbsp;        for (int i = subGroup.length-1; i &gt;= 0; i--) {</b>
<i>1455</i>&nbsp;            if (subGroup[i].fName == element2.fName &amp;&amp;
<b class="nc"><i>1456</i>&nbsp;                    subGroup[i].fTargetNamespace == element2.fTargetNamespace) {</b>
<i>1457</i>&nbsp;                return true;
<i>1458</i>&nbsp;            }
<i>1459</i>&nbsp;        }
<i>1460</i>&nbsp;
<i>1461</i>&nbsp;        // or if there is an element decl in element2&#39;s substitution group,
<b class="nc"><i>1462</i>&nbsp;        // who has the same name/namespace with element1</b>
<b class="nc"><i>1463</i>&nbsp;        subGroup = sgHandler.getSubstitutionGroup(element2);</b>
<b class="nc"><i>1464</i>&nbsp;        for (int i = subGroup.length-1; i &gt;= 0; i--) {</b>
<i>1465</i>&nbsp;            if (subGroup[i].fName == element1.fName &amp;&amp;
<b class="nc"><i>1466</i>&nbsp;                    subGroup[i].fTargetNamespace == element1.fTargetNamespace) {</b>
<i>1467</i>&nbsp;                return true;
<i>1468</i>&nbsp;            }
<i>1469</i>&nbsp;        }
<b class="nc"><i>1470</i>&nbsp;</b>
<i>1471</i>&nbsp;        return false;
<i>1472</i>&nbsp;    }
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;    // to check whether an element overlaps with a wildcard,
<i>1475</i>&nbsp;    // as defined in constraint UPA
<i>1476</i>&nbsp;    public static boolean overlapUPA(XSElementDecl element,
<i>1477</i>&nbsp;            XSWildcardDecl wildcard,
<i>1478</i>&nbsp;            SubstitutionGroupHandler sgHandler) {
<b class="nc"><i>1479</i>&nbsp;        // if the wildcard allows the element</b>
<b class="nc"><i>1480</i>&nbsp;        if (wildcard.allowNamespace(element.fTargetNamespace))</b>
<i>1481</i>&nbsp;            return true;
<i>1482</i>&nbsp;
<b class="nc"><i>1483</i>&nbsp;        // or if the wildcard allows any element in the substitution group</b>
<b class="nc"><i>1484</i>&nbsp;        XSElementDecl[] subGroup = sgHandler.getSubstitutionGroup(element);</b>
<b class="nc"><i>1485</i>&nbsp;        for (int i = subGroup.length-1; i &gt;= 0; i--) {</b>
<b class="nc"><i>1486</i>&nbsp;            if (wildcard.allowNamespace(subGroup[i].fTargetNamespace))</b>
<i>1487</i>&nbsp;                return true;
<i>1488</i>&nbsp;        }
<b class="nc"><i>1489</i>&nbsp;</b>
<i>1490</i>&nbsp;        return false;
<i>1491</i>&nbsp;    }
<i>1492</i>&nbsp;
<i>1493</i>&nbsp;    public static boolean overlapUPA(XSWildcardDecl wildcard1,
<i>1494</i>&nbsp;            XSWildcardDecl wildcard2) {
<b class="nc"><i>1495</i>&nbsp;        // if the intersection of the two wildcard is not empty list</b>
<b class="nc"><i>1496</i>&nbsp;        XSWildcardDecl intersect = wildcard1.performIntersectionWith(wildcard2, wildcard1.fProcessContents);</b>
<i>1497</i>&nbsp;        if (intersect == null ||
<i>1498</i>&nbsp;                intersect.fType != XSWildcardDecl.NSCONSTRAINT_LIST ||
<b class="nc"><i>1499</i>&nbsp;                intersect.fNamespaceList.length != 0) {</b>
<i>1500</i>&nbsp;            return true;
<i>1501</i>&nbsp;        }
<b class="nc"><i>1502</i>&nbsp;</b>
<i>1503</i>&nbsp;        return false;
<i>1504</i>&nbsp;    }
<i>1505</i>&nbsp;
<i>1506</i>&nbsp;    // call one of the above methods according to the type of decls
<i>1507</i>&nbsp;    public static boolean overlapUPA(Object decl1, Object decl2,
<b class="nc"><i>1508</i>&nbsp;            SubstitutionGroupHandler sgHandler) {</b>
<b class="nc"><i>1509</i>&nbsp;        if (decl1 instanceof XSElementDecl) {</b>
<b class="nc"><i>1510</i>&nbsp;            if (decl2 instanceof XSElementDecl) {</b>
<i>1511</i>&nbsp;                return overlapUPA((XSElementDecl)decl1,
<i>1512</i>&nbsp;                        (XSElementDecl)decl2,
<i>1513</i>&nbsp;                        sgHandler);
<i>1514</i>&nbsp;            }
<b class="nc"><i>1515</i>&nbsp;            else {</b>
<i>1516</i>&nbsp;                return overlapUPA((XSElementDecl)decl1,
<i>1517</i>&nbsp;                        (XSWildcardDecl)decl2,
<i>1518</i>&nbsp;                        sgHandler);
<i>1519</i>&nbsp;            }
<i>1520</i>&nbsp;        }
<b class="nc"><i>1521</i>&nbsp;        else {</b>
<b class="nc"><i>1522</i>&nbsp;            if (decl2 instanceof XSElementDecl) {</b>
<i>1523</i>&nbsp;                return overlapUPA((XSElementDecl)decl2,
<i>1524</i>&nbsp;                        (XSWildcardDecl)decl1,
<i>1525</i>&nbsp;                        sgHandler);
<i>1526</i>&nbsp;            }
<b class="nc"><i>1527</i>&nbsp;            else {</b>
<i>1528</i>&nbsp;                return overlapUPA((XSWildcardDecl)decl1,
<i>1529</i>&nbsp;                        (XSWildcardDecl)decl2);
<i>1530</i>&nbsp;            }
<i>1531</i>&nbsp;        }
<i>1532</i>&nbsp;    }
<i>1533</i>&nbsp;
<i>1534</i>&nbsp;} // class XSContraints
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
