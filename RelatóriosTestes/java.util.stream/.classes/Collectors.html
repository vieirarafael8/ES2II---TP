


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Collectors</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.util.stream</a> ]
</div>

<h1>Coverage Summary for Class: Collectors (java.util.stream)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Collectors</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 108)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 187)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Collectors$1OptionalBox</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Collectors$CollectorImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Collectors$Partition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Collectors$Partition$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 122)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 215)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package java.util.stream;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.util.AbstractMap;
<i>28</i>&nbsp;import java.util.AbstractSet;
<i>29</i>&nbsp;import java.util.ArrayList;
<i>30</i>&nbsp;import java.util.Collection;
<i>31</i>&nbsp;import java.util.Collections;
<i>32</i>&nbsp;import java.util.Comparator;
<i>33</i>&nbsp;import java.util.DoubleSummaryStatistics;
<i>34</i>&nbsp;import java.util.EnumSet;
<i>35</i>&nbsp;import java.util.HashMap;
<i>36</i>&nbsp;import java.util.HashSet;
<i>37</i>&nbsp;import java.util.IntSummaryStatistics;
<i>38</i>&nbsp;import java.util.Iterator;
<i>39</i>&nbsp;import java.util.List;
<i>40</i>&nbsp;import java.util.LongSummaryStatistics;
<i>41</i>&nbsp;import java.util.Map;
<i>42</i>&nbsp;import java.util.Objects;
<i>43</i>&nbsp;import java.util.Optional;
<i>44</i>&nbsp;import java.util.Set;
<i>45</i>&nbsp;import java.util.StringJoiner;
<i>46</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>47</i>&nbsp;import java.util.concurrent.ConcurrentMap;
<i>48</i>&nbsp;import java.util.function.BiConsumer;
<i>49</i>&nbsp;import java.util.function.BiFunction;
<i>50</i>&nbsp;import java.util.function.BinaryOperator;
<i>51</i>&nbsp;import java.util.function.Consumer;
<i>52</i>&nbsp;import java.util.function.Function;
<i>53</i>&nbsp;import java.util.function.Predicate;
<i>54</i>&nbsp;import java.util.function.Supplier;
<i>55</i>&nbsp;import java.util.function.ToDoubleFunction;
<i>56</i>&nbsp;import java.util.function.ToIntFunction;
<i>57</i>&nbsp;import java.util.function.ToLongFunction;
<i>58</i>&nbsp;
<i>59</i>&nbsp;/**
<i>60</i>&nbsp; * Implementations of {@link Collector} that implement various useful reduction
<i>61</i>&nbsp; * operations, such as accumulating elements into collections, summarizing
<i>62</i>&nbsp; * elements according to various criteria, etc.
<i>63</i>&nbsp; *
<i>64</i>&nbsp; * &lt;p&gt;The following are examples of using the predefined collectors to perform
<i>65</i>&nbsp; * common mutable reduction tasks:
<i>66</i>&nbsp; *
<i>67</i>&nbsp; * &lt;pre&gt;{@code
<i>68</i>&nbsp; * // Accumulate names into a List
<i>69</i>&nbsp; * List&lt;String&gt; list = people.stream()
<i>70</i>&nbsp; *   .map(Person::getName)
<i>71</i>&nbsp; *   .collect(Collectors.toList());
<i>72</i>&nbsp; *
<i>73</i>&nbsp; * // Accumulate names into a TreeSet
<i>74</i>&nbsp; * Set&lt;String&gt; set = people.stream()
<i>75</i>&nbsp; *   .map(Person::getName)
<i>76</i>&nbsp; *   .collect(Collectors.toCollection(TreeSet::new));
<i>77</i>&nbsp; *
<i>78</i>&nbsp; * // Convert elements to strings and concatenate them, separated by commas
<i>79</i>&nbsp; * String joined = things.stream()
<i>80</i>&nbsp; *   .map(Object::toString)
<i>81</i>&nbsp; *   .collect(Collectors.joining(&quot;, &quot;));
<i>82</i>&nbsp; *
<i>83</i>&nbsp; * // Compute sum of salaries of employee
<i>84</i>&nbsp; * int total = employees.stream()
<i>85</i>&nbsp; *   .collect(Collectors.summingInt(Employee::getSalary));
<i>86</i>&nbsp; *
<i>87</i>&nbsp; * // Group employees by department
<i>88</i>&nbsp; * Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()
<i>89</i>&nbsp; *   .collect(Collectors.groupingBy(Employee::getDepartment));
<i>90</i>&nbsp; *
<i>91</i>&nbsp; * // Compute sum of salaries by department
<i>92</i>&nbsp; * Map&lt;Department, Integer&gt; totalByDept = employees.stream()
<i>93</i>&nbsp; *   .collect(Collectors.groupingBy(Employee::getDepartment,
<i>94</i>&nbsp; *                                  Collectors.summingInt(Employee::getSalary)));
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * // Partition students into passing and failing
<i>97</i>&nbsp; * Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()
<i>98</i>&nbsp; *   .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));
<i>99</i>&nbsp; *
<i>100</i>&nbsp; * }&lt;/pre&gt;
<i>101</i>&nbsp; *
<i>102</i>&nbsp; * @since 1.8
<i>103</i>&nbsp; */
<b class="nc"><i>104</i>&nbsp;public final class Collectors {</b>
<i>105</i>&nbsp;
<b class="nc"><i>106</i>&nbsp;    static final Set&lt;Collector.Characteristics&gt; CH_CONCURRENT_ID</b>
<b class="nc"><i>107</i>&nbsp;            = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.CONCURRENT,</b>
<i>108</i>&nbsp;                                                     Collector.Characteristics.UNORDERED,
<i>109</i>&nbsp;                                                     Collector.Characteristics.IDENTITY_FINISH));
<b class="nc"><i>110</i>&nbsp;    static final Set&lt;Collector.Characteristics&gt; CH_CONCURRENT_NOID</b>
<b class="nc"><i>111</i>&nbsp;            = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.CONCURRENT,</b>
<i>112</i>&nbsp;                                                     Collector.Characteristics.UNORDERED));
<b class="nc"><i>113</i>&nbsp;    static final Set&lt;Collector.Characteristics&gt; CH_ID</b>
<b class="nc"><i>114</i>&nbsp;            = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));</b>
<b class="nc"><i>115</i>&nbsp;    static final Set&lt;Collector.Characteristics&gt; CH_UNORDERED_ID</b>
<b class="nc"><i>116</i>&nbsp;            = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.UNORDERED,</b>
<i>117</i>&nbsp;                                                     Collector.Characteristics.IDENTITY_FINISH));
<b class="nc"><i>118</i>&nbsp;    static final Set&lt;Collector.Characteristics&gt; CH_NOID = Collections.emptySet();</b>
<i>119</i>&nbsp;    static final Set&lt;Collector.Characteristics&gt; CH_UNORDERED_NOID
<b class="nc"><i>120</i>&nbsp;            = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.UNORDERED));</b>
<i>121</i>&nbsp;
<i>122</i>&nbsp;    private Collectors() { }
<i>123</i>&nbsp;
<i>124</i>&nbsp;    /**
<i>125</i>&nbsp;     * Construct an {@code IllegalStateException} with appropriate message.
<i>126</i>&nbsp;     *
<i>127</i>&nbsp;     * @param k the duplicate key
<i>128</i>&nbsp;     * @param u 1st value to be accumulated/merged
<i>129</i>&nbsp;     * @param v 2nd value to be accumulated/merged
<i>130</i>&nbsp;     */
<i>131</i>&nbsp;    private static IllegalStateException duplicateKeyException(
<i>132</i>&nbsp;            Object k, Object u, Object v) {
<b class="nc"><i>133</i>&nbsp;        return new IllegalStateException(String.format(</b>
<i>134</i>&nbsp;            &quot;Duplicate key %s (attempted merging values %s and %s)&quot;,
<i>135</i>&nbsp;            k, u, v));
<i>136</i>&nbsp;    }
<i>137</i>&nbsp;
<b class="nc"><i>138</i>&nbsp;    /**</b>
<i>139</i>&nbsp;     * {@code BinaryOperator&lt;Map&gt;} that merges the contents of its right
<i>140</i>&nbsp;     * argument into its left argument, throwing {@code IllegalStateException}
<i>141</i>&nbsp;     * if duplicate keys are encountered.
<i>142</i>&nbsp;     *
<i>143</i>&nbsp;     * @param &lt;K&gt; type of the map keys
<i>144</i>&nbsp;     * @param &lt;V&gt; type of the map values
<i>145</i>&nbsp;     * @param &lt;M&gt; type of the map
<i>146</i>&nbsp;     * @return a merge function for two maps
<i>147</i>&nbsp;     */
<i>148</i>&nbsp;    private static &lt;K, V, M extends Map&lt;K,V&gt;&gt;
<i>149</i>&nbsp;    BinaryOperator&lt;M&gt; uniqKeysMapMerger() {
<i>150</i>&nbsp;        return (m1, m2) -&gt; {
<i>151</i>&nbsp;            for (Map.Entry&lt;K,V&gt; e : m2.entrySet()) {
<i>152</i>&nbsp;                K k = e.getKey();
<i>153</i>&nbsp;                V v = Objects.requireNonNull(e.getValue());
<i>154</i>&nbsp;                V u = m1.putIfAbsent(k, v);
<i>155</i>&nbsp;                if (u != null) throw duplicateKeyException(k, u, v);
<i>156</i>&nbsp;            }
<i>157</i>&nbsp;            return m1;
<b class="nc"><i>158</i>&nbsp;        };</b>
<b class="nc"><i>159</i>&nbsp;    }</b>
<b class="nc"><i>160</i>&nbsp;</b>
<b class="nc"><i>161</i>&nbsp;    /**</b>
<b class="nc"><i>162</i>&nbsp;     * {@code BiConsumer&lt;Map, T&gt;} that accumulates (key, value) pairs</b>
<b class="nc"><i>163</i>&nbsp;     * extracted from elements into the map, throwing {@code IllegalStateException}</b>
<i>164</i>&nbsp;     * if duplicate keys are encountered.
<i>165</i>&nbsp;     *
<i>166</i>&nbsp;     * @param keyMapper a function that maps an element into a key
<i>167</i>&nbsp;     * @param valueMapper a function that maps an element into a value
<i>168</i>&nbsp;     * @param &lt;T&gt; type of elements
<i>169</i>&nbsp;     * @param &lt;K&gt; type of map keys
<b class="nc"><i>170</i>&nbsp;     * @param &lt;V&gt; type of map values</b>
<i>171</i>&nbsp;     * @return an accumulating consumer
<i>172</i>&nbsp;     */
<i>173</i>&nbsp;    private static &lt;T, K, V&gt;
<i>174</i>&nbsp;    BiConsumer&lt;Map&lt;K, V&gt;, T&gt; uniqKeysMapAccumulator(Function&lt;? super T, ? extends K&gt; keyMapper,
<b class="nc"><i>175</i>&nbsp;                                                    Function&lt;? super T, ? extends V&gt; valueMapper) {</b>
<i>176</i>&nbsp;        return (map, element) -&gt; {
<i>177</i>&nbsp;            K k = keyMapper.apply(element);
<i>178</i>&nbsp;            V v = Objects.requireNonNull(valueMapper.apply(element));
<i>179</i>&nbsp;            V u = map.putIfAbsent(k, v);
<b class="nc"><i>180</i>&nbsp;            if (u != null) throw duplicateKeyException(k, u, v);</b>
<i>181</i>&nbsp;        };
<i>182</i>&nbsp;    }
<i>183</i>&nbsp;
<i>184</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>185</i>&nbsp;    private static &lt;I, R&gt; Function&lt;I, R&gt; castingIdentity() {</b>
<i>186</i>&nbsp;        return i -&gt; (R) i;
<i>187</i>&nbsp;    }
<i>188</i>&nbsp;
<i>189</i>&nbsp;    /**
<b class="nc"><i>190</i>&nbsp;     * Simple implementation class for {@code Collector}.</b>
<i>191</i>&nbsp;     *
<i>192</i>&nbsp;     * @param &lt;T&gt; the type of elements to be collected
<i>193</i>&nbsp;     * @param &lt;R&gt; the type of the result
<i>194</i>&nbsp;     */
<b class="nc"><i>195</i>&nbsp;    static class CollectorImpl&lt;T, A, R&gt; implements Collector&lt;T, A, R&gt; {</b>
<i>196</i>&nbsp;        private final Supplier&lt;A&gt; supplier;
<i>197</i>&nbsp;        private final BiConsumer&lt;A, T&gt; accumulator;
<i>198</i>&nbsp;        private final BinaryOperator&lt;A&gt; combiner;
<i>199</i>&nbsp;        private final Function&lt;A, R&gt; finisher;
<i>200</i>&nbsp;        private final Set&lt;Characteristics&gt; characteristics;
<i>201</i>&nbsp;
<i>202</i>&nbsp;        CollectorImpl(Supplier&lt;A&gt; supplier,
<i>203</i>&nbsp;                      BiConsumer&lt;A, T&gt; accumulator,
<i>204</i>&nbsp;                      BinaryOperator&lt;A&gt; combiner,
<i>205</i>&nbsp;                      Function&lt;A,R&gt; finisher,
<i>206</i>&nbsp;                      Set&lt;Characteristics&gt; characteristics) {
<i>207</i>&nbsp;            this.supplier = supplier;
<i>208</i>&nbsp;            this.accumulator = accumulator;
<i>209</i>&nbsp;            this.combiner = combiner;
<i>210</i>&nbsp;            this.finisher = finisher;
<i>211</i>&nbsp;            this.characteristics = characteristics;
<i>212</i>&nbsp;        }
<b class="nc"><i>213</i>&nbsp;</b>
<b class="nc"><i>214</i>&nbsp;        CollectorImpl(Supplier&lt;A&gt; supplier,</b>
<i>215</i>&nbsp;                      BiConsumer&lt;A, T&gt; accumulator,
<i>216</i>&nbsp;                      BinaryOperator&lt;A&gt; combiner,
<i>217</i>&nbsp;                      Set&lt;Characteristics&gt; characteristics) {
<i>218</i>&nbsp;            this(supplier, accumulator, combiner, castingIdentity(), characteristics);
<i>219</i>&nbsp;        }
<i>220</i>&nbsp;
<i>221</i>&nbsp;        @Override
<i>222</i>&nbsp;        public BiConsumer&lt;A, T&gt; accumulator() {
<i>223</i>&nbsp;            return accumulator;
<i>224</i>&nbsp;        }
<i>225</i>&nbsp;
<i>226</i>&nbsp;        @Override
<i>227</i>&nbsp;        public Supplier&lt;A&gt; supplier() {
<i>228</i>&nbsp;            return supplier;
<i>229</i>&nbsp;        }
<b class="nc"><i>230</i>&nbsp;</b>
<b class="nc"><i>231</i>&nbsp;        @Override</b>
<i>232</i>&nbsp;        public BinaryOperator&lt;A&gt; combiner() {
<i>233</i>&nbsp;            return combiner;
<i>234</i>&nbsp;        }
<i>235</i>&nbsp;
<i>236</i>&nbsp;        @Override
<i>237</i>&nbsp;        public Function&lt;A, R&gt; finisher() {
<i>238</i>&nbsp;            return finisher;
<i>239</i>&nbsp;        }
<i>240</i>&nbsp;
<i>241</i>&nbsp;        @Override
<i>242</i>&nbsp;        public Set&lt;Characteristics&gt; characteristics() {
<i>243</i>&nbsp;            return characteristics;
<i>244</i>&nbsp;        }
<i>245</i>&nbsp;    }
<i>246</i>&nbsp;
<i>247</i>&nbsp;    /**
<i>248</i>&nbsp;     * Returns a {@code Collector} that accumulates the input elements into a
<i>249</i>&nbsp;     * new {@code Collection}, in encounter order.  The {@code Collection} is
<i>250</i>&nbsp;     * created by the provided factory.
<b class="nc"><i>251</i>&nbsp;     *</b>
<b class="nc"><i>252</i>&nbsp;     * @param &lt;T&gt; the type of the input elements</b>
<i>253</i>&nbsp;     * @param &lt;C&gt; the type of the resulting {@code Collection}
<i>254</i>&nbsp;     * @param collectionFactory a supplier providing a new empty {@code Collection}
<i>255</i>&nbsp;     *                          into which the results will be inserted
<i>256</i>&nbsp;     * @return a {@code Collector} which collects all the input elements into a
<i>257</i>&nbsp;     * {@code Collection}, in encounter order
<i>258</i>&nbsp;     */
<i>259</i>&nbsp;    public static &lt;T, C extends Collection&lt;T&gt;&gt;
<i>260</i>&nbsp;    Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) {
<i>261</i>&nbsp;        return new CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,
<i>262</i>&nbsp;                                   (r1, r2) -&gt; { r1.addAll(r2); return r1; },
<i>263</i>&nbsp;                                   CH_ID);
<b class="nc"><i>264</i>&nbsp;    }</b>
<i>265</i>&nbsp;
<b class="nc"><i>266</i>&nbsp;    /**</b>
<i>267</i>&nbsp;     * Returns a {@code Collector} that accumulates the input elements into a
<i>268</i>&nbsp;     * new {@code List}. There are no guarantees on the type, mutability,
<i>269</i>&nbsp;     * serializability, or thread-safety of the {@code List} returned; if more
<i>270</i>&nbsp;     * control over the returned {@code List} is required, use {@link #toCollection(Supplier)}.
<i>271</i>&nbsp;     *
<i>272</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>273</i>&nbsp;     * @return a {@code Collector} which collects all the input elements into a
<i>274</i>&nbsp;     * {@code List}, in encounter order
<i>275</i>&nbsp;     */
<i>276</i>&nbsp;    public static &lt;T&gt;
<i>277</i>&nbsp;    Collector&lt;T, ?, List&lt;T&gt;&gt; toList() {
<i>278</i>&nbsp;        return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add,
<b class="nc"><i>279</i>&nbsp;                                   (left, right) -&gt; { left.addAll(right); return left; },</b>
<i>280</i>&nbsp;                                   CH_ID);
<i>281</i>&nbsp;    }
<i>282</i>&nbsp;
<i>283</i>&nbsp;    /**
<i>284</i>&nbsp;     * Returns a {@code Collector} that accumulates the input elements into an
<i>285</i>&nbsp;     * &lt;a href=&quot;../List.html#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt; in encounter
<i>286</i>&nbsp;     * order. The returned Collector disallows null values and will throw
<i>287</i>&nbsp;     * {@code NullPointerException} if it is presented with a null value.
<i>288</i>&nbsp;     *
<i>289</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>290</i>&nbsp;     * @return a {@code Collector} that accumulates the input elements into an
<i>291</i>&nbsp;     * &lt;a href=&quot;../List.html#unmodifiable&quot;&gt;unmodifiable List&lt;/a&gt; in encounter order
<i>292</i>&nbsp;     * @since 10
<i>293</i>&nbsp;     */
<i>294</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>295</i>&nbsp;    public static &lt;T&gt;
<i>296</i>&nbsp;    Collector&lt;T, ?, List&lt;T&gt;&gt; toUnmodifiableList() {
<i>297</i>&nbsp;        return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add,
<b class="nc"><i>298</i>&nbsp;                                   (left, right) -&gt; { left.addAll(right); return left; },</b>
<b class="nc"><i>299</i>&nbsp;                                   list -&gt; (List&lt;T&gt;)List.of(list.toArray()),</b>
<i>300</i>&nbsp;                                   CH_NOID);
<i>301</i>&nbsp;    }
<i>302</i>&nbsp;
<i>303</i>&nbsp;    /**
<i>304</i>&nbsp;     * Returns a {@code Collector} that accumulates the input elements into a
<i>305</i>&nbsp;     * new {@code Set}. There are no guarantees on the type, mutability,
<i>306</i>&nbsp;     * serializability, or thread-safety of the {@code Set} returned; if more
<i>307</i>&nbsp;     * control over the returned {@code Set} is required, use
<i>308</i>&nbsp;     * {@link #toCollection(Supplier)}.
<i>309</i>&nbsp;     *
<i>310</i>&nbsp;     * &lt;p&gt;This is an {@link Collector.Characteristics#UNORDERED unordered}
<i>311</i>&nbsp;     * Collector.
<i>312</i>&nbsp;     *
<i>313</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>314</i>&nbsp;     * @return a {@code Collector} which collects all the input elements into a
<i>315</i>&nbsp;     * {@code Set}
<i>316</i>&nbsp;     */
<i>317</i>&nbsp;    public static &lt;T&gt;
<b class="nc"><i>318</i>&nbsp;    Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() {</b>
<b class="nc"><i>319</i>&nbsp;        return new CollectorImpl&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::new, Set::add,</b>
<b class="nc"><i>320</i>&nbsp;                                   (left, right) -&gt; {</b>
<b class="nc"><i>321</i>&nbsp;                                       if (left.size() &lt; right.size()) {</b>
<i>322</i>&nbsp;                                           right.addAll(left); return right;
<i>323</i>&nbsp;                                       } else {
<i>324</i>&nbsp;                                           left.addAll(right); return left;
<i>325</i>&nbsp;                                       }
<i>326</i>&nbsp;                                   },
<i>327</i>&nbsp;                                   CH_UNORDERED_ID);
<i>328</i>&nbsp;    }
<i>329</i>&nbsp;
<i>330</i>&nbsp;    /**
<i>331</i>&nbsp;     * Returns a {@code Collector} that accumulates the input elements into an
<i>332</i>&nbsp;     * &lt;a href=&quot;../Set.html#unmodifiable&quot;&gt;unmodifiable Set&lt;/a&gt;. The returned
<i>333</i>&nbsp;     * Collector disallows null values and will throw {@code NullPointerException}
<i>334</i>&nbsp;     * if it is presented with a null value. If the input contains duplicate elements,
<i>335</i>&nbsp;     * an arbitrary element of the duplicates is preserved.
<i>336</i>&nbsp;     *
<i>337</i>&nbsp;     * &lt;p&gt;This is an {@link Collector.Characteristics#UNORDERED unordered}
<i>338</i>&nbsp;     * Collector.
<i>339</i>&nbsp;     *
<i>340</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>341</i>&nbsp;     * @return a {@code Collector} that accumulates the input elements into an
<i>342</i>&nbsp;     * &lt;a href=&quot;../Set.html#unmodifiable&quot;&gt;unmodifiable Set&lt;/a&gt;
<i>343</i>&nbsp;     * @since 10
<i>344</i>&nbsp;     */
<i>345</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>346</i>&nbsp;    public static &lt;T&gt;
<i>347</i>&nbsp;    Collector&lt;T, ?, Set&lt;T&gt;&gt; toUnmodifiableSet() {
<i>348</i>&nbsp;        return new CollectorImpl&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::new, Set::add,
<i>349</i>&nbsp;                                   (left, right) -&gt; {
<i>350</i>&nbsp;                                       if (left.size() &lt; right.size()) {
<i>351</i>&nbsp;                                           right.addAll(left); return right;
<i>352</i>&nbsp;                                       } else {
<b class="nc"><i>353</i>&nbsp;                                           left.addAll(right); return left;</b>
<b class="nc"><i>354</i>&nbsp;                                       }</b>
<b class="nc"><i>355</i>&nbsp;                                   },</b>
<b class="nc"><i>356</i>&nbsp;                                   set -&gt; (Set&lt;T&gt;)Set.of(set.toArray()),</b>
<b class="nc"><i>357</i>&nbsp;                                   CH_UNORDERED_NOID);</b>
<i>358</i>&nbsp;    }
<i>359</i>&nbsp;
<i>360</i>&nbsp;    /**
<i>361</i>&nbsp;     * Returns a {@code Collector} that concatenates the input elements into a
<i>362</i>&nbsp;     * {@code String}, in encounter order.
<i>363</i>&nbsp;     *
<i>364</i>&nbsp;     * @return a {@code Collector} that concatenates the input elements into a
<i>365</i>&nbsp;     * {@code String}, in encounter order
<i>366</i>&nbsp;     */
<i>367</i>&nbsp;    public static Collector&lt;CharSequence, ?, String&gt; joining() {
<i>368</i>&nbsp;        return new CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(
<i>369</i>&nbsp;                StringBuilder::new, StringBuilder::append,
<i>370</i>&nbsp;                (r1, r2) -&gt; { r1.append(r2); return r1; },
<i>371</i>&nbsp;                StringBuilder::toString, CH_NOID);
<i>372</i>&nbsp;    }
<i>373</i>&nbsp;
<i>374</i>&nbsp;    /**
<i>375</i>&nbsp;     * Returns a {@code Collector} that concatenates the input elements,
<i>376</i>&nbsp;     * separated by the specified delimiter, in encounter order.
<i>377</i>&nbsp;     *
<i>378</i>&nbsp;     * @param delimiter the delimiter to be used between each element
<i>379</i>&nbsp;     * @return A {@code Collector} which concatenates CharSequence elements,
<b class="nc"><i>380</i>&nbsp;     * separated by the specified delimiter, in encounter order</b>
<b class="nc"><i>381</i>&nbsp;     */</b>
<b class="nc"><i>382</i>&nbsp;    public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) {</b>
<b class="nc"><i>383</i>&nbsp;        return joining(delimiter, &quot;&quot;, &quot;&quot;);</b>
<i>384</i>&nbsp;    }
<b class="nc"><i>385</i>&nbsp;</b>
<b class="nc"><i>386</i>&nbsp;    /**</b>
<b class="nc"><i>387</i>&nbsp;     * Returns a {@code Collector} that concatenates the input elements,</b>
<i>388</i>&nbsp;     * separated by the specified delimiter, with the specified prefix and
<i>389</i>&nbsp;     * suffix, in encounter order.
<b class="nc"><i>390</i>&nbsp;     *</b>
<b class="nc"><i>391</i>&nbsp;     * @param delimiter the delimiter to be used between each element</b>
<b class="nc"><i>392</i>&nbsp;     * @param  prefix the sequence of characters to be used at the beginning</b>
<b class="nc"><i>393</i>&nbsp;     *                of the joined result</b>
<i>394</i>&nbsp;     * @param  suffix the sequence of characters to be used at the end
<i>395</i>&nbsp;     *                of the joined result
<i>396</i>&nbsp;     * @return A {@code Collector} which concatenates CharSequence elements,
<i>397</i>&nbsp;     * separated by the specified delimiter, in encounter order
<i>398</i>&nbsp;     */
<i>399</i>&nbsp;    public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,
<i>400</i>&nbsp;                                                             CharSequence prefix,
<i>401</i>&nbsp;                                                             CharSequence suffix) {
<i>402</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>403</i>&nbsp;                () -&gt; new StringJoiner(delimiter, prefix, suffix),
<i>404</i>&nbsp;                StringJoiner::add, StringJoiner::merge,
<i>405</i>&nbsp;                StringJoiner::toString, CH_NOID);
<i>406</i>&nbsp;    }
<i>407</i>&nbsp;
<i>408</i>&nbsp;    /**
<i>409</i>&nbsp;     * {@code BinaryOperator&lt;Map&gt;} that merges the contents of its right
<i>410</i>&nbsp;     * argument into its left argument, using the provided merge function to
<i>411</i>&nbsp;     * handle duplicate keys.
<i>412</i>&nbsp;     *
<b class="nc"><i>413</i>&nbsp;     * @param &lt;K&gt; type of the map keys</b>
<i>414</i>&nbsp;     * @param &lt;V&gt; type of the map values
<i>415</i>&nbsp;     * @param &lt;M&gt; type of the map
<i>416</i>&nbsp;     * @param mergeFunction A merge function suitable for
<i>417</i>&nbsp;     * {@link Map#merge(Object, Object, BiFunction) Map.merge()}
<i>418</i>&nbsp;     * @return a merge function for two maps
<i>419</i>&nbsp;     */
<i>420</i>&nbsp;    private static &lt;K, V, M extends Map&lt;K,V&gt;&gt;
<i>421</i>&nbsp;    BinaryOperator&lt;M&gt; mapMerger(BinaryOperator&lt;V&gt; mergeFunction) {
<i>422</i>&nbsp;        return (m1, m2) -&gt; {
<i>423</i>&nbsp;            for (Map.Entry&lt;K,V&gt; e : m2.entrySet())
<i>424</i>&nbsp;                m1.merge(e.getKey(), e.getValue(), mergeFunction);
<i>425</i>&nbsp;            return m1;
<i>426</i>&nbsp;        };
<i>427</i>&nbsp;    }
<i>428</i>&nbsp;
<i>429</i>&nbsp;    /**
<i>430</i>&nbsp;     * Adapts a {@code Collector} accepting elements of type {@code U} to one
<i>431</i>&nbsp;     * accepting elements of type {@code T} by applying a mapping function to
<b class="nc"><i>432</i>&nbsp;     * each input element before accumulation.</b>
<i>433</i>&nbsp;     *
<i>434</i>&nbsp;     * @apiNote
<i>435</i>&nbsp;     * The {@code mapping()} collectors are most useful when used in a
<i>436</i>&nbsp;     * multi-level reduction, such as downstream of a {@code groupingBy} or
<i>437</i>&nbsp;     * {@code partitioningBy}.  For example, given a stream of
<i>438</i>&nbsp;     * {@code Person}, to accumulate the set of last names in each city:
<i>439</i>&nbsp;     * &lt;pre&gt;{@code
<i>440</i>&nbsp;     * Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity
<i>441</i>&nbsp;     *   = people.stream().collect(
<i>442</i>&nbsp;     *     groupingBy(Person::getCity,
<i>443</i>&nbsp;     *                mapping(Person::getLastName,
<i>444</i>&nbsp;     *                        toSet())));
<i>445</i>&nbsp;     * }&lt;/pre&gt;
<i>446</i>&nbsp;     *
<i>447</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>448</i>&nbsp;     * @param &lt;U&gt; type of elements accepted by downstream collector
<i>449</i>&nbsp;     * @param &lt;A&gt; intermediate accumulation type of the downstream collector
<i>450</i>&nbsp;     * @param &lt;R&gt; result type of collector
<b class="nc"><i>451</i>&nbsp;     * @param mapper a function to be applied to the input elements</b>
<i>452</i>&nbsp;     * @param downstream a collector which will accept mapped values
<i>453</i>&nbsp;     * @return a collector which applies the mapping function to the input
<i>454</i>&nbsp;     * elements and provides the mapped results to the downstream collector
<i>455</i>&nbsp;     */
<i>456</i>&nbsp;    public static &lt;T, U, A, R&gt;
<i>457</i>&nbsp;    Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper,
<i>458</i>&nbsp;                               Collector&lt;? super U, A, R&gt; downstream) {
<i>459</i>&nbsp;        BiConsumer&lt;A, ? super U&gt; downstreamAccumulator = downstream.accumulator();
<i>460</i>&nbsp;        return new CollectorImpl&lt;&gt;(downstream.supplier(),
<i>461</i>&nbsp;                                   (r, t) -&gt; downstreamAccumulator.accept(r, mapper.apply(t)),
<i>462</i>&nbsp;                                   downstream.combiner(), downstream.finisher(),
<i>463</i>&nbsp;                                   downstream.characteristics());
<i>464</i>&nbsp;    }
<b class="nc"><i>465</i>&nbsp;</b>
<b class="nc"><i>466</i>&nbsp;    /**</b>
<b class="nc"><i>467</i>&nbsp;     * Adapts a {@code Collector} accepting elements of type {@code U} to one</b>
<b class="nc"><i>468</i>&nbsp;     * accepting elements of type {@code T} by applying a flat mapping function</b>
<b class="nc"><i>469</i>&nbsp;     * to each input element before accumulation.  The flat mapping function</b>
<i>470</i>&nbsp;     * maps an input element to a {@link Stream stream} covering zero or more
<i>471</i>&nbsp;     * output elements that are then accumulated downstream.  Each mapped stream
<i>472</i>&nbsp;     * is {@link java.util.stream.BaseStream#close() closed} after its contents
<i>473</i>&nbsp;     * have been placed downstream.  (If a mapped stream is {@code null}
<i>474</i>&nbsp;     * an empty stream is used, instead.)
<i>475</i>&nbsp;     *
<i>476</i>&nbsp;     * @apiNote
<i>477</i>&nbsp;     * The {@code flatMapping()} collectors are most useful when used in a
<i>478</i>&nbsp;     * multi-level reduction, such as downstream of a {@code groupingBy} or
<i>479</i>&nbsp;     * {@code partitioningBy}.  For example, given a stream of
<i>480</i>&nbsp;     * {@code Order}, to accumulate the set of line items for each customer:
<i>481</i>&nbsp;     * &lt;pre&gt;{@code
<i>482</i>&nbsp;     * Map&lt;String, Set&lt;LineItem&gt;&gt; itemsByCustomerName
<b class="nc"><i>483</i>&nbsp;     *   = orders.stream().collect(</b>
<b class="nc"><i>484</i>&nbsp;     *     groupingBy(Order::getCustomerName,</b>
<b class="nc"><i>485</i>&nbsp;     *                flatMapping(order -&gt; order.getLineItems().stream(),</b>
<b class="nc"><i>486</i>&nbsp;     *                            toSet())));</b>
<b class="nc"><i>487</i>&nbsp;     * }&lt;/pre&gt;</b>
<i>488</i>&nbsp;     *
<i>489</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>490</i>&nbsp;     * @param &lt;U&gt; type of elements accepted by downstream collector
<i>491</i>&nbsp;     * @param &lt;A&gt; intermediate accumulation type of the downstream collector
<i>492</i>&nbsp;     * @param &lt;R&gt; result type of collector
<i>493</i>&nbsp;     * @param mapper a function to be applied to the input elements, which
<i>494</i>&nbsp;     * returns a stream of results
<i>495</i>&nbsp;     * @param downstream a collector which will receive the elements of the
<i>496</i>&nbsp;     * stream returned by mapper
<i>497</i>&nbsp;     * @return a collector which applies the mapping function to the input
<i>498</i>&nbsp;     * elements and provides the flat mapped results to the downstream collector
<i>499</i>&nbsp;     * @since 9
<i>500</i>&nbsp;     */
<i>501</i>&nbsp;    public static &lt;T, U, A, R&gt;
<i>502</i>&nbsp;    Collector&lt;T, ?, R&gt; flatMapping(Function&lt;? super T, ? extends Stream&lt;? extends U&gt;&gt; mapper,
<i>503</i>&nbsp;                                   Collector&lt;? super U, A, R&gt; downstream) {
<i>504</i>&nbsp;        BiConsumer&lt;A, ? super U&gt; downstreamAccumulator = downstream.accumulator();
<i>505</i>&nbsp;        return new CollectorImpl&lt;&gt;(downstream.supplier(),
<i>506</i>&nbsp;                            (r, t) -&gt; {
<i>507</i>&nbsp;                                try (Stream&lt;? extends U&gt; result = mapper.apply(t)) {
<i>508</i>&nbsp;                                    if (result != null)
<i>509</i>&nbsp;                                        result.sequential().forEach(u -&gt; downstreamAccumulator.accept(r, u));
<i>510</i>&nbsp;                                }
<i>511</i>&nbsp;                            },
<i>512</i>&nbsp;                            downstream.combiner(), downstream.finisher(),
<i>513</i>&nbsp;                            downstream.characteristics());
<i>514</i>&nbsp;    }
<i>515</i>&nbsp;
<b class="nc"><i>516</i>&nbsp;    /**</b>
<b class="nc"><i>517</i>&nbsp;     * Adapts a {@code Collector} to one accepting elements of the same type</b>
<b class="nc"><i>518</i>&nbsp;     * {@code T} by applying the predicate to each input element and only</b>
<b class="nc"><i>519</i>&nbsp;     * accumulating if the predicate returns {@code true}.</b>
<b class="nc"><i>520</i>&nbsp;     *</b>
<b class="nc"><i>521</i>&nbsp;     * @apiNote</b>
<b class="nc"><i>522</i>&nbsp;     * The {@code filtering()} collectors are most useful when used in a</b>
<b class="nc"><i>523</i>&nbsp;     * multi-level reduction, such as downstream of a {@code groupingBy} or</b>
<i>524</i>&nbsp;     * {@code partitioningBy}.  For example, given a stream of
<i>525</i>&nbsp;     * {@code Employee}, to accumulate the employees in each department that have a
<i>526</i>&nbsp;     * salary above a certain threshold:
<i>527</i>&nbsp;     * &lt;pre&gt;{@code
<i>528</i>&nbsp;     * Map&lt;Department, Set&lt;Employee&gt;&gt; wellPaidEmployeesByDepartment
<i>529</i>&nbsp;     *   = employees.stream().collect(
<i>530</i>&nbsp;     *     groupingBy(Employee::getDepartment,
<i>531</i>&nbsp;     *                filtering(e -&gt; e.getSalary() &gt; 2000,
<i>532</i>&nbsp;     *                          toSet())));
<i>533</i>&nbsp;     * }&lt;/pre&gt;
<i>534</i>&nbsp;     * A filtering collector differs from a stream&#39;s {@code filter()} operation.
<i>535</i>&nbsp;     * In this example, suppose there are no employees whose salary is above the
<i>536</i>&nbsp;     * threshold in some department.  Using a filtering collector as shown above
<i>537</i>&nbsp;     * would result in a mapping from that department to an empty {@code Set}.
<i>538</i>&nbsp;     * If a stream {@code filter()} operation were done instead, there would be
<b class="nc"><i>539</i>&nbsp;     * no mapping for that department at all.</b>
<b class="nc"><i>540</i>&nbsp;     *</b>
<b class="nc"><i>541</i>&nbsp;     * @param &lt;T&gt; the type of the input elements</b>
<b class="nc"><i>542</i>&nbsp;     * @param &lt;A&gt; intermediate accumulation type of the downstream collector</b>
<b class="nc"><i>543</i>&nbsp;     * @param &lt;R&gt; result type of collector</b>
<b class="nc"><i>544</i>&nbsp;     * @param predicate a predicate to be applied to the input elements</b>
<i>545</i>&nbsp;     * @param downstream a collector which will accept values that match the
<i>546</i>&nbsp;     * predicate
<i>547</i>&nbsp;     * @return a collector which applies the predicate to the input elements
<i>548</i>&nbsp;     * and provides matching elements to the downstream collector
<i>549</i>&nbsp;     * @since 9
<i>550</i>&nbsp;     */
<i>551</i>&nbsp;    public static &lt;T, A, R&gt;
<i>552</i>&nbsp;    Collector&lt;T, ?, R&gt; filtering(Predicate&lt;? super T&gt; predicate,
<i>553</i>&nbsp;                                 Collector&lt;? super T, A, R&gt; downstream) {
<b class="nc"><i>554</i>&nbsp;        BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator();</b>
<b class="nc"><i>555</i>&nbsp;        return new CollectorImpl&lt;&gt;(downstream.supplier(),</b>
<b class="nc"><i>556</i>&nbsp;                                   (r, t) -&gt; {</b>
<b class="nc"><i>557</i>&nbsp;                                       if (predicate.test(t)) {</b>
<i>558</i>&nbsp;                                           downstreamAccumulator.accept(r, t);
<b class="nc"><i>559</i>&nbsp;                                       }</b>
<i>560</i>&nbsp;                                   },
<i>561</i>&nbsp;                                   downstream.combiner(), downstream.finisher(),
<i>562</i>&nbsp;                                   downstream.characteristics());
<i>563</i>&nbsp;    }
<i>564</i>&nbsp;
<i>565</i>&nbsp;    /**
<i>566</i>&nbsp;     * Adapts a {@code Collector} to perform an additional finishing
<i>567</i>&nbsp;     * transformation.  For example, one could adapt the {@link #toList()}
<i>568</i>&nbsp;     * collector to always produce an immutable list with:
<i>569</i>&nbsp;     * &lt;pre&gt;{@code
<i>570</i>&nbsp;     * List&lt;String&gt; list = people.stream().collect(
<i>571</i>&nbsp;     *   collectingAndThen(toList(),
<i>572</i>&nbsp;     *                     Collections::unmodifiableList));
<b class="nc"><i>573</i>&nbsp;     * }&lt;/pre&gt;</b>
<b class="nc"><i>574</i>&nbsp;     *</b>
<b class="nc"><i>575</i>&nbsp;     * @param &lt;T&gt; the type of the input elements</b>
<b class="nc"><i>576</i>&nbsp;     * @param &lt;A&gt; intermediate accumulation type of the downstream collector</b>
<b class="nc"><i>577</i>&nbsp;     * @param &lt;R&gt; result type of the downstream collector</b>
<i>578</i>&nbsp;     * @param &lt;RR&gt; result type of the resulting collector
<i>579</i>&nbsp;     * @param downstream a collector
<i>580</i>&nbsp;     * @param finisher a function to be applied to the final result of the downstream collector
<i>581</i>&nbsp;     * @return a collector which performs the action of the downstream collector,
<i>582</i>&nbsp;     * followed by an additional finishing step
<i>583</i>&nbsp;     */
<i>584</i>&nbsp;    public static&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt; downstream,
<i>585</i>&nbsp;                                                                Function&lt;R,RR&gt; finisher) {
<i>586</i>&nbsp;        Set&lt;Collector.Characteristics&gt; characteristics = downstream.characteristics();
<i>587</i>&nbsp;        if (characteristics.contains(Collector.Characteristics.IDENTITY_FINISH)) {
<i>588</i>&nbsp;            if (characteristics.size() == 1)
<i>589</i>&nbsp;                characteristics = Collectors.CH_NOID;
<i>590</i>&nbsp;            else {
<b class="nc"><i>591</i>&nbsp;                characteristics = EnumSet.copyOf(characteristics);</b>
<b class="nc"><i>592</i>&nbsp;                characteristics.remove(Collector.Characteristics.IDENTITY_FINISH);</b>
<b class="nc"><i>593</i>&nbsp;                characteristics = Collections.unmodifiableSet(characteristics);</b>
<b class="nc"><i>594</i>&nbsp;            }</b>
<b class="nc"><i>595</i>&nbsp;        }</b>
<i>596</i>&nbsp;        return new CollectorImpl&lt;&gt;(downstream.supplier(),
<i>597</i>&nbsp;                                   downstream.accumulator(),
<i>598</i>&nbsp;                                   downstream.combiner(),
<i>599</i>&nbsp;                                   downstream.finisher().andThen(finisher),
<i>600</i>&nbsp;                                   characteristics);
<i>601</i>&nbsp;    }
<i>602</i>&nbsp;
<i>603</i>&nbsp;    /**
<i>604</i>&nbsp;     * Returns a {@code Collector} accepting elements of type {@code T} that
<i>605</i>&nbsp;     * counts the number of input elements.  If no elements are present, the
<i>606</i>&nbsp;     * result is 0.
<i>607</i>&nbsp;     *
<i>608</i>&nbsp;     * @implSpec
<i>609</i>&nbsp;     * This produces a result equivalent to:
<i>610</i>&nbsp;     * &lt;pre&gt;{@code
<i>611</i>&nbsp;     *     reducing(0L, e -&gt; 1L, Long::sum)
<i>612</i>&nbsp;     * }&lt;/pre&gt;
<i>613</i>&nbsp;     *
<i>614</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>615</i>&nbsp;     * @return a {@code Collector} that counts the input elements
<i>616</i>&nbsp;     */
<i>617</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Long&gt;
<i>618</i>&nbsp;    counting() {
<i>619</i>&nbsp;        return summingLong(e -&gt; 1L);
<i>620</i>&nbsp;    }
<i>621</i>&nbsp;
<i>622</i>&nbsp;    /**
<i>623</i>&nbsp;     * Returns a {@code Collector} that produces the minimal element according
<i>624</i>&nbsp;     * to a given {@code Comparator}, described as an {@code Optional&lt;T&gt;}.
<i>625</i>&nbsp;     *
<i>626</i>&nbsp;     * @implSpec
<i>627</i>&nbsp;     * This produces a result equivalent to:
<b class="nc"><i>628</i>&nbsp;     * &lt;pre&gt;{@code</b>
<b class="nc"><i>629</i>&nbsp;     *     reducing(BinaryOperator.minBy(comparator))</b>
<b class="nc"><i>630</i>&nbsp;     * }&lt;/pre&gt;</b>
<b class="nc"><i>631</i>&nbsp;     *</b>
<b class="nc"><i>632</i>&nbsp;     * @param &lt;T&gt; the type of the input elements</b>
<i>633</i>&nbsp;     * @param comparator a {@code Comparator} for comparing elements
<i>634</i>&nbsp;     * @return a {@code Collector} that produces the minimal value
<i>635</i>&nbsp;     */
<i>636</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;
<i>637</i>&nbsp;    minBy(Comparator&lt;? super T&gt; comparator) {
<i>638</i>&nbsp;        return reducing(BinaryOperator.minBy(comparator));
<i>639</i>&nbsp;    }
<i>640</i>&nbsp;
<i>641</i>&nbsp;    /**
<i>642</i>&nbsp;     * Returns a {@code Collector} that produces the maximal element according
<i>643</i>&nbsp;     * to a given {@code Comparator}, described as an {@code Optional&lt;T&gt;}.
<i>644</i>&nbsp;     *
<i>645</i>&nbsp;     * @implSpec
<i>646</i>&nbsp;     * This produces a result equivalent to:
<i>647</i>&nbsp;     * &lt;pre&gt;{@code
<i>648</i>&nbsp;     *     reducing(BinaryOperator.maxBy(comparator))
<i>649</i>&nbsp;     * }&lt;/pre&gt;
<i>650</i>&nbsp;     *
<i>651</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>652</i>&nbsp;     * @param comparator a {@code Comparator} for comparing elements
<i>653</i>&nbsp;     * @return a {@code Collector} that produces the maximal value
<i>654</i>&nbsp;     */
<i>655</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;
<i>656</i>&nbsp;    maxBy(Comparator&lt;? super T&gt; comparator) {
<i>657</i>&nbsp;        return reducing(BinaryOperator.maxBy(comparator));
<b class="nc"><i>658</i>&nbsp;    }</b>
<b class="nc"><i>659</i>&nbsp;</b>
<b class="nc"><i>660</i>&nbsp;    /**</b>
<b class="nc"><i>661</i>&nbsp;     * Returns a {@code Collector} that produces the sum of a integer-valued</b>
<b class="nc"><i>662</i>&nbsp;     * function applied to the input elements.  If no elements are present,</b>
<i>663</i>&nbsp;     * the result is 0.
<i>664</i>&nbsp;     *
<i>665</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>666</i>&nbsp;     * @param mapper a function extracting the property to be summed
<i>667</i>&nbsp;     * @return a {@code Collector} that produces the sum of a derived property
<b class="nc"><i>668</i>&nbsp;     */</b>
<i>669</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Integer&gt;
<i>670</i>&nbsp;    summingInt(ToIntFunction&lt;? super T&gt; mapper) {
<i>671</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>672</i>&nbsp;                () -&gt; new int[1],
<i>673</i>&nbsp;                (a, t) -&gt; { a[0] += mapper.applyAsInt(t); },
<i>674</i>&nbsp;                (a, b) -&gt; { a[0] += b[0]; return a; },
<i>675</i>&nbsp;                a -&gt; a[0], CH_NOID);
<i>676</i>&nbsp;    }
<i>677</i>&nbsp;
<i>678</i>&nbsp;    /**
<i>679</i>&nbsp;     * Returns a {@code Collector} that produces the sum of a long-valued
<i>680</i>&nbsp;     * function applied to the input elements.  If no elements are present,
<i>681</i>&nbsp;     * the result is 0.
<i>682</i>&nbsp;     *
<i>683</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>684</i>&nbsp;     * @param mapper a function extracting the property to be summed
<i>685</i>&nbsp;     * @return a {@code Collector} that produces the sum of a derived property
<i>686</i>&nbsp;     */
<i>687</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Long&gt;
<i>688</i>&nbsp;    summingLong(ToLongFunction&lt;? super T&gt; mapper) {
<i>689</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>690</i>&nbsp;                () -&gt; new long[1],
<i>691</i>&nbsp;                (a, t) -&gt; { a[0] += mapper.applyAsLong(t); },
<i>692</i>&nbsp;                (a, b) -&gt; { a[0] += b[0]; return a; },
<i>693</i>&nbsp;                a -&gt; a[0], CH_NOID);
<i>694</i>&nbsp;    }
<i>695</i>&nbsp;
<i>696</i>&nbsp;    /**
<i>697</i>&nbsp;     * Returns a {@code Collector} that produces the sum of a double-valued
<i>698</i>&nbsp;     * function applied to the input elements.  If no elements are present,
<b class="nc"><i>699</i>&nbsp;     * the result is 0.</b>
<b class="nc"><i>700</i>&nbsp;     *</b>
<b class="nc"><i>701</i>&nbsp;     * &lt;p&gt;The sum returned can vary depending upon the order in which</b>
<i>702</i>&nbsp;     * values are recorded, due to accumulated rounding error in
<i>703</i>&nbsp;     * addition of values of differing magnitudes. Values sorted by increasing
<i>704</i>&nbsp;     * absolute magnitude tend to yield more accurate results.  If any recorded
<b class="nc"><i>705</i>&nbsp;     * value is a {@code NaN} or the sum is at any point a {@code NaN} then the</b>
<b class="nc"><i>706</i>&nbsp;     * sum will be {@code NaN}.</b>
<i>707</i>&nbsp;     *
<i>708</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<b class="nc"><i>709</i>&nbsp;     * @param mapper a function extracting the property to be summed</b>
<b class="nc"><i>710</i>&nbsp;     * @return a {@code Collector} that produces the sum of a derived property</b>
<i>711</i>&nbsp;     */
<i>712</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Double&gt;
<i>713</i>&nbsp;    summingDouble(ToDoubleFunction&lt;? super T&gt; mapper) {
<i>714</i>&nbsp;        /*
<b class="nc"><i>715</i>&nbsp;         * In the arrays allocated for the collect operation, index 0</b>
<b class="nc"><i>716</i>&nbsp;         * holds the high-order bits of the running sum, index 1 holds</b>
<b class="nc"><i>717</i>&nbsp;         * the low-order bits of the sum computed via compensated</b>
<b class="nc"><i>718</i>&nbsp;         * summation, and index 2 holds the simple sum used to compute</b>
<i>719</i>&nbsp;         * the proper result if the stream contains infinite values of
<i>720</i>&nbsp;         * the same sign.
<i>721</i>&nbsp;         */
<i>722</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>723</i>&nbsp;                () -&gt; new double[3],
<i>724</i>&nbsp;                (a, t) -&gt; { double val = mapper.applyAsDouble(t);
<i>725</i>&nbsp;                            sumWithCompensation(a, val);
<i>726</i>&nbsp;                            a[2] += val;},
<i>727</i>&nbsp;                (a, b) -&gt; { sumWithCompensation(a, b[0]);
<i>728</i>&nbsp;                            a[2] += b[2];
<i>729</i>&nbsp;                            return sumWithCompensation(a, b[1]); },
<i>730</i>&nbsp;                a -&gt; computeFinalSum(a),
<i>731</i>&nbsp;                CH_NOID);
<i>732</i>&nbsp;    }
<i>733</i>&nbsp;
<i>734</i>&nbsp;    /**
<i>735</i>&nbsp;     * Incorporate a new double value using Kahan summation /
<i>736</i>&nbsp;     * compensation summation.
<i>737</i>&nbsp;     *
<i>738</i>&nbsp;     * High-order bits of the sum are in intermediateSum[0], low-order
<i>739</i>&nbsp;     * bits of the sum are in intermediateSum[1], any additional
<i>740</i>&nbsp;     * elements are application-specific.
<i>741</i>&nbsp;     *
<i>742</i>&nbsp;     * @param intermediateSum the high-order and low-order words of the intermediate sum
<i>743</i>&nbsp;     * @param value the name value to be included in the running sum
<i>744</i>&nbsp;     */
<i>745</i>&nbsp;    static double[] sumWithCompensation(double[] intermediateSum, double value) {
<i>746</i>&nbsp;        double tmp = value - intermediateSum[1];
<i>747</i>&nbsp;        double sum = intermediateSum[0];
<i>748</i>&nbsp;        double velvel = sum + tmp; // Little wolf of rounding error
<i>749</i>&nbsp;        intermediateSum[1] = (velvel - sum) - tmp;
<i>750</i>&nbsp;        intermediateSum[0] = velvel;
<i>751</i>&nbsp;        return intermediateSum;
<i>752</i>&nbsp;    }
<i>753</i>&nbsp;
<i>754</i>&nbsp;    /**
<i>755</i>&nbsp;     * If the compensated sum is spuriously NaN from accumulating one
<i>756</i>&nbsp;     * or more same-signed infinite values, return the
<i>757</i>&nbsp;     * correctly-signed infinity stored in the simple sum.
<i>758</i>&nbsp;     */
<b class="nc"><i>759</i>&nbsp;    static double computeFinalSum(double[] summands) {</b>
<b class="nc"><i>760</i>&nbsp;        // Better error bounds to add both terms as the final sum</b>
<b class="nc"><i>761</i>&nbsp;        double tmp = summands[0] + summands[1];</b>
<b class="nc"><i>762</i>&nbsp;        double simpleSum = summands[summands.length - 1];</b>
<b class="nc"><i>763</i>&nbsp;        if (Double.isNaN(tmp) &amp;&amp; Double.isInfinite(simpleSum))</b>
<i>764</i>&nbsp;            return simpleSum;
<i>765</i>&nbsp;        else
<i>766</i>&nbsp;            return tmp;
<i>767</i>&nbsp;    }
<i>768</i>&nbsp;
<i>769</i>&nbsp;    /**
<i>770</i>&nbsp;     * Returns a {@code Collector} that produces the arithmetic mean of an integer-valued
<i>771</i>&nbsp;     * function applied to the input elements.  If no elements are present,
<i>772</i>&nbsp;     * the result is 0.
<i>773</i>&nbsp;     *
<i>774</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>775</i>&nbsp;     * @param mapper a function extracting the property to be averaged
<i>776</i>&nbsp;     * @return a {@code Collector} that produces the arithmetic mean of a
<i>777</i>&nbsp;     * derived property
<i>778</i>&nbsp;     */
<i>779</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Double&gt;
<i>780</i>&nbsp;    averagingInt(ToIntFunction&lt;? super T&gt; mapper) {
<i>781</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>782</i>&nbsp;                () -&gt; new long[2],
<i>783</i>&nbsp;                (a, t) -&gt; { a[0] += mapper.applyAsInt(t); a[1]++; },
<i>784</i>&nbsp;                (a, b) -&gt; { a[0] += b[0]; a[1] += b[1]; return a; },
<i>785</i>&nbsp;                a -&gt; (a[1] == 0) ? 0.0d : (double) a[0] / a[1], CH_NOID);
<i>786</i>&nbsp;    }
<i>787</i>&nbsp;
<i>788</i>&nbsp;    /**
<i>789</i>&nbsp;     * Returns a {@code Collector} that produces the arithmetic mean of a long-valued
<i>790</i>&nbsp;     * function applied to the input elements.  If no elements are present,
<i>791</i>&nbsp;     * the result is 0.
<i>792</i>&nbsp;     *
<i>793</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>794</i>&nbsp;     * @param mapper a function extracting the property to be averaged
<i>795</i>&nbsp;     * @return a {@code Collector} that produces the arithmetic mean of a
<i>796</i>&nbsp;     * derived property
<i>797</i>&nbsp;     */
<i>798</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Double&gt;
<i>799</i>&nbsp;    averagingLong(ToLongFunction&lt;? super T&gt; mapper) {
<i>800</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>801</i>&nbsp;                () -&gt; new long[2],
<i>802</i>&nbsp;                (a, t) -&gt; { a[0] += mapper.applyAsLong(t); a[1]++; },
<i>803</i>&nbsp;                (a, b) -&gt; { a[0] += b[0]; a[1] += b[1]; return a; },
<i>804</i>&nbsp;                a -&gt; (a[1] == 0) ? 0.0d : (double) a[0] / a[1], CH_NOID);
<b class="nc"><i>805</i>&nbsp;    }</b>
<i>806</i>&nbsp;
<i>807</i>&nbsp;    /**
<i>808</i>&nbsp;     * Returns a {@code Collector} that produces the arithmetic mean of a double-valued
<i>809</i>&nbsp;     * function applied to the input elements.  If no elements are present,
<i>810</i>&nbsp;     * the result is 0.
<i>811</i>&nbsp;     *
<i>812</i>&nbsp;     * &lt;p&gt;The average returned can vary depending upon the order in which
<i>813</i>&nbsp;     * values are recorded, due to accumulated rounding error in
<i>814</i>&nbsp;     * addition of values of differing magnitudes. Values sorted by increasing
<i>815</i>&nbsp;     * absolute magnitude tend to yield more accurate results.  If any recorded
<i>816</i>&nbsp;     * value is a {@code NaN} or the sum is at any point a {@code NaN} then the
<i>817</i>&nbsp;     * average will be {@code NaN}.
<i>818</i>&nbsp;     *
<i>819</i>&nbsp;     * @implNote The {@code double} format can represent all
<i>820</i>&nbsp;     * consecutive integers in the range -2&lt;sup&gt;53&lt;/sup&gt; to
<i>821</i>&nbsp;     * 2&lt;sup&gt;53&lt;/sup&gt;. If the pipeline has more than 2&lt;sup&gt;53&lt;/sup&gt;
<i>822</i>&nbsp;     * values, the divisor in the average computation will saturate at
<i>823</i>&nbsp;     * 2&lt;sup&gt;53&lt;/sup&gt;, leading to additional numerical errors.
<i>824</i>&nbsp;     *
<i>825</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>826</i>&nbsp;     * @param mapper a function extracting the property to be averaged
<i>827</i>&nbsp;     * @return a {@code Collector} that produces the arithmetic mean of a
<i>828</i>&nbsp;     * derived property
<i>829</i>&nbsp;     */
<i>830</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Double&gt;
<i>831</i>&nbsp;    averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper) {
<i>832</i>&nbsp;        /*
<i>833</i>&nbsp;         * In the arrays allocated for the collect operation, index 0
<i>834</i>&nbsp;         * holds the high-order bits of the running sum, index 1 holds
<i>835</i>&nbsp;         * the low-order bits of the sum computed via compensated
<i>836</i>&nbsp;         * summation, and index 2 holds the number of values seen.
<i>837</i>&nbsp;         */
<i>838</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>839</i>&nbsp;                () -&gt; new double[4],
<i>840</i>&nbsp;                (a, t) -&gt; { double val = mapper.applyAsDouble(t); sumWithCompensation(a, val); a[2]++; a[3]+= val;},
<i>841</i>&nbsp;                (a, b) -&gt; { sumWithCompensation(a, b[0]); sumWithCompensation(a, b[1]); a[2] += b[2]; a[3] += b[3]; return a; },
<i>842</i>&nbsp;                a -&gt; (a[2] == 0) ? 0.0d : (computeFinalSum(a) / a[2]),
<i>843</i>&nbsp;                CH_NOID);
<i>844</i>&nbsp;    }
<i>845</i>&nbsp;
<i>846</i>&nbsp;    /**
<i>847</i>&nbsp;     * Returns a {@code Collector} which performs a reduction of its
<i>848</i>&nbsp;     * input elements under a specified {@code BinaryOperator} using the
<i>849</i>&nbsp;     * provided identity.
<i>850</i>&nbsp;     *
<i>851</i>&nbsp;     * @apiNote
<i>852</i>&nbsp;     * The {@code reducing()} collectors are most useful when used in a
<b class="nc"><i>853</i>&nbsp;     * multi-level reduction, downstream of {@code groupingBy} or</b>
<i>854</i>&nbsp;     * {@code partitioningBy}.  To perform a simple reduction on a stream,
<i>855</i>&nbsp;     * use {@link Stream#reduce(Object, BinaryOperator)}} instead.
<i>856</i>&nbsp;     *
<i>857</i>&nbsp;     * @param &lt;T&gt; element type for the input and output of the reduction
<i>858</i>&nbsp;     * @param identity the identity value for the reduction (also, the value
<i>859</i>&nbsp;     *                 that is returned when there are no input elements)
<i>860</i>&nbsp;     * @param op a {@code BinaryOperator&lt;T&gt;} used to reduce the input elements
<i>861</i>&nbsp;     * @return a {@code Collector} which implements the reduction operation
<i>862</i>&nbsp;     *
<i>863</i>&nbsp;     * @see #reducing(BinaryOperator)
<i>864</i>&nbsp;     * @see #reducing(Object, Function, BinaryOperator)
<i>865</i>&nbsp;     */
<i>866</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, T&gt;
<i>867</i>&nbsp;    reducing(T identity, BinaryOperator&lt;T&gt; op) {
<i>868</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>869</i>&nbsp;                boxSupplier(identity),
<i>870</i>&nbsp;                (a, t) -&gt; { a[0] = op.apply(a[0], t); },
<i>871</i>&nbsp;                (a, b) -&gt; { a[0] = op.apply(a[0], b[0]); return a; },
<i>872</i>&nbsp;                a -&gt; a[0],
<i>873</i>&nbsp;                CH_NOID);
<i>874</i>&nbsp;    }
<i>875</i>&nbsp;
<i>876</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>877</i>&nbsp;    private static &lt;T&gt; Supplier&lt;T[]&gt; boxSupplier(T identity) {
<i>878</i>&nbsp;        return () -&gt; (T[]) new Object[] { identity };
<i>879</i>&nbsp;    }
<i>880</i>&nbsp;
<i>881</i>&nbsp;    /**
<i>882</i>&nbsp;     * Returns a {@code Collector} which performs a reduction of its
<i>883</i>&nbsp;     * input elements under a specified {@code BinaryOperator}.  The result
<i>884</i>&nbsp;     * is described as an {@code Optional&lt;T&gt;}.
<i>885</i>&nbsp;     *
<i>886</i>&nbsp;     * @apiNote
<i>887</i>&nbsp;     * The {@code reducing()} collectors are most useful when used in a
<i>888</i>&nbsp;     * multi-level reduction, downstream of {@code groupingBy} or
<i>889</i>&nbsp;     * {@code partitioningBy}.  To perform a simple reduction on a stream,
<i>890</i>&nbsp;     * use {@link Stream#reduce(BinaryOperator)} instead.
<i>891</i>&nbsp;     *
<i>892</i>&nbsp;     * &lt;p&gt;For example, given a stream of {@code Person}, to calculate tallest
<i>893</i>&nbsp;     * person in each city:
<i>894</i>&nbsp;     * &lt;pre&gt;{@code
<i>895</i>&nbsp;     * Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight);
<i>896</i>&nbsp;     * Map&lt;City, Optional&lt;Person&gt;&gt; tallestByCity
<i>897</i>&nbsp;     *   = people.stream().collect(
<i>898</i>&nbsp;     *     groupingBy(Person::getCity,
<i>899</i>&nbsp;     *                reducing(BinaryOperator.maxBy(byHeight))));
<i>900</i>&nbsp;     * }&lt;/pre&gt;
<i>901</i>&nbsp;     *
<i>902</i>&nbsp;     * @param &lt;T&gt; element type for the input and output of the reduction
<i>903</i>&nbsp;     * @param op a {@code BinaryOperator&lt;T&gt;} used to reduce the input elements
<b class="nc"><i>904</i>&nbsp;     * @return a {@code Collector} which implements the reduction operation</b>
<b class="nc"><i>905</i>&nbsp;     *</b>
<b class="nc"><i>906</i>&nbsp;     * @see #reducing(Object, BinaryOperator)</b>
<b class="nc"><i>907</i>&nbsp;     * @see #reducing(Object, Function, BinaryOperator)</b>
<b class="nc"><i>908</i>&nbsp;     */</b>
<b class="nc"><i>909</i>&nbsp;    public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</b>
<i>910</i>&nbsp;    reducing(BinaryOperator&lt;T&gt; op) {
<b class="nc"><i>911</i>&nbsp;        class OptionalBox implements Consumer&lt;T&gt; {</b>
<i>912</i>&nbsp;            T value = null;
<b class="nc"><i>913</i>&nbsp;            boolean present = false;</b>
<i>914</i>&nbsp;
<b class="nc"><i>915</i>&nbsp;            @Override</b>
<b class="nc"><i>916</i>&nbsp;            public void accept(T t) {</b>
<i>917</i>&nbsp;                if (present) {
<i>918</i>&nbsp;                    value = op.apply(value, t);
<i>919</i>&nbsp;                }
<b class="nc"><i>920</i>&nbsp;                else {</b>
<b class="nc"><i>921</i>&nbsp;                    value = t;</b>
<b class="nc"><i>922</i>&nbsp;                    present = true;</b>
<i>923</i>&nbsp;                }
<b class="nc"><i>924</i>&nbsp;            }</b>
<b class="nc"><i>925</i>&nbsp;        }</b>
<i>926</i>&nbsp;
<b class="nc"><i>927</i>&nbsp;        return new CollectorImpl&lt;T, OptionalBox, Optional&lt;T&gt;&gt;(</b>
<i>928</i>&nbsp;                OptionalBox::new, OptionalBox::accept,
<i>929</i>&nbsp;                (a, b) -&gt; { if (b.present) a.accept(b.value); return a; },
<i>930</i>&nbsp;                a -&gt; Optional.ofNullable(a.value), CH_NOID);
<i>931</i>&nbsp;    }
<i>932</i>&nbsp;
<i>933</i>&nbsp;    /**
<i>934</i>&nbsp;     * Returns a {@code Collector} which performs a reduction of its
<i>935</i>&nbsp;     * input elements under a specified mapping function and
<i>936</i>&nbsp;     * {@code BinaryOperator}. This is a generalization of
<i>937</i>&nbsp;     * {@link #reducing(Object, BinaryOperator)} which allows a transformation
<i>938</i>&nbsp;     * of the elements before reduction.
<i>939</i>&nbsp;     *
<i>940</i>&nbsp;     * @apiNote
<i>941</i>&nbsp;     * The {@code reducing()} collectors are most useful when used in a
<i>942</i>&nbsp;     * multi-level reduction, downstream of {@code groupingBy} or
<i>943</i>&nbsp;     * {@code partitioningBy}.  To perform a simple map-reduce on a stream,
<i>944</i>&nbsp;     * use {@link Stream#map(Function)} and {@link Stream#reduce(Object, BinaryOperator)}
<i>945</i>&nbsp;     * instead.
<i>946</i>&nbsp;     *
<i>947</i>&nbsp;     * &lt;p&gt;For example, given a stream of {@code Person}, to calculate the longest
<i>948</i>&nbsp;     * last name of residents in each city:
<i>949</i>&nbsp;     * &lt;pre&gt;{@code
<i>950</i>&nbsp;     * Comparator&lt;String&gt; byLength = Comparator.comparing(String::length);
<i>951</i>&nbsp;     * Map&lt;City, String&gt; longestLastNameByCity
<i>952</i>&nbsp;     *   = people.stream().collect(
<i>953</i>&nbsp;     *     groupingBy(Person::getCity,
<i>954</i>&nbsp;     *                reducing(&quot;&quot;,
<i>955</i>&nbsp;     *                         Person::getLastName,
<i>956</i>&nbsp;     *                         BinaryOperator.maxBy(byLength))));
<i>957</i>&nbsp;     * }&lt;/pre&gt;
<i>958</i>&nbsp;     *
<i>959</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>960</i>&nbsp;     * @param &lt;U&gt; the type of the mapped values
<i>961</i>&nbsp;     * @param identity the identity value for the reduction (also, the value
<i>962</i>&nbsp;     *                 that is returned when there are no input elements)
<i>963</i>&nbsp;     * @param mapper a mapping function to apply to each input value
<i>964</i>&nbsp;     * @param op a {@code BinaryOperator&lt;U&gt;} used to reduce the mapped values
<i>965</i>&nbsp;     * @return a {@code Collector} implementing the map-reduce operation
<i>966</i>&nbsp;     *
<b class="nc"><i>967</i>&nbsp;     * @see #reducing(Object, BinaryOperator)</b>
<i>968</i>&nbsp;     * @see #reducing(BinaryOperator)
<i>969</i>&nbsp;     */
<i>970</i>&nbsp;    public static &lt;T, U&gt;
<i>971</i>&nbsp;    Collector&lt;T, ?, U&gt; reducing(U identity,
<i>972</i>&nbsp;                                Function&lt;? super T, ? extends U&gt; mapper,
<i>973</i>&nbsp;                                BinaryOperator&lt;U&gt; op) {
<i>974</i>&nbsp;        return new CollectorImpl&lt;&gt;(
<i>975</i>&nbsp;                boxSupplier(identity),
<i>976</i>&nbsp;                (a, t) -&gt; { a[0] = op.apply(a[0], mapper.apply(t)); },
<i>977</i>&nbsp;                (a, b) -&gt; { a[0] = op.apply(a[0], b[0]); return a; },
<i>978</i>&nbsp;                a -&gt; a[0], CH_NOID);
<i>979</i>&nbsp;    }
<i>980</i>&nbsp;
<i>981</i>&nbsp;    /**
<i>982</i>&nbsp;     * Returns a {@code Collector} implementing a &quot;group by&quot; operation on
<i>983</i>&nbsp;     * input elements of type {@code T}, grouping elements according to a
<i>984</i>&nbsp;     * classification function, and returning the results in a {@code Map}.
<i>985</i>&nbsp;     *
<i>986</i>&nbsp;     * &lt;p&gt;The classification function maps elements to some key type {@code K}.
<i>987</i>&nbsp;     * The collector produces a {@code Map&lt;K, List&lt;T&gt;&gt;} whose keys are the
<i>988</i>&nbsp;     * values resulting from applying the classification function to the input
<i>989</i>&nbsp;     * elements, and whose corresponding values are {@code List}s containing the
<i>990</i>&nbsp;     * input elements which map to the associated key under the classification
<i>991</i>&nbsp;     * function.
<i>992</i>&nbsp;     *
<i>993</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability, serializability, or
<i>994</i>&nbsp;     * thread-safety of the {@code Map} or {@code List} objects returned.
<i>995</i>&nbsp;     * @implSpec
<i>996</i>&nbsp;     * This produces a result similar to:
<i>997</i>&nbsp;     * &lt;pre&gt;{@code
<i>998</i>&nbsp;     *     groupingBy(classifier, toList());
<i>999</i>&nbsp;     * }&lt;/pre&gt;
<i>1000</i>&nbsp;     *
<i>1001</i>&nbsp;     * @implNote
<i>1002</i>&nbsp;     * The returned {@code Collector} is not concurrent.  For parallel stream
<i>1003</i>&nbsp;     * pipelines, the {@code combiner} function operates by merging the keys
<i>1004</i>&nbsp;     * from one map into another, which can be an expensive operation.  If
<i>1005</i>&nbsp;     * preservation of the order in which elements appear in the resulting {@code Map}
<i>1006</i>&nbsp;     * collector is not required, using {@link #groupingByConcurrent(Function)}
<i>1007</i>&nbsp;     * may offer better parallel performance.
<b class="nc"><i>1008</i>&nbsp;     *</b>
<i>1009</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1010</i>&nbsp;     * @param &lt;K&gt; the type of the keys
<i>1011</i>&nbsp;     * @param classifier the classifier function mapping input elements to keys
<i>1012</i>&nbsp;     * @return a {@code Collector} implementing the group-by operation
<i>1013</i>&nbsp;     *
<i>1014</i>&nbsp;     * @see #groupingBy(Function, Collector)
<i>1015</i>&nbsp;     * @see #groupingBy(Function, Supplier, Collector)
<i>1016</i>&nbsp;     * @see #groupingByConcurrent(Function)
<i>1017</i>&nbsp;     */
<i>1018</i>&nbsp;    public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;
<i>1019</i>&nbsp;    groupingBy(Function&lt;? super T, ? extends K&gt; classifier) {
<i>1020</i>&nbsp;        return groupingBy(classifier, toList());
<i>1021</i>&nbsp;    }
<i>1022</i>&nbsp;
<i>1023</i>&nbsp;    /**
<i>1024</i>&nbsp;     * Returns a {@code Collector} implementing a cascaded &quot;group by&quot; operation
<i>1025</i>&nbsp;     * on input elements of type {@code T}, grouping elements according to a
<i>1026</i>&nbsp;     * classification function, and then performing a reduction operation on
<i>1027</i>&nbsp;     * the values associated with a given key using the specified downstream
<i>1028</i>&nbsp;     * {@code Collector}.
<i>1029</i>&nbsp;     *
<i>1030</i>&nbsp;     * &lt;p&gt;The classification function maps elements to some key type {@code K}.
<i>1031</i>&nbsp;     * The downstream collector operates on elements of type {@code T} and
<i>1032</i>&nbsp;     * produces a result of type {@code D}. The resulting collector produces a
<i>1033</i>&nbsp;     * {@code Map&lt;K, D&gt;}.
<i>1034</i>&nbsp;     *
<i>1035</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability,
<i>1036</i>&nbsp;     * serializability, or thread-safety of the {@code Map} returned.
<i>1037</i>&nbsp;     *
<i>1038</i>&nbsp;     * &lt;p&gt;For example, to compute the set of last names of people in each city:
<i>1039</i>&nbsp;     * &lt;pre&gt;{@code
<i>1040</i>&nbsp;     * Map&lt;City, Set&lt;String&gt;&gt; namesByCity
<i>1041</i>&nbsp;     *   = people.stream().collect(
<i>1042</i>&nbsp;     *     groupingBy(Person::getCity,
<i>1043</i>&nbsp;     *                mapping(Person::getLastName,
<i>1044</i>&nbsp;     *                        toSet())));
<i>1045</i>&nbsp;     * }&lt;/pre&gt;
<i>1046</i>&nbsp;     *
<i>1047</i>&nbsp;     * @implNote
<i>1048</i>&nbsp;     * The returned {@code Collector} is not concurrent.  For parallel stream
<i>1049</i>&nbsp;     * pipelines, the {@code combiner} function operates by merging the keys
<i>1050</i>&nbsp;     * from one map into another, which can be an expensive operation.  If
<i>1051</i>&nbsp;     * preservation of the order in which elements are presented to the downstream
<i>1052</i>&nbsp;     * collector is not required, using {@link #groupingByConcurrent(Function, Collector)}
<i>1053</i>&nbsp;     * may offer better parallel performance.
<i>1054</i>&nbsp;     *
<b class="nc"><i>1055</i>&nbsp;     * @param &lt;T&gt; the type of the input elements</b>
<b class="nc"><i>1056</i>&nbsp;     * @param &lt;K&gt; the type of the keys</b>
<b class="nc"><i>1057</i>&nbsp;     * @param &lt;A&gt; the intermediate accumulation type of the downstream collector</b>
<i>1058</i>&nbsp;     * @param &lt;D&gt; the result type of the downstream reduction
<b class="nc"><i>1059</i>&nbsp;     * @param classifier a classifier function mapping input elements to keys</b>
<i>1060</i>&nbsp;     * @param downstream a {@code Collector} implementing the downstream reduction
<b class="nc"><i>1061</i>&nbsp;     * @return a {@code Collector} implementing the cascaded group-by operation</b>
<b class="nc"><i>1062</i>&nbsp;     * @see #groupingBy(Function)</b>
<b class="nc"><i>1063</i>&nbsp;     *</b>
<b class="nc"><i>1064</i>&nbsp;     * @see #groupingBy(Function, Supplier, Collector)</b>
<b class="nc"><i>1065</i>&nbsp;     * @see #groupingByConcurrent(Function, Collector)</b>
<i>1066</i>&nbsp;     */
<i>1067</i>&nbsp;    public static &lt;T, K, A, D&gt;
<i>1068</i>&nbsp;    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,
<b class="nc"><i>1069</i>&nbsp;                                          Collector&lt;? super T, A, D&gt; downstream) {</b>
<b class="nc"><i>1070</i>&nbsp;        return groupingBy(classifier, HashMap::new, downstream);</b>
<b class="nc"><i>1071</i>&nbsp;    }</b>
<b class="nc"><i>1072</i>&nbsp;</b>
<b class="nc"><i>1073</i>&nbsp;    /**</b>
<b class="nc"><i>1074</i>&nbsp;     * Returns a {@code Collector} implementing a cascaded &quot;group by&quot; operation</b>
<i>1075</i>&nbsp;     * on input elements of type {@code T}, grouping elements according to a
<i>1076</i>&nbsp;     * classification function, and then performing a reduction operation on
<i>1077</i>&nbsp;     * the values associated with a given key using the specified downstream
<b class="nc"><i>1078</i>&nbsp;     * {@code Collector}.  The {@code Map} produced by the Collector is created</b>
<b class="nc"><i>1079</i>&nbsp;     * with the supplied factory function.</b>
<i>1080</i>&nbsp;     *
<i>1081</i>&nbsp;     * &lt;p&gt;The classification function maps elements to some key type {@code K}.
<i>1082</i>&nbsp;     * The downstream collector operates on elements of type {@code T} and
<b class="nc"><i>1083</i>&nbsp;     * produces a result of type {@code D}. The resulting collector produces a</b>
<b class="nc"><i>1084</i>&nbsp;     * {@code Map&lt;K, D&gt;}.</b>
<b class="nc"><i>1085</i>&nbsp;     *</b>
<i>1086</i>&nbsp;     * &lt;p&gt;For example, to compute the set of last names of people in each city,
<b class="nc"><i>1087</i>&nbsp;     * where the city names are sorted:</b>
<b class="nc"><i>1088</i>&nbsp;     * &lt;pre&gt;{@code</b>
<i>1089</i>&nbsp;     * Map&lt;City, Set&lt;String&gt;&gt; namesByCity
<b class="nc"><i>1090</i>&nbsp;     *   = people.stream().collect(</b>
<i>1091</i>&nbsp;     *     groupingBy(Person::getCity,
<i>1092</i>&nbsp;     *                TreeMap::new,
<i>1093</i>&nbsp;     *                mapping(Person::getLastName,
<i>1094</i>&nbsp;     *                        toSet())));
<i>1095</i>&nbsp;     * }&lt;/pre&gt;
<i>1096</i>&nbsp;     *
<i>1097</i>&nbsp;     * @implNote
<i>1098</i>&nbsp;     * The returned {@code Collector} is not concurrent.  For parallel stream
<i>1099</i>&nbsp;     * pipelines, the {@code combiner} function operates by merging the keys
<i>1100</i>&nbsp;     * from one map into another, which can be an expensive operation.  If
<i>1101</i>&nbsp;     * preservation of the order in which elements are presented to the downstream
<i>1102</i>&nbsp;     * collector is not required, using {@link #groupingByConcurrent(Function, Supplier, Collector)}
<i>1103</i>&nbsp;     * may offer better parallel performance.
<i>1104</i>&nbsp;     *
<i>1105</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1106</i>&nbsp;     * @param &lt;K&gt; the type of the keys
<i>1107</i>&nbsp;     * @param &lt;A&gt; the intermediate accumulation type of the downstream collector
<i>1108</i>&nbsp;     * @param &lt;D&gt; the result type of the downstream reduction
<i>1109</i>&nbsp;     * @param &lt;M&gt; the type of the resulting {@code Map}
<b class="nc"><i>1110</i>&nbsp;     * @param classifier a classifier function mapping input elements to keys</b>
<i>1111</i>&nbsp;     * @param downstream a {@code Collector} implementing the downstream reduction
<i>1112</i>&nbsp;     * @param mapFactory a supplier providing a new empty {@code Map}
<i>1113</i>&nbsp;     *                   into which the results will be inserted
<i>1114</i>&nbsp;     * @return a {@code Collector} implementing the cascaded group-by operation
<i>1115</i>&nbsp;     *
<i>1116</i>&nbsp;     * @see #groupingBy(Function, Collector)
<i>1117</i>&nbsp;     * @see #groupingBy(Function)
<i>1118</i>&nbsp;     * @see #groupingByConcurrent(Function, Supplier, Collector)
<i>1119</i>&nbsp;     */
<i>1120</i>&nbsp;    public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;
<i>1121</i>&nbsp;    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,
<i>1122</i>&nbsp;                                  Supplier&lt;M&gt; mapFactory,
<i>1123</i>&nbsp;                                  Collector&lt;? super T, A, D&gt; downstream) {
<i>1124</i>&nbsp;        Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();
<i>1125</i>&nbsp;        BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator();
<i>1126</i>&nbsp;        BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; {
<i>1127</i>&nbsp;            K key = Objects.requireNonNull(classifier.apply(t), &quot;element cannot be mapped to a null key&quot;);
<i>1128</i>&nbsp;            A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());
<i>1129</i>&nbsp;            downstreamAccumulator.accept(container, t);
<i>1130</i>&nbsp;        };
<i>1131</i>&nbsp;        BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());
<i>1132</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<i>1133</i>&nbsp;        Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;
<i>1134</i>&nbsp;
<i>1135</i>&nbsp;        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
<i>1136</i>&nbsp;            return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);
<b class="nc"><i>1137</i>&nbsp;        }</b>
<b class="nc"><i>1138</i>&nbsp;        else {</b>
<b class="nc"><i>1139</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1140</i>&nbsp;            Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</b>
<b class="nc"><i>1141</i>&nbsp;            Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; {</b>
<b class="nc"><i>1142</i>&nbsp;                intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</b>
<b class="nc"><i>1143</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1144</i>&nbsp;                M castResult = (M) intermediate;</b>
<b class="nc"><i>1145</i>&nbsp;                return castResult;</b>
<b class="nc"><i>1146</i>&nbsp;            };</b>
<b class="nc"><i>1147</i>&nbsp;            return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</b>
<b class="nc"><i>1148</i>&nbsp;        }</b>
<i>1149</i>&nbsp;    }
<i>1150</i>&nbsp;
<b class="nc"><i>1151</i>&nbsp;    /**</b>
<b class="nc"><i>1152</i>&nbsp;     * Returns a concurrent {@code Collector} implementing a &quot;group by&quot;</b>
<b class="nc"><i>1153</i>&nbsp;     * operation on input elements of type {@code T}, grouping elements</b>
<b class="nc"><i>1154</i>&nbsp;     * according to a classification function.</b>
<i>1155</i>&nbsp;     *
<i>1156</i>&nbsp;     * &lt;p&gt;This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
<i>1157</i>&nbsp;     * {@link Collector.Characteristics#UNORDERED unordered} Collector.
<i>1158</i>&nbsp;     *
<i>1159</i>&nbsp;     * &lt;p&gt;The classification function maps elements to some key type {@code K}.
<i>1160</i>&nbsp;     * The collector produces a {@code ConcurrentMap&lt;K, List&lt;T&gt;&gt;} whose keys are the
<i>1161</i>&nbsp;     * values resulting from applying the classification function to the input
<i>1162</i>&nbsp;     * elements, and whose corresponding values are {@code List}s containing the
<i>1163</i>&nbsp;     * input elements which map to the associated key under the classification
<i>1164</i>&nbsp;     * function.
<i>1165</i>&nbsp;     *
<i>1166</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability, or serializability
<i>1167</i>&nbsp;     * of the {@code ConcurrentMap} or {@code List} objects returned, or of the
<i>1168</i>&nbsp;     * thread-safety of the {@code List} objects returned.
<i>1169</i>&nbsp;     * @implSpec
<i>1170</i>&nbsp;     * This produces a result similar to:
<i>1171</i>&nbsp;     * &lt;pre&gt;{@code
<i>1172</i>&nbsp;     *     groupingByConcurrent(classifier, toList());
<i>1173</i>&nbsp;     * }&lt;/pre&gt;
<i>1174</i>&nbsp;     *
<i>1175</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1176</i>&nbsp;     * @param &lt;K&gt; the type of the keys
<i>1177</i>&nbsp;     * @param classifier a classifier function mapping input elements to keys
<i>1178</i>&nbsp;     * @return a concurrent, unordered {@code Collector} implementing the group-by operation
<i>1179</i>&nbsp;     *
<i>1180</i>&nbsp;     * @see #groupingBy(Function)
<i>1181</i>&nbsp;     * @see #groupingByConcurrent(Function, Collector)
<i>1182</i>&nbsp;     * @see #groupingByConcurrent(Function, Supplier, Collector)
<i>1183</i>&nbsp;     */
<i>1184</i>&nbsp;    public static &lt;T, K&gt;
<i>1185</i>&nbsp;    Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T&gt;&gt;&gt;
<i>1186</i>&nbsp;    groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier) {
<i>1187</i>&nbsp;        return groupingByConcurrent(classifier, ConcurrentHashMap::new, toList());
<i>1188</i>&nbsp;    }
<i>1189</i>&nbsp;
<i>1190</i>&nbsp;    /**
<i>1191</i>&nbsp;     * Returns a concurrent {@code Collector} implementing a cascaded &quot;group by&quot;
<i>1192</i>&nbsp;     * operation on input elements of type {@code T}, grouping elements
<i>1193</i>&nbsp;     * according to a classification function, and then performing a reduction
<i>1194</i>&nbsp;     * operation on the values associated with a given key using the specified
<i>1195</i>&nbsp;     * downstream {@code Collector}.
<i>1196</i>&nbsp;     *
<i>1197</i>&nbsp;     * &lt;p&gt;This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
<i>1198</i>&nbsp;     * {@link Collector.Characteristics#UNORDERED unordered} Collector.
<i>1199</i>&nbsp;     *
<i>1200</i>&nbsp;     * &lt;p&gt;The classification function maps elements to some key type {@code K}.
<i>1201</i>&nbsp;     * The downstream collector operates on elements of type {@code T} and
<i>1202</i>&nbsp;     * produces a result of type {@code D}. The resulting collector produces a
<i>1203</i>&nbsp;     * {@code ConcurrentMap&lt;K, D&gt;}.
<i>1204</i>&nbsp;     *
<i>1205</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability, or serializability
<i>1206</i>&nbsp;     * of the {@code ConcurrentMap} returned.
<i>1207</i>&nbsp;     *
<i>1208</i>&nbsp;     * &lt;p&gt;For example, to compute the set of last names of people in each city,
<i>1209</i>&nbsp;     * where the city names are sorted:
<i>1210</i>&nbsp;     * &lt;pre&gt;{@code
<i>1211</i>&nbsp;     * ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
<b class="nc"><i>1212</i>&nbsp;     *   = people.stream().collect(</b>
<i>1213</i>&nbsp;     *     groupingByConcurrent(Person::getCity,
<i>1214</i>&nbsp;     *                          mapping(Person::getLastName,
<i>1215</i>&nbsp;     *                                  toSet())));
<i>1216</i>&nbsp;     * }&lt;/pre&gt;
<i>1217</i>&nbsp;     *
<i>1218</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1219</i>&nbsp;     * @param &lt;K&gt; the type of the keys
<i>1220</i>&nbsp;     * @param &lt;A&gt; the intermediate accumulation type of the downstream collector
<i>1221</i>&nbsp;     * @param &lt;D&gt; the result type of the downstream reduction
<i>1222</i>&nbsp;     * @param classifier a classifier function mapping input elements to keys
<i>1223</i>&nbsp;     * @param downstream a {@code Collector} implementing the downstream reduction
<i>1224</i>&nbsp;     * @return a concurrent, unordered {@code Collector} implementing the cascaded group-by operation
<i>1225</i>&nbsp;     *
<i>1226</i>&nbsp;     * @see #groupingBy(Function, Collector)
<i>1227</i>&nbsp;     * @see #groupingByConcurrent(Function)
<i>1228</i>&nbsp;     * @see #groupingByConcurrent(Function, Supplier, Collector)
<i>1229</i>&nbsp;     */
<i>1230</i>&nbsp;    public static &lt;T, K, A, D&gt;
<i>1231</i>&nbsp;    Collector&lt;T, ?, ConcurrentMap&lt;K, D&gt;&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,
<i>1232</i>&nbsp;                                                              Collector&lt;? super T, A, D&gt; downstream) {
<i>1233</i>&nbsp;        return groupingByConcurrent(classifier, ConcurrentHashMap::new, downstream);
<i>1234</i>&nbsp;    }
<i>1235</i>&nbsp;
<i>1236</i>&nbsp;    /**
<i>1237</i>&nbsp;     * Returns a concurrent {@code Collector} implementing a cascaded &quot;group by&quot;
<i>1238</i>&nbsp;     * operation on input elements of type {@code T}, grouping elements
<i>1239</i>&nbsp;     * according to a classification function, and then performing a reduction
<i>1240</i>&nbsp;     * operation on the values associated with a given key using the specified
<i>1241</i>&nbsp;     * downstream {@code Collector}.  The {@code ConcurrentMap} produced by the
<i>1242</i>&nbsp;     * Collector is created with the supplied factory function.
<i>1243</i>&nbsp;     *
<i>1244</i>&nbsp;     * &lt;p&gt;This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
<i>1245</i>&nbsp;     * {@link Collector.Characteristics#UNORDERED unordered} Collector.
<i>1246</i>&nbsp;     *
<i>1247</i>&nbsp;     * &lt;p&gt;The classification function maps elements to some key type {@code K}.
<i>1248</i>&nbsp;     * The downstream collector operates on elements of type {@code T} and
<i>1249</i>&nbsp;     * produces a result of type {@code D}. The resulting collector produces a
<i>1250</i>&nbsp;     * {@code ConcurrentMap&lt;K, D&gt;}.
<i>1251</i>&nbsp;     *
<i>1252</i>&nbsp;     * &lt;p&gt;For example, to compute the set of last names of people in each city,
<i>1253</i>&nbsp;     * where the city names are sorted:
<i>1254</i>&nbsp;     * &lt;pre&gt;{@code
<i>1255</i>&nbsp;     * ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
<i>1256</i>&nbsp;     *   = people.stream().collect(
<i>1257</i>&nbsp;     *     groupingByConcurrent(Person::getCity,
<i>1258</i>&nbsp;     *                          ConcurrentSkipListMap::new,
<i>1259</i>&nbsp;     *                          mapping(Person::getLastName,
<i>1260</i>&nbsp;     *                                  toSet())));
<i>1261</i>&nbsp;     * }&lt;/pre&gt;
<i>1262</i>&nbsp;     *
<i>1263</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1264</i>&nbsp;     * @param &lt;K&gt; the type of the keys
<i>1265</i>&nbsp;     * @param &lt;A&gt; the intermediate accumulation type of the downstream collector
<i>1266</i>&nbsp;     * @param &lt;D&gt; the result type of the downstream reduction
<i>1267</i>&nbsp;     * @param &lt;M&gt; the type of the resulting {@code ConcurrentMap}
<i>1268</i>&nbsp;     * @param classifier a classifier function mapping input elements to keys
<i>1269</i>&nbsp;     * @param downstream a {@code Collector} implementing the downstream reduction
<i>1270</i>&nbsp;     * @param mapFactory a supplier providing a new empty {@code ConcurrentMap}
<b class="nc"><i>1271</i>&nbsp;     *                   into which the results will be inserted</b>
<i>1272</i>&nbsp;     * @return a concurrent, unordered {@code Collector} implementing the cascaded group-by operation
<i>1273</i>&nbsp;     *
<i>1274</i>&nbsp;     * @see #groupingByConcurrent(Function)
<i>1275</i>&nbsp;     * @see #groupingByConcurrent(Function, Collector)
<i>1276</i>&nbsp;     * @see #groupingBy(Function, Supplier, Collector)
<i>1277</i>&nbsp;     */
<i>1278</i>&nbsp;    public static &lt;T, K, A, D, M extends ConcurrentMap&lt;K, D&gt;&gt;
<i>1279</i>&nbsp;    Collector&lt;T, ?, M&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,
<i>1280</i>&nbsp;                                            Supplier&lt;M&gt; mapFactory,
<i>1281</i>&nbsp;                                            Collector&lt;? super T, A, D&gt; downstream) {
<i>1282</i>&nbsp;        Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();
<i>1283</i>&nbsp;        BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator();
<i>1284</i>&nbsp;        BinaryOperator&lt;ConcurrentMap&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, ConcurrentMap&lt;K, A&gt;&gt;mapMerger(downstream.combiner());
<i>1285</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<i>1286</i>&nbsp;        Supplier&lt;ConcurrentMap&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;ConcurrentMap&lt;K, A&gt;&gt;) mapFactory;
<i>1287</i>&nbsp;        BiConsumer&lt;ConcurrentMap&lt;K, A&gt;, T&gt; accumulator;
<i>1288</i>&nbsp;        if (downstream.characteristics().contains(Collector.Characteristics.CONCURRENT)) {
<i>1289</i>&nbsp;            accumulator = (m, t) -&gt; {
<i>1290</i>&nbsp;                K key = Objects.requireNonNull(classifier.apply(t), &quot;element cannot be mapped to a null key&quot;);
<i>1291</i>&nbsp;                A resultContainer = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());
<i>1292</i>&nbsp;                downstreamAccumulator.accept(resultContainer, t);
<i>1293</i>&nbsp;            };
<i>1294</i>&nbsp;        }
<i>1295</i>&nbsp;        else {
<i>1296</i>&nbsp;            accumulator = (m, t) -&gt; {
<i>1297</i>&nbsp;                K key = Objects.requireNonNull(classifier.apply(t), &quot;element cannot be mapped to a null key&quot;);
<i>1298</i>&nbsp;                A resultContainer = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());
<i>1299</i>&nbsp;                synchronized (resultContainer) {
<i>1300</i>&nbsp;                    downstreamAccumulator.accept(resultContainer, t);
<i>1301</i>&nbsp;                }
<i>1302</i>&nbsp;            };
<i>1303</i>&nbsp;        }
<i>1304</i>&nbsp;
<i>1305</i>&nbsp;        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
<i>1306</i>&nbsp;            return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_CONCURRENT_ID);
<i>1307</i>&nbsp;        }
<i>1308</i>&nbsp;        else {
<i>1309</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<i>1310</i>&nbsp;            Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();
<i>1311</i>&nbsp;            Function&lt;ConcurrentMap&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; {
<i>1312</i>&nbsp;                intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));
<i>1313</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>1314</i>&nbsp;                M castResult = (M) intermediate;
<i>1315</i>&nbsp;                return castResult;
<i>1316</i>&nbsp;            };
<i>1317</i>&nbsp;            return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_CONCURRENT_NOID);
<i>1318</i>&nbsp;        }
<b class="nc"><i>1319</i>&nbsp;    }</b>
<b class="nc"><i>1320</i>&nbsp;</b>
<b class="nc"><i>1321</i>&nbsp;    /**</b>
<b class="nc"><i>1322</i>&nbsp;     * Returns a {@code Collector} which partitions the input elements according</b>
<i>1323</i>&nbsp;     * to a {@code Predicate}, and organizes them into a
<i>1324</i>&nbsp;     * {@code Map&lt;Boolean, List&lt;T&gt;&gt;}.
<i>1325</i>&nbsp;     *
<i>1326</i>&nbsp;     * The returned {@code Map} always contains mappings for both
<i>1327</i>&nbsp;     * {@code false} and {@code true} keys.
<i>1328</i>&nbsp;     * There are no guarantees on the type, mutability,
<i>1329</i>&nbsp;     * serializability, or thread-safety of the {@code Map} or {@code List}
<i>1330</i>&nbsp;     * returned.
<i>1331</i>&nbsp;     *
<i>1332</i>&nbsp;     * @apiNote
<i>1333</i>&nbsp;     * If a partition has no elements, its value in the result Map will be
<i>1334</i>&nbsp;     * an empty List.
<i>1335</i>&nbsp;     *
<i>1336</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1337</i>&nbsp;     * @param predicate a predicate used for classifying input elements
<i>1338</i>&nbsp;     * @return a {@code Collector} implementing the partitioning operation
<i>1339</i>&nbsp;     *
<i>1340</i>&nbsp;     * @see #partitioningBy(Predicate, Collector)
<i>1341</i>&nbsp;     */
<i>1342</i>&nbsp;    public static &lt;T&gt;
<i>1343</i>&nbsp;    Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate) {
<i>1344</i>&nbsp;        return partitioningBy(predicate, toList());
<i>1345</i>&nbsp;    }
<i>1346</i>&nbsp;
<i>1347</i>&nbsp;    /**
<i>1348</i>&nbsp;     * Returns a {@code Collector} which partitions the input elements according
<i>1349</i>&nbsp;     * to a {@code Predicate}, reduces the values in each partition according to
<i>1350</i>&nbsp;     * another {@code Collector}, and organizes them into a
<i>1351</i>&nbsp;     * {@code Map&lt;Boolean, D&gt;} whose values are the result of the downstream
<i>1352</i>&nbsp;     * reduction.
<i>1353</i>&nbsp;     *
<i>1354</i>&nbsp;     * &lt;p&gt;
<i>1355</i>&nbsp;     * The returned {@code Map} always contains mappings for both
<i>1356</i>&nbsp;     * {@code false} and {@code true} keys.
<i>1357</i>&nbsp;     * There are no guarantees on the type, mutability,
<i>1358</i>&nbsp;     * serializability, or thread-safety of the {@code Map} returned.
<i>1359</i>&nbsp;     *
<i>1360</i>&nbsp;     * @apiNote
<i>1361</i>&nbsp;     * If a partition has no elements, its value in the result Map will be
<i>1362</i>&nbsp;     * obtained by calling the downstream collector&#39;s supplier function and then
<i>1363</i>&nbsp;     * applying the finisher function.
<i>1364</i>&nbsp;     *
<i>1365</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1366</i>&nbsp;     * @param &lt;A&gt; the intermediate accumulation type of the downstream collector
<i>1367</i>&nbsp;     * @param &lt;D&gt; the result type of the downstream reduction
<i>1368</i>&nbsp;     * @param predicate a predicate used for classifying input elements
<i>1369</i>&nbsp;     * @param downstream a {@code Collector} implementing the downstream
<i>1370</i>&nbsp;     *                   reduction
<i>1371</i>&nbsp;     * @return a {@code Collector} implementing the cascaded partitioning
<i>1372</i>&nbsp;     *         operation
<i>1373</i>&nbsp;     *
<i>1374</i>&nbsp;     * @see #partitioningBy(Predicate)
<b class="nc"><i>1375</i>&nbsp;     */</b>
<i>1376</i>&nbsp;    public static &lt;T, D, A&gt;
<i>1377</i>&nbsp;    Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate,
<i>1378</i>&nbsp;                                                    Collector&lt;? super T, A, D&gt; downstream) {
<i>1379</i>&nbsp;        BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator();
<i>1380</i>&nbsp;        BiConsumer&lt;Partition&lt;A&gt;, T&gt; accumulator = (result, t) -&gt;
<i>1381</i>&nbsp;                downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t);
<i>1382</i>&nbsp;        BinaryOperator&lt;A&gt; op = downstream.combiner();
<i>1383</i>&nbsp;        BinaryOperator&lt;Partition&lt;A&gt;&gt; merger = (left, right) -&gt;
<i>1384</i>&nbsp;                new Partition&lt;&gt;(op.apply(left.forTrue, right.forTrue),
<i>1385</i>&nbsp;                                op.apply(left.forFalse, right.forFalse));
<i>1386</i>&nbsp;        Supplier&lt;Partition&lt;A&gt;&gt; supplier = () -&gt;
<i>1387</i>&nbsp;                new Partition&lt;&gt;(downstream.supplier().get(),
<i>1388</i>&nbsp;                                downstream.supplier().get());
<i>1389</i>&nbsp;        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
<i>1390</i>&nbsp;            return new CollectorImpl&lt;&gt;(supplier, accumulator, merger, CH_ID);
<i>1391</i>&nbsp;        }
<i>1392</i>&nbsp;        else {
<i>1393</i>&nbsp;            Function&lt;Partition&lt;A&gt;, Map&lt;Boolean, D&gt;&gt; finisher = par -&gt;
<i>1394</i>&nbsp;                    new Partition&lt;&gt;(downstream.finisher().apply(par.forTrue),
<i>1395</i>&nbsp;                                    downstream.finisher().apply(par.forFalse));
<i>1396</i>&nbsp;            return new CollectorImpl&lt;&gt;(supplier, accumulator, merger, finisher, CH_NOID);
<i>1397</i>&nbsp;        }
<i>1398</i>&nbsp;    }
<i>1399</i>&nbsp;
<i>1400</i>&nbsp;    /**
<i>1401</i>&nbsp;     * Returns a {@code Collector} that accumulates elements into a
<i>1402</i>&nbsp;     * {@code Map} whose keys and values are the result of applying the provided
<i>1403</i>&nbsp;     * mapping functions to the input elements.
<i>1404</i>&nbsp;     *
<i>1405</i>&nbsp;     * &lt;p&gt;If the mapped keys contain duplicates (according to
<i>1406</i>&nbsp;     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
<i>1407</i>&nbsp;     * thrown when the collection operation is performed.  If the mapped keys
<i>1408</i>&nbsp;     * might have duplicates, use {@link #toMap(Function, Function, BinaryOperator)}
<i>1409</i>&nbsp;     * instead.
<i>1410</i>&nbsp;     *
<i>1411</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability, serializability,
<i>1412</i>&nbsp;     * or thread-safety of the {@code Map} returned.
<i>1413</i>&nbsp;     *
<i>1414</i>&nbsp;     * @apiNote
<i>1415</i>&nbsp;     * It is common for either the key or the value to be the input elements.
<i>1416</i>&nbsp;     * In this case, the utility method
<i>1417</i>&nbsp;     * {@link java.util.function.Function#identity()} may be helpful.
<i>1418</i>&nbsp;     * For example, the following produces a {@code Map} mapping
<i>1419</i>&nbsp;     * students to their grade point average:
<i>1420</i>&nbsp;     * &lt;pre&gt;{@code
<i>1421</i>&nbsp;     * Map&lt;Student, Double&gt; studentToGPA
<i>1422</i>&nbsp;     *   = students.stream().collect(
<i>1423</i>&nbsp;     *     toMap(Function.identity(),
<i>1424</i>&nbsp;     *           student -&gt; computeGPA(student)));
<i>1425</i>&nbsp;     * }&lt;/pre&gt;
<i>1426</i>&nbsp;     * And the following produces a {@code Map} mapping a unique identifier to
<i>1427</i>&nbsp;     * students:
<i>1428</i>&nbsp;     * &lt;pre&gt;{@code
<b class="nc"><i>1429</i>&nbsp;     * Map&lt;String, Student&gt; studentIdToStudent</b>
<i>1430</i>&nbsp;     *   = students.stream().collect(
<i>1431</i>&nbsp;     *     toMap(Student::getId,
<i>1432</i>&nbsp;     *           Function.identity()));
<i>1433</i>&nbsp;     * }&lt;/pre&gt;
<i>1434</i>&nbsp;     *
<i>1435</i>&nbsp;     * @implNote
<i>1436</i>&nbsp;     * The returned {@code Collector} is not concurrent.  For parallel stream
<i>1437</i>&nbsp;     * pipelines, the {@code combiner} function operates by merging the keys
<i>1438</i>&nbsp;     * from one map into another, which can be an expensive operation.  If it is
<i>1439</i>&nbsp;     * not required that results are inserted into the {@code Map} in encounter
<i>1440</i>&nbsp;     * order, using {@link #toConcurrentMap(Function, Function)}
<i>1441</i>&nbsp;     * may offer better parallel performance.
<i>1442</i>&nbsp;     *
<i>1443</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1444</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1445</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1446</i>&nbsp;     * @param keyMapper a mapping function to produce keys
<i>1447</i>&nbsp;     * @param valueMapper a mapping function to produce values
<i>1448</i>&nbsp;     * @return a {@code Collector} which collects elements into a {@code Map}
<i>1449</i>&nbsp;     * whose keys and values are the result of applying mapping functions to
<i>1450</i>&nbsp;     * the input elements
<i>1451</i>&nbsp;     *
<i>1452</i>&nbsp;     * @see #toMap(Function, Function, BinaryOperator)
<i>1453</i>&nbsp;     * @see #toMap(Function, Function, BinaryOperator, Supplier)
<i>1454</i>&nbsp;     * @see #toConcurrentMap(Function, Function)
<i>1455</i>&nbsp;     */
<i>1456</i>&nbsp;    public static &lt;T, K, U&gt;
<i>1457</i>&nbsp;    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1458</i>&nbsp;                                    Function&lt;? super T, ? extends U&gt; valueMapper) {
<i>1459</i>&nbsp;        return new CollectorImpl&lt;&gt;(HashMap::new,
<i>1460</i>&nbsp;                                   uniqKeysMapAccumulator(keyMapper, valueMapper),
<i>1461</i>&nbsp;                                   uniqKeysMapMerger(),
<i>1462</i>&nbsp;                                   CH_ID);
<i>1463</i>&nbsp;    }
<i>1464</i>&nbsp;
<i>1465</i>&nbsp;    /**
<i>1466</i>&nbsp;     * Returns a {@code Collector} that accumulates the input elements into an
<i>1467</i>&nbsp;     * &lt;a href=&quot;../Map.html#unmodifiable&quot;&gt;unmodifiable Map&lt;/a&gt;,
<i>1468</i>&nbsp;     * whose keys and values are the result of applying the provided
<i>1469</i>&nbsp;     * mapping functions to the input elements.
<i>1470</i>&nbsp;     *
<b class="nc"><i>1471</i>&nbsp;     * &lt;p&gt;If the mapped keys contain duplicates (according to</b>
<b class="nc"><i>1472</i>&nbsp;     * {@link Object#equals(Object)}), an {@code IllegalStateException} is</b>
<b class="nc"><i>1473</i>&nbsp;     * thrown when the collection operation is performed.  If the mapped keys</b>
<b class="nc"><i>1474</i>&nbsp;     * might have duplicates, use {@link #toUnmodifiableMap(Function, Function, BinaryOperator)}</b>
<i>1475</i>&nbsp;     * to handle merging of the values.
<i>1476</i>&nbsp;     *
<i>1477</i>&nbsp;     * &lt;p&gt;The returned Collector disallows null keys and values. If either mapping function
<i>1478</i>&nbsp;     * returns null, {@code NullPointerException} will be thrown.
<i>1479</i>&nbsp;     *
<i>1480</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1481</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1482</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1483</i>&nbsp;     * @param keyMapper a mapping function to produce keys, must be non-null
<i>1484</i>&nbsp;     * @param valueMapper a mapping function to produce values, must be non-null
<i>1485</i>&nbsp;     * @return a {@code Collector} that accumulates the input elements into an
<i>1486</i>&nbsp;     * &lt;a href=&quot;../Map.html#unmodifiable&quot;&gt;unmodifiable Map&lt;/a&gt;, whose keys and values
<i>1487</i>&nbsp;     * are the result of applying the provided mapping functions to the input elements
<i>1488</i>&nbsp;     * @throws NullPointerException if either keyMapper or valueMapper is null
<i>1489</i>&nbsp;     *
<i>1490</i>&nbsp;     * @see #toUnmodifiableMap(Function, Function, BinaryOperator)
<b class="nc"><i>1491</i>&nbsp;     * @since 10</b>
<i>1492</i>&nbsp;     */
<b class="nc"><i>1493</i>&nbsp;    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})</b>
<b class="nc"><i>1494</i>&nbsp;    public static &lt;T, K, U&gt;</b>
<i>1495</i>&nbsp;    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toUnmodifiableMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1496</i>&nbsp;                                                Function&lt;? super T, ? extends U&gt; valueMapper) {
<i>1497</i>&nbsp;        Objects.requireNonNull(keyMapper, &quot;keyMapper&quot;);
<i>1498</i>&nbsp;        Objects.requireNonNull(valueMapper, &quot;valueMapper&quot;);
<i>1499</i>&nbsp;        return collectingAndThen(
<i>1500</i>&nbsp;                toMap(keyMapper, valueMapper),
<i>1501</i>&nbsp;                map -&gt; (Map&lt;K,U&gt;)Map.ofEntries(map.entrySet().toArray(new Map.Entry[0])));
<i>1502</i>&nbsp;    }
<i>1503</i>&nbsp;
<i>1504</i>&nbsp;    /**
<i>1505</i>&nbsp;     * Returns a {@code Collector} that accumulates elements into a
<i>1506</i>&nbsp;     * {@code Map} whose keys and values are the result of applying the provided
<i>1507</i>&nbsp;     * mapping functions to the input elements.
<i>1508</i>&nbsp;     *
<i>1509</i>&nbsp;     * &lt;p&gt;If the mapped
<i>1510</i>&nbsp;     * keys contain duplicates (according to {@link Object#equals(Object)}),
<b class="nc"><i>1511</i>&nbsp;     * the value mapping function is applied to each equal element, and the</b>
<i>1512</i>&nbsp;     * results are merged using the provided merging function.
<b class="nc"><i>1513</i>&nbsp;     *</b>
<b class="nc"><i>1514</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability, serializability,</b>
<i>1515</i>&nbsp;     * or thread-safety of the {@code Map} returned.
<i>1516</i>&nbsp;     *
<i>1517</i>&nbsp;     * @apiNote
<i>1518</i>&nbsp;     * There are multiple ways to deal with collisions between multiple elements
<i>1519</i>&nbsp;     * mapping to the same key.  The other forms of {@code toMap} simply use
<i>1520</i>&nbsp;     * a merge function that throws unconditionally, but you can easily write
<i>1521</i>&nbsp;     * more flexible merge policies.  For example, if you have a stream
<i>1522</i>&nbsp;     * of {@code Person}, and you want to produce a &quot;phone book&quot; mapping name to
<i>1523</i>&nbsp;     * address, but it is possible that two persons have the same name, you can
<i>1524</i>&nbsp;     * do as follows to gracefully deal with these collisions, and produce a
<i>1525</i>&nbsp;     * {@code Map} mapping names to a concatenated list of addresses:
<i>1526</i>&nbsp;     * &lt;pre&gt;{@code
<i>1527</i>&nbsp;     * Map&lt;String, String&gt; phoneBook
<i>1528</i>&nbsp;     *   = people.stream().collect(
<i>1529</i>&nbsp;     *     toMap(Person::getName,
<i>1530</i>&nbsp;     *           Person::getAddress,
<b class="nc"><i>1531</i>&nbsp;     *           (s, a) -&gt; s + &quot;, &quot; + a));</b>
<i>1532</i>&nbsp;     * }&lt;/pre&gt;
<b class="nc"><i>1533</i>&nbsp;     *</b>
<b class="nc"><i>1534</i>&nbsp;     * @implNote</b>
<i>1535</i>&nbsp;     * The returned {@code Collector} is not concurrent.  For parallel stream
<i>1536</i>&nbsp;     * pipelines, the {@code combiner} function operates by merging the keys
<i>1537</i>&nbsp;     * from one map into another, which can be an expensive operation.  If it is
<i>1538</i>&nbsp;     * not required that results are merged into the {@code Map} in encounter
<i>1539</i>&nbsp;     * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator)}
<i>1540</i>&nbsp;     * may offer better parallel performance.
<i>1541</i>&nbsp;     *
<i>1542</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1543</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1544</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1545</i>&nbsp;     * @param keyMapper a mapping function to produce keys
<b class="nc"><i>1546</i>&nbsp;     * @param valueMapper a mapping function to produce values</b>
<b class="nc"><i>1547</i>&nbsp;     * @param mergeFunction a merge function, used to resolve collisions between</b>
<b class="nc"><i>1548</i>&nbsp;     *                      values associated with the same key, as supplied</b>
<i>1549</i>&nbsp;     *                      to {@link Map#merge(Object, Object, BiFunction)}
<i>1550</i>&nbsp;     * @return a {@code Collector} which collects elements into a {@code Map}
<i>1551</i>&nbsp;     * whose keys are the result of applying a key mapping function to the input
<i>1552</i>&nbsp;     * elements, and whose values are the result of applying a value mapping
<b class="nc"><i>1553</i>&nbsp;     * function to all input elements equal to the key and combining them</b>
<i>1554</i>&nbsp;     * using the merge function
<i>1555</i>&nbsp;     *
<b class="nc"><i>1556</i>&nbsp;     * @see #toMap(Function, Function)</b>
<b class="nc"><i>1557</i>&nbsp;     * @see #toMap(Function, Function, BinaryOperator, Supplier)</b>
<b class="nc"><i>1558</i>&nbsp;     * @see #toConcurrentMap(Function, Function, BinaryOperator)</b>
<i>1559</i>&nbsp;     */
<i>1560</i>&nbsp;    public static &lt;T, K, U&gt;
<i>1561</i>&nbsp;    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1562</i>&nbsp;                                    Function&lt;? super T, ? extends U&gt; valueMapper,
<b class="nc"><i>1563</i>&nbsp;                                    BinaryOperator&lt;U&gt; mergeFunction) {</b>
<i>1564</i>&nbsp;        return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new);
<i>1565</i>&nbsp;    }
<i>1566</i>&nbsp;
<i>1567</i>&nbsp;
<i>1568</i>&nbsp;    /**
<i>1569</i>&nbsp;     * Returns a {@code Collector} that accumulates the input elements into an
<i>1570</i>&nbsp;     * &lt;a href=&quot;../Map.html#unmodifiable&quot;&gt;unmodifiable Map&lt;/a&gt;,
<i>1571</i>&nbsp;     * whose keys and values are the result of applying the provided
<i>1572</i>&nbsp;     * mapping functions to the input elements.
<i>1573</i>&nbsp;     *
<i>1574</i>&nbsp;     * &lt;p&gt;If the mapped
<i>1575</i>&nbsp;     * keys contain duplicates (according to {@link Object#equals(Object)}),
<i>1576</i>&nbsp;     * the value mapping function is applied to each equal element, and the
<i>1577</i>&nbsp;     * results are merged using the provided merging function.
<i>1578</i>&nbsp;     *
<i>1579</i>&nbsp;     * &lt;p&gt;The returned Collector disallows null keys and values. If either mapping function
<i>1580</i>&nbsp;     * returns null, {@code NullPointerException} will be thrown.
<i>1581</i>&nbsp;     *
<i>1582</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1583</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1584</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1585</i>&nbsp;     * @param keyMapper a mapping function to produce keys, must be non-null
<i>1586</i>&nbsp;     * @param valueMapper a mapping function to produce values, must be non-null
<i>1587</i>&nbsp;     * @param mergeFunction a merge function, used to resolve collisions between
<i>1588</i>&nbsp;     *                      values associated with the same key, as supplied
<i>1589</i>&nbsp;     *                      to {@link Map#merge(Object, Object, BiFunction)},
<i>1590</i>&nbsp;     *                      must be non-null
<i>1591</i>&nbsp;     * @return a {@code Collector} that accumulates the input elements into an
<i>1592</i>&nbsp;     * &lt;a href=&quot;../Map.html#unmodifiable&quot;&gt;unmodifiable Map&lt;/a&gt;, whose keys and values
<i>1593</i>&nbsp;     * are the result of applying the provided mapping functions to the input elements
<i>1594</i>&nbsp;     * @throws NullPointerException if the keyMapper, valueMapper, or mergeFunction is null
<i>1595</i>&nbsp;     *
<i>1596</i>&nbsp;     * @see #toUnmodifiableMap(Function, Function)
<i>1597</i>&nbsp;     * @since 10
<i>1598</i>&nbsp;     */
<i>1599</i>&nbsp;    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
<i>1600</i>&nbsp;    public static &lt;T, K, U&gt;
<i>1601</i>&nbsp;    Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toUnmodifiableMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1602</i>&nbsp;                                                Function&lt;? super T, ? extends U&gt; valueMapper,
<i>1603</i>&nbsp;                                                BinaryOperator&lt;U&gt; mergeFunction) {
<i>1604</i>&nbsp;        Objects.requireNonNull(keyMapper, &quot;keyMapper&quot;);
<i>1605</i>&nbsp;        Objects.requireNonNull(valueMapper, &quot;valueMapper&quot;);
<i>1606</i>&nbsp;        Objects.requireNonNull(mergeFunction, &quot;mergeFunction&quot;);
<i>1607</i>&nbsp;        return collectingAndThen(
<i>1608</i>&nbsp;                toMap(keyMapper, valueMapper, mergeFunction, HashMap::new),
<i>1609</i>&nbsp;                map -&gt; (Map&lt;K,U&gt;)Map.ofEntries(map.entrySet().toArray(new Map.Entry[0])));
<i>1610</i>&nbsp;    }
<i>1611</i>&nbsp;
<i>1612</i>&nbsp;    /**
<i>1613</i>&nbsp;     * Returns a {@code Collector} that accumulates elements into a
<i>1614</i>&nbsp;     * {@code Map} whose keys and values are the result of applying the provided
<i>1615</i>&nbsp;     * mapping functions to the input elements.
<i>1616</i>&nbsp;     *
<i>1617</i>&nbsp;     * &lt;p&gt;If the mapped
<i>1618</i>&nbsp;     * keys contain duplicates (according to {@link Object#equals(Object)}),
<i>1619</i>&nbsp;     * the value mapping function is applied to each equal element, and the
<i>1620</i>&nbsp;     * results are merged using the provided merging function.  The {@code Map}
<i>1621</i>&nbsp;     * is created by a provided supplier function.
<i>1622</i>&nbsp;     *
<i>1623</i>&nbsp;     * @implNote
<i>1624</i>&nbsp;     * The returned {@code Collector} is not concurrent.  For parallel stream
<i>1625</i>&nbsp;     * pipelines, the {@code combiner} function operates by merging the keys
<i>1626</i>&nbsp;     * from one map into another, which can be an expensive operation.  If it is
<i>1627</i>&nbsp;     * not required that results are merged into the {@code Map} in encounter
<i>1628</i>&nbsp;     * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)}
<i>1629</i>&nbsp;     * may offer better parallel performance.
<i>1630</i>&nbsp;     *
<i>1631</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1632</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1633</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1634</i>&nbsp;     * @param &lt;M&gt; the type of the resulting {@code Map}
<i>1635</i>&nbsp;     * @param keyMapper a mapping function to produce keys
<i>1636</i>&nbsp;     * @param valueMapper a mapping function to produce values
<i>1637</i>&nbsp;     * @param mergeFunction a merge function, used to resolve collisions between
<i>1638</i>&nbsp;     *                      values associated with the same key, as supplied
<i>1639</i>&nbsp;     *                      to {@link Map#merge(Object, Object, BiFunction)}
<i>1640</i>&nbsp;     * @param mapFactory a supplier providing a new empty {@code Map}
<i>1641</i>&nbsp;     *                   into which the results will be inserted
<i>1642</i>&nbsp;     * @return a {@code Collector} which collects elements into a {@code Map}
<i>1643</i>&nbsp;     * whose keys are the result of applying a key mapping function to the input
<i>1644</i>&nbsp;     * elements, and whose values are the result of applying a value mapping
<i>1645</i>&nbsp;     * function to all input elements equal to the key and combining them
<i>1646</i>&nbsp;     * using the merge function
<i>1647</i>&nbsp;     *
<i>1648</i>&nbsp;     * @see #toMap(Function, Function)
<i>1649</i>&nbsp;     * @see #toMap(Function, Function, BinaryOperator)
<i>1650</i>&nbsp;     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
<i>1651</i>&nbsp;     */
<i>1652</i>&nbsp;    public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt;
<i>1653</i>&nbsp;    Collector&lt;T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1654</i>&nbsp;                             Function&lt;? super T, ? extends U&gt; valueMapper,
<i>1655</i>&nbsp;                             BinaryOperator&lt;U&gt; mergeFunction,
<i>1656</i>&nbsp;                             Supplier&lt;M&gt; mapFactory) {
<i>1657</i>&nbsp;        BiConsumer&lt;M, T&gt; accumulator
<i>1658</i>&nbsp;                = (map, element) -&gt; map.merge(keyMapper.apply(element),
<i>1659</i>&nbsp;                                              valueMapper.apply(element), mergeFunction);
<i>1660</i>&nbsp;        return new CollectorImpl&lt;&gt;(mapFactory, accumulator, mapMerger(mergeFunction), CH_ID);
<i>1661</i>&nbsp;    }
<i>1662</i>&nbsp;
<i>1663</i>&nbsp;    /**
<i>1664</i>&nbsp;     * Returns a concurrent {@code Collector} that accumulates elements into a
<i>1665</i>&nbsp;     * {@code ConcurrentMap} whose keys and values are the result of applying
<i>1666</i>&nbsp;     * the provided mapping functions to the input elements.
<i>1667</i>&nbsp;     *
<i>1668</i>&nbsp;     * &lt;p&gt;If the mapped keys contain duplicates (according to
<i>1669</i>&nbsp;     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
<i>1670</i>&nbsp;     * thrown when the collection operation is performed.  If the mapped keys
<i>1671</i>&nbsp;     * may have duplicates, use
<i>1672</i>&nbsp;     * {@link #toConcurrentMap(Function, Function, BinaryOperator)} instead.
<i>1673</i>&nbsp;     *
<i>1674</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability, or serializability
<i>1675</i>&nbsp;     * of the {@code ConcurrentMap} returned.
<i>1676</i>&nbsp;     *
<i>1677</i>&nbsp;     * @apiNote
<i>1678</i>&nbsp;     * It is common for either the key or the value to be the input elements.
<i>1679</i>&nbsp;     * In this case, the utility method
<i>1680</i>&nbsp;     * {@link java.util.function.Function#identity()} may be helpful.
<i>1681</i>&nbsp;     * For example, the following produces a {@code ConcurrentMap} mapping
<i>1682</i>&nbsp;     * students to their grade point average:
<i>1683</i>&nbsp;     * &lt;pre&gt;{@code
<i>1684</i>&nbsp;     * ConcurrentMap&lt;Student, Double&gt; studentToGPA
<i>1685</i>&nbsp;     *   = students.stream().collect(
<i>1686</i>&nbsp;     *     toConcurrentMap(Function.identity(),
<i>1687</i>&nbsp;     *                     student -&gt; computeGPA(student)));
<i>1688</i>&nbsp;     * }&lt;/pre&gt;
<i>1689</i>&nbsp;     * And the following produces a {@code ConcurrentMap} mapping a
<i>1690</i>&nbsp;     * unique identifier to students:
<i>1691</i>&nbsp;     * &lt;pre&gt;{@code
<i>1692</i>&nbsp;     * ConcurrentMap&lt;String, Student&gt; studentIdToStudent
<i>1693</i>&nbsp;     *   = students.stream().collect(
<i>1694</i>&nbsp;     *     toConcurrentMap(Student::getId,
<i>1695</i>&nbsp;     *                     Function.identity()));
<i>1696</i>&nbsp;     * }&lt;/pre&gt;
<i>1697</i>&nbsp;     *
<i>1698</i>&nbsp;     * &lt;p&gt;This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
<i>1699</i>&nbsp;     * {@link Collector.Characteristics#UNORDERED unordered} Collector.
<i>1700</i>&nbsp;     *
<i>1701</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1702</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1703</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1704</i>&nbsp;     * @param keyMapper the mapping function to produce keys
<i>1705</i>&nbsp;     * @param valueMapper the mapping function to produce values
<i>1706</i>&nbsp;     * @return a concurrent, unordered {@code Collector} which collects elements into a
<i>1707</i>&nbsp;     * {@code ConcurrentMap} whose keys are the result of applying a key mapping
<i>1708</i>&nbsp;     * function to the input elements, and whose values are the result of
<i>1709</i>&nbsp;     * applying a value mapping function to the input elements
<i>1710</i>&nbsp;     *
<i>1711</i>&nbsp;     * @see #toMap(Function, Function)
<i>1712</i>&nbsp;     * @see #toConcurrentMap(Function, Function, BinaryOperator)
<i>1713</i>&nbsp;     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
<i>1714</i>&nbsp;     */
<i>1715</i>&nbsp;    public static &lt;T, K, U&gt;
<i>1716</i>&nbsp;    Collector&lt;T, ?, ConcurrentMap&lt;K,U&gt;&gt; toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1717</i>&nbsp;                                                        Function&lt;? super T, ? extends U&gt; valueMapper) {
<i>1718</i>&nbsp;        return new CollectorImpl&lt;&gt;(ConcurrentHashMap::new,
<i>1719</i>&nbsp;                                   uniqKeysMapAccumulator(keyMapper, valueMapper),
<i>1720</i>&nbsp;                                   uniqKeysMapMerger(),
<i>1721</i>&nbsp;                                   CH_CONCURRENT_ID);
<i>1722</i>&nbsp;    }
<i>1723</i>&nbsp;
<i>1724</i>&nbsp;    /**
<i>1725</i>&nbsp;     * Returns a concurrent {@code Collector} that accumulates elements into a
<i>1726</i>&nbsp;     * {@code ConcurrentMap} whose keys and values are the result of applying
<i>1727</i>&nbsp;     * the provided mapping functions to the input elements.
<i>1728</i>&nbsp;     *
<i>1729</i>&nbsp;     * &lt;p&gt;If the mapped keys contain duplicates (according to {@link Object#equals(Object)}),
<i>1730</i>&nbsp;     * the value mapping function is applied to each equal element, and the
<i>1731</i>&nbsp;     * results are merged using the provided merging function.
<i>1732</i>&nbsp;     *
<i>1733</i>&nbsp;     * &lt;p&gt;There are no guarantees on the type, mutability, or serializability
<i>1734</i>&nbsp;     * of the {@code ConcurrentMap} returned.
<i>1735</i>&nbsp;     *
<i>1736</i>&nbsp;     * @apiNote
<i>1737</i>&nbsp;     * There are multiple ways to deal with collisions between multiple elements
<i>1738</i>&nbsp;     * mapping to the same key.  The other forms of {@code toConcurrentMap} simply use
<i>1739</i>&nbsp;     * a merge function that throws unconditionally, but you can easily write
<i>1740</i>&nbsp;     * more flexible merge policies.  For example, if you have a stream
<i>1741</i>&nbsp;     * of {@code Person}, and you want to produce a &quot;phone book&quot; mapping name to
<i>1742</i>&nbsp;     * address, but it is possible that two persons have the same name, you can
<i>1743</i>&nbsp;     * do as follows to gracefully deal with these collisions, and produce a
<i>1744</i>&nbsp;     * {@code ConcurrentMap} mapping names to a concatenated list of addresses:
<i>1745</i>&nbsp;     * &lt;pre&gt;{@code
<i>1746</i>&nbsp;     * ConcurrentMap&lt;String, String&gt; phoneBook
<i>1747</i>&nbsp;     *   = people.stream().collect(
<i>1748</i>&nbsp;     *     toConcurrentMap(Person::getName,
<i>1749</i>&nbsp;     *                     Person::getAddress,
<i>1750</i>&nbsp;     *                     (s, a) -&gt; s + &quot;, &quot; + a));
<i>1751</i>&nbsp;     * }&lt;/pre&gt;
<i>1752</i>&nbsp;     *
<i>1753</i>&nbsp;     * &lt;p&gt;This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
<i>1754</i>&nbsp;     * {@link Collector.Characteristics#UNORDERED unordered} Collector.
<i>1755</i>&nbsp;     *
<i>1756</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1757</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1758</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1759</i>&nbsp;     * @param keyMapper a mapping function to produce keys
<i>1760</i>&nbsp;     * @param valueMapper a mapping function to produce values
<i>1761</i>&nbsp;     * @param mergeFunction a merge function, used to resolve collisions between
<i>1762</i>&nbsp;     *                      values associated with the same key, as supplied
<i>1763</i>&nbsp;     *                      to {@link Map#merge(Object, Object, BiFunction)}
<i>1764</i>&nbsp;     * @return a concurrent, unordered {@code Collector} which collects elements into a
<i>1765</i>&nbsp;     * {@code ConcurrentMap} whose keys are the result of applying a key mapping
<i>1766</i>&nbsp;     * function to the input elements, and whose values are the result of
<i>1767</i>&nbsp;     * applying a value mapping function to all input elements equal to the key
<i>1768</i>&nbsp;     * and combining them using the merge function
<i>1769</i>&nbsp;     *
<i>1770</i>&nbsp;     * @see #toConcurrentMap(Function, Function)
<i>1771</i>&nbsp;     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
<i>1772</i>&nbsp;     * @see #toMap(Function, Function, BinaryOperator)
<i>1773</i>&nbsp;     */
<i>1774</i>&nbsp;    public static &lt;T, K, U&gt;
<i>1775</i>&nbsp;    Collector&lt;T, ?, ConcurrentMap&lt;K,U&gt;&gt;
<i>1776</i>&nbsp;    toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1777</i>&nbsp;                    Function&lt;? super T, ? extends U&gt; valueMapper,
<i>1778</i>&nbsp;                    BinaryOperator&lt;U&gt; mergeFunction) {
<i>1779</i>&nbsp;        return toConcurrentMap(keyMapper, valueMapper, mergeFunction, ConcurrentHashMap::new);
<i>1780</i>&nbsp;    }
<i>1781</i>&nbsp;
<i>1782</i>&nbsp;    /**
<i>1783</i>&nbsp;     * Returns a concurrent {@code Collector} that accumulates elements into a
<i>1784</i>&nbsp;     * {@code ConcurrentMap} whose keys and values are the result of applying
<i>1785</i>&nbsp;     * the provided mapping functions to the input elements.
<i>1786</i>&nbsp;     *
<i>1787</i>&nbsp;     * &lt;p&gt;If the mapped keys contain duplicates (according to {@link Object#equals(Object)}),
<i>1788</i>&nbsp;     * the value mapping function is applied to each equal element, and the
<i>1789</i>&nbsp;     * results are merged using the provided merging function.  The
<i>1790</i>&nbsp;     * {@code ConcurrentMap} is created by a provided supplier function.
<i>1791</i>&nbsp;     *
<i>1792</i>&nbsp;     * &lt;p&gt;This is a {@link Collector.Characteristics#CONCURRENT concurrent} and
<i>1793</i>&nbsp;     * {@link Collector.Characteristics#UNORDERED unordered} Collector.
<i>1794</i>&nbsp;     *
<i>1795</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1796</i>&nbsp;     * @param &lt;K&gt; the output type of the key mapping function
<i>1797</i>&nbsp;     * @param &lt;U&gt; the output type of the value mapping function
<i>1798</i>&nbsp;     * @param &lt;M&gt; the type of the resulting {@code ConcurrentMap}
<i>1799</i>&nbsp;     * @param keyMapper a mapping function to produce keys
<i>1800</i>&nbsp;     * @param valueMapper a mapping function to produce values
<i>1801</i>&nbsp;     * @param mergeFunction a merge function, used to resolve collisions between
<i>1802</i>&nbsp;     *                      values associated with the same key, as supplied
<i>1803</i>&nbsp;     *                      to {@link Map#merge(Object, Object, BiFunction)}
<i>1804</i>&nbsp;     * @param mapFactory a supplier providing a new empty {@code ConcurrentMap}
<i>1805</i>&nbsp;     *                   into which the results will be inserted
<i>1806</i>&nbsp;     * @return a concurrent, unordered {@code Collector} which collects elements into a
<i>1807</i>&nbsp;     * {@code ConcurrentMap} whose keys are the result of applying a key mapping
<i>1808</i>&nbsp;     * function to the input elements, and whose values are the result of
<i>1809</i>&nbsp;     * applying a value mapping function to all input elements equal to the key
<i>1810</i>&nbsp;     * and combining them using the merge function
<i>1811</i>&nbsp;     *
<i>1812</i>&nbsp;     * @see #toConcurrentMap(Function, Function)
<i>1813</i>&nbsp;     * @see #toConcurrentMap(Function, Function, BinaryOperator)
<i>1814</i>&nbsp;     * @see #toMap(Function, Function, BinaryOperator, Supplier)
<i>1815</i>&nbsp;     */
<i>1816</i>&nbsp;    public static &lt;T, K, U, M extends ConcurrentMap&lt;K, U&gt;&gt;
<i>1817</i>&nbsp;    Collector&lt;T, ?, M&gt; toConcurrentMap(Function&lt;? super T, ? extends K&gt; keyMapper,
<i>1818</i>&nbsp;                                       Function&lt;? super T, ? extends U&gt; valueMapper,
<i>1819</i>&nbsp;                                       BinaryOperator&lt;U&gt; mergeFunction,
<i>1820</i>&nbsp;                                       Supplier&lt;M&gt; mapFactory) {
<i>1821</i>&nbsp;        BiConsumer&lt;M, T&gt; accumulator
<i>1822</i>&nbsp;                = (map, element) -&gt; map.merge(keyMapper.apply(element),
<i>1823</i>&nbsp;                                              valueMapper.apply(element), mergeFunction);
<i>1824</i>&nbsp;        return new CollectorImpl&lt;&gt;(mapFactory, accumulator, mapMerger(mergeFunction), CH_CONCURRENT_ID);
<i>1825</i>&nbsp;    }
<i>1826</i>&nbsp;
<i>1827</i>&nbsp;    /**
<i>1828</i>&nbsp;     * Returns a {@code Collector} which applies an {@code int}-producing
<i>1829</i>&nbsp;     * mapping function to each input element, and returns summary statistics
<i>1830</i>&nbsp;     * for the resulting values.
<i>1831</i>&nbsp;     *
<i>1832</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1833</i>&nbsp;     * @param mapper a mapping function to apply to each element
<i>1834</i>&nbsp;     * @return a {@code Collector} implementing the summary-statistics reduction
<i>1835</i>&nbsp;     *
<i>1836</i>&nbsp;     * @see #summarizingDouble(ToDoubleFunction)
<i>1837</i>&nbsp;     * @see #summarizingLong(ToLongFunction)
<i>1838</i>&nbsp;     */
<i>1839</i>&nbsp;    public static &lt;T&gt;
<i>1840</i>&nbsp;    Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper) {
<i>1841</i>&nbsp;        return new CollectorImpl&lt;T, IntSummaryStatistics, IntSummaryStatistics&gt;(
<i>1842</i>&nbsp;                IntSummaryStatistics::new,
<i>1843</i>&nbsp;                (r, t) -&gt; r.accept(mapper.applyAsInt(t)),
<i>1844</i>&nbsp;                (l, r) -&gt; { l.combine(r); return l; }, CH_ID);
<i>1845</i>&nbsp;    }
<i>1846</i>&nbsp;
<i>1847</i>&nbsp;    /**
<i>1848</i>&nbsp;     * Returns a {@code Collector} which applies an {@code long}-producing
<i>1849</i>&nbsp;     * mapping function to each input element, and returns summary statistics
<i>1850</i>&nbsp;     * for the resulting values.
<i>1851</i>&nbsp;     *
<i>1852</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1853</i>&nbsp;     * @param mapper the mapping function to apply to each element
<i>1854</i>&nbsp;     * @return a {@code Collector} implementing the summary-statistics reduction
<i>1855</i>&nbsp;     *
<i>1856</i>&nbsp;     * @see #summarizingDouble(ToDoubleFunction)
<i>1857</i>&nbsp;     * @see #summarizingInt(ToIntFunction)
<i>1858</i>&nbsp;     */
<i>1859</i>&nbsp;    public static &lt;T&gt;
<i>1860</i>&nbsp;    Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper) {
<i>1861</i>&nbsp;        return new CollectorImpl&lt;T, LongSummaryStatistics, LongSummaryStatistics&gt;(
<i>1862</i>&nbsp;                LongSummaryStatistics::new,
<i>1863</i>&nbsp;                (r, t) -&gt; r.accept(mapper.applyAsLong(t)),
<i>1864</i>&nbsp;                (l, r) -&gt; { l.combine(r); return l; }, CH_ID);
<i>1865</i>&nbsp;    }
<i>1866</i>&nbsp;
<i>1867</i>&nbsp;    /**
<i>1868</i>&nbsp;     * Returns a {@code Collector} which applies an {@code double}-producing
<i>1869</i>&nbsp;     * mapping function to each input element, and returns summary statistics
<i>1870</i>&nbsp;     * for the resulting values.
<i>1871</i>&nbsp;     *
<i>1872</i>&nbsp;     * @param &lt;T&gt; the type of the input elements
<i>1873</i>&nbsp;     * @param mapper a mapping function to apply to each element
<i>1874</i>&nbsp;     * @return a {@code Collector} implementing the summary-statistics reduction
<i>1875</i>&nbsp;     *
<i>1876</i>&nbsp;     * @see #summarizingLong(ToLongFunction)
<i>1877</i>&nbsp;     * @see #summarizingInt(ToIntFunction)
<i>1878</i>&nbsp;     */
<i>1879</i>&nbsp;    public static &lt;T&gt;
<i>1880</i>&nbsp;    Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper) {
<i>1881</i>&nbsp;        return new CollectorImpl&lt;T, DoubleSummaryStatistics, DoubleSummaryStatistics&gt;(
<i>1882</i>&nbsp;                DoubleSummaryStatistics::new,
<i>1883</i>&nbsp;                (r, t) -&gt; r.accept(mapper.applyAsDouble(t)),
<i>1884</i>&nbsp;                (l, r) -&gt; { l.combine(r); return l; }, CH_ID);
<i>1885</i>&nbsp;    }
<i>1886</i>&nbsp;
<i>1887</i>&nbsp;    /**
<i>1888</i>&nbsp;     * Implementation class used by partitioningBy.
<i>1889</i>&nbsp;     */
<i>1890</i>&nbsp;    private static final class Partition&lt;T&gt;
<i>1891</i>&nbsp;            extends AbstractMap&lt;Boolean, T&gt;
<i>1892</i>&nbsp;            implements Map&lt;Boolean, T&gt; {
<i>1893</i>&nbsp;        final T forTrue;
<i>1894</i>&nbsp;        final T forFalse;
<i>1895</i>&nbsp;
<i>1896</i>&nbsp;        Partition(T forTrue, T forFalse) {
<i>1897</i>&nbsp;            this.forTrue = forTrue;
<i>1898</i>&nbsp;            this.forFalse = forFalse;
<i>1899</i>&nbsp;        }
<i>1900</i>&nbsp;
<i>1901</i>&nbsp;        @Override
<i>1902</i>&nbsp;        public Set&lt;Map.Entry&lt;Boolean, T&gt;&gt; entrySet() {
<i>1903</i>&nbsp;            return new AbstractSet&lt;&gt;() {
<i>1904</i>&nbsp;                @Override
<i>1905</i>&nbsp;                public Iterator&lt;Map.Entry&lt;Boolean, T&gt;&gt; iterator() {
<i>1906</i>&nbsp;                    Map.Entry&lt;Boolean, T&gt; falseEntry = new SimpleImmutableEntry&lt;&gt;(false, forFalse);
<i>1907</i>&nbsp;                    Map.Entry&lt;Boolean, T&gt; trueEntry = new SimpleImmutableEntry&lt;&gt;(true, forTrue);
<i>1908</i>&nbsp;                    return List.of(falseEntry, trueEntry).iterator();
<i>1909</i>&nbsp;                }
<i>1910</i>&nbsp;
<i>1911</i>&nbsp;                @Override
<i>1912</i>&nbsp;                public int size() {
<i>1913</i>&nbsp;                    return 2;
<i>1914</i>&nbsp;                }
<i>1915</i>&nbsp;            };
<i>1916</i>&nbsp;        }
<i>1917</i>&nbsp;    }
<i>1918</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
