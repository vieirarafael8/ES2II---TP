


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: X509CertImpl</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.security.x509</a> ]
</div>

<h1>Coverage Summary for Class: X509CertImpl (sun.security.x509)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">X509CertImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 83)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 665)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.security.x509;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.BufferedReader;
<i>29</i>&nbsp;import java.io.BufferedInputStream;
<i>30</i>&nbsp;import java.io.ByteArrayOutputStream;
<i>31</i>&nbsp;import java.io.IOException;
<i>32</i>&nbsp;import java.io.InputStream;
<i>33</i>&nbsp;import java.io.InputStreamReader;
<i>34</i>&nbsp;import java.io.OutputStream;
<i>35</i>&nbsp;import java.math.BigInteger;
<i>36</i>&nbsp;import java.security.*;
<i>37</i>&nbsp;import java.security.spec.AlgorithmParameterSpec;
<i>38</i>&nbsp;import java.security.cert.*;
<i>39</i>&nbsp;import java.security.cert.Certificate;
<i>40</i>&nbsp;import java.util.*;
<i>41</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>42</i>&nbsp;
<i>43</i>&nbsp;import javax.security.auth.x500.X500Principal;
<i>44</i>&nbsp;
<i>45</i>&nbsp;import java.util.Base64;
<i>46</i>&nbsp;import sun.security.util.*;
<i>47</i>&nbsp;import sun.security.provider.X509Factory;
<i>48</i>&nbsp;
<i>49</i>&nbsp;/**
<i>50</i>&nbsp; * The X509CertImpl class represents an X.509 certificate. These certificates
<i>51</i>&nbsp; * are widely used to support authentication and other functionality in
<i>52</i>&nbsp; * Internet security systems.  Common applications include Privacy Enhanced
<i>53</i>&nbsp; * Mail (PEM), Transport Layer Security (SSL), code signing for trusted
<i>54</i>&nbsp; * software distribution, and Secure Electronic Transactions (SET).  There
<i>55</i>&nbsp; * is a commercial infrastructure ready to manage large scale deployments
<i>56</i>&nbsp; * of X.509 identity certificates.
<i>57</i>&nbsp; *
<i>58</i>&nbsp; * &lt;P&gt;These certificates are managed and vouched for by &lt;em&gt;Certificate
<i>59</i>&nbsp; * Authorities&lt;/em&gt; (CAs).  CAs are services which create certificates by
<i>60</i>&nbsp; * placing data in the X.509 standard format and then digitally signing
<i>61</i>&nbsp; * that data.  Such signatures are quite difficult to forge.  CAs act as
<i>62</i>&nbsp; * trusted third parties, making introductions between agents who have no
<i>63</i>&nbsp; * direct knowledge of each other.  CA certificates are either signed by
<i>64</i>&nbsp; * themselves, or by some other CA such as a &quot;root&quot; CA.
<i>65</i>&nbsp; *
<i>66</i>&nbsp; * &lt;P&gt;RFC 1422 is very informative, though it does not describe much
<i>67</i>&nbsp; * of the recent work being done with X.509 certificates.  That includes
<i>68</i>&nbsp; * a 1996 version (X.509v3) and a variety of enhancements being made to
<i>69</i>&nbsp; * facilitate an explosion of personal certificates used as &quot;Internet
<i>70</i>&nbsp; * Drivers&#39; Licences&quot;, or with SET for credit card transactions.
<i>71</i>&nbsp; *
<i>72</i>&nbsp; * &lt;P&gt;More recent work includes the IETF PKIX Working Group efforts,
<i>73</i>&nbsp; * especially RFC2459.
<i>74</i>&nbsp; *
<i>75</i>&nbsp; * @author Dave Brownell
<i>76</i>&nbsp; * @author Amit Kapoor
<i>77</i>&nbsp; * @author Hemma Prafullchandra
<i>78</i>&nbsp; * @see X509CertInfo
<i>79</i>&nbsp; */
<i>80</i>&nbsp;public class X509CertImpl extends X509Certificate implements DerEncoder {
<i>81</i>&nbsp;
<i>82</i>&nbsp;    private static final long serialVersionUID = -3457612960190864406L;
<i>83</i>&nbsp;
<i>84</i>&nbsp;    private static final char DOT = &#39;.&#39;;
<i>85</i>&nbsp;    /**
<i>86</i>&nbsp;     * Public attribute names.
<i>87</i>&nbsp;     */
<i>88</i>&nbsp;    public static final String NAME = &quot;x509&quot;;
<i>89</i>&nbsp;    public static final String INFO = X509CertInfo.NAME;
<i>90</i>&nbsp;    public static final String ALG_ID = &quot;algorithm&quot;;
<i>91</i>&nbsp;    public static final String SIGNATURE = &quot;signature&quot;;
<i>92</i>&nbsp;    public static final String SIGNED_CERT = &quot;signed_cert&quot;;
<i>93</i>&nbsp;
<i>94</i>&nbsp;    /**
<i>95</i>&nbsp;     * The following are defined for ease-of-use. These
<i>96</i>&nbsp;     * are the most frequently retrieved attributes.
<i>97</i>&nbsp;     */
<i>98</i>&nbsp;    // x509.info.subject.dname
<i>99</i>&nbsp;    public static final String SUBJECT_DN = NAME + DOT + INFO + DOT +
<i>100</i>&nbsp;                               X509CertInfo.SUBJECT + DOT + X509CertInfo.DN_NAME;
<i>101</i>&nbsp;    // x509.info.issuer.dname
<i>102</i>&nbsp;    public static final String ISSUER_DN = NAME + DOT + INFO + DOT +
<i>103</i>&nbsp;                               X509CertInfo.ISSUER + DOT + X509CertInfo.DN_NAME;
<i>104</i>&nbsp;    // x509.info.serialNumber.number
<i>105</i>&nbsp;    public static final String SERIAL_ID = NAME + DOT + INFO + DOT +
<i>106</i>&nbsp;                               X509CertInfo.SERIAL_NUMBER + DOT +
<i>107</i>&nbsp;                               CertificateSerialNumber.NUMBER;
<i>108</i>&nbsp;    // x509.info.key.value
<i>109</i>&nbsp;    public static final String PUBLIC_KEY = NAME + DOT + INFO + DOT +
<i>110</i>&nbsp;                               X509CertInfo.KEY + DOT +
<i>111</i>&nbsp;                               CertificateX509Key.KEY;
<i>112</i>&nbsp;
<i>113</i>&nbsp;    // x509.info.version.value
<i>114</i>&nbsp;    public static final String VERSION = NAME + DOT + INFO + DOT +
<i>115</i>&nbsp;                               X509CertInfo.VERSION + DOT +
<i>116</i>&nbsp;                               CertificateVersion.VERSION;
<i>117</i>&nbsp;
<i>118</i>&nbsp;    // x509.algorithm
<i>119</i>&nbsp;    public static final String SIG_ALG = NAME + DOT + ALG_ID;
<i>120</i>&nbsp;
<i>121</i>&nbsp;    // x509.signature
<i>122</i>&nbsp;    public static final String SIG = NAME + DOT + SIGNATURE;
<i>123</i>&nbsp;
<i>124</i>&nbsp;    // when we sign and decode we set this to true
<i>125</i>&nbsp;    // this is our means to make certificates immutable
<b class="nc"><i>126</i>&nbsp;    private boolean readOnly = false;</b>
<i>127</i>&nbsp;
<i>128</i>&nbsp;    // Certificate data, and its envelope
<b class="nc"><i>129</i>&nbsp;    private byte[]              signedCert = null;</b>
<b class="nc"><i>130</i>&nbsp;    protected X509CertInfo      info = null;</b>
<b class="nc"><i>131</i>&nbsp;    protected AlgorithmId       algId = null;</b>
<b class="nc"><i>132</i>&nbsp;    protected byte[]            signature = null;</b>
<i>133</i>&nbsp;
<i>134</i>&nbsp;    // recognized extension OIDS
<i>135</i>&nbsp;    private static final String KEY_USAGE_OID = &quot;2.5.29.15&quot;;
<i>136</i>&nbsp;    private static final String EXTENDED_KEY_USAGE_OID = &quot;2.5.29.37&quot;;
<i>137</i>&nbsp;    private static final String BASIC_CONSTRAINT_OID = &quot;2.5.29.19&quot;;
<i>138</i>&nbsp;    private static final String SUBJECT_ALT_NAME_OID = &quot;2.5.29.17&quot;;
<i>139</i>&nbsp;    private static final String ISSUER_ALT_NAME_OID = &quot;2.5.29.18&quot;;
<i>140</i>&nbsp;    private static final String AUTH_INFO_ACCESS_OID = &quot;1.3.6.1.5.5.7.1.1&quot;;
<i>141</i>&nbsp;
<i>142</i>&nbsp;    // number of standard key usage bits.
<i>143</i>&nbsp;    private static final int NUM_STANDARD_KEY_USAGE = 9;
<i>144</i>&nbsp;
<i>145</i>&nbsp;    // SubjectAlterntativeNames cache
<i>146</i>&nbsp;    private Collection&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
<i>147</i>&nbsp;
<i>148</i>&nbsp;    // IssuerAlternativeNames cache
<i>149</i>&nbsp;    private Collection&lt;List&lt;?&gt;&gt; issuerAlternativeNames;
<i>150</i>&nbsp;
<i>151</i>&nbsp;    // ExtendedKeyUsage cache
<i>152</i>&nbsp;    private List&lt;String&gt; extKeyUsage;
<i>153</i>&nbsp;
<i>154</i>&nbsp;    // AuthorityInformationAccess cache
<i>155</i>&nbsp;    private Set&lt;AccessDescription&gt; authInfoAccess;
<i>156</i>&nbsp;
<i>157</i>&nbsp;    /**
<i>158</i>&nbsp;     * PublicKey that has previously been used to verify
<i>159</i>&nbsp;     * the signature of this certificate. Null if the certificate has not
<i>160</i>&nbsp;     * yet been verified.
<i>161</i>&nbsp;     */
<i>162</i>&nbsp;    private PublicKey verifiedPublicKey;
<i>163</i>&nbsp;    /**
<i>164</i>&nbsp;     * If verifiedPublicKey is not null, name of the provider used to
<i>165</i>&nbsp;     * successfully verify the signature of this certificate, or the
<i>166</i>&nbsp;     * empty String if no provider was explicitly specified.
<i>167</i>&nbsp;     */
<i>168</i>&nbsp;    private String verifiedProvider;
<i>169</i>&nbsp;    /**
<i>170</i>&nbsp;     * If verifiedPublicKey is not null, result of the verification using
<i>171</i>&nbsp;     * verifiedPublicKey and verifiedProvider. If true, verification was
<i>172</i>&nbsp;     * successful, if false, it failed.
<i>173</i>&nbsp;     */
<i>174</i>&nbsp;    private boolean verificationResult;
<i>175</i>&nbsp;
<i>176</i>&nbsp;    /**
<i>177</i>&nbsp;     * Default constructor.
<i>178</i>&nbsp;     */
<i>179</i>&nbsp;    public X509CertImpl() { }
<i>180</i>&nbsp;
<i>181</i>&nbsp;    /**
<i>182</i>&nbsp;     * Unmarshals a certificate from its encoded form, parsing the
<i>183</i>&nbsp;     * encoded bytes.  This form of constructor is used by agents which
<i>184</i>&nbsp;     * need to examine and use certificate contents.  That is, this is
<i>185</i>&nbsp;     * one of the more commonly used constructors.  Note that the buffer
<i>186</i>&nbsp;     * must include only a certificate, and no &quot;garbage&quot; may be left at
<i>187</i>&nbsp;     * the end.  If you need to ignore data at the end of a certificate,
<i>188</i>&nbsp;     * use another constructor.
<i>189</i>&nbsp;     *
<i>190</i>&nbsp;     * @param certData the encoded bytes, with no trailing padding.
<i>191</i>&nbsp;     * @exception CertificateException on parsing and initialization errors.
<i>192</i>&nbsp;     */
<b class="nc"><i>193</i>&nbsp;    public X509CertImpl(byte[] certData) throws CertificateException {</b>
<i>194</i>&nbsp;        try {
<b class="nc"><i>195</i>&nbsp;            parse(new DerValue(certData));</b>
<b class="nc"><i>196</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i>197</i>&nbsp;            signedCert = null;</b>
<b class="nc"><i>198</i>&nbsp;            throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);</b>
<b class="nc"><i>199</i>&nbsp;        }</b>
<i>200</i>&nbsp;    }
<i>201</i>&nbsp;
<i>202</i>&nbsp;    /**
<i>203</i>&nbsp;     * unmarshals an X.509 certificate from an input stream.  If the
<i>204</i>&nbsp;     * certificate is RFC1421 hex-encoded, then it must begin with
<i>205</i>&nbsp;     * the line X509Factory.BEGIN_CERT and end with the line
<i>206</i>&nbsp;     * X509Factory.END_CERT.
<i>207</i>&nbsp;     *
<i>208</i>&nbsp;     * @param in an input stream holding at least one certificate that may
<i>209</i>&nbsp;     *        be either DER-encoded or RFC1421 hex-encoded version of the
<i>210</i>&nbsp;     *        DER-encoded certificate.
<i>211</i>&nbsp;     * @exception CertificateException on parsing and initialization errors.
<i>212</i>&nbsp;     */
<b class="nc"><i>213</i>&nbsp;    public X509CertImpl(InputStream in) throws CertificateException {</b>
<i>214</i>&nbsp;
<b class="nc"><i>215</i>&nbsp;        DerValue der = null;</b>
<i>216</i>&nbsp;
<b class="nc"><i>217</i>&nbsp;        BufferedInputStream inBuffered = new BufferedInputStream(in);</b>
<i>218</i>&nbsp;
<i>219</i>&nbsp;        // First try reading stream as HEX-encoded DER-encoded bytes,
<i>220</i>&nbsp;        // since not mistakable for raw DER
<i>221</i>&nbsp;        try {
<b class="nc"><i>222</i>&nbsp;            inBuffered.mark(Integer.MAX_VALUE);</b>
<b class="nc"><i>223</i>&nbsp;            der = readRFC1421Cert(inBuffered);</b>
<b class="nc"><i>224</i>&nbsp;        } catch (IOException ioe) {</b>
<i>225</i>&nbsp;            try {
<i>226</i>&nbsp;                // Next, try reading stream as raw DER-encoded bytes
<b class="nc"><i>227</i>&nbsp;                inBuffered.reset();</b>
<b class="nc"><i>228</i>&nbsp;                der = new DerValue(inBuffered);</b>
<b class="nc"><i>229</i>&nbsp;            } catch (IOException ioe1) {</b>
<b class="nc"><i>230</i>&nbsp;                throw new CertificateException(&quot;Input stream must be &quot; +</b>
<i>231</i>&nbsp;                                               &quot;either DER-encoded bytes &quot; +
<i>232</i>&nbsp;                                               &quot;or RFC1421 hex-encoded &quot; +
<i>233</i>&nbsp;                                               &quot;DER-encoded bytes: &quot; +
<b class="nc"><i>234</i>&nbsp;                                               ioe1.getMessage(), ioe1);</b>
<b class="nc"><i>235</i>&nbsp;            }</b>
<b class="nc"><i>236</i>&nbsp;        }</b>
<i>237</i>&nbsp;        try {
<b class="nc"><i>238</i>&nbsp;            parse(der);</b>
<b class="nc"><i>239</i>&nbsp;        } catch (IOException ioe) {</b>
<b class="nc"><i>240</i>&nbsp;            signedCert = null;</b>
<b class="nc"><i>241</i>&nbsp;            throw new CertificateException(&quot;Unable to parse DER value of &quot; +</b>
<i>242</i>&nbsp;                                           &quot;certificate, &quot; + ioe, ioe);
<b class="nc"><i>243</i>&nbsp;        }</b>
<i>244</i>&nbsp;    }
<i>245</i>&nbsp;
<i>246</i>&nbsp;    /**
<i>247</i>&nbsp;     * read input stream as HEX-encoded DER-encoded bytes
<i>248</i>&nbsp;     *
<i>249</i>&nbsp;     * @param in InputStream to read
<i>250</i>&nbsp;     * @return DerValue corresponding to decoded HEX-encoded bytes
<i>251</i>&nbsp;     * @throws IOException if stream can not be interpreted as RFC1421
<i>252</i>&nbsp;     *                     encoded bytes
<i>253</i>&nbsp;     */
<i>254</i>&nbsp;    private DerValue readRFC1421Cert(InputStream in) throws IOException {
<b class="nc"><i>255</i>&nbsp;        DerValue der = null;</b>
<b class="nc"><i>256</i>&nbsp;        String line = null;</b>
<b class="nc"><i>257</i>&nbsp;        BufferedReader certBufferedReader =</b>
<i>258</i>&nbsp;            new BufferedReader(new InputStreamReader(in, &quot;ASCII&quot;));
<i>259</i>&nbsp;        try {
<b class="nc"><i>260</i>&nbsp;            line = certBufferedReader.readLine();</b>
<b class="nc"><i>261</i>&nbsp;        } catch (IOException ioe1) {</b>
<b class="nc"><i>262</i>&nbsp;            throw new IOException(&quot;Unable to read InputStream: &quot; +</b>
<b class="nc"><i>263</i>&nbsp;                                  ioe1.getMessage());</b>
<b class="nc"><i>264</i>&nbsp;        }</b>
<b class="nc"><i>265</i>&nbsp;        if (line.equals(X509Factory.BEGIN_CERT)) {</b>
<i>266</i>&nbsp;            /* stream appears to be hex-encoded bytes */
<b class="nc"><i>267</i>&nbsp;            ByteArrayOutputStream decstream = new ByteArrayOutputStream();</b>
<i>268</i>&nbsp;            try {
<b class="nc"><i>269</i>&nbsp;                while ((line = certBufferedReader.readLine()) != null) {</b>
<b class="nc"><i>270</i>&nbsp;                    if (line.equals(X509Factory.END_CERT)) {</b>
<b class="nc"><i>271</i>&nbsp;                        der = new DerValue(decstream.toByteArray());</b>
<b class="nc"><i>272</i>&nbsp;                        break;</b>
<i>273</i>&nbsp;                    } else {
<b class="nc"><i>274</i>&nbsp;                        decstream.write(Pem.decode(line));</b>
<i>275</i>&nbsp;                    }
<i>276</i>&nbsp;                }
<b class="nc"><i>277</i>&nbsp;            } catch (IOException ioe2) {</b>
<b class="nc"><i>278</i>&nbsp;                throw new IOException(&quot;Unable to read InputStream: &quot;</b>
<b class="nc"><i>279</i>&nbsp;                                      + ioe2.getMessage());</b>
<b class="nc"><i>280</i>&nbsp;            }</b>
<b class="nc"><i>281</i>&nbsp;        } else {</b>
<b class="nc"><i>282</i>&nbsp;            throw new IOException(&quot;InputStream is not RFC1421 hex-encoded &quot; +</b>
<i>283</i>&nbsp;                                  &quot;DER bytes&quot;);
<i>284</i>&nbsp;        }
<b class="nc"><i>285</i>&nbsp;        return der;</b>
<i>286</i>&nbsp;    }
<i>287</i>&nbsp;
<i>288</i>&nbsp;    /**
<i>289</i>&nbsp;     * Construct an initialized X509 Certificate. The certificate is stored
<i>290</i>&nbsp;     * in raw form and has to be signed to be useful.
<i>291</i>&nbsp;     *
<i>292</i>&nbsp;     * @param certInfo the X509CertificateInfo which the Certificate is to be
<i>293</i>&nbsp;     *             created from.
<i>294</i>&nbsp;     */
<b class="nc"><i>295</i>&nbsp;    public X509CertImpl(X509CertInfo certInfo) {</b>
<b class="nc"><i>296</i>&nbsp;        this.info = certInfo;</b>
<i>297</i>&nbsp;    }
<i>298</i>&nbsp;
<i>299</i>&nbsp;    /**
<i>300</i>&nbsp;     * Unmarshal a certificate from its encoded form, parsing a DER value.
<i>301</i>&nbsp;     * This form of constructor is used by agents which need to examine
<i>302</i>&nbsp;     * and use certificate contents.
<i>303</i>&nbsp;     *
<i>304</i>&nbsp;     * @param derVal the der value containing the encoded cert.
<i>305</i>&nbsp;     * @exception CertificateException on parsing and initialization errors.
<i>306</i>&nbsp;     */
<b class="nc"><i>307</i>&nbsp;    public X509CertImpl(DerValue derVal) throws CertificateException {</b>
<i>308</i>&nbsp;        try {
<b class="nc"><i>309</i>&nbsp;            parse(derVal);</b>
<b class="nc"><i>310</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i>311</i>&nbsp;            signedCert = null;</b>
<b class="nc"><i>312</i>&nbsp;            throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);</b>
<b class="nc"><i>313</i>&nbsp;        }</b>
<i>314</i>&nbsp;    }
<i>315</i>&nbsp;
<i>316</i>&nbsp;    /**
<i>317</i>&nbsp;     * Appends the certificate to an output stream.
<i>318</i>&nbsp;     *
<i>319</i>&nbsp;     * @param out an input stream to which the certificate is appended.
<i>320</i>&nbsp;     * @exception CertificateEncodingException on encoding errors.
<i>321</i>&nbsp;     */
<i>322</i>&nbsp;    public void encode(OutputStream out)
<i>323</i>&nbsp;    throws CertificateEncodingException {
<b class="nc"><i>324</i>&nbsp;        if (signedCert == null)</b>
<b class="nc"><i>325</i>&nbsp;            throw new CertificateEncodingException(</b>
<i>326</i>&nbsp;                          &quot;Null certificate to encode&quot;);
<i>327</i>&nbsp;        try {
<b class="nc"><i>328</i>&nbsp;            out.write(signedCert.clone());</b>
<b class="nc"><i>329</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i>330</i>&nbsp;            throw new CertificateEncodingException(e.toString());</b>
<b class="nc"><i>331</i>&nbsp;        }</b>
<i>332</i>&nbsp;    }
<i>333</i>&nbsp;
<i>334</i>&nbsp;    /**
<i>335</i>&nbsp;     * DER encode this object onto an output stream.
<i>336</i>&nbsp;     * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
<i>337</i>&nbsp;     *
<i>338</i>&nbsp;     * @param out the output stream on which to write the DER encoding.
<i>339</i>&nbsp;     *
<i>340</i>&nbsp;     * @exception IOException on encoding error.
<i>341</i>&nbsp;     */
<i>342</i>&nbsp;    public void derEncode(OutputStream out) throws IOException {
<b class="nc"><i>343</i>&nbsp;        if (signedCert == null)</b>
<b class="nc"><i>344</i>&nbsp;            throw new IOException(&quot;Null certificate to encode&quot;);</b>
<b class="nc"><i>345</i>&nbsp;        out.write(signedCert.clone());</b>
<i>346</i>&nbsp;    }
<i>347</i>&nbsp;
<i>348</i>&nbsp;    /**
<i>349</i>&nbsp;     * Returns the encoded form of this certificate. It is
<i>350</i>&nbsp;     * assumed that each certificate type would have only a single
<i>351</i>&nbsp;     * form of encoding; for example, X.509 certificates would
<i>352</i>&nbsp;     * be encoded as ASN.1 DER.
<i>353</i>&nbsp;     *
<i>354</i>&nbsp;     * @exception CertificateEncodingException if an encoding error occurs.
<i>355</i>&nbsp;     */
<i>356</i>&nbsp;    public byte[] getEncoded() throws CertificateEncodingException {
<b class="nc"><i>357</i>&nbsp;        return getEncodedInternal().clone();</b>
<i>358</i>&nbsp;    }
<i>359</i>&nbsp;
<i>360</i>&nbsp;    /**
<i>361</i>&nbsp;     * Returned the encoding as an uncloned byte array. Callers must
<i>362</i>&nbsp;     * guarantee that they neither modify it nor expose it to untrusted
<i>363</i>&nbsp;     * code.
<i>364</i>&nbsp;     */
<i>365</i>&nbsp;    public byte[] getEncodedInternal() throws CertificateEncodingException {
<b class="nc"><i>366</i>&nbsp;        if (signedCert == null) {</b>
<b class="nc"><i>367</i>&nbsp;            throw new CertificateEncodingException(</b>
<i>368</i>&nbsp;                          &quot;Null certificate to encode&quot;);
<i>369</i>&nbsp;        }
<b class="nc"><i>370</i>&nbsp;        return signedCert;</b>
<i>371</i>&nbsp;    }
<i>372</i>&nbsp;
<i>373</i>&nbsp;    /**
<i>374</i>&nbsp;     * Throws an exception if the certificate was not signed using the
<i>375</i>&nbsp;     * verification key provided.  Successfully verifying a certificate
<i>376</i>&nbsp;     * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
<i>377</i>&nbsp;     * it represents.
<i>378</i>&nbsp;     *
<i>379</i>&nbsp;     * @param key the public key used for verification.
<i>380</i>&nbsp;     *
<i>381</i>&nbsp;     * @exception InvalidKeyException on incorrect key.
<i>382</i>&nbsp;     * @exception NoSuchAlgorithmException on unsupported signature
<i>383</i>&nbsp;     * algorithms.
<i>384</i>&nbsp;     * @exception NoSuchProviderException if there&#39;s no default provider.
<i>385</i>&nbsp;     * @exception SignatureException on signature errors.
<i>386</i>&nbsp;     * @exception CertificateException on encoding errors.
<i>387</i>&nbsp;     */
<i>388</i>&nbsp;    public void verify(PublicKey key)
<i>389</i>&nbsp;    throws CertificateException, NoSuchAlgorithmException,
<i>390</i>&nbsp;        InvalidKeyException, NoSuchProviderException, SignatureException {
<i>391</i>&nbsp;        verify(key, &quot;&quot;);
<b class="nc"><i>392</i>&nbsp;    }</b>
<i>393</i>&nbsp;
<i>394</i>&nbsp;    /**
<i>395</i>&nbsp;     * Throws an exception if the certificate was not signed using the
<i>396</i>&nbsp;     * verification key provided.  Successfully verifying a certificate
<i>397</i>&nbsp;     * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
<i>398</i>&nbsp;     * it represents.
<i>399</i>&nbsp;     *
<i>400</i>&nbsp;     * @param key the public key used for verification.
<i>401</i>&nbsp;     * @param sigProvider the name of the provider.
<i>402</i>&nbsp;     *
<i>403</i>&nbsp;     * @exception NoSuchAlgorithmException on unsupported signature
<i>404</i>&nbsp;     * algorithms.
<i>405</i>&nbsp;     * @exception InvalidKeyException on incorrect key.
<i>406</i>&nbsp;     * @exception NoSuchProviderException on incorrect provider.
<i>407</i>&nbsp;     * @exception SignatureException on signature errors.
<i>408</i>&nbsp;     * @exception CertificateException on encoding errors.
<i>409</i>&nbsp;     */
<i>410</i>&nbsp;    public synchronized void verify(PublicKey key, String sigProvider)
<i>411</i>&nbsp;            throws CertificateException, NoSuchAlgorithmException,
<i>412</i>&nbsp;            InvalidKeyException, NoSuchProviderException, SignatureException {
<i>413</i>&nbsp;        if (sigProvider == null) {
<b class="nc"><i>414</i>&nbsp;            sigProvider = &quot;&quot;;</b>
<b class="nc"><i>415</i>&nbsp;        }</b>
<i>416</i>&nbsp;        if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {
<b class="nc"><i>417</i>&nbsp;            // this certificate has already been verified using</b>
<i>418</i>&nbsp;            // this public key. Make sure providers match, too.
<i>419</i>&nbsp;            if (sigProvider.equals(verifiedProvider)) {
<b class="nc"><i>420</i>&nbsp;                if (verificationResult) {</b>
<b class="nc"><i>421</i>&nbsp;                    return;</b>
<i>422</i>&nbsp;                } else {
<i>423</i>&nbsp;                    throw new SignatureException(&quot;Signature does not match.&quot;);
<b class="nc"><i>424</i>&nbsp;                }</b>
<i>425</i>&nbsp;            }
<i>426</i>&nbsp;        }
<i>427</i>&nbsp;        if (signedCert == null) {
<b class="nc"><i>428</i>&nbsp;            throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);</b>
<b class="nc"><i>429</i>&nbsp;        }</b>
<i>430</i>&nbsp;        // Verify the signature ...
<i>431</i>&nbsp;        Signature sigVerf = null;
<b class="nc"><i>432</i>&nbsp;        if (sigProvider.length() == 0) {</b>
<b class="nc"><i>433</i>&nbsp;            sigVerf = Signature.getInstance(algId.getName());</b>
<b class="nc"><i>434</i>&nbsp;        } else {</b>
<i>435</i>&nbsp;            sigVerf = Signature.getInstance(algId.getName(), sigProvider);
<b class="nc"><i>436</i>&nbsp;        }</b>
<i>437</i>&nbsp;
<b class="nc"><i>438</i>&nbsp;        sigVerf.initVerify(key);</b>
<i>439</i>&nbsp;
<b class="nc"><i>440</i>&nbsp;        // set parameters after Signature.initSign/initVerify call,</b>
<b class="nc"><i>441</i>&nbsp;        // so the deferred provider selection happens when key is set</b>
<i>442</i>&nbsp;        try {
<i>443</i>&nbsp;            SignatureUtil.specialSetParameter(sigVerf, getSigAlgParams());
<b class="nc"><i>444</i>&nbsp;        } catch (ProviderException e) {</b>
<b class="nc"><i>445</i>&nbsp;            throw new CertificateException(e.getMessage(), e.getCause());</b>
<b class="nc"><i>446</i>&nbsp;        } catch (InvalidAlgorithmParameterException e) {</b>
<i>447</i>&nbsp;            throw new CertificateException(e);
<b class="nc"><i>448</i>&nbsp;        }</b>
<b class="nc"><i>449</i>&nbsp;</b>
<i>450</i>&nbsp;        byte[] rawCert = info.getEncodedInfo();
<i>451</i>&nbsp;        sigVerf.update(rawCert, 0, rawCert.length);
<i>452</i>&nbsp;
<i>453</i>&nbsp;        // verify may throw SignatureException for invalid encodings, etc.
<i>454</i>&nbsp;        verificationResult = sigVerf.verify(signature);
<i>455</i>&nbsp;        verifiedPublicKey = key;
<i>456</i>&nbsp;        verifiedProvider = sigProvider;
<i>457</i>&nbsp;
<i>458</i>&nbsp;        if (verificationResult == false) {
<i>459</i>&nbsp;            throw new SignatureException(&quot;Signature does not match.&quot;);
<i>460</i>&nbsp;        }
<i>461</i>&nbsp;    }
<i>462</i>&nbsp;
<i>463</i>&nbsp;    /**
<i>464</i>&nbsp;     * Throws an exception if the certificate was not signed using the
<i>465</i>&nbsp;     * verification key provided.  This method uses the signature verification
<i>466</i>&nbsp;     * engine supplied by the specified provider. Note that the specified
<i>467</i>&nbsp;     * Provider object does not have to be registered in the provider list.
<i>468</i>&nbsp;     * Successfully verifying a certificate does &lt;em&gt;not&lt;/em&gt; indicate that one
<i>469</i>&nbsp;     * should trust the entity which it represents.
<i>470</i>&nbsp;     *
<i>471</i>&nbsp;     * @param key the public key used for verification.
<i>472</i>&nbsp;     * @param sigProvider the provider.
<b class="nc"><i>473</i>&nbsp;     *</b>
<b class="nc"><i>474</i>&nbsp;     * @exception NoSuchAlgorithmException on unsupported signature</b>
<i>475</i>&nbsp;     * algorithms.
<i>476</i>&nbsp;     * @exception InvalidKeyException on incorrect key.
<b class="nc"><i>477</i>&nbsp;     * @exception SignatureException on signature errors.</b>
<b class="nc"><i>478</i>&nbsp;     * @exception CertificateException on encoding errors.</b>
<b class="nc"><i>479</i>&nbsp;     */</b>
<i>480</i>&nbsp;    public synchronized void verify(PublicKey key, Provider sigProvider)
<b class="nc"><i>481</i>&nbsp;            throws CertificateException, NoSuchAlgorithmException,</b>
<i>482</i>&nbsp;            InvalidKeyException, SignatureException {
<b class="nc"><i>483</i>&nbsp;        if (signedCert == null) {</b>
<i>484</i>&nbsp;            throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);
<b class="nc"><i>485</i>&nbsp;        }</b>
<b class="nc"><i>486</i>&nbsp;        // Verify the signature ...</b>
<i>487</i>&nbsp;        Signature sigVerf = null;
<i>488</i>&nbsp;        if (sigProvider == null) {
<b class="nc"><i>489</i>&nbsp;            sigVerf = Signature.getInstance(algId.getName());</b>
<b class="nc"><i>490</i>&nbsp;        } else {</b>
<i>491</i>&nbsp;            sigVerf = Signature.getInstance(algId.getName(), sigProvider);
<b class="nc"><i>492</i>&nbsp;        }</b>
<b class="nc"><i>493</i>&nbsp;</b>
<i>494</i>&nbsp;        sigVerf.initVerify(key);
<i>495</i>&nbsp;
<i>496</i>&nbsp;        // set parameters after Signature.initSign/initVerify call,
<i>497</i>&nbsp;        // so the deferred provider selection happens when key is set
<i>498</i>&nbsp;        try {
<i>499</i>&nbsp;            SignatureUtil.specialSetParameter(sigVerf, getSigAlgParams());
<i>500</i>&nbsp;        } catch (ProviderException e) {
<i>501</i>&nbsp;            throw new CertificateException(e.getMessage(), e.getCause());
<i>502</i>&nbsp;        } catch (InvalidAlgorithmParameterException e) {
<i>503</i>&nbsp;            throw new CertificateException(e);
<i>504</i>&nbsp;        }
<i>505</i>&nbsp;
<b class="nc"><i>506</i>&nbsp;        byte[] rawCert = info.getEncodedInfo();</b>
<i>507</i>&nbsp;        sigVerf.update(rawCert, 0, rawCert.length);
<i>508</i>&nbsp;
<i>509</i>&nbsp;        // verify may throw SignatureException for invalid encodings, etc.
<i>510</i>&nbsp;        verificationResult = sigVerf.verify(signature);
<i>511</i>&nbsp;        verifiedPublicKey = key;
<i>512</i>&nbsp;
<i>513</i>&nbsp;        if (verificationResult == false) {
<i>514</i>&nbsp;            throw new SignatureException(&quot;Signature does not match.&quot;);
<i>515</i>&nbsp;        }
<i>516</i>&nbsp;    }
<i>517</i>&nbsp;
<i>518</i>&nbsp;    /**
<i>519</i>&nbsp;     * Creates an X.509 certificate, and signs it using the given key
<i>520</i>&nbsp;     * (associating a signature algorithm and an X.500 name).
<i>521</i>&nbsp;     * This operation is used to implement the certificate generation
<i>522</i>&nbsp;     * functionality of a certificate authority.
<i>523</i>&nbsp;     *
<i>524</i>&nbsp;     * @param key the private key used for signing.
<i>525</i>&nbsp;     * @param algorithm the name of the signature algorithm used.
<i>526</i>&nbsp;     *
<i>527</i>&nbsp;     * @exception InvalidKeyException on incorrect key.
<b class="nc"><i>528</i>&nbsp;     * @exception NoSuchAlgorithmException on unsupported signature</b>
<i>529</i>&nbsp;     * algorithms.
<i>530</i>&nbsp;     * @exception NoSuchProviderException if there&#39;s no default provider.
<i>531</i>&nbsp;     * @exception SignatureException on signature errors.
<i>532</i>&nbsp;     * @exception CertificateException on encoding errors.
<i>533</i>&nbsp;     */
<i>534</i>&nbsp;    public void sign(PrivateKey key, String algorithm)
<i>535</i>&nbsp;    throws CertificateException, NoSuchAlgorithmException,
<i>536</i>&nbsp;        InvalidKeyException, NoSuchProviderException, SignatureException {
<i>537</i>&nbsp;        sign(key, algorithm, null);
<i>538</i>&nbsp;    }
<i>539</i>&nbsp;
<i>540</i>&nbsp;    /**
<i>541</i>&nbsp;     * Creates an X.509 certificate, and signs it using the given key
<i>542</i>&nbsp;     * (associating a signature algorithm and an X.500 name).
<i>543</i>&nbsp;     * This operation is used to implement the certificate generation
<i>544</i>&nbsp;     * functionality of a certificate authority.
<i>545</i>&nbsp;     *
<i>546</i>&nbsp;     * @param key the private key used for signing.
<i>547</i>&nbsp;     * @param algorithm the name of the signature algorithm used.
<i>548</i>&nbsp;     * @param provider the name of the provider.
<i>549</i>&nbsp;     *
<i>550</i>&nbsp;     * @exception NoSuchAlgorithmException on unsupported signature
<i>551</i>&nbsp;     * algorithms.
<b class="nc"><i>552</i>&nbsp;     * @exception InvalidKeyException on incorrect key.</b>
<b class="nc"><i>553</i>&nbsp;     * @exception NoSuchProviderException on incorrect provider.</b>
<i>554</i>&nbsp;     * @exception SignatureException on signature errors.
<b class="nc"><i>555</i>&nbsp;     * @exception CertificateException on encoding errors.</b>
<b class="nc"><i>556</i>&nbsp;     */</b>
<b class="nc"><i>557</i>&nbsp;    public void sign(PrivateKey key, String algorithm, String provider)</b>
<i>558</i>&nbsp;    throws CertificateException, NoSuchAlgorithmException,
<b class="nc"><i>559</i>&nbsp;        InvalidKeyException, NoSuchProviderException, SignatureException {</b>
<i>560</i>&nbsp;        try {
<b class="nc"><i>561</i>&nbsp;            sign(key, null, algorithm, provider);</b>
<i>562</i>&nbsp;        } catch (InvalidAlgorithmParameterException e) {
<i>563</i>&nbsp;            // should not happen; re-throw just in case
<b class="nc"><i>564</i>&nbsp;            throw new SignatureException(e);</b>
<i>565</i>&nbsp;        }
<b class="nc"><i>566</i>&nbsp;    }</b>
<b class="nc"><i>567</i>&nbsp;</b>
<i>568</i>&nbsp;    /**
<i>569</i>&nbsp;     * Creates an X.509 certificate, and signs it using the given key
<b class="nc"><i>570</i>&nbsp;     * (associating a signature algorithm and an X.500 name), signature</b>
<b class="nc"><i>571</i>&nbsp;     * parameters, and security provider. If the given provider name</b>
<i>572</i>&nbsp;     * is null or empty, the implementation look up will be based on
<i>573</i>&nbsp;     * provider configurations.
<b class="nc"><i>574</i>&nbsp;     * This operation is used to implement the certificate generation</b>
<i>575</i>&nbsp;     * functionality of a certificate authority.
<i>576</i>&nbsp;     *
<b class="nc"><i>577</i>&nbsp;     * @param key the private key used for signing</b>
<b class="nc"><i>578</i>&nbsp;     * @param signingParams the parameters used for signing</b>
<b class="nc"><i>579</i>&nbsp;     * @param algorithm the name of the signature algorithm used</b>
<i>580</i>&nbsp;     * @param provider the name of the provider, may be null
<i>581</i>&nbsp;     *
<b class="nc"><i>582</i>&nbsp;     * @exception NoSuchAlgorithmException on unsupported signature</b>
<b class="nc"><i>583</i>&nbsp;     *            algorithms</b>
<b class="nc"><i>584</i>&nbsp;     * @exception InvalidKeyException on incorrect key</b>
<i>585</i>&nbsp;     * @exception InvalidAlgorithmParameterException on invalid signature
<b class="nc"><i>586</i>&nbsp;     *            parameters</b>
<b class="nc"><i>587</i>&nbsp;     * @exception NoSuchProviderException on incorrect provider</b>
<b class="nc"><i>588</i>&nbsp;     * @exception SignatureException on signature errors</b>
<i>589</i>&nbsp;     * @exception CertificateException on encoding errors
<i>590</i>&nbsp;     */
<i>591</i>&nbsp;    public void sign(PrivateKey key, AlgorithmParameterSpec signingParams,
<i>592</i>&nbsp;            String algorithm, String provider)
<i>593</i>&nbsp;            throws CertificateException, NoSuchAlgorithmException,
<i>594</i>&nbsp;            InvalidKeyException, InvalidAlgorithmParameterException,
<i>595</i>&nbsp;            NoSuchProviderException, SignatureException {
<i>596</i>&nbsp;        try {
<i>597</i>&nbsp;            if (readOnly)
<i>598</i>&nbsp;                throw new CertificateEncodingException(
<i>599</i>&nbsp;                              &quot;cannot over-write existing certificate&quot;);
<i>600</i>&nbsp;            Signature sigEngine = null;
<b class="nc"><i>601</i>&nbsp;            if ((provider == null) || (provider.length() == 0))</b>
<b class="nc"><i>602</i>&nbsp;                sigEngine = Signature.getInstance(algorithm);</b>
<i>603</i>&nbsp;            else
<i>604</i>&nbsp;                sigEngine = Signature.getInstance(algorithm, provider);
<i>605</i>&nbsp;
<i>606</i>&nbsp;            sigEngine.initSign(key);
<i>607</i>&nbsp;
<i>608</i>&nbsp;            // set parameters after Signature.initSign/initVerify call, so
<i>609</i>&nbsp;            // the deferred provider selection happens when the key is set
<i>610</i>&nbsp;            try {
<i>611</i>&nbsp;                sigEngine.setParameter(signingParams);
<i>612</i>&nbsp;            } catch (UnsupportedOperationException e) {
<i>613</i>&nbsp;                // for backward compatibility, only re-throw when
<i>614</i>&nbsp;                // parameters is not null
<i>615</i>&nbsp;                if (signingParams != null) throw e;
<i>616</i>&nbsp;            }
<i>617</i>&nbsp;
<i>618</i>&nbsp;            // in case the name is reset
<i>619</i>&nbsp;            if (signingParams != null) {
<i>620</i>&nbsp;                algId = AlgorithmId.get(sigEngine.getParameters());
<b class="nc"><i>621</i>&nbsp;            } else {</b>
<i>622</i>&nbsp;                algId = AlgorithmId.get(algorithm);
<b class="nc"><i>623</i>&nbsp;            }</b>
<b class="nc"><i>624</i>&nbsp;            DerOutputStream out = new DerOutputStream();</b>
<b class="nc"><i>625</i>&nbsp;            DerOutputStream tmp = new DerOutputStream();</b>
<b class="nc"><i>626</i>&nbsp;</b>
<b class="nc"><i>627</i>&nbsp;            // encode certificate info</b>
<b class="nc"><i>628</i>&nbsp;            info.encode(tmp);</b>
<b class="nc"><i>629</i>&nbsp;            byte[] rawCert = tmp.toByteArray();</b>
<i>630</i>&nbsp;
<i>631</i>&nbsp;            // encode algorithm identifier
<i>632</i>&nbsp;            algId.encode(tmp);
<i>633</i>&nbsp;
<i>634</i>&nbsp;            // Create and encode the signature itself.
<i>635</i>&nbsp;            sigEngine.update(rawCert, 0, rawCert.length);
<i>636</i>&nbsp;            signature = sigEngine.sign();
<i>637</i>&nbsp;            tmp.putBitString(signature);
<i>638</i>&nbsp;
<i>639</i>&nbsp;            // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
<i>640</i>&nbsp;            out.write(DerValue.tag_Sequence, tmp);
<i>641</i>&nbsp;            signedCert = out.toByteArray();
<i>642</i>&nbsp;            readOnly = true;
<i>643</i>&nbsp;
<b class="nc"><i>644</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i>645</i>&nbsp;            throw new CertificateEncodingException(e.toString());</b>
<b class="nc"><i>646</i>&nbsp;      }</b>
<b class="nc"><i>647</i>&nbsp;    }</b>
<i>648</i>&nbsp;
<i>649</i>&nbsp;    /**
<i>650</i>&nbsp;     * Checks that the certificate is currently valid, i.e. the current
<b class="nc"><i>651</i>&nbsp;     * time is within the specified validity period.</b>
<b class="nc"><i>652</i>&nbsp;     *</b>
<i>653</i>&nbsp;     * @exception CertificateExpiredException if the certificate has expired.
<b class="nc"><i>654</i>&nbsp;     * @exception CertificateNotYetValidException if the certificate is not</b>
<b class="nc"><i>655</i>&nbsp;     * yet valid.</b>
<b class="nc"><i>656</i>&nbsp;     */</b>
<i>657</i>&nbsp;    public void checkValidity()
<b class="nc"><i>658</i>&nbsp;    throws CertificateExpiredException, CertificateNotYetValidException {</b>
<i>659</i>&nbsp;        Date date = new Date();
<b class="nc"><i>660</i>&nbsp;        checkValidity(date);</b>
<b class="nc"><i>661</i>&nbsp;    }</b>
<b class="nc"><i>662</i>&nbsp;</b>
<b class="nc"><i>663</i>&nbsp;    /**</b>
<b class="nc"><i>664</i>&nbsp;     * Checks that the specified date is within the certificate&#39;s</b>
<i>665</i>&nbsp;     * validity period, or basically if the certificate would be
<i>666</i>&nbsp;     * valid at the specified date/time.
<b class="nc"><i>667</i>&nbsp;     *</b>
<i>668</i>&nbsp;     * @param date the Date to check against to see if this certificate
<b class="nc"><i>669</i>&nbsp;     *        is valid at that date/time.</b>
<b class="nc"><i>670</i>&nbsp;     *</b>
<b class="nc"><i>671</i>&nbsp;     * @exception CertificateExpiredException if the certificate has expired</b>
<b class="nc"><i>672</i>&nbsp;     * with respect to the &lt;code&gt;date&lt;/code&gt; supplied.</b>
<b class="nc"><i>673</i>&nbsp;     * @exception CertificateNotYetValidException if the certificate is not</b>
<i>674</i>&nbsp;     * yet valid with respect to the &lt;code&gt;date&lt;/code&gt; supplied.
<b class="nc"><i>675</i>&nbsp;     */</b>
<b class="nc"><i>676</i>&nbsp;    public void checkValidity(Date date)</b>
<b class="nc"><i>677</i>&nbsp;    throws CertificateExpiredException, CertificateNotYetValidException {</b>
<b class="nc"><i>678</i>&nbsp;</b>
<i>679</i>&nbsp;        CertificateValidity interval = null;
<b class="nc"><i>680</i>&nbsp;        try {</b>
<i>681</i>&nbsp;            interval = (CertificateValidity)info.get(CertificateValidity.NAME);
<b class="nc"><i>682</i>&nbsp;        } catch (Exception e) {</b>
<i>683</i>&nbsp;            throw new CertificateNotYetValidException(&quot;Incorrect validity period&quot;);
<i>684</i>&nbsp;        }
<i>685</i>&nbsp;        if (interval == null)
<i>686</i>&nbsp;            throw new CertificateNotYetValidException(&quot;Null validity period&quot;);
<i>687</i>&nbsp;        interval.valid(date);
<i>688</i>&nbsp;    }
<i>689</i>&nbsp;
<i>690</i>&nbsp;    /**
<i>691</i>&nbsp;     * Return the requested attribute from the certificate.
<i>692</i>&nbsp;     *
<i>693</i>&nbsp;     * Note that the X509CertInfo is not cloned for performance reasons.
<i>694</i>&nbsp;     * Callers must ensure that they do not modify it. All other
<i>695</i>&nbsp;     * attributes are cloned.
<i>696</i>&nbsp;     *
<i>697</i>&nbsp;     * @param name the name of the attribute.
<b class="nc"><i>698</i>&nbsp;     * @exception CertificateParsingException on invalid attribute identifier.</b>
<b class="nc"><i>699</i>&nbsp;     */</b>
<i>700</i>&nbsp;    public Object get(String name)
<i>701</i>&nbsp;    throws CertificateParsingException {
<b class="nc"><i>702</i>&nbsp;        X509AttributeName attr = new X509AttributeName(name);</b>
<b class="nc"><i>703</i>&nbsp;        String id = attr.getPrefix();</b>
<b class="nc"><i>704</i>&nbsp;        if (!(id.equalsIgnoreCase(NAME))) {</b>
<b class="nc"><i>705</i>&nbsp;            throw new CertificateParsingException(&quot;Invalid root of &quot;</b>
<i>706</i>&nbsp;                          + &quot;attribute name, expected [&quot; + NAME +
<i>707</i>&nbsp;                          &quot;], received &quot; + &quot;[&quot; + id + &quot;]&quot;);
<b class="nc"><i>708</i>&nbsp;        }</b>
<b class="nc"><i>709</i>&nbsp;        attr = new X509AttributeName(attr.getSuffix());</b>
<i>710</i>&nbsp;        id = attr.getPrefix();
<b class="nc"><i>711</i>&nbsp;</b>
<b class="nc"><i>712</i>&nbsp;        if (id.equalsIgnoreCase(INFO)) {</b>
<b class="nc"><i>713</i>&nbsp;            if (info == null) {</b>
<b class="nc"><i>714</i>&nbsp;                return null;</b>
<i>715</i>&nbsp;            }
<i>716</i>&nbsp;            if (attr.getSuffix() != null) {
<b class="nc"><i>717</i>&nbsp;                try {</b>
<b class="nc"><i>718</i>&nbsp;                    return info.get(attr.getSuffix());</b>
<i>719</i>&nbsp;                } catch (IOException e) {
<b class="nc"><i>720</i>&nbsp;                    throw new CertificateParsingException(e.toString());</b>
<b class="nc"><i>721</i>&nbsp;                } catch (CertificateException e) {</b>
<i>722</i>&nbsp;                    throw new CertificateParsingException(e.toString());
<i>723</i>&nbsp;                }
<b class="nc"><i>724</i>&nbsp;            } else {</b>
<i>725</i>&nbsp;                return info;
<i>726</i>&nbsp;            }
<i>727</i>&nbsp;        } else if (id.equalsIgnoreCase(ALG_ID)) {
<i>728</i>&nbsp;            return(algId);
<i>729</i>&nbsp;        } else if (id.equalsIgnoreCase(SIGNATURE)) {
<i>730</i>&nbsp;            if (signature != null)
<i>731</i>&nbsp;                return signature.clone();
<i>732</i>&nbsp;            else
<i>733</i>&nbsp;                return null;
<i>734</i>&nbsp;        } else if (id.equalsIgnoreCase(SIGNED_CERT)) {
<i>735</i>&nbsp;            if (signedCert != null)
<i>736</i>&nbsp;                return signedCert.clone();
<i>737</i>&nbsp;            else
<i>738</i>&nbsp;                return null;
<b class="nc"><i>739</i>&nbsp;        } else {</b>
<b class="nc"><i>740</i>&nbsp;            throw new CertificateParsingException(&quot;Attribute name not &quot;</b>
<i>741</i>&nbsp;                 + &quot;recognized or get() not allowed for the same: &quot; + id);
<i>742</i>&nbsp;        }
<b class="nc"><i>743</i>&nbsp;    }</b>
<b class="nc"><i>744</i>&nbsp;</b>
<b class="nc"><i>745</i>&nbsp;    /**</b>
<b class="nc"><i>746</i>&nbsp;     * Set the requested attribute in the certificate.</b>
<i>747</i>&nbsp;     *
<i>748</i>&nbsp;     * @param name the name of the attribute.
<i>749</i>&nbsp;     * @param obj the value of the attribute.
<b class="nc"><i>750</i>&nbsp;     * @exception CertificateException on invalid attribute identifier.</b>
<b class="nc"><i>751</i>&nbsp;     * @exception IOException on encoding error of attribute.</b>
<i>752</i>&nbsp;     */
<b class="nc"><i>753</i>&nbsp;    public void set(String name, Object obj)</b>
<b class="nc"><i>754</i>&nbsp;    throws CertificateException, IOException {</b>
<b class="nc"><i>755</i>&nbsp;        // check if immutable</b>
<i>756</i>&nbsp;        if (readOnly)
<b class="nc"><i>757</i>&nbsp;            throw new CertificateException(&quot;cannot over-write existing&quot;</b>
<i>758</i>&nbsp;                                           + &quot; certificate&quot;);
<b class="nc"><i>759</i>&nbsp;</b>
<b class="nc"><i>760</i>&nbsp;        X509AttributeName attr = new X509AttributeName(name);</b>
<b class="nc"><i>761</i>&nbsp;        String id = attr.getPrefix();</b>
<b class="nc"><i>762</i>&nbsp;        if (!(id.equalsIgnoreCase(NAME))) {</b>
<b class="nc"><i>763</i>&nbsp;            throw new CertificateException(&quot;Invalid root of attribute name,&quot;</b>
<b class="nc"><i>764</i>&nbsp;                           + &quot; expected [&quot; + NAME + &quot;], received &quot; + id);</b>
<i>765</i>&nbsp;        }
<b class="nc"><i>766</i>&nbsp;        attr = new X509AttributeName(attr.getSuffix());</b>
<i>767</i>&nbsp;        id = attr.getPrefix();
<i>768</i>&nbsp;
<i>769</i>&nbsp;        if (id.equalsIgnoreCase(INFO)) {
<i>770</i>&nbsp;            if (attr.getSuffix() == null) {
<i>771</i>&nbsp;                if (!(obj instanceof X509CertInfo)) {
<i>772</i>&nbsp;                    throw new CertificateException(&quot;Attribute value should&quot;
<i>773</i>&nbsp;                                    + &quot; be of type X509CertInfo.&quot;);
<i>774</i>&nbsp;                }
<i>775</i>&nbsp;                info = (X509CertInfo)obj;
<b class="nc"><i>776</i>&nbsp;                signedCert = null;  //reset this as certificate data has changed</b>
<b class="nc"><i>777</i>&nbsp;            } else {</b>
<b class="nc"><i>778</i>&nbsp;                info.set(attr.getSuffix(), obj);</b>
<b class="nc"><i>779</i>&nbsp;                signedCert = null;  //reset this as certificate data has changed</b>
<b class="nc"><i>780</i>&nbsp;            }</b>
<i>781</i>&nbsp;        } else {
<b class="nc"><i>782</i>&nbsp;            throw new CertificateException(&quot;Attribute name not recognized or &quot; +</b>
<i>783</i>&nbsp;                              &quot;set() not allowed for the same: &quot; + id);
<i>784</i>&nbsp;        }
<i>785</i>&nbsp;    }
<i>786</i>&nbsp;
<i>787</i>&nbsp;    /**
<i>788</i>&nbsp;     * Delete the requested attribute from the certificate.
<b class="nc"><i>789</i>&nbsp;     *</b>
<i>790</i>&nbsp;     * @param name the name of the attribute.
<i>791</i>&nbsp;     * @exception CertificateException on invalid attribute identifier.
<i>792</i>&nbsp;     * @exception IOException on other errors.
<i>793</i>&nbsp;     */
<i>794</i>&nbsp;    public void delete(String name)
<i>795</i>&nbsp;    throws CertificateException, IOException {
<i>796</i>&nbsp;        // check if immutable
<i>797</i>&nbsp;        if (readOnly)
<i>798</i>&nbsp;            throw new CertificateException(&quot;cannot over-write existing&quot;
<b class="nc"><i>799</i>&nbsp;                                           + &quot; certificate&quot;);</b>
<b class="nc"><i>800</i>&nbsp;</b>
<i>801</i>&nbsp;        X509AttributeName attr = new X509AttributeName(name);
<b class="nc"><i>802</i>&nbsp;        String id = attr.getPrefix();</b>
<i>803</i>&nbsp;        if (!(id.equalsIgnoreCase(NAME))) {
<b class="nc"><i>804</i>&nbsp;            throw new CertificateException(&quot;Invalid root of attribute name,&quot;</b>
<b class="nc"><i>805</i>&nbsp;                                   + &quot; expected [&quot;</b>
<b class="nc"><i>806</i>&nbsp;                                   + NAME + &quot;], received &quot; + id);</b>
<i>807</i>&nbsp;        }
<b class="nc"><i>808</i>&nbsp;        attr = new X509AttributeName(attr.getSuffix());</b>
<b class="nc"><i>809</i>&nbsp;        id = attr.getPrefix();</b>
<b class="nc"><i>810</i>&nbsp;</b>
<i>811</i>&nbsp;        if (id.equalsIgnoreCase(INFO)) {
<b class="nc"><i>812</i>&nbsp;            if (attr.getSuffix() != null) {</b>
<i>813</i>&nbsp;                info = null;
<i>814</i>&nbsp;            } else {
<i>815</i>&nbsp;                info.delete(attr.getSuffix());
<i>816</i>&nbsp;            }
<i>817</i>&nbsp;        } else if (id.equalsIgnoreCase(ALG_ID)) {
<i>818</i>&nbsp;            algId = null;
<i>819</i>&nbsp;        } else if (id.equalsIgnoreCase(SIGNATURE)) {
<i>820</i>&nbsp;            signature = null;
<i>821</i>&nbsp;        } else if (id.equalsIgnoreCase(SIGNED_CERT)) {
<i>822</i>&nbsp;            signedCert = null;
<b class="nc"><i>823</i>&nbsp;        } else {</b>
<b class="nc"><i>824</i>&nbsp;            throw new CertificateException(&quot;Attribute name not recognized or &quot; +</b>
<i>825</i>&nbsp;                              &quot;delete() not allowed for the same: &quot; + id);
<b class="nc"><i>826</i>&nbsp;        }</b>
<i>827</i>&nbsp;    }
<b class="nc"><i>828</i>&nbsp;</b>
<b class="nc"><i>829</i>&nbsp;    /**</b>
<b class="nc"><i>830</i>&nbsp;     * Return an enumeration of names of attributes existing within this</b>
<i>831</i>&nbsp;     * attribute.
<i>832</i>&nbsp;     */
<i>833</i>&nbsp;    public Enumeration&lt;String&gt; getElements() {
<i>834</i>&nbsp;        AttributeNameEnumeration elements = new AttributeNameEnumeration();
<i>835</i>&nbsp;        elements.addElement(NAME + DOT + INFO);
<i>836</i>&nbsp;        elements.addElement(NAME + DOT + ALG_ID);
<i>837</i>&nbsp;        elements.addElement(NAME + DOT + SIGNATURE);
<i>838</i>&nbsp;        elements.addElement(NAME + DOT + SIGNED_CERT);
<i>839</i>&nbsp;
<b class="nc"><i>840</i>&nbsp;        return elements.elements();</b>
<b class="nc"><i>841</i>&nbsp;    }</b>
<i>842</i>&nbsp;
<b class="nc"><i>843</i>&nbsp;    /**</b>
<b class="nc"><i>844</i>&nbsp;     * Return the name of this attribute.</b>
<b class="nc"><i>845</i>&nbsp;     */</b>
<b class="nc"><i>846</i>&nbsp;    public String getName() {</b>
<b class="nc"><i>847</i>&nbsp;        return(NAME);</b>
<i>848</i>&nbsp;    }
<i>849</i>&nbsp;
<i>850</i>&nbsp;    /**
<i>851</i>&nbsp;     * Returns a printable representation of the certificate.  This does not
<i>852</i>&nbsp;     * contain all the information available to distinguish this from any
<i>853</i>&nbsp;     * other certificate.  The certificate must be fully constructed
<i>854</i>&nbsp;     * before this function may be called.
<i>855</i>&nbsp;     */
<i>856</i>&nbsp;    public String toString() {
<b class="nc"><i>857</i>&nbsp;        if (info == null || algId == null || signature == null)</b>
<i>858</i>&nbsp;            return &quot;&quot;;
<b class="nc"><i>859</i>&nbsp;</b>
<i>860</i>&nbsp;        HexDumpEncoder encoder = new HexDumpEncoder();
<i>861</i>&nbsp;        return &quot;[\n&quot; + info + &#39;\n&#39; +
<i>862</i>&nbsp;            &quot;  Algorithm: [&quot; + algId + &quot;]\n&quot; +
<i>863</i>&nbsp;            &quot;  Signature:\n&quot; + encoder.encodeBuffer(signature) + &quot;\n]&quot;;
<i>864</i>&nbsp;    }
<i>865</i>&nbsp;
<i>866</i>&nbsp;    // the strongly typed gets, as per java.security.cert.X509Certificate
<i>867</i>&nbsp;
<i>868</i>&nbsp;    /**
<b class="nc"><i>869</i>&nbsp;     * Gets the publickey from this certificate.</b>
<b class="nc"><i>870</i>&nbsp;     *</b>
<i>871</i>&nbsp;     * @return the publickey.
<b class="nc"><i>872</i>&nbsp;     */</b>
<i>873</i>&nbsp;    public PublicKey getPublicKey() {
<i>874</i>&nbsp;        if (info == null)
<b class="nc"><i>875</i>&nbsp;            return null;</b>
<b class="nc"><i>876</i>&nbsp;        try {</b>
<b class="nc"><i>877</i>&nbsp;            PublicKey key = (PublicKey)info.get(CertificateX509Key.NAME</b>
<i>878</i>&nbsp;                                + DOT + CertificateX509Key.KEY);
<i>879</i>&nbsp;            return key;
<i>880</i>&nbsp;        } catch (Exception e) {
<i>881</i>&nbsp;            return null;
<i>882</i>&nbsp;        }
<i>883</i>&nbsp;    }
<i>884</i>&nbsp;
<i>885</i>&nbsp;    /**
<i>886</i>&nbsp;     * Gets the version number from the certificate.
<i>887</i>&nbsp;     *
<b class="nc"><i>888</i>&nbsp;     * @return the version number, i.e. 1, 2 or 3.</b>
<b class="nc"><i>889</i>&nbsp;     */</b>
<i>890</i>&nbsp;    public int getVersion() {
<b class="nc"><i>891</i>&nbsp;        if (info == null)</b>
<i>892</i>&nbsp;            return -1;
<b class="nc"><i>893</i>&nbsp;        try {</b>
<b class="nc"><i>894</i>&nbsp;            int vers = ((Integer)info.get(CertificateVersion.NAME</b>
<b class="nc"><i>895</i>&nbsp;                        + DOT + CertificateVersion.VERSION)).intValue();</b>
<i>896</i>&nbsp;            return vers+1;
<i>897</i>&nbsp;        } catch (Exception e) {
<i>898</i>&nbsp;            return -1;
<i>899</i>&nbsp;        }
<i>900</i>&nbsp;    }
<i>901</i>&nbsp;
<i>902</i>&nbsp;    /**
<i>903</i>&nbsp;     * Gets the serial number from the certificate.
<i>904</i>&nbsp;     *
<b class="nc"><i>905</i>&nbsp;     * @return the serial number.</b>
<b class="nc"><i>906</i>&nbsp;     */</b>
<i>907</i>&nbsp;    public BigInteger getSerialNumber() {
<i>908</i>&nbsp;        SerialNumber ser = getSerialNumberObject();
<b class="nc"><i>909</i>&nbsp;</b>
<i>910</i>&nbsp;        return ser != null ? ser.getNumber() : null;
<i>911</i>&nbsp;    }
<b class="nc"><i>912</i>&nbsp;</b>
<b class="nc"><i>913</i>&nbsp;    /**</b>
<b class="nc"><i>914</i>&nbsp;     * Gets the serial number from the certificate as</b>
<i>915</i>&nbsp;     * a SerialNumber object.
<i>916</i>&nbsp;     *
<i>917</i>&nbsp;     * @return the serial number.
<i>918</i>&nbsp;     */
<i>919</i>&nbsp;    public SerialNumber getSerialNumberObject() {
<i>920</i>&nbsp;        if (info == null)
<i>921</i>&nbsp;            return null;
<i>922</i>&nbsp;        try {
<i>923</i>&nbsp;            SerialNumber ser = (SerialNumber)info.get(
<b class="nc"><i>924</i>&nbsp;                              CertificateSerialNumber.NAME + DOT +</b>
<b class="nc"><i>925</i>&nbsp;                              CertificateSerialNumber.NUMBER);</b>
<i>926</i>&nbsp;           return ser;
<b class="nc"><i>927</i>&nbsp;        } catch (Exception e) {</b>
<i>928</i>&nbsp;            return null;
<b class="nc"><i>929</i>&nbsp;        }</b>
<b class="nc"><i>930</i>&nbsp;    }</b>
<b class="nc"><i>931</i>&nbsp;</b>
<i>932</i>&nbsp;
<i>933</i>&nbsp;    /**
<i>934</i>&nbsp;     * Gets the subject distinguished name from the certificate.
<i>935</i>&nbsp;     *
<i>936</i>&nbsp;     * @return the subject name.
<i>937</i>&nbsp;     */
<i>938</i>&nbsp;    public Principal getSubjectDN() {
<i>939</i>&nbsp;        if (info == null)
<i>940</i>&nbsp;            return null;
<b class="nc"><i>941</i>&nbsp;        try {</b>
<b class="nc"><i>942</i>&nbsp;            Principal subject = (Principal)info.get(X509CertInfo.SUBJECT + DOT +</b>
<i>943</i>&nbsp;                                                    X509CertInfo.DN_NAME);
<i>944</i>&nbsp;            return subject;
<b class="nc"><i>945</i>&nbsp;        } catch (Exception e) {</b>
<i>946</i>&nbsp;            return null;
<i>947</i>&nbsp;        }
<b class="nc"><i>948</i>&nbsp;    }</b>
<b class="nc"><i>949</i>&nbsp;</b>
<b class="nc"><i>950</i>&nbsp;    /**</b>
<i>951</i>&nbsp;     * Get subject name as X500Principal. Overrides implementation in
<i>952</i>&nbsp;     * X509Certificate with a slightly more efficient version that is
<i>953</i>&nbsp;     * also aware of X509CertImpl mutability.
<i>954</i>&nbsp;     */
<i>955</i>&nbsp;    public X500Principal getSubjectX500Principal() {
<i>956</i>&nbsp;        if (info == null) {
<i>957</i>&nbsp;            return null;
<i>958</i>&nbsp;        }
<i>959</i>&nbsp;        try {
<b class="nc"><i>960</i>&nbsp;            X500Principal subject = (X500Principal)info.get(</b>
<b class="nc"><i>961</i>&nbsp;                                            X509CertInfo.SUBJECT + DOT +</b>
<i>962</i>&nbsp;                                            &quot;x500principal&quot;);
<b class="nc"><i>963</i>&nbsp;            return subject;</b>
<i>964</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i>965</i>&nbsp;            return null;</b>
<b class="nc"><i>966</i>&nbsp;        }</b>
<b class="nc"><i>967</i>&nbsp;    }</b>
<i>968</i>&nbsp;
<i>969</i>&nbsp;    /**
<i>970</i>&nbsp;     * Gets the issuer distinguished name from the certificate.
<i>971</i>&nbsp;     *
<i>972</i>&nbsp;     * @return the issuer name.
<i>973</i>&nbsp;     */
<i>974</i>&nbsp;    public Principal getIssuerDN() {
<i>975</i>&nbsp;        if (info == null)
<i>976</i>&nbsp;            return null;
<b class="nc"><i>977</i>&nbsp;        try {</b>
<b class="nc"><i>978</i>&nbsp;            Principal issuer = (Principal)info.get(X509CertInfo.ISSUER + DOT +</b>
<i>979</i>&nbsp;                                                   X509CertInfo.DN_NAME);
<b class="nc"><i>980</i>&nbsp;            return issuer;</b>
<i>981</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i>982</i>&nbsp;            return null;</b>
<b class="nc"><i>983</i>&nbsp;        }</b>
<b class="nc"><i>984</i>&nbsp;    }</b>
<i>985</i>&nbsp;
<i>986</i>&nbsp;    /**
<i>987</i>&nbsp;     * Get issuer name as X500Principal. Overrides implementation in
<i>988</i>&nbsp;     * X509Certificate with a slightly more efficient version that is
<i>989</i>&nbsp;     * also aware of X509CertImpl mutability.
<i>990</i>&nbsp;     */
<i>991</i>&nbsp;    public X500Principal getIssuerX500Principal() {
<i>992</i>&nbsp;        if (info == null) {
<i>993</i>&nbsp;            return null;
<i>994</i>&nbsp;        }
<i>995</i>&nbsp;        try {
<i>996</i>&nbsp;            X500Principal issuer = (X500Principal)info.get(
<b class="nc"><i>997</i>&nbsp;                                            X509CertInfo.ISSUER + DOT +</b>
<b class="nc"><i>998</i>&nbsp;                                            &quot;x500principal&quot;);</b>
<i>999</i>&nbsp;            return issuer;
<b class="nc"><i>1000</i>&nbsp;        } catch (Exception e) {</b>
<i>1001</i>&nbsp;            return null;
<i>1002</i>&nbsp;        }
<i>1003</i>&nbsp;    }
<i>1004</i>&nbsp;
<i>1005</i>&nbsp;    /**
<i>1006</i>&nbsp;     * Gets the notBefore date from the validity period of the certificate.
<i>1007</i>&nbsp;     *
<i>1008</i>&nbsp;     * @return the start date of the validity period.
<b class="nc"><i>1009</i>&nbsp;     */</b>
<b class="nc"><i>1010</i>&nbsp;    public Date getNotBefore() {</b>
<b class="nc"><i>1011</i>&nbsp;        if (info == null)</b>
<i>1012</i>&nbsp;            return null;
<i>1013</i>&nbsp;        try {
<i>1014</i>&nbsp;            Date d = (Date) info.get(CertificateValidity.NAME + DOT +
<i>1015</i>&nbsp;                                        CertificateValidity.NOT_BEFORE);
<i>1016</i>&nbsp;            return d;
<i>1017</i>&nbsp;        } catch (Exception e) {
<i>1018</i>&nbsp;            return null;
<i>1019</i>&nbsp;        }
<i>1020</i>&nbsp;    }
<i>1021</i>&nbsp;
<b class="nc"><i>1022</i>&nbsp;    /**</b>
<b class="nc"><i>1023</i>&nbsp;     * Gets the notAfter date from the validity period of the certificate.</b>
<b class="nc"><i>1024</i>&nbsp;     *</b>
<i>1025</i>&nbsp;     * @return the end date of the validity period.
<i>1026</i>&nbsp;     */
<i>1027</i>&nbsp;    public Date getNotAfter() {
<i>1028</i>&nbsp;        if (info == null)
<i>1029</i>&nbsp;            return null;
<i>1030</i>&nbsp;        try {
<i>1031</i>&nbsp;            Date d = (Date) info.get(CertificateValidity.NAME + DOT +
<i>1032</i>&nbsp;                                     CertificateValidity.NOT_AFTER);
<i>1033</i>&nbsp;            return d;
<b class="nc"><i>1034</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i>1035</i>&nbsp;            return null;</b>
<b class="nc"><i>1036</i>&nbsp;        }</b>
<b class="nc"><i>1037</i>&nbsp;    }</b>
<i>1038</i>&nbsp;
<i>1039</i>&nbsp;    /**
<i>1040</i>&nbsp;     * Gets the DER encoded certificate informations, the
<i>1041</i>&nbsp;     * &lt;code&gt;tbsCertificate&lt;/code&gt; from this certificate.
<i>1042</i>&nbsp;     * This can be used to verify the signature independently.
<i>1043</i>&nbsp;     *
<i>1044</i>&nbsp;     * @return the DER encoded certificate information.
<i>1045</i>&nbsp;     * @exception CertificateEncodingException if an encoding error occurs.
<i>1046</i>&nbsp;     */
<i>1047</i>&nbsp;    public byte[] getTBSCertificate() throws CertificateEncodingException {
<b class="nc"><i>1048</i>&nbsp;        if (info != null) {</b>
<b class="nc"><i>1049</i>&nbsp;            return info.getEncodedInfo();</b>
<i>1050</i>&nbsp;        } else
<b class="nc"><i>1051</i>&nbsp;            throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);</b>
<b class="nc"><i>1052</i>&nbsp;    }</b>
<b class="nc"><i>1053</i>&nbsp;</b>
<i>1054</i>&nbsp;    /**
<i>1055</i>&nbsp;     * Gets the raw Signature bits from the certificate.
<i>1056</i>&nbsp;     *
<i>1057</i>&nbsp;     * @return the signature.
<i>1058</i>&nbsp;     */
<i>1059</i>&nbsp;    public byte[] getSignature() {
<i>1060</i>&nbsp;        if (signature == null)
<i>1061</i>&nbsp;            return null;
<i>1062</i>&nbsp;        return signature.clone();
<b class="nc"><i>1063</i>&nbsp;    }</b>
<b class="nc"><i>1064</i>&nbsp;</b>
<i>1065</i>&nbsp;    /**
<b class="nc"><i>1066</i>&nbsp;     * Gets the signature algorithm name for the certificate</b>
<i>1067</i>&nbsp;     * signature algorithm.
<b class="nc"><i>1068</i>&nbsp;     * For example, the string &quot;SHA-1/DSA&quot; or &quot;DSS&quot;.</b>
<b class="nc"><i>1069</i>&nbsp;     *</b>
<i>1070</i>&nbsp;     * @return the signature algorithm name.
<b class="nc"><i>1071</i>&nbsp;     */</b>
<b class="nc"><i>1072</i>&nbsp;    public String getSigAlgName() {</b>
<b class="nc"><i>1073</i>&nbsp;        if (algId == null)</b>
<i>1074</i>&nbsp;            return null;
<i>1075</i>&nbsp;        return (algId.getName());
<i>1076</i>&nbsp;    }
<i>1077</i>&nbsp;
<i>1078</i>&nbsp;    /**
<i>1079</i>&nbsp;     * Gets the signature algorithm OID string from the certificate.
<i>1080</i>&nbsp;     * For example, the string &quot;1.2.840.10040.4.3&quot;
<i>1081</i>&nbsp;     *
<i>1082</i>&nbsp;     * @return the signature algorithm oid string.
<b class="nc"><i>1083</i>&nbsp;     */</b>
<b class="nc"><i>1084</i>&nbsp;    public String getSigAlgOID() {</b>
<i>1085</i>&nbsp;        if (algId == null)
<b class="nc"><i>1086</i>&nbsp;            return null;</b>
<i>1087</i>&nbsp;        ObjectIdentifier oid = algId.getOID();
<b class="nc"><i>1088</i>&nbsp;        return (oid.toString());</b>
<b class="nc"><i>1089</i>&nbsp;    }</b>
<i>1090</i>&nbsp;
<b class="nc"><i>1091</i>&nbsp;    /**</b>
<b class="nc"><i>1092</i>&nbsp;     * Gets the DER encoded signature algorithm parameters from this</b>
<b class="nc"><i>1093</i>&nbsp;     * certificate&#39;s signature algorithm.</b>
<i>1094</i>&nbsp;     *
<i>1095</i>&nbsp;     * @return the DER encoded signature algorithm parameters, or
<i>1096</i>&nbsp;     *         null if no parameters are present.
<i>1097</i>&nbsp;     */
<b class="nc"><i>1098</i>&nbsp;    public byte[] getSigAlgParams() {</b>
<b class="nc"><i>1099</i>&nbsp;        if (algId == null)</b>
<b class="nc"><i>1100</i>&nbsp;            return null;</b>
<i>1101</i>&nbsp;        try {
<b class="nc"><i>1102</i>&nbsp;            return algId.getEncodedParams();</b>
<i>1103</i>&nbsp;        } catch (IOException e) {
<b class="nc"><i>1104</i>&nbsp;            return null;</b>
<i>1105</i>&nbsp;        }
<b class="nc"><i>1106</i>&nbsp;    }</b>
<i>1107</i>&nbsp;
<i>1108</i>&nbsp;    /**
<i>1109</i>&nbsp;     * Gets the Issuer Unique Identity from the certificate.
<i>1110</i>&nbsp;     *
<i>1111</i>&nbsp;     * @return the Issuer Unique Identity.
<i>1112</i>&nbsp;     */
<b class="nc"><i>1113</i>&nbsp;    public boolean[] getIssuerUniqueID() {</b>
<b class="nc"><i>1114</i>&nbsp;        if (info == null)</b>
<i>1115</i>&nbsp;            return null;
<b class="nc"><i>1116</i>&nbsp;        try {</b>
<i>1117</i>&nbsp;            UniqueIdentity id = (UniqueIdentity)info.get(
<b class="nc"><i>1118</i>&nbsp;                                 X509CertInfo.ISSUER_ID);</b>
<i>1119</i>&nbsp;            if (id == null)
<b class="nc"><i>1120</i>&nbsp;                return null;</b>
<i>1121</i>&nbsp;            else
<i>1122</i>&nbsp;                return (id.getId());
<i>1123</i>&nbsp;        } catch (Exception e) {
<i>1124</i>&nbsp;            return null;
<i>1125</i>&nbsp;        }
<i>1126</i>&nbsp;    }
<i>1127</i>&nbsp;
<i>1128</i>&nbsp;    /**
<i>1129</i>&nbsp;     * Gets the Subject Unique Identity from the certificate.
<b class="nc"><i>1130</i>&nbsp;     *</b>
<b class="nc"><i>1131</i>&nbsp;     * @return the Subject Unique Identity.</b>
<i>1132</i>&nbsp;     */
<i>1133</i>&nbsp;    public boolean[] getSubjectUniqueID() {
<i>1134</i>&nbsp;        if (info == null)
<i>1135</i>&nbsp;            return null;
<i>1136</i>&nbsp;        try {
<i>1137</i>&nbsp;            UniqueIdentity id = (UniqueIdentity)info.get(
<i>1138</i>&nbsp;                                 X509CertInfo.SUBJECT_ID);
<i>1139</i>&nbsp;            if (id == null)
<b class="nc"><i>1140</i>&nbsp;                return null;</b>
<b class="nc"><i>1141</i>&nbsp;            else</b>
<i>1142</i>&nbsp;                return (id.getId());
<i>1143</i>&nbsp;        } catch (Exception e) {
<i>1144</i>&nbsp;            return null;
<i>1145</i>&nbsp;        }
<i>1146</i>&nbsp;    }
<i>1147</i>&nbsp;
<i>1148</i>&nbsp;    public KeyIdentifier getAuthKeyId() {
<i>1149</i>&nbsp;        AuthorityKeyIdentifierExtension aki
<b class="nc"><i>1150</i>&nbsp;            = getAuthorityKeyIdentifierExtension();</b>
<b class="nc"><i>1151</i>&nbsp;        if (aki != null) {</b>
<i>1152</i>&nbsp;            try {
<i>1153</i>&nbsp;                return (KeyIdentifier)aki.get(
<i>1154</i>&nbsp;                    AuthorityKeyIdentifierExtension.KEY_ID);
<i>1155</i>&nbsp;            } catch (IOException ioe) {} // not possible
<i>1156</i>&nbsp;        }
<i>1157</i>&nbsp;        return null;
<i>1158</i>&nbsp;    }
<i>1159</i>&nbsp;
<b class="nc"><i>1160</i>&nbsp;    /**</b>
<b class="nc"><i>1161</i>&nbsp;     * Returns the subject&#39;s key identifier, or null</b>
<i>1162</i>&nbsp;     */
<i>1163</i>&nbsp;    public KeyIdentifier getSubjectKeyId() {
<i>1164</i>&nbsp;        SubjectKeyIdentifierExtension ski = getSubjectKeyIdentifierExtension();
<i>1165</i>&nbsp;        if (ski != null) {
<i>1166</i>&nbsp;            try {
<i>1167</i>&nbsp;                return ski.get(SubjectKeyIdentifierExtension.KEY_ID);
<i>1168</i>&nbsp;            } catch (IOException ioe) {} // not possible
<i>1169</i>&nbsp;        }
<b class="nc"><i>1170</i>&nbsp;        return null;</b>
<b class="nc"><i>1171</i>&nbsp;    }</b>
<i>1172</i>&nbsp;
<i>1173</i>&nbsp;    /**
<i>1174</i>&nbsp;     * Get AuthorityKeyIdentifier extension
<i>1175</i>&nbsp;     * @return AuthorityKeyIdentifier object or null (if no such object
<i>1176</i>&nbsp;     * in certificate)
<i>1177</i>&nbsp;     */
<i>1178</i>&nbsp;    public AuthorityKeyIdentifierExtension getAuthorityKeyIdentifierExtension()
<b class="nc"><i>1179</i>&nbsp;    {</b>
<b class="nc"><i>1180</i>&nbsp;        return (AuthorityKeyIdentifierExtension)</b>
<i>1181</i>&nbsp;            getExtension(PKIXExtensions.AuthorityKey_Id);
<i>1182</i>&nbsp;    }
<i>1183</i>&nbsp;
<i>1184</i>&nbsp;    /**
<i>1185</i>&nbsp;     * Get BasicConstraints extension
<i>1186</i>&nbsp;     * @return BasicConstraints object or null (if no such object in
<i>1187</i>&nbsp;     * certificate)
<i>1188</i>&nbsp;     */
<b class="nc"><i>1189</i>&nbsp;    public BasicConstraintsExtension getBasicConstraintsExtension() {</b>
<b class="nc"><i>1190</i>&nbsp;        return (BasicConstraintsExtension)</b>
<i>1191</i>&nbsp;            getExtension(PKIXExtensions.BasicConstraints_Id);
<i>1192</i>&nbsp;    }
<i>1193</i>&nbsp;
<i>1194</i>&nbsp;    /**
<i>1195</i>&nbsp;     * Get CertificatePoliciesExtension
<i>1196</i>&nbsp;     * @return CertificatePoliciesExtension or null (if no such object in
<i>1197</i>&nbsp;     * certificate)
<i>1198</i>&nbsp;     */
<b class="nc"><i>1199</i>&nbsp;    public CertificatePoliciesExtension getCertificatePoliciesExtension() {</b>
<b class="nc"><i>1200</i>&nbsp;        return (CertificatePoliciesExtension)</b>
<i>1201</i>&nbsp;            getExtension(PKIXExtensions.CertificatePolicies_Id);
<i>1202</i>&nbsp;    }
<i>1203</i>&nbsp;
<i>1204</i>&nbsp;    /**
<i>1205</i>&nbsp;     * Get ExtendedKeyUsage extension
<i>1206</i>&nbsp;     * @return ExtendedKeyUsage extension object or null (if no such object
<i>1207</i>&nbsp;     * in certificate)
<b class="nc"><i>1208</i>&nbsp;     */</b>
<b class="nc"><i>1209</i>&nbsp;    public ExtendedKeyUsageExtension getExtendedKeyUsageExtension() {</b>
<i>1210</i>&nbsp;        return (ExtendedKeyUsageExtension)
<i>1211</i>&nbsp;            getExtension(PKIXExtensions.ExtendedKeyUsage_Id);
<i>1212</i>&nbsp;    }
<i>1213</i>&nbsp;
<i>1214</i>&nbsp;    /**
<i>1215</i>&nbsp;     * Get IssuerAlternativeName extension
<i>1216</i>&nbsp;     * @return IssuerAlternativeName object or null (if no such object in
<i>1217</i>&nbsp;     * certificate)
<i>1218</i>&nbsp;     */
<b class="nc"><i>1219</i>&nbsp;    public IssuerAlternativeNameExtension getIssuerAlternativeNameExtension() {</b>
<b class="nc"><i>1220</i>&nbsp;        return (IssuerAlternativeNameExtension)</b>
<i>1221</i>&nbsp;            getExtension(PKIXExtensions.IssuerAlternativeName_Id);
<i>1222</i>&nbsp;    }
<i>1223</i>&nbsp;
<i>1224</i>&nbsp;    /**
<i>1225</i>&nbsp;     * Get NameConstraints extension
<i>1226</i>&nbsp;     * @return NameConstraints object or null (if no such object in certificate)
<i>1227</i>&nbsp;     */
<i>1228</i>&nbsp;    public NameConstraintsExtension getNameConstraintsExtension() {
<b class="nc"><i>1229</i>&nbsp;        return (NameConstraintsExtension)</b>
<b class="nc"><i>1230</i>&nbsp;            getExtension(PKIXExtensions.NameConstraints_Id);</b>
<i>1231</i>&nbsp;    }
<i>1232</i>&nbsp;
<i>1233</i>&nbsp;    /**
<i>1234</i>&nbsp;     * Get PolicyConstraints extension
<i>1235</i>&nbsp;     * @return PolicyConstraints object or null (if no such object in
<i>1236</i>&nbsp;     * certificate)
<i>1237</i>&nbsp;     */
<i>1238</i>&nbsp;    public PolicyConstraintsExtension getPolicyConstraintsExtension() {
<b class="nc"><i>1239</i>&nbsp;        return (PolicyConstraintsExtension)</b>
<b class="nc"><i>1240</i>&nbsp;            getExtension(PKIXExtensions.PolicyConstraints_Id);</b>
<i>1241</i>&nbsp;    }
<i>1242</i>&nbsp;
<i>1243</i>&nbsp;    /**
<i>1244</i>&nbsp;     * Get PolicyMappingsExtension extension
<i>1245</i>&nbsp;     * @return PolicyMappingsExtension object or null (if no such object
<i>1246</i>&nbsp;     * in certificate)
<i>1247</i>&nbsp;     */
<b class="nc"><i>1248</i>&nbsp;    public PolicyMappingsExtension getPolicyMappingsExtension() {</b>
<b class="nc"><i>1249</i>&nbsp;        return (PolicyMappingsExtension)</b>
<i>1250</i>&nbsp;            getExtension(PKIXExtensions.PolicyMappings_Id);
<b class="nc"><i>1251</i>&nbsp;    }</b>
<i>1252</i>&nbsp;
<b class="nc"><i>1253</i>&nbsp;    /**</b>
<b class="nc"><i>1254</i>&nbsp;     * Get PrivateKeyUsage extension</b>
<b class="nc"><i>1255</i>&nbsp;     * @return PrivateKeyUsage object or null (if no such object in certificate)</b>
<b class="nc"><i>1256</i>&nbsp;     */</b>
<b class="nc"><i>1257</i>&nbsp;    public PrivateKeyUsageExtension getPrivateKeyUsageExtension() {</b>
<i>1258</i>&nbsp;        return (PrivateKeyUsageExtension)
<i>1259</i>&nbsp;            getExtension(PKIXExtensions.PrivateKeyUsage_Id);
<i>1260</i>&nbsp;    }
<i>1261</i>&nbsp;
<i>1262</i>&nbsp;    /**
<i>1263</i>&nbsp;     * Get SubjectAlternativeName extension
<i>1264</i>&nbsp;     * @return SubjectAlternativeName object or null (if no such object in
<i>1265</i>&nbsp;     * certificate)
<i>1266</i>&nbsp;     */
<i>1267</i>&nbsp;    public SubjectAlternativeNameExtension getSubjectAlternativeNameExtension()
<i>1268</i>&nbsp;    {
<i>1269</i>&nbsp;        return (SubjectAlternativeNameExtension)
<b class="nc"><i>1270</i>&nbsp;            getExtension(PKIXExtensions.SubjectAlternativeName_Id);</b>
<b class="nc"><i>1271</i>&nbsp;    }</b>
<i>1272</i>&nbsp;
<i>1273</i>&nbsp;    /**
<b class="nc"><i>1274</i>&nbsp;     * Get SubjectKeyIdentifier extension</b>
<i>1275</i>&nbsp;     * @return SubjectKeyIdentifier object or null (if no such object in
<b class="nc"><i>1276</i>&nbsp;     * certificate)</b>
<b class="nc"><i>1277</i>&nbsp;     */</b>
<i>1278</i>&nbsp;    public SubjectKeyIdentifierExtension getSubjectKeyIdentifierExtension() {
<b class="nc"><i>1279</i>&nbsp;        return (SubjectKeyIdentifierExtension)</b>
<b class="nc"><i>1280</i>&nbsp;            getExtension(PKIXExtensions.SubjectKey_Id);</b>
<b class="nc"><i>1281</i>&nbsp;    }</b>
<b class="nc"><i>1282</i>&nbsp;</b>
<i>1283</i>&nbsp;    /**
<b class="nc"><i>1284</i>&nbsp;     * Get CRLDistributionPoints extension</b>
<b class="nc"><i>1285</i>&nbsp;     * @return CRLDistributionPoints object or null (if no such object in</b>
<b class="nc"><i>1286</i>&nbsp;     * certificate)</b>
<b class="nc"><i>1287</i>&nbsp;     */</b>
<i>1288</i>&nbsp;    public CRLDistributionPointsExtension getCRLDistributionPointsExtension() {
<i>1289</i>&nbsp;        return (CRLDistributionPointsExtension)
<i>1290</i>&nbsp;            getExtension(PKIXExtensions.CRLDistributionPoints_Id);
<i>1291</i>&nbsp;    }
<i>1292</i>&nbsp;
<i>1293</i>&nbsp;    /**
<i>1294</i>&nbsp;     * Return true if a critical extension is found that is
<i>1295</i>&nbsp;     * not supported, otherwise return false.
<i>1296</i>&nbsp;     */
<i>1297</i>&nbsp;    public boolean hasUnsupportedCriticalExtension() {
<i>1298</i>&nbsp;        if (info == null)
<i>1299</i>&nbsp;            return false;
<b class="nc"><i>1300</i>&nbsp;        try {</b>
<b class="nc"><i>1301</i>&nbsp;            CertificateExtensions exts = (CertificateExtensions)info.get(</b>
<i>1302</i>&nbsp;                                         CertificateExtensions.NAME);
<i>1303</i>&nbsp;            if (exts == null)
<b class="nc"><i>1304</i>&nbsp;                return false;</b>
<i>1305</i>&nbsp;            return exts.hasUnsupportedCriticalExtension();
<b class="nc"><i>1306</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i>1307</i>&nbsp;            return false;</b>
<i>1308</i>&nbsp;        }
<b class="nc"><i>1309</i>&nbsp;    }</b>
<b class="nc"><i>1310</i>&nbsp;</b>
<b class="nc"><i>1311</i>&nbsp;    /**</b>
<b class="nc"><i>1312</i>&nbsp;     * Gets a Set of the extension(s) marked CRITICAL in the</b>
<i>1313</i>&nbsp;     * certificate. In the returned set, each extension is
<b class="nc"><i>1314</i>&nbsp;     * represented by its OID string.</b>
<b class="nc"><i>1315</i>&nbsp;     *</b>
<b class="nc"><i>1316</i>&nbsp;     * @return a set of the extension oid strings in the</b>
<b class="nc"><i>1317</i>&nbsp;     * certificate that are marked critical.</b>
<b class="nc"><i>1318</i>&nbsp;     */</b>
<i>1319</i>&nbsp;    public Set&lt;String&gt; getCriticalExtensionOIDs() {
<i>1320</i>&nbsp;        if (info == null) {
<i>1321</i>&nbsp;            return null;
<i>1322</i>&nbsp;        }
<i>1323</i>&nbsp;        try {
<i>1324</i>&nbsp;            CertificateExtensions exts = (CertificateExtensions)info.get(
<i>1325</i>&nbsp;                                         CertificateExtensions.NAME);
<i>1326</i>&nbsp;            if (exts == null) {
<i>1327</i>&nbsp;                return null;
<i>1328</i>&nbsp;            }
<i>1329</i>&nbsp;            Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
<b class="nc"><i>1330</i>&nbsp;            for (Extension ex : exts.getAllExtensions()) {</b>
<b class="nc"><i>1331</i>&nbsp;                if (ex.isCritical()) {</b>
<i>1332</i>&nbsp;                    extSet.add(ex.getExtensionId().toString());
<i>1333</i>&nbsp;                }
<i>1334</i>&nbsp;            }
<i>1335</i>&nbsp;            return extSet;
<b class="nc"><i>1336</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i>1337</i>&nbsp;            return null;</b>
<b class="nc"><i>1338</i>&nbsp;        }</b>
<b class="nc"><i>1339</i>&nbsp;    }</b>
<b class="nc"><i>1340</i>&nbsp;</b>
<b class="nc"><i>1341</i>&nbsp;    /**</b>
<i>1342</i>&nbsp;     * Gets a Set of the extension(s) marked NON-CRITICAL in the
<b class="nc"><i>1343</i>&nbsp;     * certificate. In the returned set, each extension is</b>
<b class="nc"><i>1344</i>&nbsp;     * represented by its OID string.</b>
<b class="nc"><i>1345</i>&nbsp;     *</b>
<i>1346</i>&nbsp;     * @return a set of the extension oid strings in the
<b class="nc"><i>1347</i>&nbsp;     * certificate that are NOT marked critical.</b>
<b class="nc"><i>1348</i>&nbsp;     */</b>
<i>1349</i>&nbsp;    public Set&lt;String&gt; getNonCriticalExtensionOIDs() {
<b class="nc"><i>1350</i>&nbsp;        if (info == null) {</b>
<i>1351</i>&nbsp;            return null;
<b class="nc"><i>1352</i>&nbsp;        }</b>
<i>1353</i>&nbsp;        try {
<b class="nc"><i>1354</i>&nbsp;            CertificateExtensions exts = (CertificateExtensions)info.get(</b>
<i>1355</i>&nbsp;                                         CertificateExtensions.NAME);
<b class="nc"><i>1356</i>&nbsp;            if (exts == null) {</b>
<b class="nc"><i>1357</i>&nbsp;                return null;</b>
<i>1358</i>&nbsp;            }
<i>1359</i>&nbsp;            Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
<i>1360</i>&nbsp;            for (Extension ex : exts.getAllExtensions()) {
<i>1361</i>&nbsp;                if (!ex.isCritical()) {
<b class="nc"><i>1362</i>&nbsp;                    extSet.add(ex.getExtensionId().toString());</b>
<b class="nc"><i>1363</i>&nbsp;                }</b>
<i>1364</i>&nbsp;            }
<i>1365</i>&nbsp;            extSet.addAll(exts.getUnparseableExtensions().keySet());
<i>1366</i>&nbsp;            return extSet;
<i>1367</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i>1368</i>&nbsp;            return null;</b>
<b class="nc"><i>1369</i>&nbsp;        }</b>
<b class="nc"><i>1370</i>&nbsp;    }</b>
<b class="nc"><i>1371</i>&nbsp;</b>
<b class="nc"><i>1372</i>&nbsp;    /**</b>
<b class="nc"><i>1373</i>&nbsp;     * Gets the extension identified by the given ObjectIdentifier</b>
<i>1374</i>&nbsp;     *
<b class="nc"><i>1375</i>&nbsp;     * @param oid the Object Identifier value for the extension.</b>
<i>1376</i>&nbsp;     * @return Extension or null if certificate does not contain this
<b class="nc"><i>1377</i>&nbsp;     *         extension</b>
<b class="nc"><i>1378</i>&nbsp;     */</b>
<i>1379</i>&nbsp;    public Extension getExtension(ObjectIdentifier oid) {
<i>1380</i>&nbsp;        if (info == null) {
<i>1381</i>&nbsp;            return null;
<i>1382</i>&nbsp;        }
<i>1383</i>&nbsp;        try {
<i>1384</i>&nbsp;            CertificateExtensions extensions;
<i>1385</i>&nbsp;            try {
<i>1386</i>&nbsp;                extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);
<i>1387</i>&nbsp;            } catch (CertificateException ce) {
<i>1388</i>&nbsp;                return null;
<i>1389</i>&nbsp;            }
<b class="nc"><i>1390</i>&nbsp;            if (extensions == null) {</b>
<b class="nc"><i>1391</i>&nbsp;                return null;</b>
<b class="nc"><i>1392</i>&nbsp;            } else {</b>
<b class="nc"><i>1393</i>&nbsp;                Extension ex = extensions.getExtension(oid.toString());</b>
<i>1394</i>&nbsp;                if (ex != null) {
<i>1395</i>&nbsp;                    return ex;
<b class="nc"><i>1396</i>&nbsp;                }</b>
<i>1397</i>&nbsp;                for (Extension ex2: extensions.getAllExtensions()) {
<b class="nc"><i>1398</i>&nbsp;                    if (ex2.getExtensionId().equals(oid)) {</b>
<b class="nc"><i>1399</i>&nbsp;                        //XXXX May want to consider cloning this</b>
<i>1400</i>&nbsp;                        return ex2;
<i>1401</i>&nbsp;                    }
<b class="nc"><i>1402</i>&nbsp;                }</b>
<b class="nc"><i>1403</i>&nbsp;                /* no such extension in this certificate */</b>
<b class="nc"><i>1404</i>&nbsp;                return null;</b>
<b class="nc"><i>1405</i>&nbsp;            }</b>
<b class="nc"><i>1406</i>&nbsp;        } catch (IOException ioe) {</b>
<i>1407</i>&nbsp;            return null;
<b class="nc"><i>1408</i>&nbsp;        }</b>
<i>1409</i>&nbsp;    }
<i>1410</i>&nbsp;
<b class="nc"><i>1411</i>&nbsp;    public Extension getUnparseableExtension(ObjectIdentifier oid) {</b>
<b class="nc"><i>1412</i>&nbsp;        if (info == null) {</b>
<i>1413</i>&nbsp;            return null;
<b class="nc"><i>1414</i>&nbsp;        }</b>
<i>1415</i>&nbsp;        try {
<b class="nc"><i>1416</i>&nbsp;            CertificateExtensions extensions;</b>
<b class="nc"><i>1417</i>&nbsp;            try {</b>
<b class="nc"><i>1418</i>&nbsp;                extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);</b>
<i>1419</i>&nbsp;            } catch (CertificateException ce) {
<b class="nc"><i>1420</i>&nbsp;                return null;</b>
<b class="nc"><i>1421</i>&nbsp;            }</b>
<i>1422</i>&nbsp;            if (extensions == null) {
<i>1423</i>&nbsp;                return null;
<b class="nc"><i>1424</i>&nbsp;            } else {</b>
<b class="nc"><i>1425</i>&nbsp;                return extensions.getUnparseableExtensions().get(oid.toString());</b>
<b class="nc"><i>1426</i>&nbsp;            }</b>
<i>1427</i>&nbsp;        } catch (IOException ioe) {
<b class="nc"><i>1428</i>&nbsp;            return null;</b>
<b class="nc"><i>1429</i>&nbsp;        }</b>
<b class="nc"><i>1430</i>&nbsp;    }</b>
<b class="nc"><i>1431</i>&nbsp;</b>
<b class="nc"><i>1432</i>&nbsp;    /**</b>
<i>1433</i>&nbsp;     * Gets the DER encoded extension identified by the given
<i>1434</i>&nbsp;     * oid String.
<i>1435</i>&nbsp;     *
<i>1436</i>&nbsp;     * @param oid the Object Identifier value for the extension.
<i>1437</i>&nbsp;     */
<i>1438</i>&nbsp;    public byte[] getExtensionValue(String oid) {
<i>1439</i>&nbsp;        try {
<i>1440</i>&nbsp;            ObjectIdentifier findOID = new ObjectIdentifier(oid);
<i>1441</i>&nbsp;            String extAlias = OIDMap.getName(findOID);
<i>1442</i>&nbsp;            Extension certExt = null;
<b class="nc"><i>1443</i>&nbsp;            CertificateExtensions exts = (CertificateExtensions)info.get(</b>
<b class="nc"><i>1444</i>&nbsp;                                     CertificateExtensions.NAME);</b>
<b class="nc"><i>1445</i>&nbsp;</b>
<i>1446</i>&nbsp;            if (extAlias == null) { // may be unknown
<b class="nc"><i>1447</i>&nbsp;                // get the extensions, search thru&#39; for this oid</b>
<b class="nc"><i>1448</i>&nbsp;                if (exts == null) {</b>
<b class="nc"><i>1449</i>&nbsp;                    return null;</b>
<i>1450</i>&nbsp;                }
<b class="nc"><i>1451</i>&nbsp;</b>
<b class="nc"><i>1452</i>&nbsp;                for (Extension ex : exts.getAllExtensions()) {</b>
<b class="nc"><i>1453</i>&nbsp;                    ObjectIdentifier inCertOID = ex.getExtensionId();</b>
<b class="nc"><i>1454</i>&nbsp;                    if (inCertOID.equals(findOID)) {</b>
<b class="nc"><i>1455</i>&nbsp;                        certExt = ex;</b>
<i>1456</i>&nbsp;                        break;
<b class="nc"><i>1457</i>&nbsp;                    }</b>
<b class="nc"><i>1458</i>&nbsp;                }</b>
<b class="nc"><i>1459</i>&nbsp;            } else { // there&#39;s sub-class that can handle this extension</b>
<i>1460</i>&nbsp;                try {
<i>1461</i>&nbsp;                    certExt = (Extension)this.get(extAlias);
<i>1462</i>&nbsp;                } catch (CertificateException e) {
<i>1463</i>&nbsp;                    // get() throws an Exception instead of returning null, ignore
<i>1464</i>&nbsp;                }
<i>1465</i>&nbsp;            }
<i>1466</i>&nbsp;            if (certExt == null) {
<i>1467</i>&nbsp;                if (exts != null) {
<i>1468</i>&nbsp;                    certExt = exts.getUnparseableExtensions().get(oid);
<i>1469</i>&nbsp;                }
<i>1470</i>&nbsp;                if (certExt == null) {
<b class="nc"><i>1471</i>&nbsp;                    return null;</b>
<b class="nc"><i>1472</i>&nbsp;                }</b>
<i>1473</i>&nbsp;            }
<b class="nc"><i>1474</i>&nbsp;            byte[] extData = certExt.getExtensionValue();</b>
<b class="nc"><i>1475</i>&nbsp;            if (extData == null) {</b>
<b class="nc"><i>1476</i>&nbsp;                return null;</b>
<i>1477</i>&nbsp;            }
<b class="nc"><i>1478</i>&nbsp;            DerOutputStream out = new DerOutputStream();</b>
<b class="nc"><i>1479</i>&nbsp;            out.putOctetString(extData);</b>
<b class="nc"><i>1480</i>&nbsp;            return out.toByteArray();</b>
<i>1481</i>&nbsp;        } catch (Exception e) {
<i>1482</i>&nbsp;            return null;
<i>1483</i>&nbsp;        }
<i>1484</i>&nbsp;    }
<i>1485</i>&nbsp;
<i>1486</i>&nbsp;    /**
<i>1487</i>&nbsp;     * Get a boolean array representing the bits of the KeyUsage extension,
<i>1488</i>&nbsp;     * (oid = 2.5.29.15).
<i>1489</i>&nbsp;     * @return the bit values of this extension as an array of booleans.
<i>1490</i>&nbsp;     */
<i>1491</i>&nbsp;    public boolean[] getKeyUsage() {
<i>1492</i>&nbsp;        try {
<b class="nc"><i>1493</i>&nbsp;            String extAlias = OIDMap.getName(PKIXExtensions.KeyUsage_Id);</b>
<b class="nc"><i>1494</i>&nbsp;            if (extAlias == null)</b>
<b class="nc"><i>1495</i>&nbsp;                return null;</b>
<b class="nc"><i>1496</i>&nbsp;</b>
<b class="nc"><i>1497</i>&nbsp;            KeyUsageExtension certExt = (KeyUsageExtension)this.get(extAlias);</b>
<i>1498</i>&nbsp;            if (certExt == null)
<b class="nc"><i>1499</i>&nbsp;                return null;</b>
<i>1500</i>&nbsp;
<b class="nc"><i>1501</i>&nbsp;            boolean[] ret = certExt.getBits();</b>
<b class="nc"><i>1502</i>&nbsp;            if (ret.length &lt; NUM_STANDARD_KEY_USAGE) {</b>
<b class="nc"><i>1503</i>&nbsp;                boolean[] usageBits = new boolean[NUM_STANDARD_KEY_USAGE];</b>
<i>1504</i>&nbsp;                System.arraycopy(ret, 0, usageBits, 0, ret.length);
<i>1505</i>&nbsp;                ret = usageBits;
<i>1506</i>&nbsp;            }
<i>1507</i>&nbsp;            return ret;
<i>1508</i>&nbsp;        } catch (Exception e) {
<i>1509</i>&nbsp;            return null;
<i>1510</i>&nbsp;        }
<i>1511</i>&nbsp;    }
<i>1512</i>&nbsp;
<i>1513</i>&nbsp;    /**
<b class="nc"><i>1514</i>&nbsp;     * This method are the overridden implementation of</b>
<b class="nc"><i>1515</i>&nbsp;     * getExtendedKeyUsage method in X509Certificate in the Sun</b>
<b class="nc"><i>1516</i>&nbsp;     * provider. It is better performance-wise since it returns cached</b>
<b class="nc"><i>1517</i>&nbsp;     * values.</b>
<b class="nc"><i>1518</i>&nbsp;     */</b>
<b class="nc"><i>1519</i>&nbsp;    public synchronized List&lt;String&gt; getExtendedKeyUsage()</b>
<b class="nc"><i>1520</i>&nbsp;        throws CertificateParsingException {</b>
<i>1521</i>&nbsp;        if (readOnly &amp;&amp; extKeyUsage != null) {
<b class="nc"><i>1522</i>&nbsp;            return extKeyUsage;</b>
<b class="nc"><i>1523</i>&nbsp;        } else {</b>
<b class="nc"><i>1524</i>&nbsp;            ExtendedKeyUsageExtension ext = getExtendedKeyUsageExtension();</b>
<b class="nc"><i>1525</i>&nbsp;            if (ext == null) {</b>
<i>1526</i>&nbsp;                return null;
<b class="nc"><i>1527</i>&nbsp;            }</b>
<b class="nc"><i>1528</i>&nbsp;            extKeyUsage =</b>
<b class="nc"><i>1529</i>&nbsp;                Collections.unmodifiableList(ext.getExtendedKeyUsage());</b>
<i>1530</i>&nbsp;            return extKeyUsage;
<i>1531</i>&nbsp;        }
<i>1532</i>&nbsp;    }
<i>1533</i>&nbsp;
<i>1534</i>&nbsp;    /**
<i>1535</i>&nbsp;     * This static method is the default implementation of the
<i>1536</i>&nbsp;     * getExtendedKeyUsage method in X509Certificate. A
<i>1537</i>&nbsp;     * X509Certificate provider generally should overwrite this to
<i>1538</i>&nbsp;     * provide among other things caching for better performance.
<i>1539</i>&nbsp;     */
<i>1540</i>&nbsp;    public static List&lt;String&gt; getExtendedKeyUsage(X509Certificate cert)
<i>1541</i>&nbsp;        throws CertificateParsingException {
<i>1542</i>&nbsp;        try {
<b class="nc"><i>1543</i>&nbsp;            byte[] ext = cert.getExtensionValue(EXTENDED_KEY_USAGE_OID);</b>
<b class="nc"><i>1544</i>&nbsp;            if (ext == null)</b>
<i>1545</i>&nbsp;                return null;
<b class="nc"><i>1546</i>&nbsp;            DerValue val = new DerValue(ext);</b>
<b class="nc"><i>1547</i>&nbsp;            byte[] data = val.getOctetString();</b>
<b class="nc"><i>1548</i>&nbsp;</b>
<b class="nc"><i>1549</i>&nbsp;            ExtendedKeyUsageExtension ekuExt =</b>
<b class="nc"><i>1550</i>&nbsp;                new ExtendedKeyUsageExtension(Boolean.FALSE, data);</b>
<b class="nc"><i>1551</i>&nbsp;            return Collections.unmodifiableList(ekuExt.getExtendedKeyUsage());</b>
<i>1552</i>&nbsp;        } catch (IOException ioe) {
<b class="nc"><i>1553</i>&nbsp;            throw new CertificateParsingException(ioe);</b>
<b class="nc"><i>1554</i>&nbsp;        }</b>
<i>1555</i>&nbsp;    }
<b class="nc"><i>1556</i>&nbsp;</b>
<b class="nc"><i>1557</i>&nbsp;    /**</b>
<i>1558</i>&nbsp;     * Get the certificate constraints path length from
<b class="nc"><i>1559</i>&nbsp;     * the critical BasicConstraints extension, (oid = 2.5.29.19).</b>
<b class="nc"><i>1560</i>&nbsp;     * @return the length of the constraint.</b>
<i>1561</i>&nbsp;     */
<b class="nc"><i>1562</i>&nbsp;    public int getBasicConstraints() {</b>
<b class="nc"><i>1563</i>&nbsp;        try {</b>
<i>1564</i>&nbsp;            String extAlias = OIDMap.getName(PKIXExtensions.BasicConstraints_Id);
<i>1565</i>&nbsp;            if (extAlias == null)
<b class="nc"><i>1566</i>&nbsp;                return -1;</b>
<b class="nc"><i>1567</i>&nbsp;            BasicConstraintsExtension certExt =</b>
<i>1568</i>&nbsp;                        (BasicConstraintsExtension)this.get(extAlias);
<b class="nc"><i>1569</i>&nbsp;            if (certExt == null)</b>
<i>1570</i>&nbsp;                return -1;
<b class="nc"><i>1571</i>&nbsp;</b>
<i>1572</i>&nbsp;            if (((Boolean)certExt.get(BasicConstraintsExtension.IS_CA)
<i>1573</i>&nbsp;                 ).booleanValue() == true)
<b class="nc"><i>1574</i>&nbsp;                return ((Integer)certExt.get(</b>
<b class="nc"><i>1575</i>&nbsp;                        BasicConstraintsExtension.PATH_LEN)).intValue();</b>
<i>1576</i>&nbsp;            else
<i>1577</i>&nbsp;                return -1;
<b class="nc"><i>1578</i>&nbsp;        } catch (Exception e) {</b>
<i>1579</i>&nbsp;            return -1;
<b class="nc"><i>1580</i>&nbsp;        }</b>
<b class="nc"><i>1581</i>&nbsp;    }</b>
<i>1582</i>&nbsp;
<i>1583</i>&nbsp;    /**
<b class="nc"><i>1584</i>&nbsp;     * Converts a GeneralNames structure into an immutable Collection of</b>
<b class="nc"><i>1585</i>&nbsp;     * alternative names (subject or issuer) in the form required by</b>
<b class="nc"><i>1586</i>&nbsp;     * {@link #getSubjectAlternativeNames} or</b>
<i>1587</i>&nbsp;     * {@link #getIssuerAlternativeNames}.
<i>1588</i>&nbsp;     *
<b class="nc"><i>1589</i>&nbsp;     * @param names the GeneralNames to be converted</b>
<b class="nc"><i>1590</i>&nbsp;     * @return an immutable Collection of alternative names</b>
<b class="nc"><i>1591</i>&nbsp;     */</b>
<i>1592</i>&nbsp;    private static Collection&lt;List&lt;?&gt;&gt; makeAltNames(GeneralNames names) {
<i>1593</i>&nbsp;        if (names.isEmpty()) {
<i>1594</i>&nbsp;            return Collections.&lt;List&lt;?&gt;&gt;emptySet();
<i>1595</i>&nbsp;        }
<i>1596</i>&nbsp;        List&lt;List&lt;?&gt;&gt; newNames = new ArrayList&lt;&gt;();
<i>1597</i>&nbsp;        for (GeneralName gname : names.names()) {
<i>1598</i>&nbsp;            GeneralNameInterface name = gname.getName();
<b class="nc"><i>1599</i>&nbsp;            List&lt;Object&gt; nameEntry = new ArrayList&lt;&gt;(2);</b>
<b class="nc"><i>1600</i>&nbsp;            nameEntry.add(Integer.valueOf(name.getType()));</b>
<b class="nc"><i>1601</i>&nbsp;            switch (name.getType()) {</b>
<i>1602</i>&nbsp;            case GeneralNameInterface.NAME_RFC822:
<b class="nc"><i>1603</i>&nbsp;                nameEntry.add(((RFC822Name) name).getName());</b>
<i>1604</i>&nbsp;                break;
<b class="nc"><i>1605</i>&nbsp;            case GeneralNameInterface.NAME_DNS:</b>
<b class="nc"><i>1606</i>&nbsp;                nameEntry.add(((DNSName) name).getName());</b>
<b class="nc"><i>1607</i>&nbsp;                break;</b>
<b class="nc"><i>1608</i>&nbsp;            case GeneralNameInterface.NAME_DIRECTORY:</b>
<b class="nc"><i>1609</i>&nbsp;                nameEntry.add(((X500Name) name).getRFC2253Name());</b>
<b class="nc"><i>1610</i>&nbsp;                break;</b>
<b class="nc"><i>1611</i>&nbsp;            case GeneralNameInterface.NAME_URI:</b>
<i>1612</i>&nbsp;                nameEntry.add(((URIName) name).getName());
<b class="nc"><i>1613</i>&nbsp;                break;</b>
<b class="nc"><i>1614</i>&nbsp;            case GeneralNameInterface.NAME_IP:</b>
<b class="nc"><i>1615</i>&nbsp;                try {</b>
<b class="nc"><i>1616</i>&nbsp;                    nameEntry.add(((IPAddressName) name).getName());</b>
<i>1617</i>&nbsp;                } catch (IOException ioe) {
<b class="nc"><i>1618</i>&nbsp;                    // IPAddressName in cert is bogus</b>
<b class="nc"><i>1619</i>&nbsp;                    throw new RuntimeException(&quot;IPAddress cannot be parsed&quot;,</b>
<i>1620</i>&nbsp;                        ioe);
<b class="nc"><i>1621</i>&nbsp;                }</b>
<i>1622</i>&nbsp;                break;
<i>1623</i>&nbsp;            case GeneralNameInterface.NAME_OID:
<i>1624</i>&nbsp;                nameEntry.add(((OIDName) name).getOID().toString());
<i>1625</i>&nbsp;                break;
<i>1626</i>&nbsp;            default:
<i>1627</i>&nbsp;                // add DER encoded form
<i>1628</i>&nbsp;                DerOutputStream derOut = new DerOutputStream();
<i>1629</i>&nbsp;                try {
<i>1630</i>&nbsp;                    name.encode(derOut);
<i>1631</i>&nbsp;                } catch (IOException ioe) {
<i>1632</i>&nbsp;                    // should not occur since name has already been decoded
<i>1633</i>&nbsp;                    // from cert (this would indicate a bug in our code)
<b class="nc"><i>1634</i>&nbsp;                    throw new RuntimeException(&quot;name cannot be encoded&quot;, ioe);</b>
<b class="nc"><i>1635</i>&nbsp;                }</b>
<i>1636</i>&nbsp;                nameEntry.add(derOut.toByteArray());
<b class="nc"><i>1637</i>&nbsp;                break;</b>
<b class="nc"><i>1638</i>&nbsp;            }</b>
<b class="nc"><i>1639</i>&nbsp;            newNames.add(Collections.unmodifiableList(nameEntry));</b>
<b class="nc"><i>1640</i>&nbsp;        }</b>
<i>1641</i>&nbsp;        return Collections.unmodifiableCollection(newNames);
<i>1642</i>&nbsp;    }
<i>1643</i>&nbsp;
<b class="nc"><i>1644</i>&nbsp;    /**</b>
<i>1645</i>&nbsp;     * Checks a Collection of altNames and clones any name entries of type
<b class="nc"><i>1646</i>&nbsp;     * byte [].</b>
<i>1647</i>&nbsp;     */ // only partially generified due to javac bug
<b class="nc"><i>1648</i>&nbsp;    private static Collection&lt;List&lt;?&gt;&gt; cloneAltNames(Collection&lt;List&lt;?&gt;&gt; altNames) {</b>
<b class="nc"><i>1649</i>&nbsp;        boolean mustClone = false;</b>
<b class="nc"><i>1650</i>&nbsp;        for (List&lt;?&gt; nameEntry : altNames) {</b>
<b class="nc"><i>1651</i>&nbsp;            if (nameEntry.get(1) instanceof byte[]) {</b>
<i>1652</i>&nbsp;                // must clone names
<i>1653</i>&nbsp;                mustClone = true;
<i>1654</i>&nbsp;            }
<i>1655</i>&nbsp;        }
<i>1656</i>&nbsp;        if (mustClone) {
<i>1657</i>&nbsp;            List&lt;List&lt;?&gt;&gt; namesCopy = new ArrayList&lt;&gt;();
<i>1658</i>&nbsp;            for (List&lt;?&gt; nameEntry : altNames) {
<i>1659</i>&nbsp;                Object nameObject = nameEntry.get(1);
<i>1660</i>&nbsp;                if (nameObject instanceof byte[]) {
<i>1661</i>&nbsp;                    List&lt;Object&gt; nameEntryCopy =
<i>1662</i>&nbsp;                                        new ArrayList&lt;&gt;(nameEntry);
<b class="nc"><i>1663</i>&nbsp;                    nameEntryCopy.set(1, ((byte[])nameObject).clone());</b>
<b class="nc"><i>1664</i>&nbsp;                    namesCopy.add(Collections.unmodifiableList(nameEntryCopy));</b>
<b class="nc"><i>1665</i>&nbsp;                } else {</b>
<i>1666</i>&nbsp;                    namesCopy.add(nameEntry);
<b class="nc"><i>1667</i>&nbsp;                }</b>
<b class="nc"><i>1668</i>&nbsp;            }</b>
<i>1669</i>&nbsp;            return Collections.unmodifiableCollection(namesCopy);
<b class="nc"><i>1670</i>&nbsp;        } else {</b>
<i>1671</i>&nbsp;            return altNames;
<i>1672</i>&nbsp;        }
<i>1673</i>&nbsp;    }
<i>1674</i>&nbsp;
<i>1675</i>&nbsp;    /**
<b class="nc"><i>1676</i>&nbsp;     * This method are the overridden implementation of</b>
<i>1677</i>&nbsp;     * getSubjectAlternativeNames method in X509Certificate in the Sun
<b class="nc"><i>1678</i>&nbsp;     * provider. It is better performance-wise since it returns cached</b>
<i>1679</i>&nbsp;     * values.
<b class="nc"><i>1680</i>&nbsp;     */</b>
<b class="nc"><i>1681</i>&nbsp;    public synchronized Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames()</b>
<b class="nc"><i>1682</i>&nbsp;        throws CertificateParsingException {</b>
<b class="nc"><i>1683</i>&nbsp;        // return cached value if we can</b>
<b class="nc"><i>1684</i>&nbsp;        if (readOnly &amp;&amp; subjectAlternativeNames != null)  {</b>
<i>1685</i>&nbsp;            return cloneAltNames(subjectAlternativeNames);
<i>1686</i>&nbsp;        }
<i>1687</i>&nbsp;        SubjectAlternativeNameExtension subjectAltNameExt =
<i>1688</i>&nbsp;            getSubjectAlternativeNameExtension();
<i>1689</i>&nbsp;        if (subjectAltNameExt == null) {
<i>1690</i>&nbsp;            return null;
<i>1691</i>&nbsp;        }
<i>1692</i>&nbsp;        GeneralNames names;
<i>1693</i>&nbsp;        try {
<i>1694</i>&nbsp;            names = subjectAltNameExt.get(
<i>1695</i>&nbsp;                    SubjectAlternativeNameExtension.SUBJECT_NAME);
<i>1696</i>&nbsp;        } catch (IOException ioe) {
<b class="nc"><i>1697</i>&nbsp;            // should not occur</b>
<b class="nc"><i>1698</i>&nbsp;            return Collections.&lt;List&lt;?&gt;&gt;emptySet();</b>
<i>1699</i>&nbsp;        }
<b class="nc"><i>1700</i>&nbsp;        subjectAlternativeNames = makeAltNames(names);</b>
<b class="nc"><i>1701</i>&nbsp;        return subjectAlternativeNames;</b>
<b class="nc"><i>1702</i>&nbsp;    }</b>
<b class="nc"><i>1703</i>&nbsp;</b>
<i>1704</i>&nbsp;    /**
<i>1705</i>&nbsp;     * This static method is the default implementation of the
<i>1706</i>&nbsp;     * getSubjectAlternaitveNames method in X509Certificate. A
<b class="nc"><i>1707</i>&nbsp;     * X509Certificate provider generally should overwrite this to</b>
<i>1708</i>&nbsp;     * provide among other things caching for better performance.
<b class="nc"><i>1709</i>&nbsp;     */</b>
<i>1710</i>&nbsp;    public static Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames(X509Certificate cert)
<b class="nc"><i>1711</i>&nbsp;        throws CertificateParsingException {</b>
<b class="nc"><i>1712</i>&nbsp;        try {</b>
<b class="nc"><i>1713</i>&nbsp;            byte[] ext = cert.getExtensionValue(SUBJECT_ALT_NAME_OID);</b>
<b class="nc"><i>1714</i>&nbsp;            if (ext == null) {</b>
<i>1715</i>&nbsp;                return null;
<i>1716</i>&nbsp;            }
<i>1717</i>&nbsp;            DerValue val = new DerValue(ext);
<i>1718</i>&nbsp;            byte[] data = val.getOctetString();
<i>1719</i>&nbsp;
<i>1720</i>&nbsp;            SubjectAlternativeNameExtension subjectAltNameExt =
<i>1721</i>&nbsp;                new SubjectAlternativeNameExtension(Boolean.FALSE,
<i>1722</i>&nbsp;                                                    data);
<i>1723</i>&nbsp;
<i>1724</i>&nbsp;            GeneralNames names;
<i>1725</i>&nbsp;            try {
<b class="nc"><i>1726</i>&nbsp;                names = subjectAltNameExt.get(</b>
<b class="nc"><i>1727</i>&nbsp;                        SubjectAlternativeNameExtension.SUBJECT_NAME);</b>
<b class="nc"><i>1728</i>&nbsp;            }  catch (IOException ioe) {</b>
<i>1729</i>&nbsp;                // should not occur
<i>1730</i>&nbsp;                return Collections.&lt;List&lt;?&gt;&gt;emptySet();
<b class="nc"><i>1731</i>&nbsp;            }</b>
<b class="nc"><i>1732</i>&nbsp;            return makeAltNames(names);</b>
<i>1733</i>&nbsp;        } catch (IOException ioe) {
<b class="nc"><i>1734</i>&nbsp;            throw new CertificateParsingException(ioe);</b>
<i>1735</i>&nbsp;        }
<i>1736</i>&nbsp;    }
<i>1737</i>&nbsp;
<i>1738</i>&nbsp;    /**
<b class="nc"><i>1739</i>&nbsp;     * This method are the overridden implementation of</b>
<i>1740</i>&nbsp;     * getIssuerAlternativeNames method in X509Certificate in the Sun
<b class="nc"><i>1741</i>&nbsp;     * provider. It is better performance-wise since it returns cached</b>
<i>1742</i>&nbsp;     * values.
<b class="nc"><i>1743</i>&nbsp;     */</b>
<b class="nc"><i>1744</i>&nbsp;    public synchronized Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames()</b>
<b class="nc"><i>1745</i>&nbsp;        throws CertificateParsingException {</b>
<b class="nc"><i>1746</i>&nbsp;        // return cached value if we can</b>
<b class="nc"><i>1747</i>&nbsp;        if (readOnly &amp;&amp; issuerAlternativeNames != null) {</b>
<i>1748</i>&nbsp;            return cloneAltNames(issuerAlternativeNames);
<i>1749</i>&nbsp;        }
<i>1750</i>&nbsp;        IssuerAlternativeNameExtension issuerAltNameExt =
<i>1751</i>&nbsp;            getIssuerAlternativeNameExtension();
<b class="nc"><i>1752</i>&nbsp;        if (issuerAltNameExt == null) {</b>
<b class="nc"><i>1753</i>&nbsp;            return null;</b>
<i>1754</i>&nbsp;        }
<i>1755</i>&nbsp;        GeneralNames names;
<i>1756</i>&nbsp;        try {
<i>1757</i>&nbsp;            names = issuerAltNameExt.get(
<i>1758</i>&nbsp;                    IssuerAlternativeNameExtension.ISSUER_NAME);
<i>1759</i>&nbsp;        } catch (IOException ioe) {
<i>1760</i>&nbsp;            // should not occur
<i>1761</i>&nbsp;            return Collections.&lt;List&lt;?&gt;&gt;emptySet();
<i>1762</i>&nbsp;        }
<i>1763</i>&nbsp;        issuerAlternativeNames = makeAltNames(names);
<i>1764</i>&nbsp;        return issuerAlternativeNames;
<i>1765</i>&nbsp;    }
<i>1766</i>&nbsp;
<i>1767</i>&nbsp;    /**
<i>1768</i>&nbsp;     * This static method is the default implementation of the
<i>1769</i>&nbsp;     * getIssuerAlternaitveNames method in X509Certificate. A
<i>1770</i>&nbsp;     * X509Certificate provider generally should overwrite this to
<b class="nc"><i>1771</i>&nbsp;     * provide among other things caching for better performance.</b>
<b class="nc"><i>1772</i>&nbsp;     */</b>
<i>1773</i>&nbsp;    public static Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames(X509Certificate cert)
<i>1774</i>&nbsp;        throws CertificateParsingException {
<b class="nc"><i>1775</i>&nbsp;        try {</b>
<b class="nc"><i>1776</i>&nbsp;            byte[] ext = cert.getExtensionValue(ISSUER_ALT_NAME_OID);</b>
<i>1777</i>&nbsp;            if (ext == null) {
<i>1778</i>&nbsp;                return null;
<b class="nc"><i>1779</i>&nbsp;            }</b>
<b class="nc"><i>1780</i>&nbsp;</b>
<i>1781</i>&nbsp;            DerValue val = new DerValue(ext);
<b class="nc"><i>1782</i>&nbsp;            byte[] data = val.getOctetString();</b>
<b class="nc"><i>1783</i>&nbsp;</b>
<b class="nc"><i>1784</i>&nbsp;            IssuerAlternativeNameExtension issuerAltNameExt =</b>
<i>1785</i>&nbsp;                new IssuerAlternativeNameExtension(Boolean.FALSE,
<b class="nc"><i>1786</i>&nbsp;                                                    data);</b>
<b class="nc"><i>1787</i>&nbsp;            GeneralNames names;</b>
<b class="nc"><i>1788</i>&nbsp;            try {</b>
<i>1789</i>&nbsp;                names = issuerAltNameExt.get(
<b class="nc"><i>1790</i>&nbsp;                        IssuerAlternativeNameExtension.ISSUER_NAME);</b>
<b class="nc"><i>1791</i>&nbsp;            }  catch (IOException ioe) {</b>
<i>1792</i>&nbsp;                // should not occur
<i>1793</i>&nbsp;                return Collections.&lt;List&lt;?&gt;&gt;emptySet();
<b class="nc"><i>1794</i>&nbsp;            }</b>
<b class="nc"><i>1795</i>&nbsp;            return makeAltNames(names);</b>
<i>1796</i>&nbsp;        } catch (IOException ioe) {
<b class="nc"><i>1797</i>&nbsp;            throw new CertificateParsingException(ioe);</b>
<b class="nc"><i>1798</i>&nbsp;        }</b>
<i>1799</i>&nbsp;    }
<b class="nc"><i>1800</i>&nbsp;</b>
<b class="nc"><i>1801</i>&nbsp;    public AuthorityInfoAccessExtension getAuthorityInfoAccessExtension() {</b>
<i>1802</i>&nbsp;        return (AuthorityInfoAccessExtension)
<i>1803</i>&nbsp;            getExtension(PKIXExtensions.AuthInfoAccess_Id);
<b class="nc"><i>1804</i>&nbsp;    }</b>
<i>1805</i>&nbsp;
<i>1806</i>&nbsp;    /************************************************************/
<b class="nc"><i>1807</i>&nbsp;</b>
<i>1808</i>&nbsp;    /*
<i>1809</i>&nbsp;     * Cert is a SIGNED ASN.1 macro, a three elment sequence:
<i>1810</i>&nbsp;     *
<b class="nc"><i>1811</i>&nbsp;     *  - Data to be signed (ToBeSigned) -- the &quot;raw&quot; cert</b>
<b class="nc"><i>1812</i>&nbsp;     *  - Signature algorithm (SigAlgId)</b>
<b class="nc"><i>1813</i>&nbsp;     *  - The signature bits</b>
<i>1814</i>&nbsp;     *
<i>1815</i>&nbsp;     * This routine unmarshals the certificate, saving the signature
<i>1816</i>&nbsp;     * parts away for later verification.
<i>1817</i>&nbsp;     */
<i>1818</i>&nbsp;    private void parse(DerValue val)
<i>1819</i>&nbsp;    throws CertificateException, IOException {
<i>1820</i>&nbsp;        // check if can over write the certificate
<i>1821</i>&nbsp;        if (readOnly)
<i>1822</i>&nbsp;            throw new CertificateParsingException(
<b class="nc"><i>1823</i>&nbsp;                      &quot;cannot over-write existing certificate&quot;);</b>
<b class="nc"><i>1824</i>&nbsp;</b>
<b class="nc"><i>1825</i>&nbsp;        if (val.data == null || val.tag != DerValue.tag_Sequence)</b>
<b class="nc"><i>1826</i>&nbsp;            throw new CertificateParsingException(</b>
<i>1827</i>&nbsp;                      &quot;invalid DER-encoded certificate data&quot;);
<b class="nc"><i>1828</i>&nbsp;</b>
<i>1829</i>&nbsp;        signedCert = val.toByteArray();
<b class="nc"><i>1830</i>&nbsp;        DerValue[] seq = new DerValue[3];</b>
<b class="nc"><i>1831</i>&nbsp;</b>
<i>1832</i>&nbsp;        seq[0] = val.data.getDerValue();
<i>1833</i>&nbsp;        seq[1] = val.data.getDerValue();
<b class="nc"><i>1834</i>&nbsp;        seq[2] = val.data.getDerValue();</b>
<b class="nc"><i>1835</i>&nbsp;</b>
<b class="nc"><i>1836</i>&nbsp;        if (val.data.available() != 0) {</b>
<b class="nc"><i>1837</i>&nbsp;            throw new CertificateParsingException(&quot;signed overrun, bytes = &quot;</b>
<b class="nc"><i>1838</i>&nbsp;                                     + val.data.available());</b>
<i>1839</i>&nbsp;        }
<b class="nc"><i>1840</i>&nbsp;        if (seq[0].tag != DerValue.tag_Sequence) {</b>
<b class="nc"><i>1841</i>&nbsp;            throw new CertificateParsingException(&quot;signed fields invalid&quot;);</b>
<i>1842</i>&nbsp;        }
<i>1843</i>&nbsp;
<i>1844</i>&nbsp;        algId = AlgorithmId.parse(seq[1]);
<i>1845</i>&nbsp;        signature = seq[2].getBitString();
<i>1846</i>&nbsp;
<i>1847</i>&nbsp;        if (seq[1].data.available() != 0) {
<i>1848</i>&nbsp;            throw new CertificateParsingException(&quot;algid field overrun&quot;);
<i>1849</i>&nbsp;        }
<b class="nc"><i>1850</i>&nbsp;        if (seq[2].data.available() != 0)</b>
<b class="nc"><i>1851</i>&nbsp;            throw new CertificateParsingException(&quot;signed fields overrun&quot;);</b>
<b class="nc"><i>1852</i>&nbsp;</b>
<i>1853</i>&nbsp;        // The CertificateInfo
<i>1854</i>&nbsp;        info = new X509CertInfo(seq[0]);
<i>1855</i>&nbsp;
<i>1856</i>&nbsp;        // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
<i>1857</i>&nbsp;        AlgorithmId infoSigAlg = (AlgorithmId)info.get(
<i>1858</i>&nbsp;                                              CertificateAlgorithmId.NAME
<i>1859</i>&nbsp;                                              + DOT +
<i>1860</i>&nbsp;                                              CertificateAlgorithmId.ALGORITHM);
<i>1861</i>&nbsp;        if (! algId.equals(infoSigAlg))
<b class="nc"><i>1862</i>&nbsp;            throw new CertificateException(&quot;Signature algorithm mismatch&quot;);</b>
<b class="nc"><i>1863</i>&nbsp;        readOnly = true;</b>
<b class="nc"><i>1864</i>&nbsp;    }</b>
<i>1865</i>&nbsp;
<i>1866</i>&nbsp;    /**
<i>1867</i>&nbsp;     * Extract the subject or issuer X500Principal from an X509Certificate.
<i>1868</i>&nbsp;     * Parses the encoded form of the cert to preserve the principal&#39;s
<i>1869</i>&nbsp;     * ASN.1 encoding.
<i>1870</i>&nbsp;     */
<i>1871</i>&nbsp;    private static X500Principal getX500Principal(X509Certificate cert,
<i>1872</i>&nbsp;            boolean getIssuer) throws Exception {
<i>1873</i>&nbsp;        byte[] encoded = cert.getEncoded();
<i>1874</i>&nbsp;        DerInputStream derIn = new DerInputStream(encoded);
<i>1875</i>&nbsp;        DerValue tbsCert = derIn.getSequence(3)[0];
<b class="nc"><i>1876</i>&nbsp;        DerInputStream tbsIn = tbsCert.data;</b>
<b class="nc"><i>1877</i>&nbsp;        DerValue tmp;</b>
<i>1878</i>&nbsp;        tmp = tbsIn.getDerValue();
<b class="nc"><i>1879</i>&nbsp;        // skip version number if present</b>
<i>1880</i>&nbsp;        if (tmp.isContextSpecific((byte)0)) {
<i>1881</i>&nbsp;          tmp = tbsIn.getDerValue();
<i>1882</i>&nbsp;        }
<i>1883</i>&nbsp;        // tmp always contains serial number now
<i>1884</i>&nbsp;        tmp = tbsIn.getDerValue();              // skip signature
<i>1885</i>&nbsp;        tmp = tbsIn.getDerValue();              // issuer
<i>1886</i>&nbsp;        if (getIssuer == false) {
<i>1887</i>&nbsp;            tmp = tbsIn.getDerValue();          // skip validity
<i>1888</i>&nbsp;            tmp = tbsIn.getDerValue();          // subject
<i>1889</i>&nbsp;        }
<b class="nc"><i>1890</i>&nbsp;        byte[] principalBytes = tmp.toByteArray();</b>
<b class="nc"><i>1891</i>&nbsp;        return new X500Principal(principalBytes);</b>
<i>1892</i>&nbsp;    }
<b class="nc"><i>1893</i>&nbsp;</b>
<i>1894</i>&nbsp;    /**
<i>1895</i>&nbsp;     * Extract the subject X500Principal from an X509Certificate.
<i>1896</i>&nbsp;     * Called from java.security.cert.X509Certificate.getSubjectX500Principal().
<i>1897</i>&nbsp;     */
<i>1898</i>&nbsp;    public static X500Principal getSubjectX500Principal(X509Certificate cert) {
<i>1899</i>&nbsp;        try {
<i>1900</i>&nbsp;            return getX500Principal(cert, false);
<i>1901</i>&nbsp;        } catch (Exception e) {
<b class="nc"><i>1902</i>&nbsp;            throw new RuntimeException(&quot;Could not parse subject&quot;, e);</b>
<b class="nc"><i>1903</i>&nbsp;        }</b>
<b class="nc"><i>1904</i>&nbsp;    }</b>
<i>1905</i>&nbsp;
<i>1906</i>&nbsp;    /**
<i>1907</i>&nbsp;     * Extract the issuer X500Principal from an X509Certificate.
<i>1908</i>&nbsp;     * Called from java.security.cert.X509Certificate.getIssuerX500Principal().
<i>1909</i>&nbsp;     */
<i>1910</i>&nbsp;    public static X500Principal getIssuerX500Principal(X509Certificate cert) {
<i>1911</i>&nbsp;        try {
<i>1912</i>&nbsp;            return getX500Principal(cert, true);
<i>1913</i>&nbsp;        } catch (Exception e) {
<i>1914</i>&nbsp;            throw new RuntimeException(&quot;Could not parse issuer&quot;, e);
<b class="nc"><i>1915</i>&nbsp;        }</b>
<i>1916</i>&nbsp;    }
<b class="nc"><i>1917</i>&nbsp;</b>
<b class="nc"><i>1918</i>&nbsp;    /**</b>
<i>1919</i>&nbsp;     * Returned the encoding of the given certificate for internal use.
<b class="nc"><i>1920</i>&nbsp;     * Callers must guarantee that they neither modify it nor expose it</b>
<i>1921</i>&nbsp;     * to untrusted code. Uses getEncodedInternal() if the certificate
<b class="nc"><i>1922</i>&nbsp;     * is instance of X509CertImpl, getEncoded() otherwise.</b>
<b class="nc"><i>1923</i>&nbsp;     */</b>
<i>1924</i>&nbsp;    public static byte[] getEncodedInternal(Certificate cert)
<i>1925</i>&nbsp;            throws CertificateEncodingException {
<i>1926</i>&nbsp;        if (cert instanceof X509CertImpl) {
<b class="nc"><i>1927</i>&nbsp;            return ((X509CertImpl)cert).getEncodedInternal();</b>
<i>1928</i>&nbsp;        } else {
<i>1929</i>&nbsp;            return cert.getEncoded();
<b class="nc"><i>1930</i>&nbsp;        }</b>
<i>1931</i>&nbsp;    }
<i>1932</i>&nbsp;
<i>1933</i>&nbsp;    /**
<b class="nc"><i>1934</i>&nbsp;     * Utility method to convert an arbitrary instance of X509Certificate</b>
<b class="nc"><i>1935</i>&nbsp;     * to a X509CertImpl. Does a cast if possible, otherwise reparses</b>
<i>1936</i>&nbsp;     * the encoding.
<i>1937</i>&nbsp;     */
<i>1938</i>&nbsp;    public static X509CertImpl toImpl(X509Certificate cert)
<i>1939</i>&nbsp;            throws CertificateException {
<i>1940</i>&nbsp;        if (cert instanceof X509CertImpl) {
<i>1941</i>&nbsp;            return (X509CertImpl)cert;
<i>1942</i>&nbsp;        } else {
<i>1943</i>&nbsp;            return X509Factory.intern(cert);
<b class="nc"><i>1944</i>&nbsp;        }</b>
<i>1945</i>&nbsp;    }
<b class="nc"><i>1946</i>&nbsp;</b>
<b class="nc"><i>1947</i>&nbsp;    /**</b>
<b class="nc"><i>1948</i>&nbsp;     * Utility method to test if a certificate is self-issued. This is</b>
<b class="nc"><i>1949</i>&nbsp;     * the case iff the subject and issuer X500Principals are equal.</b>
<b class="nc"><i>1950</i>&nbsp;     */</b>
<b class="nc"><i>1951</i>&nbsp;    public static boolean isSelfIssued(X509Certificate cert) {</b>
<i>1952</i>&nbsp;        X500Principal subject = cert.getSubjectX500Principal();
<b class="nc"><i>1953</i>&nbsp;        X500Principal issuer = cert.getIssuerX500Principal();</b>
<b class="nc"><i>1954</i>&nbsp;        return subject.equals(issuer);</b>
<i>1955</i>&nbsp;    }
<b class="nc"><i>1956</i>&nbsp;</b>
<b class="nc"><i>1957</i>&nbsp;    /**</b>
<i>1958</i>&nbsp;     * Utility method to test if a certificate is self-signed. This is
<i>1959</i>&nbsp;     * the case iff the subject and issuer X500Principals are equal
<i>1960</i>&nbsp;     * AND the certificate&#39;s subject public key can be used to verify
<i>1961</i>&nbsp;     * the certificate. In case of exception, returns false.
<i>1962</i>&nbsp;     */
<i>1963</i>&nbsp;    public static boolean isSelfSigned(X509Certificate cert,
<b class="nc"><i>1964</i>&nbsp;        String sigProvider) {</b>
<i>1965</i>&nbsp;        if (isSelfIssued(cert)) {
<b class="nc"><i>1966</i>&nbsp;            try {</b>
<b class="nc"><i>1967</i>&nbsp;                if (sigProvider == null) {</b>
<b class="nc"><i>1968</i>&nbsp;                    cert.verify(cert.getPublicKey());</b>
<b class="nc"><i>1969</i>&nbsp;                } else {</b>
<i>1970</i>&nbsp;                    cert.verify(cert.getPublicKey(), sigProvider);
<i>1971</i>&nbsp;                }
<i>1972</i>&nbsp;                return true;
<i>1973</i>&nbsp;            } catch (Exception e) {
<i>1974</i>&nbsp;                // In case of exception, return false
<i>1975</i>&nbsp;            }
<i>1976</i>&nbsp;        }
<i>1977</i>&nbsp;        return false;
<i>1978</i>&nbsp;    }
<i>1979</i>&nbsp;
<i>1980</i>&nbsp;    private ConcurrentHashMap&lt;String,String&gt; fingerprints =
<i>1981</i>&nbsp;            new ConcurrentHashMap&lt;&gt;(2);
<i>1982</i>&nbsp;
<i>1983</i>&nbsp;    public String getFingerprint(String algorithm) {
<i>1984</i>&nbsp;        return fingerprints.computeIfAbsent(algorithm,
<i>1985</i>&nbsp;            x -&gt; getFingerprint(x, this));
<i>1986</i>&nbsp;    }
<i>1987</i>&nbsp;
<i>1988</i>&nbsp;    /**
<i>1989</i>&nbsp;     * Gets the requested finger print of the certificate. The result
<i>1990</i>&nbsp;     * only contains 0-9 and A-F. No small case, no colon.
<i>1991</i>&nbsp;     */
<i>1992</i>&nbsp;    public static String getFingerprint(String algorithm,
<i>1993</i>&nbsp;            X509Certificate cert) {
<i>1994</i>&nbsp;        try {
<i>1995</i>&nbsp;            byte[] encCertInfo = cert.getEncoded();
<i>1996</i>&nbsp;            MessageDigest md = MessageDigest.getInstance(algorithm);
<i>1997</i>&nbsp;            byte[] digest = md.digest(encCertInfo);
<i>1998</i>&nbsp;            StringBuilder sb = new StringBuilder(digest.length * 2);
<i>1999</i>&nbsp;            for (int i = 0; i &lt; digest.length; i++) {
<i>2000</i>&nbsp;                byte2hex(digest[i], sb);
<i>2001</i>&nbsp;            }
<i>2002</i>&nbsp;            return sb.toString();
<i>2003</i>&nbsp;        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {
<i>2004</i>&nbsp;            // ignored
<i>2005</i>&nbsp;        }
<i>2006</i>&nbsp;        return &quot;&quot;;
<i>2007</i>&nbsp;    }
<i>2008</i>&nbsp;
<i>2009</i>&nbsp;    /**
<i>2010</i>&nbsp;     * Converts a byte to hex digit and writes to the supplied builder
<i>2011</i>&nbsp;     */
<i>2012</i>&nbsp;    private static void byte2hex(byte b, StringBuilder buf) {
<i>2013</i>&nbsp;        char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,
<i>2014</i>&nbsp;                &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };
<i>2015</i>&nbsp;        int high = ((b &amp; 0xf0) &gt;&gt; 4);
<i>2016</i>&nbsp;        int low = (b &amp; 0x0f);
<i>2017</i>&nbsp;        buf.append(hexChars[high])
<i>2018</i>&nbsp;            .append(hexChars[low]);
<i>2019</i>&nbsp;    }
<i>2020</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:14</div>
</div>
</body>
</html>
