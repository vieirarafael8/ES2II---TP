


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DrawImage</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.java2d.pipe</a> ]
</div>

<h1>Coverage Summary for Class: DrawImage (sun.java2d.pipe)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DrawImage</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 398)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.java2d.pipe;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.awt.AlphaComposite;
<i>29</i>&nbsp;import java.awt.Color;
<i>30</i>&nbsp;import java.awt.Image;
<i>31</i>&nbsp;import java.awt.Transparency;
<i>32</i>&nbsp;import java.awt.geom.AffineTransform;
<i>33</i>&nbsp;import java.awt.geom.NoninvertibleTransformException;
<i>34</i>&nbsp;import java.awt.image.AffineTransformOp;
<i>35</i>&nbsp;import java.awt.image.BufferedImage;
<i>36</i>&nbsp;import java.awt.image.BufferedImageOp;
<i>37</i>&nbsp;import java.awt.image.ColorModel;
<i>38</i>&nbsp;import java.awt.image.DataBuffer;
<i>39</i>&nbsp;import java.awt.image.ImageObserver;
<i>40</i>&nbsp;import java.awt.image.IndexColorModel;
<i>41</i>&nbsp;import java.awt.image.Raster;
<i>42</i>&nbsp;import java.awt.image.VolatileImage;
<i>43</i>&nbsp;import sun.awt.SunHints;
<i>44</i>&nbsp;import sun.awt.image.ImageRepresentation;
<i>45</i>&nbsp;import sun.awt.image.SurfaceManager;
<i>46</i>&nbsp;import sun.awt.image.ToolkitImage;
<i>47</i>&nbsp;import sun.java2d.InvalidPipeException;
<i>48</i>&nbsp;import sun.java2d.SunGraphics2D;
<i>49</i>&nbsp;import sun.java2d.SurfaceData;
<i>50</i>&nbsp;import sun.java2d.loops.Blit;
<i>51</i>&nbsp;import sun.java2d.loops.BlitBg;
<i>52</i>&nbsp;import sun.java2d.loops.TransformHelper;
<i>53</i>&nbsp;import sun.java2d.loops.MaskBlit;
<i>54</i>&nbsp;import sun.java2d.loops.CompositeType;
<i>55</i>&nbsp;import sun.java2d.loops.ScaledBlit;
<i>56</i>&nbsp;import sun.java2d.loops.SurfaceType;
<i>57</i>&nbsp;
<b class="nc"><i>58</i>&nbsp;public class DrawImage implements DrawImagePipe</b>
<i>59</i>&nbsp;{
<i>60</i>&nbsp;    public boolean copyImage(SunGraphics2D sg, Image img,
<i>61</i>&nbsp;                             int x, int y,
<i>62</i>&nbsp;                             Color bgColor)
<i>63</i>&nbsp;    {
<b class="nc"><i>64</i>&nbsp;        int imgw = img.getWidth(null);</b>
<b class="nc"><i>65</i>&nbsp;        int imgh = img.getHeight(null);</b>
<b class="nc"><i>66</i>&nbsp;        if (isSimpleTranslate(sg)) {</b>
<b class="nc"><i>67</i>&nbsp;            return renderImageCopy(sg, img, bgColor,</b>
<i>68</i>&nbsp;                                   x + sg.transX, y + sg.transY,
<i>69</i>&nbsp;                                   0, 0, imgw, imgh);
<i>70</i>&nbsp;        }
<b class="nc"><i>71</i>&nbsp;        AffineTransform atfm = sg.transform;</b>
<b class="nc"><i>72</i>&nbsp;        if ((x | y) != 0) {</b>
<b class="nc"><i>73</i>&nbsp;            atfm = new AffineTransform(atfm);</b>
<b class="nc"><i>74</i>&nbsp;            atfm.translate(x, y);</b>
<i>75</i>&nbsp;        }
<b class="nc"><i>76</i>&nbsp;        transformImage(sg, img, atfm, sg.interpolationType,</b>
<i>77</i>&nbsp;                       0, 0, imgw, imgh, bgColor);
<b class="nc"><i>78</i>&nbsp;        return true;</b>
<i>79</i>&nbsp;    }
<i>80</i>&nbsp;
<i>81</i>&nbsp;    public boolean copyImage(SunGraphics2D sg, Image img,
<i>82</i>&nbsp;                             int dx, int dy, int sx, int sy, int w, int h,
<i>83</i>&nbsp;                             Color bgColor)
<i>84</i>&nbsp;    {
<b class="nc"><i>85</i>&nbsp;        if (isSimpleTranslate(sg)) {</b>
<b class="nc"><i>86</i>&nbsp;            return renderImageCopy(sg, img, bgColor,</b>
<i>87</i>&nbsp;                                   dx + sg.transX, dy + sg.transY,
<i>88</i>&nbsp;                                   sx, sy, w, h);
<i>89</i>&nbsp;        }
<b class="nc"><i>90</i>&nbsp;        scaleImage(sg, img, dx, dy, (dx + w), (dy + h),</b>
<i>91</i>&nbsp;                   sx, sy, (sx + w), (sy + h), bgColor);
<b class="nc"><i>92</i>&nbsp;        return true;</b>
<i>93</i>&nbsp;    }
<i>94</i>&nbsp;
<i>95</i>&nbsp;    public boolean scaleImage(SunGraphics2D sg, Image img, int x, int y,
<i>96</i>&nbsp;                              int width, int height,
<i>97</i>&nbsp;                              Color bgColor)
<i>98</i>&nbsp;    {
<b class="nc"><i>99</i>&nbsp;        int imgw = img.getWidth(null);</b>
<b class="nc"><i>100</i>&nbsp;        int imgh = img.getHeight(null);</b>
<i>101</i>&nbsp;        // Only accelerate scale if:
<i>102</i>&nbsp;        //          - w/h positive values
<i>103</i>&nbsp;        //          - sg transform integer translate/identity only
<i>104</i>&nbsp;        //          - no bgColor in operation
<b class="nc"><i>105</i>&nbsp;        if ((width &gt; 0) &amp;&amp; (height &gt; 0) &amp;&amp; isSimpleTranslate(sg)) {</b>
<b class="nc"><i>106</i>&nbsp;            double dx1 = x + sg.transX;</b>
<b class="nc"><i>107</i>&nbsp;            double dy1 = y + sg.transY;</b>
<b class="nc"><i>108</i>&nbsp;            double dx2 = dx1 + width;</b>
<b class="nc"><i>109</i>&nbsp;            double dy2 = dy1 + height;</b>
<b class="nc"><i>110</i>&nbsp;            if (renderImageScale(sg, img, bgColor, sg.interpolationType,</b>
<i>111</i>&nbsp;                                 0, 0, imgw, imgh,
<i>112</i>&nbsp;                                 dx1, dy1, dx2, dy2))
<i>113</i>&nbsp;            {
<b class="nc"><i>114</i>&nbsp;                return true;</b>
<i>115</i>&nbsp;            }
<i>116</i>&nbsp;        }
<i>117</i>&nbsp;
<b class="nc"><i>118</i>&nbsp;        AffineTransform atfm = sg.transform;</b>
<b class="nc"><i>119</i>&nbsp;        if ((x | y) != 0 || width != imgw || height != imgh) {</b>
<b class="nc"><i>120</i>&nbsp;            atfm = new AffineTransform(atfm);</b>
<b class="nc"><i>121</i>&nbsp;            atfm.translate(x, y);</b>
<b class="nc"><i>122</i>&nbsp;            atfm.scale(((double)width)/imgw, ((double)height)/imgh);</b>
<i>123</i>&nbsp;        }
<b class="nc"><i>124</i>&nbsp;        transformImage(sg, img, atfm, sg.interpolationType,</b>
<i>125</i>&nbsp;                       0, 0, imgw, imgh, bgColor);
<b class="nc"><i>126</i>&nbsp;        return true;</b>
<i>127</i>&nbsp;    }
<i>128</i>&nbsp;
<i>129</i>&nbsp;    /*
<i>130</i>&nbsp;     * This method is only called in those circumstances where the
<i>131</i>&nbsp;     * operation has a non-null secondary transform specified.  Its
<i>132</i>&nbsp;     * role is to check for various optimizations based on the types
<i>133</i>&nbsp;     * of both the secondary and SG2D transforms and to do some
<i>134</i>&nbsp;     * quick calculations to avoid having to combine the transforms
<i>135</i>&nbsp;     * and/or to call a more generalized method.
<i>136</i>&nbsp;     */
<i>137</i>&nbsp;    protected void transformImage(SunGraphics2D sg, Image img, int x, int y,
<i>138</i>&nbsp;                                  AffineTransform extraAT, int interpType)
<i>139</i>&nbsp;    {
<b class="nc"><i>140</i>&nbsp;        int txtype = extraAT.getType();</b>
<b class="nc"><i>141</i>&nbsp;        int imgw = img.getWidth(null);</b>
<b class="nc"><i>142</i>&nbsp;        int imgh = img.getHeight(null);</b>
<i>143</i>&nbsp;        boolean checkfinalxform;
<i>144</i>&nbsp;
<b class="nc"><i>145</i>&nbsp;        if (sg.transformState &lt;= SunGraphics2D.TRANSFORM_ANY_TRANSLATE &amp;&amp;</b>
<i>146</i>&nbsp;            (txtype == AffineTransform.TYPE_IDENTITY ||
<i>147</i>&nbsp;             txtype == AffineTransform.TYPE_TRANSLATION))
<i>148</i>&nbsp;        {
<i>149</i>&nbsp;            // First optimization - both are some kind of translate
<i>150</i>&nbsp;
<i>151</i>&nbsp;            // Combine the translations and check if interpolation is necessary.
<b class="nc"><i>152</i>&nbsp;            double tx = extraAT.getTranslateX();</b>
<b class="nc"><i>153</i>&nbsp;            double ty = extraAT.getTranslateY();</b>
<b class="nc"><i>154</i>&nbsp;            tx += sg.transform.getTranslateX();</b>
<b class="nc"><i>155</i>&nbsp;            ty += sg.transform.getTranslateY();</b>
<b class="nc"><i>156</i>&nbsp;            int itx = (int) Math.floor(tx + 0.5);</b>
<b class="nc"><i>157</i>&nbsp;            int ity = (int) Math.floor(ty + 0.5);</b>
<b class="nc"><i>158</i>&nbsp;            if (interpType == AffineTransformOp.TYPE_NEAREST_NEIGHBOR ||</b>
<b class="nc"><i>159</i>&nbsp;                (closeToInteger(itx, tx) &amp;&amp; closeToInteger(ity, ty)))</b>
<i>160</i>&nbsp;            {
<b class="nc"><i>161</i>&nbsp;                renderImageCopy(sg, img, null, x+itx, y+ity, 0, 0, imgw, imgh);</b>
<i>162</i>&nbsp;                return;
<i>163</i>&nbsp;            }
<b class="nc"><i>164</i>&nbsp;            checkfinalxform = false;</b>
<b class="nc"><i>165</i>&nbsp;        } else if (sg.transformState &lt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE &amp;&amp;</b>
<i>166</i>&nbsp;                   ((txtype &amp; (AffineTransform.TYPE_FLIP |
<i>167</i>&nbsp;                               AffineTransform.TYPE_MASK_ROTATION |
<i>168</i>&nbsp;                               AffineTransform.TYPE_GENERAL_TRANSFORM)) == 0))
<i>169</i>&nbsp;        {
<i>170</i>&nbsp;            // Second optimization - both are some kind of translate or scale
<i>171</i>&nbsp;
<i>172</i>&nbsp;            // Combine the scales and check if interpolation is necessary.
<i>173</i>&nbsp;
<i>174</i>&nbsp;            // Transform source bounds by extraAT,
<i>175</i>&nbsp;            // then translate the bounds again by x, y
<i>176</i>&nbsp;            // then transform the bounds again by sg.transform
<b class="nc"><i>177</i>&nbsp;            double coords[] = new double[] {</b>
<i>178</i>&nbsp;                0, 0, imgw, imgh,
<i>179</i>&nbsp;            };
<b class="nc"><i>180</i>&nbsp;            extraAT.transform(coords, 0, coords, 0, 2);</b>
<b class="nc"><i>181</i>&nbsp;            coords[0] += x;</b>
<b class="nc"><i>182</i>&nbsp;            coords[1] += y;</b>
<b class="nc"><i>183</i>&nbsp;            coords[2] += x;</b>
<b class="nc"><i>184</i>&nbsp;            coords[3] += y;</b>
<b class="nc"><i>185</i>&nbsp;            sg.transform.transform(coords, 0, coords, 0, 2);</b>
<i>186</i>&nbsp;
<b class="nc"><i>187</i>&nbsp;            if (tryCopyOrScale(sg, img, 0, 0, imgw, imgh,</b>
<i>188</i>&nbsp;                               null, interpType, coords))
<i>189</i>&nbsp;            {
<i>190</i>&nbsp;                return;
<i>191</i>&nbsp;            }
<b class="nc"><i>192</i>&nbsp;            checkfinalxform = false;</b>
<b class="nc"><i>193</i>&nbsp;        } else {</b>
<b class="nc"><i>194</i>&nbsp;            checkfinalxform = true;</b>
<i>195</i>&nbsp;        }
<i>196</i>&nbsp;
<i>197</i>&nbsp;        // Begin Transform
<b class="nc"><i>198</i>&nbsp;        AffineTransform tx = new AffineTransform(sg.transform);</b>
<b class="nc"><i>199</i>&nbsp;        tx.translate(x, y);</b>
<b class="nc"><i>200</i>&nbsp;        tx.concatenate(extraAT);</b>
<i>201</i>&nbsp;
<i>202</i>&nbsp;        // Do not try any more optimizations if either of the cases
<i>203</i>&nbsp;        // above was tried as we have already verified that the
<i>204</i>&nbsp;        // resulting transform will not simplify.
<b class="nc"><i>205</i>&nbsp;        if (checkfinalxform) {</b>
<i>206</i>&nbsp;            // In this case neither of the above simple transform
<i>207</i>&nbsp;            // pairs was found so we will do some final tests on
<i>208</i>&nbsp;            // the final rendering transform which may be the
<i>209</i>&nbsp;            // simple product of two complex transforms.
<b class="nc"><i>210</i>&nbsp;            transformImage(sg, img, tx, interpType, 0, 0, imgw, imgh, null);</b>
<i>211</i>&nbsp;        } else {
<b class="nc"><i>212</i>&nbsp;            renderImageXform(sg, img, tx, interpType, 0, 0, imgw, imgh, null);</b>
<i>213</i>&nbsp;        }
<i>214</i>&nbsp;    }
<i>215</i>&nbsp;
<i>216</i>&nbsp;    /*
<i>217</i>&nbsp;     * This method is called with a final rendering transform that
<i>218</i>&nbsp;     * has combined all of the information about the Graphics2D
<i>219</i>&nbsp;     * transform attribute with the transformations specified by
<i>220</i>&nbsp;     * the arguments to the drawImage call.
<i>221</i>&nbsp;     * Its role is to see if the combined transform ends up being
<i>222</i>&nbsp;     * acceleratable by either a renderImageCopy or renderImageScale
<i>223</i>&nbsp;     * once all of the math is done.
<i>224</i>&nbsp;     *
<i>225</i>&nbsp;     * Note: The transform supplied here has an origin that is
<i>226</i>&nbsp;     * already adjusted to point to the device location where
<i>227</i>&nbsp;     * the (sx1, sy1) location of the source image should be placed.
<i>228</i>&nbsp;     */
<i>229</i>&nbsp;    protected void transformImage(SunGraphics2D sg, Image img,
<i>230</i>&nbsp;                                  AffineTransform tx, int interpType,
<i>231</i>&nbsp;                                  int sx1, int sy1, int sx2, int sy2,
<i>232</i>&nbsp;                                  Color bgColor)
<i>233</i>&nbsp;    {
<i>234</i>&nbsp;        // Transform 3 source corners by tx and analyze them
<i>235</i>&nbsp;        // for simplified operations (Copy or Scale).  Using
<i>236</i>&nbsp;        // 3 points lets us analyze any kind of transform,
<i>237</i>&nbsp;        // even transforms that involve very tiny amounts of
<i>238</i>&nbsp;        // rotation or skew to see if they degenerate to a
<i>239</i>&nbsp;        // simple scale or copy operation within the allowable
<i>240</i>&nbsp;        // error bounds.
<i>241</i>&nbsp;        // Note that we use (0,0,w,h) instead of (sx1,sy1,sx2,sy2)
<i>242</i>&nbsp;        // because the transform is already translated such that
<i>243</i>&nbsp;        // the origin is where sx1, sy1 should go.
<b class="nc"><i>244</i>&nbsp;        double coords[] = new double[6];</b>
<i>245</i>&nbsp;        /* index:  0  1    2  3    4  5  */
<i>246</i>&nbsp;        /* coord: (0, 0), (w, h), (0, h) */
<b class="nc"><i>247</i>&nbsp;        coords[2] = sx2 - sx1;</b>
<b class="nc"><i>248</i>&nbsp;        coords[3] = coords[5] = sy2 - sy1;</b>
<b class="nc"><i>249</i>&nbsp;        tx.transform(coords, 0, coords, 0, 3);</b>
<i>250</i>&nbsp;        // First test if the X coords of the transformed UL
<i>251</i>&nbsp;        // and LL points match and that the Y coords of the
<i>252</i>&nbsp;        // transformed LR and LL points also match.
<i>253</i>&nbsp;        // If they do then it is a &quot;rectilinear&quot; transform and
<i>254</i>&nbsp;        // tryCopyOrScale will make sure it is upright and
<i>255</i>&nbsp;        // integer-based.
<b class="nc"><i>256</i>&nbsp;        if (Math.abs(coords[0] - coords[4]) &lt; MAX_TX_ERROR &amp;&amp;</b>
<b class="nc"><i>257</i>&nbsp;            Math.abs(coords[3] - coords[5]) &lt; MAX_TX_ERROR &amp;&amp;</b>
<b class="nc"><i>258</i>&nbsp;            tryCopyOrScale(sg, img, sx1, sy1, sx2, sy2,</b>
<i>259</i>&nbsp;                           bgColor, interpType, coords))
<i>260</i>&nbsp;        {
<i>261</i>&nbsp;            return;
<i>262</i>&nbsp;        }
<i>263</i>&nbsp;
<b class="nc"><i>264</i>&nbsp;        renderImageXform(sg, img, tx, interpType, sx1, sy1, sx2, sy2, bgColor);</b>
<i>265</i>&nbsp;    }
<i>266</i>&nbsp;
<i>267</i>&nbsp;    /*
<i>268</i>&nbsp;     * Check the bounding coordinates of the transformed source
<i>269</i>&nbsp;     * image to see if they fall on integer coordinates such
<i>270</i>&nbsp;     * that they will cause no interpolation anomalies if we
<i>271</i>&nbsp;     * use our simplified Blit or ScaledBlit operations instead
<i>272</i>&nbsp;     * of a full transform operation.
<i>273</i>&nbsp;     */
<i>274</i>&nbsp;    protected boolean tryCopyOrScale(SunGraphics2D sg,
<i>275</i>&nbsp;                                     Image img,
<i>276</i>&nbsp;                                     int sx1, int sy1,
<i>277</i>&nbsp;                                     int sx2, int sy2,
<i>278</i>&nbsp;                                     Color bgColor, int interpType,
<i>279</i>&nbsp;                                     double coords[])
<i>280</i>&nbsp;    {
<b class="nc"><i>281</i>&nbsp;        double dx1 = coords[0];</b>
<b class="nc"><i>282</i>&nbsp;        double dy1 = coords[1];</b>
<b class="nc"><i>283</i>&nbsp;        double dx2 = coords[2];</b>
<b class="nc"><i>284</i>&nbsp;        double dy2 = coords[3];</b>
<b class="nc"><i>285</i>&nbsp;        double dw = dx2 - dx1;</b>
<b class="nc"><i>286</i>&nbsp;        double dh = dy2 - dy1;</b>
<i>287</i>&nbsp;
<i>288</i>&nbsp;        /* If any of the destination coordinates exceed the integer range,
<i>289</i>&nbsp;         * then the calculations performed in calls made here cannot be
<i>290</i>&nbsp;         * guaranteed to be correct, or to converge (terminate).
<i>291</i>&nbsp;         * So return out of here, deferring to code that can handle this.
<i>292</i>&nbsp;         */
<b class="nc"><i>293</i>&nbsp;        if (dx1 &lt; Integer.MIN_VALUE || dx1 &gt; Integer.MAX_VALUE ||</b>
<i>294</i>&nbsp;            dy1 &lt; Integer.MIN_VALUE || dy1 &gt; Integer.MAX_VALUE ||
<i>295</i>&nbsp;            dx2 &lt; Integer.MIN_VALUE || dx2 &gt; Integer.MAX_VALUE ||
<i>296</i>&nbsp;            dy2 &lt; Integer.MIN_VALUE || dy2 &gt; Integer.MAX_VALUE)
<i>297</i>&nbsp;        {
<b class="nc"><i>298</i>&nbsp;            return false;</b>
<i>299</i>&nbsp;        }
<i>300</i>&nbsp;
<i>301</i>&nbsp;        // First check if width and height are very close to img w&amp;h.
<b class="nc"><i>302</i>&nbsp;        if (closeToInteger(sx2-sx1, dw) &amp;&amp; closeToInteger(sy2-sy1, dh)) {</b>
<i>303</i>&nbsp;            // Round location to nearest pixel and then test
<i>304</i>&nbsp;            // if it will cause interpolation anomalies.
<b class="nc"><i>305</i>&nbsp;            int idx = (int) Math.floor(dx1 + 0.5);</b>
<b class="nc"><i>306</i>&nbsp;            int idy = (int) Math.floor(dy1 + 0.5);</b>
<b class="nc"><i>307</i>&nbsp;            if (interpType == AffineTransformOp.TYPE_NEAREST_NEIGHBOR ||</b>
<b class="nc"><i>308</i>&nbsp;                (closeToInteger(idx, dx1) &amp;&amp; closeToInteger(idy, dy1)))</b>
<i>309</i>&nbsp;            {
<b class="nc"><i>310</i>&nbsp;                renderImageCopy(sg, img, bgColor,</b>
<i>311</i>&nbsp;                                idx, idy,
<i>312</i>&nbsp;                                sx1, sy1, sx2-sx1, sy2-sy1);
<b class="nc"><i>313</i>&nbsp;                return true;</b>
<i>314</i>&nbsp;            }
<i>315</i>&nbsp;        }
<i>316</i>&nbsp;        // (For now) We can only use our ScaledBlits if the image
<i>317</i>&nbsp;        // is upright (i.e. dw &amp; dh both &gt; 0)
<b class="nc"><i>318</i>&nbsp;        if (dw &gt; 0 &amp;&amp; dh &gt; 0) {</b>
<b class="nc"><i>319</i>&nbsp;            if (renderImageScale(sg, img, bgColor, interpType,</b>
<i>320</i>&nbsp;                                 sx1, sy1, sx2, sy2,
<i>321</i>&nbsp;                                 dx1, dy1, dx2, dy2))
<i>322</i>&nbsp;            {
<b class="nc"><i>323</i>&nbsp;                return true;</b>
<i>324</i>&nbsp;            }
<i>325</i>&nbsp;        }
<b class="nc"><i>326</i>&nbsp;        return false;</b>
<i>327</i>&nbsp;    }
<i>328</i>&nbsp;
<i>329</i>&nbsp;    /**
<i>330</i>&nbsp;     * Return a non-accelerated BufferedImage of the requested type with the
<i>331</i>&nbsp;     * indicated subimage of the original image located at 0,0 in the new image.
<i>332</i>&nbsp;     * If a bgColor is supplied, composite the original image over that color
<i>333</i>&nbsp;     * with a SrcOver operation, otherwise make a SrcNoEa copy.
<i>334</i>&nbsp;     * &lt;p&gt;
<i>335</i>&nbsp;     * Returned BufferedImage is not accelerated for two reasons:
<i>336</i>&nbsp;     * &lt;ul&gt;
<i>337</i>&nbsp;     * &lt;li&gt; Types of the image and surface are predefined, because these types
<i>338</i>&nbsp;     *      correspond to the TransformHelpers, which we know we have. And
<i>339</i>&nbsp;     *      acceleration can change the type of the surface
<i>340</i>&nbsp;     * &lt;li&gt; Image will be used only once and acceleration caching wouldn&#39;t help
<i>341</i>&nbsp;     * &lt;/ul&gt;
<i>342</i>&nbsp;     */
<i>343</i>&nbsp;    private BufferedImage makeBufferedImage(Image img, Color bgColor, int type,
<i>344</i>&nbsp;                                            int sx1, int sy1, int sx2, int sy2)
<i>345</i>&nbsp;    {
<b class="nc"><i>346</i>&nbsp;        final int width = sx2 - sx1;</b>
<b class="nc"><i>347</i>&nbsp;        final int height = sy2 - sy1;</b>
<b class="nc"><i>348</i>&nbsp;        final BufferedImage bimg = new BufferedImage(width, height, type);</b>
<b class="nc"><i>349</i>&nbsp;        final SunGraphics2D g2d = (SunGraphics2D) bimg.createGraphics();</b>
<b class="nc"><i>350</i>&nbsp;        g2d.setComposite(AlphaComposite.Src);</b>
<b class="nc"><i>351</i>&nbsp;        bimg.setAccelerationPriority(0);</b>
<b class="nc"><i>352</i>&nbsp;        if (bgColor != null) {</b>
<b class="nc"><i>353</i>&nbsp;            g2d.setColor(bgColor);</b>
<b class="nc"><i>354</i>&nbsp;            g2d.fillRect(0, 0, width, height);</b>
<b class="nc"><i>355</i>&nbsp;            g2d.setComposite(AlphaComposite.SrcOver);</b>
<i>356</i>&nbsp;        }
<b class="nc"><i>357</i>&nbsp;        g2d.copyImage(img, 0, 0, sx1, sy1, width, height, null, null);</b>
<b class="nc"><i>358</i>&nbsp;        g2d.dispose();</b>
<b class="nc"><i>359</i>&nbsp;        return bimg;</b>
<i>360</i>&nbsp;    }
<i>361</i>&nbsp;
<i>362</i>&nbsp;    protected void renderImageXform(SunGraphics2D sg, Image img,
<i>363</i>&nbsp;                                    AffineTransform tx, int interpType,
<i>364</i>&nbsp;                                    int sx1, int sy1, int sx2, int sy2,
<i>365</i>&nbsp;                                    Color bgColor)
<i>366</i>&nbsp;    {
<i>367</i>&nbsp;        final AffineTransform itx;
<i>368</i>&nbsp;        try {
<b class="nc"><i>369</i>&nbsp;            itx = tx.createInverse();</b>
<b class="nc"><i>370</i>&nbsp;        } catch (final NoninvertibleTransformException ignored) {</b>
<i>371</i>&nbsp;            // Non-invertible transform means no output
<i>372</i>&nbsp;            return;
<b class="nc"><i>373</i>&nbsp;        }</b>
<i>374</i>&nbsp;
<i>375</i>&nbsp;        /*
<i>376</i>&nbsp;         * Find the maximum bounds on the destination that will be
<i>377</i>&nbsp;         * affected by the transformed source.  First, transform all
<i>378</i>&nbsp;         * four corners of the source and then min and max the resulting
<i>379</i>&nbsp;         * destination coordinates of the transformed corners.
<i>380</i>&nbsp;         * Note that tx already has the offset to sx1,sy1 accounted
<i>381</i>&nbsp;         * for so we use the box (0, 0, sx2-sx1, sy2-sy1) as the
<i>382</i>&nbsp;         * source coordinates.
<i>383</i>&nbsp;         */
<b class="nc"><i>384</i>&nbsp;        final double[] coords = new double[8];</b>
<i>385</i>&nbsp;        /* corner:  UL      UR      LL      LR   */
<i>386</i>&nbsp;        /* index:  0  1    2  3    4  5    6  7  */
<i>387</i>&nbsp;        /* coord: (0, 0), (w, 0), (0, h), (w, h) */
<b class="nc"><i>388</i>&nbsp;        coords[2] = coords[6] = sx2 - sx1;</b>
<b class="nc"><i>389</i>&nbsp;        coords[5] = coords[7] = sy2 - sy1;</b>
<b class="nc"><i>390</i>&nbsp;        tx.transform(coords, 0, coords, 0, 4);</b>
<i>391</i>&nbsp;        double ddx1, ddy1, ddx2, ddy2;
<b class="nc"><i>392</i>&nbsp;        ddx1 = ddx2 = coords[0];</b>
<b class="nc"><i>393</i>&nbsp;        ddy1 = ddy2 = coords[1];</b>
<b class="nc"><i>394</i>&nbsp;        for (int i = 2; i &lt; coords.length; i += 2) {</b>
<b class="nc"><i>395</i>&nbsp;            double d = coords[i];</b>
<b class="nc"><i>396</i>&nbsp;            if (ddx1 &gt; d) ddx1 = d;</b>
<b class="nc"><i>397</i>&nbsp;            else if (ddx2 &lt; d) ddx2 = d;</b>
<b class="nc"><i>398</i>&nbsp;            d = coords[i+1];</b>
<b class="nc"><i>399</i>&nbsp;            if (ddy1 &gt; d) ddy1 = d;</b>
<b class="nc"><i>400</i>&nbsp;            else if (ddy2 &lt; d) ddy2 = d;</b>
<i>401</i>&nbsp;        }
<i>402</i>&nbsp;
<b class="nc"><i>403</i>&nbsp;        Region clip = sg.getCompClip();</b>
<b class="nc"><i>404</i>&nbsp;        final int dx1 = Math.max((int) Math.floor(ddx1), clip.getLoX());</b>
<b class="nc"><i>405</i>&nbsp;        final int dy1 = Math.max((int) Math.floor(ddy1), clip.getLoY());</b>
<b class="nc"><i>406</i>&nbsp;        final int dx2 = Math.min((int) Math.ceil(ddx2), clip.getHiX());</b>
<b class="nc"><i>407</i>&nbsp;        final int dy2 = Math.min((int) Math.ceil(ddy2), clip.getHiY());</b>
<b class="nc"><i>408</i>&nbsp;        if (dx2 &lt;= dx1 || dy2 &lt;= dy1) {</b>
<i>409</i>&nbsp;            // empty destination means no output
<i>410</i>&nbsp;            return;
<i>411</i>&nbsp;        }
<i>412</i>&nbsp;
<b class="nc"><i>413</i>&nbsp;        final SurfaceData dstData = sg.surfaceData;</b>
<b class="nc"><i>414</i>&nbsp;        SurfaceData srcData = dstData.getSourceSurfaceData(img,</b>
<i>415</i>&nbsp;                                                           SunGraphics2D.TRANSFORM_GENERIC,
<i>416</i>&nbsp;                                                           sg.imageComp,
<i>417</i>&nbsp;                                                           bgColor);
<i>418</i>&nbsp;
<b class="nc"><i>419</i>&nbsp;        if (srcData == null) {</b>
<b class="nc"><i>420</i>&nbsp;            img = getBufferedImage(img);</b>
<b class="nc"><i>421</i>&nbsp;            srcData = dstData.getSourceSurfaceData(img,</b>
<i>422</i>&nbsp;                                                   SunGraphics2D.TRANSFORM_GENERIC,
<i>423</i>&nbsp;                                                   sg.imageComp,
<i>424</i>&nbsp;                                                   bgColor);
<b class="nc"><i>425</i>&nbsp;            if (srcData == null) {</b>
<i>426</i>&nbsp;                // REMIND: Is this correct?  Can this happen?
<i>427</i>&nbsp;                return;
<i>428</i>&nbsp;            }
<i>429</i>&nbsp;        }
<i>430</i>&nbsp;
<b class="nc"><i>431</i>&nbsp;        if (isBgOperation(srcData, bgColor)) {</b>
<i>432</i>&nbsp;            // We cannot perform bg operations during transform so make
<i>433</i>&nbsp;            // a temp image with the appropriate background based on
<i>434</i>&nbsp;            // background alpha value and work from there. If background
<b class="nc"><i>435</i>&nbsp;            // alpha is opaque use INT_RGB else use INT_ARGB so that we</b>
<i>436</i>&nbsp;            // will not lose translucency of background.
<i>437</i>&nbsp;
<b class="nc"><i>438</i>&nbsp;            int bgAlpha = bgColor.getAlpha();</b>
<b class="nc"><i>439</i>&nbsp;            int type = ((bgAlpha == 255)</b>
<b class="nc"><i>440</i>&nbsp;                        ? BufferedImage.TYPE_INT_RGB</b>
<i>441</i>&nbsp;                        : BufferedImage.TYPE_INT_ARGB);
<b class="nc"><i>442</i>&nbsp;            img = makeBufferedImage(img, bgColor, type, sx1, sy1, sx2, sy2);</b>
<i>443</i>&nbsp;            // Temp image has appropriate subimage at 0,0 now.
<i>444</i>&nbsp;            sx2 -= sx1;
<i>445</i>&nbsp;            sy2 -= sy1;
<i>446</i>&nbsp;            sx1 = sy1 = 0;
<i>447</i>&nbsp;
<b class="nc"><i>448</i>&nbsp;            srcData = dstData.getSourceSurfaceData(img,</b>
<b class="nc"><i>449</i>&nbsp;                                                   SunGraphics2D.TRANSFORM_GENERIC,</b>
<i>450</i>&nbsp;                                                   sg.imageComp,
<b class="nc"><i>451</i>&nbsp;                                                   bgColor);</b>
<i>452</i>&nbsp;        }
<i>453</i>&nbsp;
<i>454</i>&nbsp;        SurfaceType srcType = srcData.getSurfaceType();
<i>455</i>&nbsp;        TransformHelper helper = TransformHelper.getFromCache(srcType);
<i>456</i>&nbsp;
<i>457</i>&nbsp;        if (helper == null) {
<i>458</i>&nbsp;            /* We have no helper for this source image type.
<b class="nc"><i>459</i>&nbsp;             * But we know that we do have helpers for both RGB and ARGB,</b>
<i>460</i>&nbsp;             * so convert to one of those types depending on transparency.
<i>461</i>&nbsp;             * ARGB_PRE might be a better choice if the source image has
<b class="nc"><i>462</i>&nbsp;             * alpha, but it may cause some recursion here since we only</b>
<i>463</i>&nbsp;             * tend to have converters that convert to ARGB.
<b class="nc"><i>464</i>&nbsp;             */</b>
<b class="nc"><i>465</i>&nbsp;            int type = ((srcData.getTransparency() == Transparency.OPAQUE)</b>
<b class="nc"><i>466</i>&nbsp;                        ? BufferedImage.TYPE_INT_RGB</b>
<i>467</i>&nbsp;                        : BufferedImage.TYPE_INT_ARGB);
<b class="nc"><i>468</i>&nbsp;            img = makeBufferedImage(img, null, type, sx1, sy1, sx2, sy2);</b>
<i>469</i>&nbsp;            // Temp image has appropriate subimage at 0,0 now.
<i>470</i>&nbsp;            sx2 -= sx1;
<i>471</i>&nbsp;            sy2 -= sy1;
<b class="nc"><i>472</i>&nbsp;            sx1 = sy1 = 0;</b>
<b class="nc"><i>473</i>&nbsp;</b>
<i>474</i>&nbsp;            srcData = dstData.getSourceSurfaceData(img,
<i>475</i>&nbsp;                                                   SunGraphics2D.TRANSFORM_GENERIC,
<i>476</i>&nbsp;                                                   sg.imageComp,
<b class="nc"><i>477</i>&nbsp;                                                   null);</b>
<b class="nc"><i>478</i>&nbsp;            srcType = srcData.getSurfaceType();</b>
<i>479</i>&nbsp;            helper = TransformHelper.getFromCache(srcType);
<i>480</i>&nbsp;            // assert(helper != null);
<i>481</i>&nbsp;        }
<b class="nc"><i>482</i>&nbsp;</b>
<i>483</i>&nbsp;        SurfaceType dstType = dstData.getSurfaceType();
<i>484</i>&nbsp;        if (sg.compositeState &lt;= SunGraphics2D.COMP_ALPHA) {
<i>485</i>&nbsp;            /* NOTE: We either have, or we can make,
<i>486</i>&nbsp;             * a MaskBlit for any alpha composite type
<i>487</i>&nbsp;             */
<i>488</i>&nbsp;            MaskBlit maskblit = MaskBlit.getFromCache(SurfaceType.IntArgbPre,
<i>489</i>&nbsp;                                                      sg.imageComp, dstType);
<i>490</i>&nbsp;
<b class="nc"><i>491</i>&nbsp;            /* NOTE: We can only use the native TransformHelper</b>
<i>492</i>&nbsp;             * func to go directly to the dest if both the helper
<b class="nc"><i>493</i>&nbsp;             * and the MaskBlit are native.</b>
<i>494</i>&nbsp;             * All helpers are native at this point, but some MaskBlit
<i>495</i>&nbsp;             * objects are implemented in Java, so we need to check.
<i>496</i>&nbsp;             */
<i>497</i>&nbsp;            if (maskblit.getNativePrim() != 0) {
<i>498</i>&nbsp;                // We can render directly.
<i>499</i>&nbsp;                helper.Transform(maskblit, srcData, dstData,
<i>500</i>&nbsp;                                 sg.composite, clip,
<i>501</i>&nbsp;                                 itx, interpType,
<i>502</i>&nbsp;                                 sx1, sy1, sx2, sy2,
<i>503</i>&nbsp;                                 dx1, dy1, dx2, dy2,
<i>504</i>&nbsp;                                 null, 0, 0);
<b class="nc"><i>505</i>&nbsp;                return;</b>
<b class="nc"><i>506</i>&nbsp;            }</b>
<b class="nc"><i>507</i>&nbsp;        }</b>
<i>508</i>&nbsp;
<b class="nc"><i>509</i>&nbsp;        // We need to transform to a temp image and then copy</b>
<b class="nc"><i>510</i>&nbsp;        // just the pieces that are valid data to the dest.</b>
<b class="nc"><i>511</i>&nbsp;        final int w = dx2 - dx1;</b>
<i>512</i>&nbsp;        final int h = dy2 - dy1;
<i>513</i>&nbsp;        BufferedImage tmpimg = new BufferedImage(w, h,
<i>514</i>&nbsp;                                                 BufferedImage.TYPE_INT_ARGB_PRE);
<i>515</i>&nbsp;        SurfaceData tmpData = SurfaceData.getPrimarySurfaceData(tmpimg);
<i>516</i>&nbsp;        SurfaceType tmpType = tmpData.getSurfaceType();
<i>517</i>&nbsp;        MaskBlit tmpmaskblit = MaskBlit.getFromCache(SurfaceType.IntArgbPre,
<i>518</i>&nbsp;                                                     CompositeType.SrcNoEa,
<i>519</i>&nbsp;                                                     tmpType);
<i>520</i>&nbsp;        /*
<i>521</i>&nbsp;         * The helper function fills a temporary edges buffer
<i>522</i>&nbsp;         * for us with the bounding coordinates of each scanline
<i>523</i>&nbsp;         * in the following format:
<i>524</i>&nbsp;         *
<i>525</i>&nbsp;         * edges[0, 1] = [top y, bottom y)
<i>526</i>&nbsp;         * edges[2, 3] = [left x, right x) of top row
<i>527</i>&nbsp;         * ...
<b class="nc"><i>528</i>&nbsp;         * edges[h*2, h*2+1] = [left x, right x) of bottom row</b>
<i>529</i>&nbsp;         *
<i>530</i>&nbsp;         * all coordinates in the edges array will be relative to dx1, dy1
<i>531</i>&nbsp;         *
<b class="nc"><i>532</i>&nbsp;         * edges thus has to be h*2+2 in length</b>
<i>533</i>&nbsp;         */
<i>534</i>&nbsp;        final int[] edges = new int[h * 2 + 2];
<i>535</i>&nbsp;        // It is important that edges[0]=edges[1]=0 when we call
<i>536</i>&nbsp;        // Transform in case it must return early and we would
<i>537</i>&nbsp;        // not want to render anything on an error condition.
<i>538</i>&nbsp;        helper.Transform(tmpmaskblit, srcData, tmpData,
<b class="nc"><i>539</i>&nbsp;                         AlphaComposite.Src, null,</b>
<b class="nc"><i>540</i>&nbsp;                         itx, interpType,</b>
<i>541</i>&nbsp;                         sx1, sy1, sx2, sy2,
<i>542</i>&nbsp;                         0, 0, w, h,
<i>543</i>&nbsp;                         edges, dx1, dy1);
<i>544</i>&nbsp;
<b class="nc"><i>545</i>&nbsp;        final Region region = Region.getInstance(dx1, dy1, dx2, dy2, edges);</b>
<b class="nc"><i>546</i>&nbsp;        clip = clip.getIntersection(region);</b>
<i>547</i>&nbsp;
<i>548</i>&nbsp;        /* NOTE: We either have, or we can make,
<i>549</i>&nbsp;         * a Blit for any composite type, even Custom
<i>550</i>&nbsp;         */
<i>551</i>&nbsp;        final Blit blit = Blit.getFromCache(tmpType, sg.imageComp, dstType);
<i>552</i>&nbsp;        blit.Blit(tmpData, dstData, sg.composite, clip, 0, 0, dx1, dy1, w, h);
<i>553</i>&nbsp;    }
<i>554</i>&nbsp;
<i>555</i>&nbsp;    // Render an image using only integer translation
<i>556</i>&nbsp;    // (no scale or transform or sub-pixel interpolated translations).
<b class="nc"><i>557</i>&nbsp;    protected boolean renderImageCopy(SunGraphics2D sg, Image img,</b>
<b class="nc"><i>558</i>&nbsp;                                      Color bgColor,</b>
<i>559</i>&nbsp;                                      int dx, int dy,
<b class="nc"><i>560</i>&nbsp;                                      int sx, int sy,</b>
<i>561</i>&nbsp;                                      int w, int h)
<i>562</i>&nbsp;    {
<i>563</i>&nbsp;        Region clip = sg.getCompClip();
<i>564</i>&nbsp;        SurfaceData dstData = sg.surfaceData;
<b class="nc"><i>565</i>&nbsp;</b>
<b class="nc"><i>566</i>&nbsp;        int attempts = 0;</b>
<i>567</i>&nbsp;        // Loop up to twice through; this gives us a chance to
<i>568</i>&nbsp;        // revalidate the surfaceData objects in case of an exception
<i>569</i>&nbsp;        // and try it once more
<b class="nc"><i>570</i>&nbsp;        while (true) {</b>
<b class="nc"><i>571</i>&nbsp;            SurfaceData srcData =</b>
<i>572</i>&nbsp;                dstData.getSourceSurfaceData(img,
<i>573</i>&nbsp;                                             SunGraphics2D.TRANSFORM_ISIDENT,
<i>574</i>&nbsp;                                             sg.imageComp,
<b class="nc"><i>575</i>&nbsp;                                             bgColor);</b>
<b class="nc"><i>576</i>&nbsp;            if (srcData == null) {</b>
<b class="nc"><i>577</i>&nbsp;                return false;</b>
<i>578</i>&nbsp;            }
<i>579</i>&nbsp;
<b class="nc"><i>580</i>&nbsp;            try {</b>
<b class="nc"><i>581</i>&nbsp;                SurfaceType srcType = srcData.getSurfaceType();</b>
<b class="nc"><i>582</i>&nbsp;                SurfaceType dstType = dstData.getSurfaceType();</b>
<b class="nc"><i>583</i>&nbsp;                blitSurfaceData(sg, clip,</b>
<i>584</i>&nbsp;                                srcData, dstData, srcType, dstType,
<i>585</i>&nbsp;                                sx, sy, dx, dy, w, h, bgColor);
<b class="nc"><i>586</i>&nbsp;                return true;</b>
<i>587</i>&nbsp;            } catch (NullPointerException e) {
<b class="nc"><i>588</i>&nbsp;                if (!(SurfaceData.isNull(dstData) ||</b>
<i>589</i>&nbsp;                      SurfaceData.isNull(srcData)))
<b class="nc"><i>590</i>&nbsp;                {</b>
<i>591</i>&nbsp;                    // Something else caused the exception, throw it...
<i>592</i>&nbsp;                    throw e;
<i>593</i>&nbsp;                }
<b class="nc"><i>594</i>&nbsp;                return false;</b>
<b class="nc"><i>595</i>&nbsp;                // NOP if we have been disposed</b>
<b class="nc"><i>596</i>&nbsp;            } catch (InvalidPipeException e) {</b>
<b class="nc"><i>597</i>&nbsp;                // Always catch the exception; try this a couple of times</b>
<b class="nc"><i>598</i>&nbsp;                // and fail silently if the system is not yet ready to</b>
<i>599</i>&nbsp;                // revalidate the source or dest surfaceData objects.
<b class="nc"><i>600</i>&nbsp;                ++attempts;</b>
<i>601</i>&nbsp;                clip = sg.getCompClip();   // ensures sg.surfaceData is valid
<i>602</i>&nbsp;                dstData = sg.surfaceData;
<b class="nc"><i>603</i>&nbsp;                if (SurfaceData.isNull(dstData) ||</b>
<i>604</i>&nbsp;                    SurfaceData.isNull(srcData) || (attempts &gt; 1))
<i>605</i>&nbsp;                {
<i>606</i>&nbsp;                    return false;
<i>607</i>&nbsp;                }
<i>608</i>&nbsp;            }
<i>609</i>&nbsp;        }
<i>610</i>&nbsp;    }
<i>611</i>&nbsp;
<i>612</i>&nbsp;    // Render an image using only integer scaling (no transform).
<i>613</i>&nbsp;    protected boolean renderImageScale(SunGraphics2D sg, Image img,
<i>614</i>&nbsp;                                       Color bgColor, int interpType,
<i>615</i>&nbsp;                                       int sx1, int sy1,
<b class="nc"><i>616</i>&nbsp;                                       int sx2, int sy2,</b>
<b class="nc"><i>617</i>&nbsp;                                       double dx1, double dy1,</b>
<i>618</i>&nbsp;                                       double dx2, double dy2)
<i>619</i>&nbsp;    {
<b class="nc"><i>620</i>&nbsp;        // Currently only NEAREST_NEIGHBOR interpolation is implemented</b>
<b class="nc"><i>621</i>&nbsp;        // for ScaledBlit operations.</b>
<i>622</i>&nbsp;        if (interpType != AffineTransformOp.TYPE_NEAREST_NEIGHBOR) {
<b class="nc"><i>623</i>&nbsp;            return false;</b>
<i>624</i>&nbsp;        }
<i>625</i>&nbsp;
<i>626</i>&nbsp;        Region clip = sg.getCompClip();
<i>627</i>&nbsp;        SurfaceData dstData = sg.surfaceData;
<b class="nc"><i>628</i>&nbsp;</b>
<b class="nc"><i>629</i>&nbsp;        int attempts = 0;</b>
<i>630</i>&nbsp;        // Loop up to twice through; this gives us a chance to
<i>631</i>&nbsp;        // revalidate the surfaceData objects in case of an exception
<i>632</i>&nbsp;        // and try it once more
<i>633</i>&nbsp;        while (true) {
<b class="nc"><i>634</i>&nbsp;            SurfaceData srcData =</b>
<b class="nc"><i>635</i>&nbsp;                dstData.getSourceSurfaceData(img,</b>
<i>636</i>&nbsp;                                             SunGraphics2D.TRANSFORM_TRANSLATESCALE,
<i>637</i>&nbsp;                                             sg.imageComp,
<i>638</i>&nbsp;                                             bgColor);
<b class="nc"><i>639</i>&nbsp;</b>
<b class="nc"><i>640</i>&nbsp;            if (srcData == null || isBgOperation(srcData, bgColor)) {</b>
<b class="nc"><i>641</i>&nbsp;                return false;</b>
<i>642</i>&nbsp;            }
<i>643</i>&nbsp;
<i>644</i>&nbsp;            try {
<b class="nc"><i>645</i>&nbsp;                SurfaceType srcType = srcData.getSurfaceType();</b>
<b class="nc"><i>646</i>&nbsp;                SurfaceType dstType = dstData.getSurfaceType();</b>
<i>647</i>&nbsp;                return scaleSurfaceData(sg, clip,
<b class="nc"><i>648</i>&nbsp;                                        srcData, dstData, srcType, dstType,</b>
<i>649</i>&nbsp;                                        sx1, sy1, sx2, sy2,
<b class="nc"><i>650</i>&nbsp;                                        dx1, dy1, dx2, dy2);</b>
<i>651</i>&nbsp;            } catch (NullPointerException e) {
<b class="nc"><i>652</i>&nbsp;                if (!SurfaceData.isNull(dstData)) {</b>
<i>653</i>&nbsp;                    // Something else caused the exception, throw it...
<i>654</i>&nbsp;                    throw e;
<i>655</i>&nbsp;                }
<b class="nc"><i>656</i>&nbsp;                return false;</b>
<b class="nc"><i>657</i>&nbsp;                // NOP if we have been disposed</b>
<b class="nc"><i>658</i>&nbsp;            } catch (InvalidPipeException e) {</b>
<b class="nc"><i>659</i>&nbsp;                // Always catch the exception; try this a couple of times</b>
<b class="nc"><i>660</i>&nbsp;                // and fail silently if the system is not yet ready to</b>
<i>661</i>&nbsp;                // revalidate the source or dest surfaceData objects.
<b class="nc"><i>662</i>&nbsp;                ++attempts;</b>
<i>663</i>&nbsp;                clip = sg.getCompClip();  // ensures sg.surfaceData is valid
<i>664</i>&nbsp;                dstData = sg.surfaceData;
<b class="nc"><i>665</i>&nbsp;                if (SurfaceData.isNull(dstData) ||</b>
<i>666</i>&nbsp;                    SurfaceData.isNull(srcData) || (attempts &gt; 1))
<i>667</i>&nbsp;                {
<i>668</i>&nbsp;                    return false;
<i>669</i>&nbsp;                }
<i>670</i>&nbsp;            }
<i>671</i>&nbsp;        }
<i>672</i>&nbsp;    }
<i>673</i>&nbsp;
<i>674</i>&nbsp;    public boolean scaleImage(SunGraphics2D sg, Image img,
<b class="nc"><i>675</i>&nbsp;                              int dx1, int dy1, int dx2, int dy2,</b>
<b class="nc"><i>676</i>&nbsp;                              int sx1, int sy1, int sx2, int sy2,</b>
<b class="nc"><i>677</i>&nbsp;                              Color bgColor)</b>
<b class="nc"><i>678</i>&nbsp;    {</b>
<i>679</i>&nbsp;        int srcW, srcH, dstW, dstH;
<b class="nc"><i>680</i>&nbsp;        int srcX, srcY, dstX, dstY;</b>
<b class="nc"><i>681</i>&nbsp;        boolean srcWidthFlip = false;</b>
<b class="nc"><i>682</i>&nbsp;        boolean srcHeightFlip = false;</b>
<i>683</i>&nbsp;        boolean dstWidthFlip = false;
<b class="nc"><i>684</i>&nbsp;        boolean dstHeightFlip = false;</b>
<b class="nc"><i>685</i>&nbsp;</b>
<b class="nc"><i>686</i>&nbsp;        if (sx2 &gt; sx1) {</b>
<i>687</i>&nbsp;            srcW = sx2 - sx1;
<b class="nc"><i>688</i>&nbsp;            srcX = sx1;</b>
<b class="nc"><i>689</i>&nbsp;        } else {</b>
<b class="nc"><i>690</i>&nbsp;            srcWidthFlip = true;</b>
<i>691</i>&nbsp;            srcW = sx1 - sx2;
<b class="nc"><i>692</i>&nbsp;            srcX = sx2;</b>
<b class="nc"><i>693</i>&nbsp;        }</b>
<b class="nc"><i>694</i>&nbsp;        if (sy2 &gt; sy1) {</b>
<i>695</i>&nbsp;            srcH = sy2-sy1;
<b class="nc"><i>696</i>&nbsp;            srcY = sy1;</b>
<b class="nc"><i>697</i>&nbsp;        } else {</b>
<b class="nc"><i>698</i>&nbsp;            srcHeightFlip = true;</b>
<i>699</i>&nbsp;            srcH = sy1-sy2;
<b class="nc"><i>700</i>&nbsp;            srcY = sy2;</b>
<b class="nc"><i>701</i>&nbsp;        }</b>
<b class="nc"><i>702</i>&nbsp;        if (dx2 &gt; dx1) {</b>
<i>703</i>&nbsp;            dstW = dx2 - dx1;
<b class="nc"><i>704</i>&nbsp;            dstX = dx1;</b>
<b class="nc"><i>705</i>&nbsp;        } else {</b>
<b class="nc"><i>706</i>&nbsp;            dstW = dx1 - dx2;</b>
<i>707</i>&nbsp;            dstWidthFlip = true;
<b class="nc"><i>708</i>&nbsp;            dstX = dx2;</b>
<b class="nc"><i>709</i>&nbsp;        }</b>
<b class="nc"><i>710</i>&nbsp;        if (dy2 &gt; dy1) {</b>
<i>711</i>&nbsp;            dstH = dy2 - dy1;
<b class="nc"><i>712</i>&nbsp;            dstY = dy1;</b>
<b class="nc"><i>713</i>&nbsp;        } else {</b>
<i>714</i>&nbsp;            dstH = dy1 - dy2;
<i>715</i>&nbsp;            dstHeightFlip = true;
<b class="nc"><i>716</i>&nbsp;            dstY = dy2;</b>
<i>717</i>&nbsp;        }
<b class="nc"><i>718</i>&nbsp;        if (srcW &lt;= 0 || srcH &lt;= 0) {</b>
<i>719</i>&nbsp;            return true;
<b class="nc"><i>720</i>&nbsp;        }</b>
<b class="nc"><i>721</i>&nbsp;        // Only accelerate scale if it does not involve a flip or transform</b>
<b class="nc"><i>722</i>&nbsp;        if ((srcWidthFlip == dstWidthFlip) &amp;&amp;</b>
<b class="nc"><i>723</i>&nbsp;            (srcHeightFlip == dstHeightFlip) &amp;&amp;</b>
<b class="nc"><i>724</i>&nbsp;            isSimpleTranslate(sg))</b>
<i>725</i>&nbsp;        {
<i>726</i>&nbsp;            double ddx1 = dstX + sg.transX;
<i>727</i>&nbsp;            double ddy1 = dstY + sg.transY;
<b class="nc"><i>728</i>&nbsp;            double ddx2 = ddx1 + dstW;</b>
<i>729</i>&nbsp;            double ddy2 = ddy1 + dstH;
<i>730</i>&nbsp;            if (renderImageScale(sg, img, bgColor, sg.interpolationType,
<i>731</i>&nbsp;                                 srcX, srcY, srcX+srcW, srcY+srcH,
<b class="nc"><i>732</i>&nbsp;                                 ddx1, ddy1, ddx2, ddy2))</b>
<b class="nc"><i>733</i>&nbsp;            {</b>
<b class="nc"><i>734</i>&nbsp;                return true;</b>
<b class="nc"><i>735</i>&nbsp;            }</b>
<b class="nc"><i>736</i>&nbsp;        }</b>
<b class="nc"><i>737</i>&nbsp;</b>
<i>738</i>&nbsp;        AffineTransform atfm = new AffineTransform(sg.transform);
<b class="nc"><i>739</i>&nbsp;        atfm.translate(dx1, dy1);</b>
<b class="nc"><i>740</i>&nbsp;        double m00 = (double)(dx2-dx1)/(sx2-sx1);</b>
<b class="nc"><i>741</i>&nbsp;        double m11 = (double)(dy2-dy1)/(sy2-sy1);</b>
<b class="nc"><i>742</i>&nbsp;        atfm.scale(m00, m11);</b>
<b class="nc"><i>743</i>&nbsp;        atfm.translate(srcX-sx1, srcY-sy1);</b>
<b class="nc"><i>744</i>&nbsp;</b>
<i>745</i>&nbsp;        final double scaleX = SurfaceManager.getImageScaleX(img);
<b class="nc"><i>746</i>&nbsp;        final double scaleY = SurfaceManager.getImageScaleY(img);</b>
<b class="nc"><i>747</i>&nbsp;        final int imgW = (int) Math.ceil(img.getWidth(null) * scaleX);</b>
<i>748</i>&nbsp;        final int imgH = (int) Math.ceil(img.getHeight(null) * scaleY);
<b class="nc"><i>749</i>&nbsp;        srcW += srcX;</b>
<b class="nc"><i>750</i>&nbsp;        srcH += srcY;</b>
<i>751</i>&nbsp;        // Make sure we are not out of bounds
<b class="nc"><i>752</i>&nbsp;        if (srcW &gt; imgW) {</b>
<b class="nc"><i>753</i>&nbsp;            srcW = imgW;</b>
<b class="nc"><i>754</i>&nbsp;        }</b>
<i>755</i>&nbsp;        if (srcH &gt; imgH) {
<b class="nc"><i>756</i>&nbsp;            srcH = imgH;</b>
<b class="nc"><i>757</i>&nbsp;        }</b>
<b class="nc"><i>758</i>&nbsp;        if (srcX &lt; 0) {</b>
<i>759</i>&nbsp;            atfm.translate(-srcX, 0);
<b class="nc"><i>760</i>&nbsp;            srcX = 0;</b>
<b class="nc"><i>761</i>&nbsp;        }</b>
<i>762</i>&nbsp;        if (srcY &lt; 0) {
<i>763</i>&nbsp;            atfm.translate(0, -srcY);
<i>764</i>&nbsp;            srcY = 0;
<i>765</i>&nbsp;        }
<i>766</i>&nbsp;        if (srcX &gt;= srcW || srcY &gt;= srcH) {
<i>767</i>&nbsp;            return true;
<i>768</i>&nbsp;        }
<i>769</i>&nbsp;        // Note: src[WH] are currently the right and bottom coordinates.
<i>770</i>&nbsp;        // The following two lines would adjust src[WH] back to being
<b class="nc"><i>771</i>&nbsp;        // dimensions.</b>
<i>772</i>&nbsp;        //     srcW -= srcX;
<b class="nc"><i>773</i>&nbsp;        //     srcH -= srcY;</b>
<i>774</i>&nbsp;        // Since transformImage needs right and bottom coords we will
<i>775</i>&nbsp;        // omit this adjustment.
<i>776</i>&nbsp;
<i>777</i>&nbsp;        transformImage(sg, img, atfm, sg.interpolationType,
<i>778</i>&nbsp;                       srcX, srcY, srcW, srcH, bgColor);
<i>779</i>&nbsp;        return true;
<i>780</i>&nbsp;    }
<i>781</i>&nbsp;
<i>782</i>&nbsp;    /**
<i>783</i>&nbsp;     ** Utilities
<i>784</i>&nbsp;     ** The following methods are used by the public methods above
<i>785</i>&nbsp;     ** for performing various operations
<i>786</i>&nbsp;     **/
<i>787</i>&nbsp;
<i>788</i>&nbsp;    /*
<i>789</i>&nbsp;     * This constant represents a tradeoff between the
<i>790</i>&nbsp;     * need to make sure that image transformations are
<i>791</i>&nbsp;     * &quot;very close&quot; to integer device coordinates before
<i>792</i>&nbsp;     * we decide to use an integer scale or copy operation
<i>793</i>&nbsp;     * as a substitute and the fact that roundoff errors
<i>794</i>&nbsp;     * in AffineTransforms are frequently introduced by
<i>795</i>&nbsp;     * performing multiple sequential operations on them.
<i>796</i>&nbsp;     *
<i>797</i>&nbsp;     * The evaluation of bug 4990624 details the potential
<i>798</i>&nbsp;     * for this error cutoff to result in display anomalies
<b class="nc"><i>799</i>&nbsp;     * in different types of image operations and how this</b>
<i>800</i>&nbsp;     * value represents a good compromise here.
<i>801</i>&nbsp;     */
<i>802</i>&nbsp;    private static final double MAX_TX_ERROR = .0001;
<b class="nc"><i>803</i>&nbsp;</b>
<b class="nc"><i>804</i>&nbsp;    public static boolean closeToInteger(int i, double d) {</b>
<i>805</i>&nbsp;        return (Math.abs(d-i) &lt; MAX_TX_ERROR);
<b class="nc"><i>806</i>&nbsp;    }</b>
<i>807</i>&nbsp;
<b class="nc"><i>808</i>&nbsp;    public static boolean isSimpleTranslate(SunGraphics2D sg) {</b>
<i>809</i>&nbsp;        int ts = sg.transformState;
<b class="nc"><i>810</i>&nbsp;        if (ts &lt;= SunGraphics2D.TRANSFORM_INT_TRANSLATE) {</b>
<i>811</i>&nbsp;            // Integer translates are always &quot;simple&quot;
<i>812</i>&nbsp;            return true;
<b class="nc"><i>813</i>&nbsp;        }</b>
<b class="nc"><i>814</i>&nbsp;        if (ts &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</b>
<i>815</i>&nbsp;            // Scales and beyond are always &quot;not simple&quot;
<b class="nc"><i>816</i>&nbsp;            return false;</b>
<i>817</i>&nbsp;        }
<i>818</i>&nbsp;        // non-integer translates are only simple when not interpolating
<i>819</i>&nbsp;        if (sg.interpolationType == AffineTransformOp.TYPE_NEAREST_NEIGHBOR) {
<i>820</i>&nbsp;            return true;
<i>821</i>&nbsp;        }
<b class="nc"><i>822</i>&nbsp;        return false;</b>
<i>823</i>&nbsp;    }
<b class="nc"><i>824</i>&nbsp;</b>
<i>825</i>&nbsp;    protected static boolean isBgOperation(SurfaceData srcData, Color bgColor) {
<i>826</i>&nbsp;        // If we cannot get the srcData, then cannot assume anything about
<i>827</i>&nbsp;        // the image
<b class="nc"><i>828</i>&nbsp;        return ((srcData == null) ||</b>
<b class="nc"><i>829</i>&nbsp;                ((bgColor != null) &amp;&amp;</b>
<i>830</i>&nbsp;                 (srcData.getTransparency() != Transparency.OPAQUE)));
<i>831</i>&nbsp;    }
<b class="nc"><i>832</i>&nbsp;</b>
<i>833</i>&nbsp;    protected BufferedImage getBufferedImage(Image img) {
<i>834</i>&nbsp;        if (img instanceof BufferedImage) {
<i>835</i>&nbsp;            return (BufferedImage)img;
<i>836</i>&nbsp;        }
<i>837</i>&nbsp;        // Must be VolatileImage; get BufferedImage representation
<i>838</i>&nbsp;        return ((VolatileImage)img).getSnapshot();
<i>839</i>&nbsp;    }
<i>840</i>&nbsp;
<i>841</i>&nbsp;    /*
<b class="nc"><i>842</i>&nbsp;     * Return the color model to be used with this BufferedImage and</b>
<b class="nc"><i>843</i>&nbsp;     * transform.</b>
<i>844</i>&nbsp;     */
<b class="nc"><i>845</i>&nbsp;    private ColorModel getTransformColorModel(SunGraphics2D sg,</b>
<b class="nc"><i>846</i>&nbsp;                                              BufferedImage bImg,</b>
<i>847</i>&nbsp;                                              AffineTransform tx) {
<b class="nc"><i>848</i>&nbsp;        ColorModel cm = bImg.getColorModel();</b>
<b class="nc"><i>849</i>&nbsp;        ColorModel dstCM = cm;</b>
<i>850</i>&nbsp;
<i>851</i>&nbsp;        if (tx.isIdentity()) {
<b class="nc"><i>852</i>&nbsp;            return dstCM;</b>
<i>853</i>&nbsp;        }
<i>854</i>&nbsp;        int type = tx.getType();
<i>855</i>&nbsp;        boolean needTrans =
<b class="nc"><i>856</i>&nbsp;                ((type &amp; (AffineTransform.TYPE_MASK_ROTATION |</b>
<b class="nc"><i>857</i>&nbsp;                          AffineTransform.TYPE_GENERAL_TRANSFORM)) != 0);</b>
<i>858</i>&nbsp;        if (! needTrans &amp;&amp;
<i>859</i>&nbsp;              type != AffineTransform.TYPE_TRANSLATION &amp;&amp;
<b class="nc"><i>860</i>&nbsp;              type != AffineTransform.TYPE_IDENTITY)</b>
<i>861</i>&nbsp;        {
<i>862</i>&nbsp;            double[] mtx = new double[4];
<b class="nc"><i>863</i>&nbsp;            tx.getMatrix(mtx);</b>
<b class="nc"><i>864</i>&nbsp;            // Check out the matrix.  A non-integral scale will force ARGB</b>
<b class="nc"><i>865</i>&nbsp;            // since the edge conditions cannot be guaranteed.</b>
<b class="nc"><i>866</i>&nbsp;            needTrans = (mtx[0] != (int)mtx[0] || mtx[3] != (int)mtx[3]);</b>
<i>867</i>&nbsp;        }
<b class="nc"><i>868</i>&nbsp;</b>
<i>869</i>&nbsp;        if (sg.renderHint != SunHints.INTVAL_RENDER_QUALITY) {
<b class="nc"><i>870</i>&nbsp;            if (cm instanceof IndexColorModel) {</b>
<b class="nc"><i>871</i>&nbsp;                Raster raster = bImg.getRaster();</b>
<i>872</i>&nbsp;                IndexColorModel icm = (IndexColorModel) cm;
<i>873</i>&nbsp;                // Just need to make sure that we have a transparent pixel
<b class="nc"><i>874</i>&nbsp;                if (needTrans &amp;&amp; cm.getTransparency() == Transparency.OPAQUE) {</b>
<b class="nc"><i>875</i>&nbsp;                    // Fix 4221407</b>
<b class="nc"><i>876</i>&nbsp;                    if (raster instanceof sun.awt.image.BytePackedRaster) {</b>
<i>877</i>&nbsp;                        dstCM = ColorModel.getRGBdefault();
<i>878</i>&nbsp;                    }
<i>879</i>&nbsp;                    else {
<i>880</i>&nbsp;                        double[] matrix = new double[6];
<b class="nc"><i>881</i>&nbsp;                        tx.getMatrix(matrix);</b>
<b class="nc"><i>882</i>&nbsp;                        if (matrix[1] == 0. &amp;&amp; matrix[2] ==0.</b>
<b class="nc"><i>883</i>&nbsp;                            &amp;&amp; matrix[4] == 0. &amp;&amp; matrix[5] == 0.) {</b>
<b class="nc"><i>884</i>&nbsp;                            // Only scaling so do not need to create</b>
<b class="nc"><i>885</i>&nbsp;                        }</b>
<b class="nc"><i>886</i>&nbsp;                        else {</b>
<b class="nc"><i>887</i>&nbsp;                            int mapSize = icm.getMapSize();</b>
<i>888</i>&nbsp;                            if (mapSize &lt; 256) {
<i>889</i>&nbsp;                                int[] cmap = new int[mapSize+1];
<i>890</i>&nbsp;                                icm.getRGBs(cmap);
<b class="nc"><i>891</i>&nbsp;                                cmap[mapSize] = 0x0000;</b>
<i>892</i>&nbsp;                                dstCM = new
<b class="nc"><i>893</i>&nbsp;                                    IndexColorModel(icm.getPixelSize(),</b>
<i>894</i>&nbsp;                                                    mapSize+1,
<i>895</i>&nbsp;                                                    cmap, 0, true, mapSize,
<i>896</i>&nbsp;                                                    DataBuffer.TYPE_BYTE);
<i>897</i>&nbsp;                            }
<b class="nc"><i>898</i>&nbsp;                            else {</b>
<b class="nc"><i>899</i>&nbsp;                                dstCM = ColorModel.getRGBdefault();</b>
<i>900</i>&nbsp;                            }
<i>901</i>&nbsp;                        }  /* if (matrix[0] &lt; 1.f ...) */
<i>902</i>&nbsp;                    }   /* raster instanceof sun.awt.image.BytePackedRaster */
<b class="nc"><i>903</i>&nbsp;                } /* if (cm.getTransparency() == cm.OPAQUE) */</b>
<i>904</i>&nbsp;            } /* if (cm instanceof IndexColorModel) */
<i>905</i>&nbsp;            else if (needTrans &amp;&amp; cm.getTransparency() == Transparency.OPAQUE) {
<i>906</i>&nbsp;                // Need a bitmask transparency
<i>907</i>&nbsp;                // REMIND: for now, use full transparency since no loops
<b class="nc"><i>908</i>&nbsp;                // for bitmask</b>
<b class="nc"><i>909</i>&nbsp;                dstCM = ColorModel.getRGBdefault();</b>
<i>910</i>&nbsp;            }
<i>911</i>&nbsp;        } /* if (sg.renderHint == RENDER_QUALITY) */
<i>912</i>&nbsp;        else {
<i>913</i>&nbsp;
<b class="nc"><i>914</i>&nbsp;            if (cm instanceof IndexColorModel ||</b>
<i>915</i>&nbsp;                (needTrans &amp;&amp; cm.getTransparency() == Transparency.OPAQUE))
<i>916</i>&nbsp;            {
<i>917</i>&nbsp;                // Need a bitmask transparency
<b class="nc"><i>918</i>&nbsp;                // REMIND: for now, use full transparency since no loops</b>
<i>919</i>&nbsp;                // for bitmask
<i>920</i>&nbsp;                dstCM = ColorModel.getRGBdefault();
<i>921</i>&nbsp;            }
<i>922</i>&nbsp;        }
<i>923</i>&nbsp;
<i>924</i>&nbsp;        return dstCM;
<i>925</i>&nbsp;    }
<i>926</i>&nbsp;
<i>927</i>&nbsp;    protected void blitSurfaceData(SunGraphics2D sg,
<i>928</i>&nbsp;                                   Region clipRegion,
<i>929</i>&nbsp;                                   SurfaceData srcData,
<i>930</i>&nbsp;                                   SurfaceData dstData,
<b class="nc"><i>931</i>&nbsp;                                   SurfaceType srcType,</b>
<i>932</i>&nbsp;                                   SurfaceType dstType,
<i>933</i>&nbsp;                                   int sx, int sy, int dx, int dy,
<i>934</i>&nbsp;                                   int w, int h,
<i>935</i>&nbsp;                                   Color bgColor)
<i>936</i>&nbsp;    {
<i>937</i>&nbsp;        if (w &lt;= 0 || h &lt;= 0) {
<i>938</i>&nbsp;            /*
<i>939</i>&nbsp;             * Fix for bugid 4783274 - BlitBg throws an exception for
<i>940</i>&nbsp;             * a particular set of anomalous parameters.
<i>941</i>&nbsp;             * REMIND: The native loops do proper clipping and would
<i>942</i>&nbsp;             * detect this situation themselves, but the Java loops
<i>943</i>&nbsp;             * all seem to trust their parameters a little too well
<i>944</i>&nbsp;             * to the point where they will try to process a negative
<i>945</i>&nbsp;             * area of pixels and throw exceptions.  The real fix is
<i>946</i>&nbsp;             * to modify the Java loops to do proper clipping so that
<i>947</i>&nbsp;             * they can deal with negative dimensions as well as
<i>948</i>&nbsp;             * improperly large dimensions, but that fix is too risky
<i>949</i>&nbsp;             * to integrate for Mantis at this point.  In the meantime
<b class="nc"><i>950</i>&nbsp;             * eliminating the negative or zero dimensions here is</b>
<b class="nc"><i>951</i>&nbsp;             * &quot;correct&quot; and saves them from some nasty exceptional</b>
<b class="nc"><i>952</i>&nbsp;             * conditions, one of which is the test case of 4783274.</b>
<i>953</i>&nbsp;             */
<b class="nc"><i>954</i>&nbsp;            return;</b>
<i>955</i>&nbsp;        }
<b class="nc"><i>956</i>&nbsp;        CompositeType comp = sg.imageComp;</b>
<i>957</i>&nbsp;        if (CompositeType.SrcOverNoEa.equals(comp) &amp;&amp;
<b class="nc"><i>958</i>&nbsp;            (srcData.getTransparency() == Transparency.OPAQUE ||</b>
<b class="nc"><i>959</i>&nbsp;             (bgColor != null &amp;&amp;</b>
<b class="nc"><i>960</i>&nbsp;              bgColor.getTransparency() == Transparency.OPAQUE)))</b>
<i>961</i>&nbsp;        {
<b class="nc"><i>962</i>&nbsp;            comp = CompositeType.SrcNoEa;</b>
<b class="nc"><i>963</i>&nbsp;        }</b>
<b class="nc"><i>964</i>&nbsp;        if (srcData == dstData &amp;&amp; sx == dx &amp;&amp; sy == dy</b>
<b class="nc"><i>965</i>&nbsp;                &amp;&amp; CompositeType.SrcNoEa.equals(comp)) {</b>
<i>966</i>&nbsp;            // Performance optimization. We skip the Blit/BlitBG if we know that
<i>967</i>&nbsp;            // it will be noop.
<i>968</i>&nbsp;            return;
<i>969</i>&nbsp;        }
<i>970</i>&nbsp;        if (!isBgOperation(srcData, bgColor)) {
<i>971</i>&nbsp;            Blit blit = Blit.getFromCache(srcType, comp, dstType);
<i>972</i>&nbsp;            blit.Blit(srcData, dstData, sg.composite, clipRegion,
<i>973</i>&nbsp;                      sx, sy, dx, dy, w, h);
<i>974</i>&nbsp;        } else {
<i>975</i>&nbsp;            BlitBg blit = BlitBg.getFromCache(srcType, comp, dstType);
<i>976</i>&nbsp;            blit.BlitBg(srcData, dstData, sg.composite, clipRegion,
<i>977</i>&nbsp;                        bgColor.getRGB(), sx, sy, dx, dy, w, h);
<i>978</i>&nbsp;        }
<i>979</i>&nbsp;    }
<b class="nc"><i>980</i>&nbsp;</b>
<b class="nc"><i>981</i>&nbsp;    protected boolean scaleSurfaceData(SunGraphics2D sg,</b>
<b class="nc"><i>982</i>&nbsp;                                       Region clipRegion,</b>
<i>983</i>&nbsp;                                       SurfaceData srcData,
<b class="nc"><i>984</i>&nbsp;                                       SurfaceData dstData,</b>
<i>985</i>&nbsp;                                       SurfaceType srcType,
<i>986</i>&nbsp;                                       SurfaceType dstType,
<b class="nc"><i>987</i>&nbsp;                                       int sx1, int sy1,</b>
<b class="nc"><i>988</i>&nbsp;                                       int sx2, int sy2,</b>
<b class="nc"><i>989</i>&nbsp;                                       double dx1, double dy1,</b>
<i>990</i>&nbsp;                                       double dx2, double dy2)
<b class="nc"><i>991</i>&nbsp;    {</b>
<i>992</i>&nbsp;        CompositeType comp = sg.imageComp;
<b class="nc"><i>993</i>&nbsp;        if (CompositeType.SrcOverNoEa.equals(comp) &amp;&amp;</b>
<i>994</i>&nbsp;            (srcData.getTransparency() == Transparency.OPAQUE))
<i>995</i>&nbsp;        {
<i>996</i>&nbsp;            comp = CompositeType.SrcNoEa;
<i>997</i>&nbsp;        }
<i>998</i>&nbsp;
<b class="nc"><i>999</i>&nbsp;        ScaledBlit blit = ScaledBlit.getFromCache(srcType, comp, dstType);</b>
<b class="nc"><i>1000</i>&nbsp;        if (blit != null) {</b>
<b class="nc"><i>1001</i>&nbsp;            blit.Scale(srcData, dstData, sg.composite, clipRegion,</b>
<i>1002</i>&nbsp;                       sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
<i>1003</i>&nbsp;            return true;
<i>1004</i>&nbsp;        }
<b class="nc"><i>1005</i>&nbsp;        return false;</b>
<i>1006</i>&nbsp;    }
<b class="nc"><i>1007</i>&nbsp;</b>
<i>1008</i>&nbsp;    protected static boolean imageReady(ToolkitImage sunimg,
<i>1009</i>&nbsp;                                        ImageObserver observer)
<i>1010</i>&nbsp;    {
<i>1011</i>&nbsp;        if (sunimg.hasError()) {
<i>1012</i>&nbsp;            if (observer != null) {
<i>1013</i>&nbsp;                observer.imageUpdate(sunimg,
<b class="nc"><i>1014</i>&nbsp;                                     ImageObserver.ERROR|ImageObserver.ABORT,</b>
<b class="nc"><i>1015</i>&nbsp;                                     -1, -1, -1, -1);</b>
<i>1016</i>&nbsp;            }
<b class="nc"><i>1017</i>&nbsp;            return false;</b>
<b class="nc"><i>1018</i>&nbsp;        }</b>
<b class="nc"><i>1019</i>&nbsp;        return true;</b>
<i>1020</i>&nbsp;    }
<b class="nc"><i>1021</i>&nbsp;</b>
<b class="nc"><i>1022</i>&nbsp;    public boolean copyImage(SunGraphics2D sg, Image img,</b>
<i>1023</i>&nbsp;                             int x, int y,
<i>1024</i>&nbsp;                             Color bgColor,
<i>1025</i>&nbsp;                             ImageObserver observer) {
<i>1026</i>&nbsp;        if (!(img instanceof ToolkitImage)) {
<i>1027</i>&nbsp;            return copyImage(sg, img, x, y, bgColor);
<i>1028</i>&nbsp;        } else {
<i>1029</i>&nbsp;            ToolkitImage sunimg = (ToolkitImage)img;
<b class="nc"><i>1030</i>&nbsp;            if (!imageReady(sunimg, observer)) {</b>
<b class="nc"><i>1031</i>&nbsp;                return false;</b>
<i>1032</i>&nbsp;            }
<b class="nc"><i>1033</i>&nbsp;            ImageRepresentation ir = sunimg.getImageRep();</b>
<b class="nc"><i>1034</i>&nbsp;            return ir.drawToBufImage(sg, sunimg, x, y, bgColor, observer);</b>
<b class="nc"><i>1035</i>&nbsp;        }</b>
<i>1036</i>&nbsp;    }
<b class="nc"><i>1037</i>&nbsp;</b>
<b class="nc"><i>1038</i>&nbsp;    public boolean copyImage(SunGraphics2D sg, Image img,</b>
<i>1039</i>&nbsp;                             int dx, int dy, int sx, int sy, int w, int h,
<i>1040</i>&nbsp;                             Color bgColor,
<i>1041</i>&nbsp;                             ImageObserver observer) {
<i>1042</i>&nbsp;        if (!(img instanceof ToolkitImage)) {
<i>1043</i>&nbsp;            return copyImage(sg, img, dx, dy, sx, sy, w, h, bgColor);
<i>1044</i>&nbsp;        } else {
<i>1045</i>&nbsp;            ToolkitImage sunimg = (ToolkitImage)img;
<i>1046</i>&nbsp;            if (!imageReady(sunimg, observer)) {
<i>1047</i>&nbsp;                return false;
<i>1048</i>&nbsp;            }
<i>1049</i>&nbsp;            ImageRepresentation ir = sunimg.getImageRep();
<b class="nc"><i>1050</i>&nbsp;            return ir.drawToBufImage(sg, sunimg,</b>
<b class="nc"><i>1051</i>&nbsp;                                     dx, dy, (dx + w), (dy + h),</b>
<i>1052</i>&nbsp;                                     sx, sy, (sx + w), (sy + h),
<b class="nc"><i>1053</i>&nbsp;                                     bgColor, observer);</b>
<b class="nc"><i>1054</i>&nbsp;        }</b>
<b class="nc"><i>1055</i>&nbsp;    }</b>
<i>1056</i>&nbsp;
<b class="nc"><i>1057</i>&nbsp;    public boolean scaleImage(SunGraphics2D sg, Image img,</b>
<b class="nc"><i>1058</i>&nbsp;                                int x, int y,</b>
<i>1059</i>&nbsp;                                int width, int height,
<i>1060</i>&nbsp;                                Color bgColor,
<i>1061</i>&nbsp;                                ImageObserver observer) {
<i>1062</i>&nbsp;        if (!(img instanceof ToolkitImage)) {
<i>1063</i>&nbsp;            return scaleImage(sg, img, x, y, width, height, bgColor);
<i>1064</i>&nbsp;        } else {
<i>1065</i>&nbsp;            ToolkitImage sunimg = (ToolkitImage)img;
<i>1066</i>&nbsp;            if (!imageReady(sunimg, observer)) {
<i>1067</i>&nbsp;                return false;
<b class="nc"><i>1068</i>&nbsp;            }</b>
<b class="nc"><i>1069</i>&nbsp;            ImageRepresentation ir = sunimg.getImageRep();</b>
<i>1070</i>&nbsp;            return ir.drawToBufImage(sg, sunimg, x, y, width, height, bgColor,
<i>1071</i>&nbsp;                                     observer);
<b class="nc"><i>1072</i>&nbsp;        }</b>
<b class="nc"><i>1073</i>&nbsp;    }</b>
<b class="nc"><i>1074</i>&nbsp;</b>
<i>1075</i>&nbsp;    public boolean scaleImage(SunGraphics2D sg, Image img,
<b class="nc"><i>1076</i>&nbsp;                              int dx1, int dy1, int dx2, int dy2,</b>
<b class="nc"><i>1077</i>&nbsp;                              int sx1, int sy1, int sx2, int sy2,</b>
<i>1078</i>&nbsp;                              Color bgColor,
<i>1079</i>&nbsp;                              ImageObserver observer) {
<i>1080</i>&nbsp;        if (!(img instanceof ToolkitImage)) {
<i>1081</i>&nbsp;            return scaleImage(sg, img, dx1, dy1, dx2, dy2,
<i>1082</i>&nbsp;                              sx1, sy1, sx2, sy2, bgColor);
<i>1083</i>&nbsp;        } else {
<i>1084</i>&nbsp;            ToolkitImage sunimg = (ToolkitImage)img;
<b class="nc"><i>1085</i>&nbsp;            if (!imageReady(sunimg, observer)) {</b>
<b class="nc"><i>1086</i>&nbsp;                return false;</b>
<b class="nc"><i>1087</i>&nbsp;            }</b>
<i>1088</i>&nbsp;            ImageRepresentation ir = sunimg.getImageRep();
<b class="nc"><i>1089</i>&nbsp;            return ir.drawToBufImage(sg, sunimg, dx1, dy1, dx2, dy2,</b>
<b class="nc"><i>1090</i>&nbsp;                                     sx1, sy1, sx2, sy2, bgColor, observer);</b>
<b class="nc"><i>1091</i>&nbsp;        }</b>
<i>1092</i>&nbsp;    }
<b class="nc"><i>1093</i>&nbsp;</b>
<b class="nc"><i>1094</i>&nbsp;    public boolean transformImage(SunGraphics2D sg, Image img,</b>
<i>1095</i>&nbsp;                                  AffineTransform atfm,
<i>1096</i>&nbsp;                                  ImageObserver observer) {
<i>1097</i>&nbsp;        if (!(img instanceof ToolkitImage)) {
<i>1098</i>&nbsp;            transformImage(sg, img, 0, 0, atfm, sg.interpolationType);
<i>1099</i>&nbsp;            return true;
<i>1100</i>&nbsp;        } else {
<b class="nc"><i>1101</i>&nbsp;            ToolkitImage sunimg = (ToolkitImage)img;</b>
<b class="nc"><i>1102</i>&nbsp;            if (!imageReady(sunimg, observer)) {</b>
<b class="nc"><i>1103</i>&nbsp;                return false;</b>
<b class="nc"><i>1104</i>&nbsp;            }</b>
<b class="nc"><i>1105</i>&nbsp;            ImageRepresentation ir = sunimg.getImageRep();</b>
<b class="nc"><i>1106</i>&nbsp;            return ir.drawToBufImage(sg, sunimg, atfm, observer);</b>
<i>1107</i>&nbsp;        }
<i>1108</i>&nbsp;    }
<b class="nc"><i>1109</i>&nbsp;</b>
<i>1110</i>&nbsp;    public void transformImage(SunGraphics2D sg, BufferedImage img,
<i>1111</i>&nbsp;                               BufferedImageOp op, int x, int y)
<b class="nc"><i>1112</i>&nbsp;    {</b>
<i>1113</i>&nbsp;        if (op != null) {
<i>1114</i>&nbsp;            if (op instanceof AffineTransformOp) {
<i>1115</i>&nbsp;                AffineTransformOp atop = (AffineTransformOp) op;
<i>1116</i>&nbsp;                transformImage(sg, img, x, y,
<i>1117</i>&nbsp;                               atop.getTransform(),
<i>1118</i>&nbsp;                               atop.getInterpolationType());
<i>1119</i>&nbsp;                return;
<i>1120</i>&nbsp;            } else {
<i>1121</i>&nbsp;                img = op.filter(img, null);
<i>1122</i>&nbsp;            }
<i>1123</i>&nbsp;        }
<i>1124</i>&nbsp;        copyImage(sg, img, x, y, null);
<i>1125</i>&nbsp;    }
<i>1126</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
