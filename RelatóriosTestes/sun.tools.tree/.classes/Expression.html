


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Expression</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.tools.tree</a> ]
</div>

<h1>Coverage Summary for Class: Expression (sun.tools.tree)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Expression</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 187)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.tools.tree;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import sun.tools.java.*;
<i>29</i>&nbsp;import sun.tools.asm.Label;
<i>30</i>&nbsp;import sun.tools.asm.Assembler;
<i>31</i>&nbsp;import java.io.PrintStream;
<i>32</i>&nbsp;import java.util.Hashtable;
<i>33</i>&nbsp;
<i>34</i>&nbsp;/**
<i>35</i>&nbsp; * WARNING: The contents of this source file are not part of any
<i>36</i>&nbsp; * supported API.  Code that depends on them does so at its own risk:
<i>37</i>&nbsp; * they are subject to change or removal without notice.
<i>38</i>&nbsp; */
<i>39</i>&nbsp;public
<i>40</i>&nbsp;class Expression extends Node {
<i>41</i>&nbsp;    Type type;
<i>42</i>&nbsp;
<i>43</i>&nbsp;    /**
<i>44</i>&nbsp;     * Constructor
<i>45</i>&nbsp;     */
<i>46</i>&nbsp;    Expression(int op, long where, Type type) {
<b class="nc"><i>47</i>&nbsp;        super(op, where);</b>
<b class="nc"><i>48</i>&nbsp;        this.type = type;</b>
<i>49</i>&nbsp;    }
<i>50</i>&nbsp;
<i>51</i>&nbsp;    /**
<i>52</i>&nbsp;     * Type checking may assign a more complex implementation
<i>53</i>&nbsp;     * to an innocuous-looking expression (like an identifier).
<i>54</i>&nbsp;     * Return that implementation, or the original expression itself
<i>55</i>&nbsp;     * if there is no special implementation.
<i>56</i>&nbsp;     * &lt;p&gt;
<i>57</i>&nbsp;     * This appears at present to be dead code, and is not called
<i>58</i>&nbsp;     * from within javac.  Access to the implementation generally
<i>59</i>&nbsp;     * occurs within the same class, and thus uses the underlying
<i>60</i>&nbsp;     * field directly.
<i>61</i>&nbsp;     */
<i>62</i>&nbsp;    public Expression getImplementation() {
<b class="nc"><i>63</i>&nbsp;        return this;</b>
<i>64</i>&nbsp;    }
<i>65</i>&nbsp;
<i>66</i>&nbsp;    public Type getType() {
<b class="nc"><i>67</i>&nbsp;        return type;</b>
<i>68</i>&nbsp;    }
<i>69</i>&nbsp;
<i>70</i>&nbsp;    /**
<i>71</i>&nbsp;     * Return the precedence of the operator
<i>72</i>&nbsp;     */
<i>73</i>&nbsp;    int precedence() {
<b class="nc"><i>74</i>&nbsp;        return (op &lt; opPrecedence.length) ? opPrecedence[op] : 100;</b>
<i>75</i>&nbsp;    }
<i>76</i>&nbsp;
<i>77</i>&nbsp;    /**
<i>78</i>&nbsp;     * Order the expression based on precedence
<i>79</i>&nbsp;     */
<i>80</i>&nbsp;    public Expression order() {
<b class="nc"><i>81</i>&nbsp;        return this;</b>
<i>82</i>&nbsp;    }
<i>83</i>&nbsp;
<i>84</i>&nbsp;    /**
<i>85</i>&nbsp;     * Return true if constant, according to JLS 15.27.
<i>86</i>&nbsp;     * A constant expression must inline away to a literal constant.
<i>87</i>&nbsp;     */
<i>88</i>&nbsp;    public boolean isConstant() {
<b class="nc"><i>89</i>&nbsp;        return false;</b>
<i>90</i>&nbsp;    }
<i>91</i>&nbsp;
<i>92</i>&nbsp;    /**
<i>93</i>&nbsp;     * Return the constant value.
<i>94</i>&nbsp;     */
<i>95</i>&nbsp;    public Object getValue() {
<b class="nc"><i>96</i>&nbsp;        return null;</b>
<i>97</i>&nbsp;    }
<i>98</i>&nbsp;
<i>99</i>&nbsp;    /**
<i>100</i>&nbsp;     * Check if the expression is known to be equal to a given value.
<i>101</i>&nbsp;     * Returns false for any expression other than a literal constant,
<i>102</i>&nbsp;     * thus should be called only after simplification (inlining) has
<i>103</i>&nbsp;     * been performed.
<i>104</i>&nbsp;     */
<i>105</i>&nbsp;    public boolean equals(int i) {
<b class="nc"><i>106</i>&nbsp;        return false;</b>
<i>107</i>&nbsp;    }
<i>108</i>&nbsp;    public boolean equals(boolean b) {
<b class="nc"><i>109</i>&nbsp;        return false;</b>
<i>110</i>&nbsp;    }
<i>111</i>&nbsp;    public boolean equals(Identifier id) {
<b class="nc"><i>112</i>&nbsp;        return false;</b>
<i>113</i>&nbsp;    }
<i>114</i>&nbsp;    public boolean equals(String s) {
<b class="nc"><i>115</i>&nbsp;        return false;</b>
<i>116</i>&nbsp;    }
<i>117</i>&nbsp;
<i>118</i>&nbsp;    /**
<i>119</i>&nbsp;     * Check if the expression must be a null reference.
<i>120</i>&nbsp;     */
<i>121</i>&nbsp;    public boolean isNull() {
<b class="nc"><i>122</i>&nbsp;        return false;</b>
<i>123</i>&nbsp;    }
<i>124</i>&nbsp;
<i>125</i>&nbsp;    /**
<i>126</i>&nbsp;     * Check if the expression cannot be a null reference.
<i>127</i>&nbsp;     */
<i>128</i>&nbsp;    public boolean isNonNull() {
<b class="nc"><i>129</i>&nbsp;        return false;</b>
<i>130</i>&nbsp;    }
<i>131</i>&nbsp;
<i>132</i>&nbsp;    /**
<i>133</i>&nbsp;     * Check if the expression is equal to its default static value
<i>134</i>&nbsp;     */
<i>135</i>&nbsp;    public boolean equalsDefault() {
<b class="nc"><i>136</i>&nbsp;        return false;</b>
<i>137</i>&nbsp;    }
<i>138</i>&nbsp;
<i>139</i>&nbsp;
<i>140</i>&nbsp;    /**
<i>141</i>&nbsp;     * Convert an expresion to a type
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    Type toType(Environment env, Context ctx) {
<b class="nc"><i>144</i>&nbsp;        env.error(where, &quot;invalid.type.expr&quot;);</b>
<b class="nc"><i>145</i>&nbsp;        return Type.tError;</b>
<i>146</i>&nbsp;    }
<i>147</i>&nbsp;
<i>148</i>&nbsp;    /**
<i>149</i>&nbsp;     * Convert an expresion to a type in a context where a qualified
<i>150</i>&nbsp;     * type name is expected, e.g., in the prefix of a qualified type
<i>151</i>&nbsp;     * name.
<i>152</i>&nbsp;     */
<i>153</i>&nbsp;    /*-----------------------------------------------------*
<i>154</i>&nbsp;    Type toQualifiedType(Environment env, Context ctx) {
<i>155</i>&nbsp;        env.error(where, &quot;invalid.type.expr&quot;);
<i>156</i>&nbsp;        return Type.tError;
<i>157</i>&nbsp;    }
<i>158</i>&nbsp;    *-----------------------------------------------------*/
<i>159</i>&nbsp;
<i>160</i>&nbsp;    /**
<i>161</i>&nbsp;     * See if this expression fits in the given type.
<i>162</i>&nbsp;     * This is useful because some larger numbers fit into
<i>163</i>&nbsp;     * smaller types.
<i>164</i>&nbsp;     * &lt;p&gt;
<i>165</i>&nbsp;     * If it is an &quot;int&quot; constant expression, inline it, if necessary,
<i>166</i>&nbsp;     * to examine its numerical value.  See JLS 5.2 and 15.24.
<i>167</i>&nbsp;     */
<i>168</i>&nbsp;    public boolean fitsType(Environment env, Context ctx, Type t) {
<i>169</i>&nbsp;        try {
<b class="nc"><i>170</i>&nbsp;            if (env.isMoreSpecific(this.type, t)) {</b>
<b class="nc"><i>171</i>&nbsp;                return true;</b>
<i>172</i>&nbsp;            }
<b class="nc"><i>173</i>&nbsp;            if (this.type.isType(TC_INT) &amp;&amp; this.isConstant() &amp;&amp; ctx != null) {</b>
<i>174</i>&nbsp;                // Tentative inlining is harmless for constant expressions.
<b class="nc"><i>175</i>&nbsp;                Expression n = this.inlineValue(env, ctx);</b>
<b class="nc"><i>176</i>&nbsp;                if (n != this &amp;&amp; n instanceof ConstantExpression) {</b>
<b class="nc"><i>177</i>&nbsp;                    return n.fitsType(env, ctx, t);</b>
<i>178</i>&nbsp;                }
<i>179</i>&nbsp;            }
<b class="nc"><i>180</i>&nbsp;            return false;</b>
<b class="nc"><i>181</i>&nbsp;        } catch (ClassNotFound e) {</b>
<b class="nc"><i>182</i>&nbsp;            return false;</b>
<i>183</i>&nbsp;        }
<i>184</i>&nbsp;    }
<i>185</i>&nbsp;
<i>186</i>&nbsp;    /** @deprecated (for backward compatibility) */
<i>187</i>&nbsp;    @Deprecated
<i>188</i>&nbsp;    public boolean fitsType(Environment env, Type t) {
<b class="nc"><i>189</i>&nbsp;        return fitsType(env, (Context) null, t);</b>
<i>190</i>&nbsp;    }
<i>191</i>&nbsp;
<i>192</i>&nbsp;    /**
<i>193</i>&nbsp;     * Check an expression
<i>194</i>&nbsp;     */
<i>195</i>&nbsp;    public Vset checkValue(Environment env, Context ctx, Vset vset, Hashtable&lt;Object, Object&gt; exp) {
<b class="nc"><i>196</i>&nbsp;        return vset;</b>
<i>197</i>&nbsp;    }
<i>198</i>&nbsp;    public Vset checkInitializer(Environment env, Context ctx, Vset vset, Type t, Hashtable&lt;Object, Object&gt; exp) {
<b class="nc"><i>199</i>&nbsp;        return checkValue(env, ctx, vset, exp);</b>
<i>200</i>&nbsp;    }
<i>201</i>&nbsp;    public Vset check(Environment env, Context ctx, Vset vset, Hashtable&lt;Object, Object&gt; exp) {
<b class="nc"><i>202</i>&nbsp;        throw new CompilerError(&quot;check failed&quot;);</b>
<i>203</i>&nbsp;    }
<i>204</i>&nbsp;
<i>205</i>&nbsp;    public Vset checkLHS(Environment env, Context ctx,
<i>206</i>&nbsp;                            Vset vset, Hashtable&lt;Object, Object&gt; exp) {
<b class="nc"><i>207</i>&nbsp;        env.error(where, &quot;invalid.lhs.assignment&quot;);</b>
<b class="nc"><i>208</i>&nbsp;        type = Type.tError;</b>
<b class="nc"><i>209</i>&nbsp;        return vset;</b>
<i>210</i>&nbsp;    }
<i>211</i>&nbsp;
<i>212</i>&nbsp;    /**
<i>213</i>&nbsp;     * Return a {@code FieldUpdater} object to be used in updating the
<i>214</i>&nbsp;     * value of the location denoted by {@code this}, which must be an
<i>215</i>&nbsp;     * expression suitable for the left-hand side of an assignment.
<i>216</i>&nbsp;     * This is used for implementing assignments to private fields for which
<i>217</i>&nbsp;     * an access method is required.  Returns null if no access method is
<i>218</i>&nbsp;     * needed, in which case the assignment is handled in the usual way, by
<i>219</i>&nbsp;     * direct access.  Only simple assignment expressions are handled here
<i>220</i>&nbsp;     * Assignment operators and pre/post increment/decrement operators are
<i>221</i>&nbsp;     * are handled by &#39;getUpdater&#39; below.
<i>222</i>&nbsp;     * &lt;p&gt;
<i>223</i>&nbsp;     * Called during the checking phase.
<i>224</i>&nbsp;     */
<i>225</i>&nbsp;
<i>226</i>&nbsp;    public FieldUpdater getAssigner(Environment env, Context ctx) {
<b class="nc"><i>227</i>&nbsp;        throw new CompilerError(&quot;getAssigner lhs&quot;);</b>
<i>228</i>&nbsp;    }
<i>229</i>&nbsp;
<i>230</i>&nbsp;    /**
<i>231</i>&nbsp;     * Return a {@code FieldUpdater} object to be used in updating the value of the
<i>232</i>&nbsp;     * location denoted by {@code this}, which must be an expression suitable for the
<i>233</i>&nbsp;     * left-hand side of an assignment.  This is used for implementing the assignment
<i>234</i>&nbsp;     * operators and the increment/decrement operators on private fields that require an
<i>235</i>&nbsp;     * access method, e.g., uplevel from an inner class.  Returns null if no access method
<i>236</i>&nbsp;     * is needed.
<i>237</i>&nbsp;     * &lt;p&gt;
<i>238</i>&nbsp;     * Called during the checking phase.
<i>239</i>&nbsp;     */
<i>240</i>&nbsp;
<i>241</i>&nbsp;    public FieldUpdater getUpdater(Environment env, Context ctx) {
<b class="nc"><i>242</i>&nbsp;        throw new CompilerError(&quot;getUpdater lhs&quot;);</b>
<i>243</i>&nbsp;    }
<i>244</i>&nbsp;
<i>245</i>&nbsp;    public Vset checkAssignOp(Environment env, Context ctx,
<i>246</i>&nbsp;                              Vset vset, Hashtable&lt;Object, Object&gt; exp, Expression outside) {
<b class="nc"><i>247</i>&nbsp;        if (outside instanceof IncDecExpression)</b>
<b class="nc"><i>248</i>&nbsp;            env.error(where, &quot;invalid.arg&quot;, opNames[outside.op]);</b>
<i>249</i>&nbsp;        else
<b class="nc"><i>250</i>&nbsp;            env.error(where, &quot;invalid.lhs.assignment&quot;);</b>
<b class="nc"><i>251</i>&nbsp;        type = Type.tError;</b>
<b class="nc"><i>252</i>&nbsp;        return vset;</b>
<i>253</i>&nbsp;    }
<i>254</i>&nbsp;
<i>255</i>&nbsp;    /**
<i>256</i>&nbsp;     * Check something that might be an AmbiguousName (refman 6.5.2).
<i>257</i>&nbsp;     * A string of dot-separated identifiers might be, in order of preference:
<i>258</i>&nbsp;     * &lt;nl&gt;
<i>259</i>&nbsp;     * &lt;li&gt; a variable name followed by fields or types
<i>260</i>&nbsp;     * &lt;li&gt; a type name followed by fields or types
<i>261</i>&nbsp;     * &lt;li&gt; a package name followed a type and then fields or types
<i>262</i>&nbsp;     * &lt;/nl&gt;
<i>263</i>&nbsp;     * If a type name is found, it rewrites itself as a {@code TypeExpression}.
<i>264</i>&nbsp;     * If a node decides it can only be a package prefix, it sets its
<i>265</i>&nbsp;     * type to {@code Type.tPackage}.  The caller must detect this
<i>266</i>&nbsp;     * and act appropriately to verify the full package name.
<i>267</i>&nbsp;     * @arg loc the expression containing the ambiguous expression
<i>268</i>&nbsp;     */
<i>269</i>&nbsp;    public Vset checkAmbigName(Environment env, Context ctx, Vset vset, Hashtable&lt;Object, Object&gt; exp,
<i>270</i>&nbsp;                               UnaryExpression loc) {
<b class="nc"><i>271</i>&nbsp;        return checkValue(env, ctx, vset, exp);</b>
<i>272</i>&nbsp;    }
<i>273</i>&nbsp;
<i>274</i>&nbsp;    /**
<i>275</i>&nbsp;     * Check a condition.  Return a ConditionVars(), which indicates when
<i>276</i>&nbsp;     * which variables are set if the condition is true, and which are set if
<i>277</i>&nbsp;     * the condition is false.
<i>278</i>&nbsp;     */
<i>279</i>&nbsp;    public ConditionVars checkCondition(Environment env, Context ctx,
<i>280</i>&nbsp;                                        Vset vset, Hashtable&lt;Object, Object&gt; exp) {
<b class="nc"><i>281</i>&nbsp;        ConditionVars cvars = new ConditionVars();</b>
<b class="nc"><i>282</i>&nbsp;        checkCondition(env, ctx, vset, exp, cvars);</b>
<b class="nc"><i>283</i>&nbsp;        return cvars;</b>
<i>284</i>&nbsp;    }
<i>285</i>&nbsp;
<i>286</i>&nbsp;    /*
<i>287</i>&nbsp;     * Check a condition.
<i>288</i>&nbsp;     *
<i>289</i>&nbsp;     * cvars is modified so that
<i>290</i>&nbsp;     *    cvar.vsTrue indicates variables with a known value if result = true
<i>291</i>&nbsp;     *    cvars.vsFalse indicates variables with a known value if !result
<i>292</i>&nbsp;     *
<i>293</i>&nbsp;     * The default action is to simply call checkValue on the expression, and
<i>294</i>&nbsp;     * to see both vsTrue and vsFalse to the result.
<i>295</i>&nbsp;     */
<i>296</i>&nbsp;
<i>297</i>&nbsp;    public void checkCondition(Environment env, Context ctx,
<i>298</i>&nbsp;                               Vset vset, Hashtable&lt;Object, Object&gt; exp, ConditionVars cvars) {
<b class="nc"><i>299</i>&nbsp;        cvars.vsTrue = cvars.vsFalse = checkValue(env, ctx, vset, exp);</b>
<i>300</i>&nbsp;        // unshare side effects:
<b class="nc"><i>301</i>&nbsp;        cvars.vsFalse = cvars.vsFalse.copy();</b>
<i>302</i>&nbsp;    }
<i>303</i>&nbsp;
<i>304</i>&nbsp;    /**
<i>305</i>&nbsp;     * Evaluate.
<i>306</i>&nbsp;     *
<i>307</i>&nbsp;     * Attempt to compute the value of an expression node.  If all operands are
<i>308</i>&nbsp;     * literal constants of the same kind (e.g., IntegerExpression nodes), a
<i>309</i>&nbsp;     * new constant node of the proper type is returned representing the value
<i>310</i>&nbsp;     * as computed at compile-time.  Otherwise, the original node &#39;this&#39; is
<i>311</i>&nbsp;     * returned.
<i>312</i>&nbsp;     */
<i>313</i>&nbsp;    Expression eval() {
<b class="nc"><i>314</i>&nbsp;        return this;</b>
<i>315</i>&nbsp;    }
<i>316</i>&nbsp;
<i>317</i>&nbsp;    /**
<i>318</i>&nbsp;     * Simplify.
<i>319</i>&nbsp;     *
<i>320</i>&nbsp;     * Attempt to simplify an expression node by returning a semantically-
<i>321</i>&nbsp;     * equivalent expression that is presumably less costly to execute.  There
<i>322</i>&nbsp;     * is some overlap with the intent of &#39;eval&#39;, as compile-time evaluation of
<i>323</i>&nbsp;     * conditional expressions and the short-circuit boolean operators is
<i>324</i>&nbsp;     * performed here.  Other simplifications include logical identities
<i>325</i>&nbsp;     * involving logical negation and comparisons.  If no simplification is
<i>326</i>&nbsp;     * possible, the original node &#39;this&#39; is returned.  It is assumed that the
<i>327</i>&nbsp;     * children of the node have previously been recursively simplified and
<i>328</i>&nbsp;     * evaluated.  A result of &#39;null&#39; indicates that the expression may be
<i>329</i>&nbsp;     * elided entirely.
<i>330</i>&nbsp;     */
<i>331</i>&nbsp;    Expression simplify() {
<b class="nc"><i>332</i>&nbsp;        return this;</b>
<i>333</i>&nbsp;    }
<i>334</i>&nbsp;
<i>335</i>&nbsp;    /**
<i>336</i>&nbsp;     * Inline.
<i>337</i>&nbsp;     *
<i>338</i>&nbsp;     * Recursively simplify each child of an expression node, destructively
<i>339</i>&nbsp;     * replacing the child with the simplified result.  Also attempts to
<i>340</i>&nbsp;     * simplify the current node &#39;this&#39;, and returns the simplified result.
<i>341</i>&nbsp;     *
<i>342</i>&nbsp;     * The name &#39;inline&#39; is somthing of a misnomer, as these methods are
<i>343</i>&nbsp;     * responsible for compile-time expression simplification in general.
<i>344</i>&nbsp;     * The &#39;eval&#39; and &#39;simplify&#39; methods apply to a single expression node
<i>345</i>&nbsp;     * only -- it is &#39;inline&#39; and &#39;inlineValue&#39; that drive the simplification
<i>346</i>&nbsp;     * of entire expressions.
<i>347</i>&nbsp;     */
<i>348</i>&nbsp;    public Expression inline(Environment env, Context ctx) {
<b class="nc"><i>349</i>&nbsp;        return null;</b>
<i>350</i>&nbsp;    }
<i>351</i>&nbsp;    public Expression inlineValue(Environment env, Context ctx) {
<b class="nc"><i>352</i>&nbsp;        return this;</b>
<i>353</i>&nbsp;    }
<i>354</i>&nbsp;
<i>355</i>&nbsp;    /**
<i>356</i>&nbsp;     * Attempt to evaluate this expression.  If this expression
<i>357</i>&nbsp;     * yields a value, append it to the StringBuffer `buffer&#39;.
<i>358</i>&nbsp;     * If this expression cannot be evaluated at this time (for
<i>359</i>&nbsp;     * example if it contains a division by zero, a non-constant
<i>360</i>&nbsp;     * subexpression, or a subexpression which &quot;refuses&quot; to evaluate)
<i>361</i>&nbsp;     * then return `null&#39; to indicate failure.
<i>362</i>&nbsp;     *
<i>363</i>&nbsp;     * It is anticipated that this method will be called to evaluate
<i>364</i>&nbsp;     * concatenations of compile-time constant strings.  The call
<i>365</i>&nbsp;     * originates from AddExpression#inlineValue().
<i>366</i>&nbsp;     *
<i>367</i>&nbsp;     * See AddExpression#inlineValueSB() for detailed comments.
<i>368</i>&nbsp;     */
<i>369</i>&nbsp;    protected StringBuffer inlineValueSB(Environment env,
<i>370</i>&nbsp;                                         Context ctx,
<i>371</i>&nbsp;                                         StringBuffer buffer) {
<b class="nc"><i>372</i>&nbsp;        Expression inlined = inlineValue(env, ctx);</b>
<b class="nc"><i>373</i>&nbsp;        Object val = inlined.getValue();</b>
<i>374</i>&nbsp;
<b class="nc"><i>375</i>&nbsp;        if (val == null &amp;&amp; !inlined.isNull()){</b>
<i>376</i>&nbsp;            // This (supposedly constant) expression refuses to yield
<i>377</i>&nbsp;            // a value.  This can happen, in particular, when we are
<i>378</i>&nbsp;            // trying to evaluate a division by zero.  It can also
<i>379</i>&nbsp;            // happen in cases where isConstant() is able to classify
<i>380</i>&nbsp;            // expressions as constant that the compiler&#39;s inlining
<i>381</i>&nbsp;            // mechanisms aren&#39;t able to evaluate; this is rare,
<i>382</i>&nbsp;            // and all such cases that we have found so far
<i>383</i>&nbsp;            // (e.g. 4082814, 4106244) have been plugged up.
<i>384</i>&nbsp;            //
<i>385</i>&nbsp;            // We return a null to indicate that we have failed to
<i>386</i>&nbsp;            // evaluate the concatenation.
<b class="nc"><i>387</i>&nbsp;            return null;</b>
<i>388</i>&nbsp;        }
<i>389</i>&nbsp;
<i>390</i>&nbsp;        // For boolean and character expressions, getValue() returns
<i>391</i>&nbsp;        // an Integer.  We need to take care, when appending the result
<i>392</i>&nbsp;        // of getValue(), that we preserve the type.
<i>393</i>&nbsp;        // Fix for 4103959, 4102672.
<b class="nc"><i>394</i>&nbsp;        if (type == Type.tChar) {</b>
<b class="nc"><i>395</i>&nbsp;            buffer.append((char)((Integer)val).intValue());</b>
<b class="nc"><i>396</i>&nbsp;        } else if (type == Type.tBoolean) {</b>
<b class="nc"><i>397</i>&nbsp;            buffer.append(((Integer)val).intValue() != 0);</b>
<i>398</i>&nbsp;        } else {
<b class="nc"><i>399</i>&nbsp;            buffer.append(val);</b>
<i>400</i>&nbsp;        }
<i>401</i>&nbsp;
<b class="nc"><i>402</i>&nbsp;        return buffer;</b>
<i>403</i>&nbsp;    }
<i>404</i>&nbsp;
<i>405</i>&nbsp;    public Expression inlineLHS(Environment env, Context ctx) {
<b class="nc"><i>406</i>&nbsp;        return null;</b>
<i>407</i>&nbsp;    }
<i>408</i>&nbsp;
<i>409</i>&nbsp;    /**
<i>410</i>&nbsp;     * The cost of inlining this expression.
<i>411</i>&nbsp;     * This cost controls the inlining of methods, and does not determine
<i>412</i>&nbsp;     * the compile-time simplifications performed by &#39;inline&#39; and friends.
<i>413</i>&nbsp;     */
<i>414</i>&nbsp;    public int costInline(int thresh, Environment env, Context ctx) {
<b class="nc"><i>415</i>&nbsp;        return 1;</b>
<i>416</i>&nbsp;    }
<i>417</i>&nbsp;
<i>418</i>&nbsp;    /**
<i>419</i>&nbsp;     * Code
<i>420</i>&nbsp;     */
<i>421</i>&nbsp;    void codeBranch(Environment env, Context ctx, Assembler asm, Label lbl, boolean whenTrue) {
<b class="nc"><i>422</i>&nbsp;        if (type.isType(TC_BOOLEAN)) {</b>
<b class="nc"><i>423</i>&nbsp;            codeValue(env, ctx, asm);</b>
<b class="nc"><i>424</i>&nbsp;            asm.add(where, whenTrue ? opc_ifne : opc_ifeq, lbl, whenTrue);</b>
<i>425</i>&nbsp;        } else {
<b class="nc"><i>426</i>&nbsp;            throw new CompilerError(&quot;codeBranch &quot; + opNames[op]);</b>
<i>427</i>&nbsp;        }
<i>428</i>&nbsp;    }
<i>429</i>&nbsp;    public void codeValue(Environment env, Context ctx, Assembler asm) {
<b class="nc"><i>430</i>&nbsp;        if (type.isType(TC_BOOLEAN)) {</b>
<b class="nc"><i>431</i>&nbsp;            Label l1 = new Label();</b>
<b class="nc"><i>432</i>&nbsp;            Label l2 = new Label();</b>
<i>433</i>&nbsp;
<b class="nc"><i>434</i>&nbsp;            codeBranch(env, ctx, asm, l1, true);</b>
<b class="nc"><i>435</i>&nbsp;            asm.add(true, where, opc_ldc, 0);</b>
<b class="nc"><i>436</i>&nbsp;            asm.add(true, where, opc_goto, l2);</b>
<b class="nc"><i>437</i>&nbsp;            asm.add(l1);</b>
<b class="nc"><i>438</i>&nbsp;            asm.add(true, where, opc_ldc, 1);</b>
<b class="nc"><i>439</i>&nbsp;            asm.add(l2);</b>
<b class="nc"><i>440</i>&nbsp;        } else {</b>
<b class="nc"><i>441</i>&nbsp;            throw new CompilerError(&quot;codeValue&quot;);</b>
<i>442</i>&nbsp;        }
<i>443</i>&nbsp;    }
<i>444</i>&nbsp;    public void code(Environment env, Context ctx, Assembler asm) {
<b class="nc"><i>445</i>&nbsp;        codeValue(env, ctx, asm);</b>
<i>446</i>&nbsp;
<b class="nc"><i>447</i>&nbsp;        switch (type.getTypeCode()) {</b>
<i>448</i>&nbsp;          case TC_VOID:
<b class="nc"><i>449</i>&nbsp;            break;</b>
<i>450</i>&nbsp;
<i>451</i>&nbsp;          case TC_DOUBLE:
<i>452</i>&nbsp;          case TC_LONG:
<b class="nc"><i>453</i>&nbsp;            asm.add(where, opc_pop2);</b>
<b class="nc"><i>454</i>&nbsp;            break;</b>
<i>455</i>&nbsp;
<i>456</i>&nbsp;          default:
<b class="nc"><i>457</i>&nbsp;            asm.add(where, opc_pop);</b>
<i>458</i>&nbsp;            break;
<i>459</i>&nbsp;        }
<i>460</i>&nbsp;    }
<i>461</i>&nbsp;    int codeLValue(Environment env, Context ctx, Assembler asm) {
<b class="nc"><i>462</i>&nbsp;        print(System.out);</b>
<b class="nc"><i>463</i>&nbsp;        throw new CompilerError(&quot;invalid lhs&quot;);</b>
<i>464</i>&nbsp;    }
<i>465</i>&nbsp;    void codeLoad(Environment env, Context ctx, Assembler asm) {
<b class="nc"><i>466</i>&nbsp;        print(System.out);</b>
<b class="nc"><i>467</i>&nbsp;        throw new CompilerError(&quot;invalid load&quot;);</b>
<i>468</i>&nbsp;    }
<i>469</i>&nbsp;    void codeStore(Environment env, Context ctx, Assembler asm) {
<b class="nc"><i>470</i>&nbsp;        print(System.out);</b>
<b class="nc"><i>471</i>&nbsp;        throw new CompilerError(&quot;invalid store&quot;);</b>
<i>472</i>&nbsp;    }
<i>473</i>&nbsp;
<i>474</i>&nbsp;    /**
<i>475</i>&nbsp;     * Convert this expression to a string.
<i>476</i>&nbsp;     */
<i>477</i>&nbsp;    void ensureString(Environment env, Context ctx, Assembler asm)
<i>478</i>&nbsp;            throws ClassNotFound, AmbiguousMember
<i>479</i>&nbsp;    {
<b class="nc"><i>480</i>&nbsp;        if (type == Type.tString &amp;&amp; isNonNull()) {</b>
<i>481</i>&nbsp;            return;
<i>482</i>&nbsp;        }
<i>483</i>&nbsp;        // Make sure it&#39;s a non-null string.
<b class="nc"><i>484</i>&nbsp;        ClassDefinition sourceClass = ctx.field.getClassDefinition();</b>
<b class="nc"><i>485</i>&nbsp;        ClassDeclaration stClass = env.getClassDeclaration(Type.tString);</b>
<b class="nc"><i>486</i>&nbsp;        ClassDefinition stClsDef = stClass.getClassDefinition(env);</b>
<i>487</i>&nbsp;        // FIX FOR 4071548
<i>488</i>&nbsp;        // We use &#39;String.valueOf&#39; to do the conversion, in order to
<i>489</i>&nbsp;        // correctly handle null references and efficiently handle
<i>490</i>&nbsp;        // primitive types.  For reference types, we force the argument
<i>491</i>&nbsp;        // to be interpreted as of &#39;Object&#39; type, thus avoiding the
<i>492</i>&nbsp;        // the special-case overloading of &#39;valueOf&#39; for character arrays.
<i>493</i>&nbsp;        // This special treatment would conflict with JLS 15.17.1.1.
<b class="nc"><i>494</i>&nbsp;        if (type.inMask(TM_REFERENCE)) {</b>
<i>495</i>&nbsp;            // Reference type
<b class="nc"><i>496</i>&nbsp;            if (type != Type.tString) {</b>
<i>497</i>&nbsp;                // Convert non-string object to string.  If object is
<i>498</i>&nbsp;                // a string, we don&#39;t need to convert it, except in the
<i>499</i>&nbsp;                // case that it is null, which is handled below.
<b class="nc"><i>500</i>&nbsp;                Type argType1[] = {Type.tObject};</b>
<b class="nc"><i>501</i>&nbsp;                MemberDefinition f1 =</b>
<b class="nc"><i>502</i>&nbsp;                    stClsDef.matchMethod(env, sourceClass, idValueOf, argType1);</b>
<b class="nc"><i>503</i>&nbsp;                asm.add(where, opc_invokestatic, f1);</b>
<i>504</i>&nbsp;            }
<i>505</i>&nbsp;            // FIX FOR 4030173
<i>506</i>&nbsp;            // If the argument was null, then value is &quot;null&quot;, but if the
<i>507</i>&nbsp;            // argument was not null, &#39;toString&#39; was called and could have
<i>508</i>&nbsp;            // returned null.  We call &#39;valueOf&#39; again to make sure that
<i>509</i>&nbsp;            // the result is a non-null string.  See JLS 15.17.1.1.  The
<i>510</i>&nbsp;            // approach taken here minimizes code size -- open code would
<i>511</i>&nbsp;            // be faster.  The &#39;toString&#39; method for an array class cannot
<i>512</i>&nbsp;            // be overridden, thus we know that it will never return null.
<b class="nc"><i>513</i>&nbsp;            if (!type.inMask(TM_ARRAY|TM_NULL)) {</b>
<b class="nc"><i>514</i>&nbsp;                Type argType2[] = {Type.tString};</b>
<b class="nc"><i>515</i>&nbsp;                MemberDefinition f2 =</b>
<b class="nc"><i>516</i>&nbsp;                    stClsDef.matchMethod(env, sourceClass, idValueOf, argType2);</b>
<b class="nc"><i>517</i>&nbsp;                asm.add(where, opc_invokestatic, f2);</b>
<b class="nc"><i>518</i>&nbsp;            }</b>
<i>519</i>&nbsp;        } else {
<i>520</i>&nbsp;            // Primitive type
<b class="nc"><i>521</i>&nbsp;            Type argType[] = {type};</b>
<b class="nc"><i>522</i>&nbsp;            MemberDefinition f =</b>
<b class="nc"><i>523</i>&nbsp;                stClsDef.matchMethod(env, sourceClass, idValueOf, argType);</b>
<b class="nc"><i>524</i>&nbsp;            asm.add(where, opc_invokestatic, f);</b>
<i>525</i>&nbsp;        }
<i>526</i>&nbsp;    }
<i>527</i>&nbsp;
<i>528</i>&nbsp;    /**
<i>529</i>&nbsp;     * Convert this expression to a string and append it to the string
<i>530</i>&nbsp;     * buffer on the top of the stack.
<i>531</i>&nbsp;     * If the needBuffer argument is true, the string buffer needs to be
<i>532</i>&nbsp;     * created, initialized, and pushed on the stack, first.
<i>533</i>&nbsp;     */
<i>534</i>&nbsp;    void codeAppend(Environment env, Context ctx, Assembler asm,
<i>535</i>&nbsp;                    ClassDeclaration sbClass, boolean needBuffer)
<i>536</i>&nbsp;            throws ClassNotFound, AmbiguousMember
<i>537</i>&nbsp;    {
<b class="nc"><i>538</i>&nbsp;        ClassDefinition sourceClass = ctx.field.getClassDefinition();</b>
<b class="nc"><i>539</i>&nbsp;        ClassDefinition sbClsDef = sbClass.getClassDefinition(env);</b>
<i>540</i>&nbsp;        MemberDefinition f;
<b class="nc"><i>541</i>&nbsp;        if (needBuffer) {</b>
<i>542</i>&nbsp;            // need to create the string buffer
<b class="nc"><i>543</i>&nbsp;            asm.add(where, opc_new, sbClass); // create the class</b>
<b class="nc"><i>544</i>&nbsp;            asm.add(where, opc_dup);</b>
<b class="nc"><i>545</i>&nbsp;            if (equals(&quot;&quot;)) {</b>
<i>546</i>&nbsp;                // make an empty string buffer
<b class="nc"><i>547</i>&nbsp;                f = sbClsDef.matchMethod(env, sourceClass, idInit);</b>
<i>548</i>&nbsp;            } else {
<i>549</i>&nbsp;                // optimize by initializing the buffer with the string
<b class="nc"><i>550</i>&nbsp;                codeValue(env, ctx, asm);</b>
<b class="nc"><i>551</i>&nbsp;                ensureString(env, ctx, asm);</b>
<b class="nc"><i>552</i>&nbsp;                Type argType[] = {Type.tString};</b>
<b class="nc"><i>553</i>&nbsp;                f = sbClsDef.matchMethod(env, sourceClass, idInit, argType);</b>
<i>554</i>&nbsp;            }
<b class="nc"><i>555</i>&nbsp;            asm.add(where, opc_invokespecial, f);</b>
<i>556</i>&nbsp;        } else {
<i>557</i>&nbsp;            // append this item to the string buffer
<b class="nc"><i>558</i>&nbsp;            codeValue(env, ctx, asm);</b>
<i>559</i>&nbsp;            // FIX FOR 4071548
<i>560</i>&nbsp;            // &#39;StringBuffer.append&#39; converts its argument as if by
<i>561</i>&nbsp;            // &#39;valueOf&#39;, treating character arrays specially.  This
<i>562</i>&nbsp;            // violates JLS 15.17.1.1, which requires that concatenation
<i>563</i>&nbsp;            // convert non-primitive arguments using &#39;toString&#39;.  We force
<i>564</i>&nbsp;            // the treatment of all reference types as type &#39;Object&#39;, thus
<i>565</i>&nbsp;            // invoking an overloading of &#39;append&#39; that has the required
<i>566</i>&nbsp;            // semantics.
<b class="nc"><i>567</i>&nbsp;            Type argType[] =</b>
<b class="nc"><i>568</i>&nbsp;                { (type.inMask(TM_REFERENCE) &amp;&amp; type != Type.tString)</b>
<i>569</i>&nbsp;                  ? Type.tObject
<i>570</i>&nbsp;                  : type };
<b class="nc"><i>571</i>&nbsp;            f = sbClsDef.matchMethod(env, sourceClass, idAppend, argType);</b>
<b class="nc"><i>572</i>&nbsp;            asm.add(where, opc_invokevirtual, f);</b>
<i>573</i>&nbsp;        }
<i>574</i>&nbsp;    }
<i>575</i>&nbsp;
<i>576</i>&nbsp;    /**
<i>577</i>&nbsp;     * Code
<i>578</i>&nbsp;     */
<i>579</i>&nbsp;    void codeDup(Environment env, Context ctx, Assembler asm, int items, int depth) {
<b class="nc"><i>580</i>&nbsp;        switch (items) {</b>
<i>581</i>&nbsp;          case 0:
<i>582</i>&nbsp;            return;
<i>583</i>&nbsp;
<i>584</i>&nbsp;          case 1:
<b class="nc"><i>585</i>&nbsp;            switch (depth) {</b>
<i>586</i>&nbsp;              case 0:
<b class="nc"><i>587</i>&nbsp;                asm.add(where, opc_dup);</b>
<i>588</i>&nbsp;                return;
<i>589</i>&nbsp;              case 1:
<b class="nc"><i>590</i>&nbsp;                asm.add(where, opc_dup_x1);</b>
<i>591</i>&nbsp;                return;
<i>592</i>&nbsp;              case 2:
<b class="nc"><i>593</i>&nbsp;                asm.add(where, opc_dup_x2);</b>
<i>594</i>&nbsp;                return;
<i>595</i>&nbsp;
<i>596</i>&nbsp;            }
<b class="nc"><i>597</i>&nbsp;            break;</b>
<i>598</i>&nbsp;          case 2:
<b class="nc"><i>599</i>&nbsp;            switch (depth) {</b>
<i>600</i>&nbsp;              case 0:
<b class="nc"><i>601</i>&nbsp;                asm.add(where, opc_dup2);</b>
<i>602</i>&nbsp;                return;
<i>603</i>&nbsp;              case 1:
<b class="nc"><i>604</i>&nbsp;                asm.add(where, opc_dup2_x1);</b>
<i>605</i>&nbsp;                return;
<i>606</i>&nbsp;              case 2:
<b class="nc"><i>607</i>&nbsp;                asm.add(where, opc_dup2_x2);</b>
<i>608</i>&nbsp;                return;
<i>609</i>&nbsp;
<i>610</i>&nbsp;            }
<i>611</i>&nbsp;            break;
<i>612</i>&nbsp;        }
<b class="nc"><i>613</i>&nbsp;        throw new CompilerError(&quot;can&#39;t dup: &quot; + items + &quot;, &quot; + depth);</b>
<i>614</i>&nbsp;    }
<i>615</i>&nbsp;
<i>616</i>&nbsp;    void codeConversion(Environment env, Context ctx, Assembler asm, Type f, Type t) {
<b class="nc"><i>617</i>&nbsp;        int from = f.getTypeCode();</b>
<b class="nc"><i>618</i>&nbsp;        int to = t.getTypeCode();</b>
<i>619</i>&nbsp;
<b class="nc"><i>620</i>&nbsp;        switch (to) {</b>
<i>621</i>&nbsp;          case TC_BOOLEAN:
<b class="nc"><i>622</i>&nbsp;            if (from != TC_BOOLEAN) {</b>
<b class="nc"><i>623</i>&nbsp;                break;</b>
<i>624</i>&nbsp;            }
<i>625</i>&nbsp;            return;
<i>626</i>&nbsp;          case TC_BYTE:
<b class="nc"><i>627</i>&nbsp;            if (from != TC_BYTE) {</b>
<b class="nc"><i>628</i>&nbsp;                codeConversion(env, ctx, asm, f, Type.tInt);</b>
<b class="nc"><i>629</i>&nbsp;                asm.add(where, opc_i2b);</b>
<i>630</i>&nbsp;            }
<i>631</i>&nbsp;            return;
<i>632</i>&nbsp;          case TC_CHAR:
<b class="nc"><i>633</i>&nbsp;            if (from != TC_CHAR) {</b>
<b class="nc"><i>634</i>&nbsp;                codeConversion(env, ctx, asm, f, Type.tInt);</b>
<b class="nc"><i>635</i>&nbsp;                asm.add(where, opc_i2c);</b>
<i>636</i>&nbsp;            }
<i>637</i>&nbsp;            return;
<i>638</i>&nbsp;          case TC_SHORT:
<b class="nc"><i>639</i>&nbsp;            if (from != TC_SHORT) {</b>
<b class="nc"><i>640</i>&nbsp;                codeConversion(env, ctx, asm, f, Type.tInt);</b>
<b class="nc"><i>641</i>&nbsp;                asm.add(where, opc_i2s);</b>
<i>642</i>&nbsp;            }
<i>643</i>&nbsp;            return;
<i>644</i>&nbsp;          case TC_INT:
<b class="nc"><i>645</i>&nbsp;            switch (from) {</b>
<i>646</i>&nbsp;              case TC_BYTE:
<i>647</i>&nbsp;              case TC_CHAR:
<i>648</i>&nbsp;              case TC_SHORT:
<i>649</i>&nbsp;              case TC_INT:
<i>650</i>&nbsp;                return;
<i>651</i>&nbsp;              case TC_LONG:
<b class="nc"><i>652</i>&nbsp;                asm.add(where, opc_l2i);</b>
<i>653</i>&nbsp;                return;
<i>654</i>&nbsp;              case TC_FLOAT:
<b class="nc"><i>655</i>&nbsp;                asm.add(where, opc_f2i);</b>
<i>656</i>&nbsp;                return;
<i>657</i>&nbsp;              case TC_DOUBLE:
<b class="nc"><i>658</i>&nbsp;                asm.add(where, opc_d2i);</b>
<i>659</i>&nbsp;                return;
<i>660</i>&nbsp;            }
<b class="nc"><i>661</i>&nbsp;            break;</b>
<i>662</i>&nbsp;          case TC_LONG:
<b class="nc"><i>663</i>&nbsp;            switch (from) {</b>
<i>664</i>&nbsp;              case TC_BYTE:
<i>665</i>&nbsp;              case TC_CHAR:
<i>666</i>&nbsp;              case TC_SHORT:
<i>667</i>&nbsp;              case TC_INT:
<b class="nc"><i>668</i>&nbsp;                asm.add(where, opc_i2l);</b>
<i>669</i>&nbsp;                return;
<i>670</i>&nbsp;              case TC_LONG:
<i>671</i>&nbsp;                return;
<i>672</i>&nbsp;              case TC_FLOAT:
<b class="nc"><i>673</i>&nbsp;                asm.add(where, opc_f2l);</b>
<i>674</i>&nbsp;                return;
<i>675</i>&nbsp;              case TC_DOUBLE:
<b class="nc"><i>676</i>&nbsp;                asm.add(where, opc_d2l);</b>
<i>677</i>&nbsp;                return;
<i>678</i>&nbsp;            }
<b class="nc"><i>679</i>&nbsp;            break;</b>
<i>680</i>&nbsp;          case TC_FLOAT:
<b class="nc"><i>681</i>&nbsp;            switch (from) {</b>
<i>682</i>&nbsp;              case TC_BYTE:
<i>683</i>&nbsp;              case TC_CHAR:
<i>684</i>&nbsp;              case TC_SHORT:
<i>685</i>&nbsp;              case TC_INT:
<b class="nc"><i>686</i>&nbsp;                asm.add(where, opc_i2f);</b>
<i>687</i>&nbsp;                return;
<i>688</i>&nbsp;              case TC_LONG:
<b class="nc"><i>689</i>&nbsp;                asm.add(where, opc_l2f);</b>
<i>690</i>&nbsp;                return;
<i>691</i>&nbsp;              case TC_FLOAT:
<i>692</i>&nbsp;                return;
<i>693</i>&nbsp;              case TC_DOUBLE:
<b class="nc"><i>694</i>&nbsp;                asm.add(where, opc_d2f);</b>
<i>695</i>&nbsp;                return;
<i>696</i>&nbsp;            }
<b class="nc"><i>697</i>&nbsp;            break;</b>
<i>698</i>&nbsp;          case TC_DOUBLE:
<b class="nc"><i>699</i>&nbsp;            switch (from) {</b>
<i>700</i>&nbsp;              case TC_BYTE:
<i>701</i>&nbsp;              case TC_CHAR:
<i>702</i>&nbsp;              case TC_SHORT:
<i>703</i>&nbsp;              case TC_INT:
<b class="nc"><i>704</i>&nbsp;                asm.add(where, opc_i2d);</b>
<i>705</i>&nbsp;                return;
<i>706</i>&nbsp;              case TC_LONG:
<b class="nc"><i>707</i>&nbsp;                asm.add(where, opc_l2d);</b>
<i>708</i>&nbsp;                return;
<i>709</i>&nbsp;              case TC_FLOAT:
<b class="nc"><i>710</i>&nbsp;                asm.add(where, opc_f2d);</b>
<i>711</i>&nbsp;                return;
<i>712</i>&nbsp;              case TC_DOUBLE:
<i>713</i>&nbsp;                return;
<i>714</i>&nbsp;            }
<b class="nc"><i>715</i>&nbsp;            break;</b>
<i>716</i>&nbsp;
<i>717</i>&nbsp;          case TC_CLASS:
<b class="nc"><i>718</i>&nbsp;            switch (from) {</b>
<i>719</i>&nbsp;              case TC_NULL:
<i>720</i>&nbsp;                return;
<i>721</i>&nbsp;              case TC_CLASS:
<i>722</i>&nbsp;              case TC_ARRAY:
<i>723</i>&nbsp;                try {
<b class="nc"><i>724</i>&nbsp;                    if (!env.implicitCast(f, t)) {</b>
<b class="nc"><i>725</i>&nbsp;                        asm.add(where, opc_checkcast, env.getClassDeclaration(t));</b>
<i>726</i>&nbsp;                    }
<b class="nc"><i>727</i>&nbsp;                } catch (ClassNotFound e) {</b>
<b class="nc"><i>728</i>&nbsp;                    throw new CompilerError(e);</b>
<b class="nc"><i>729</i>&nbsp;                }</b>
<i>730</i>&nbsp;                return;
<i>731</i>&nbsp;            }
<i>732</i>&nbsp;
<b class="nc"><i>733</i>&nbsp;            break;</b>
<i>734</i>&nbsp;
<i>735</i>&nbsp;          case TC_ARRAY:
<b class="nc"><i>736</i>&nbsp;            switch (from) {</b>
<i>737</i>&nbsp;              case TC_NULL:
<i>738</i>&nbsp;                return;
<i>739</i>&nbsp;              case TC_CLASS:
<i>740</i>&nbsp;              case TC_ARRAY:
<i>741</i>&nbsp;                try {
<b class="nc"><i>742</i>&nbsp;                    if (!env.implicitCast(f, t)) {</b>
<b class="nc"><i>743</i>&nbsp;                        asm.add(where, opc_checkcast, t);</b>
<i>744</i>&nbsp;                    }
<i>745</i>&nbsp;                    return;
<b class="nc"><i>746</i>&nbsp;                } catch (ClassNotFound e) {</b>
<b class="nc"><i>747</i>&nbsp;                    throw new CompilerError(e);</b>
<i>748</i>&nbsp;                }
<i>749</i>&nbsp;            }
<i>750</i>&nbsp;            break;
<i>751</i>&nbsp;        }
<b class="nc"><i>752</i>&nbsp;        throw new CompilerError(&quot;codeConversion: &quot; + from + &quot;, &quot; + to);</b>
<i>753</i>&nbsp;    }
<i>754</i>&nbsp;
<i>755</i>&nbsp;    /**
<i>756</i>&nbsp;     * Check if the first thing is a constructor invocation
<i>757</i>&nbsp;     */
<i>758</i>&nbsp;    public Expression firstConstructor() {
<b class="nc"><i>759</i>&nbsp;        return null;</b>
<i>760</i>&nbsp;    }
<i>761</i>&nbsp;
<i>762</i>&nbsp;    /**
<i>763</i>&nbsp;     * Create a copy of the expression for method inlining
<i>764</i>&nbsp;     */
<i>765</i>&nbsp;    public Expression copyInline(Context ctx) {
<b class="nc"><i>766</i>&nbsp;        return (Expression)clone();</b>
<i>767</i>&nbsp;    }
<i>768</i>&nbsp;
<i>769</i>&nbsp;    /**
<i>770</i>&nbsp;     * Print
<i>771</i>&nbsp;     */
<i>772</i>&nbsp;    public void print(PrintStream out) {
<b class="nc"><i>773</i>&nbsp;        out.print(opNames[op]);</b>
<i>774</i>&nbsp;    }
<i>775</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:11</div>
</div>
</body>
</html>
